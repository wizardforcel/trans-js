© 作者，独家授权`Springer Fachmedien Wiesbaden GmbH`，`Springer Nature`的一部分 2024`J. L. Zuckarelli`学习使用`Python`和`JavaScript` [https://doi.org/10.1007/978-3-658-42912-6_21](https://doi.org/10.1007/978-3-658-42912-6_21)

# 21. 变量与对象：如何存储数据以便使用？

Joachim L. Zuckarelli^([1](#Aff2) )(1)`München`, `Germany`概览

在本章中，我们将把重点转向在`Python`中处理变量。此外，我们还将探讨如何将各种变量聚合到类列表的结构（数组）中，并在哈希（字典）中映射键值对。鉴于`Python`的面向对象特性，所有变量都是具有属性和方法的对象，我们的讨论将超越仅仅创建、赋值和在不同数据类型之间转换变量。我们将深入探讨`Python`的面向对象实现，并演示您如何利用面向对象编程在`Python`中为您的项目带来益处。

在本章中，您将学习：

+   如何在`Python`中创建变量并为其赋值

+   变量的基本类型有哪些，如何使用它们

+   变量的对象特性表达了什么，以及这对您在变量的实际工作中意味着什么

+   如何将变量从一种数据类型转换为另一种数据类型，以及`Python`何时自动为您进行转换

+   存在更复杂的数据类型（例如，列表和字典），以及如何使用它们

+   如何在`Python`中定义类，如何自己定义和使用对象类

## 21.1 创建和赋值变量

与其他一些语言不同，在`Python`中创建变量是相当简单的。这是因为变量在`Python`中不需要声明；它们在首次使用时会自动创建。因此，赋值

`>>>` `x = 5`创建了一个（整数）变量并将其值设置为`5`（`>>>`是提示字符，提示您输入，因此您不需要输入这个！）

我们在这里简单地将变量命名为`x`。在►章节[11](474412_1_En_11_Chapter.xhtml)，我们说变量名应该是有意义的，并允许代码的阅读者猜测变量将包含什么样的内容。尽管在这些例子中我们将其简化，`Python`仍然为您提供了使用有意义的变量名的每一个机会。正如您从►节[20.​1.​3](474412_1_En_20_Chapter.xhtml#Sec4)中已知，`Python`中的名称可以由大小写字母、数字和下划线字符组成。数字不允许出现在变量名的开头，但可以在名称的其他地方使用。此外，名称开头（有时结尾）带下划线在`Python`中有特殊含义，我们将在后面讨论。因此，不建议以下划线开头或结尾命名变量。除此之外，您可以完全自由地命名您的变量。

`Python`决定变量应该具有什么类型。在变量的生命周期内，类型可能会改变，例如，通过将不同类型的数据分配给变量。

`>>> x = 'A string (str) variable'`不仅值发生了变化，变量的数据类型也发生了变化，现在它是一个字符串变量。在下一节中，当我们查看变量的对象特性时，您将学习到在`Python`中创建变量的第二种方法，除了赋值以外。

如果您在`Python`控制台中工作，可以随时通过输入变量的名称来显示变量的值。

`>>> x` `'A string (str) variable'`如果您在`Python`脚本中编写代码，则必须使用`print()`函数，您在上一章中已学习过，来打印变量的内容：`print(x)`

如果您在`Python`程序中仅写变量名，则没有输出。

顺便提一下，您不能在控制台中访问您在程序中创建的变量。控制台的命名空间和您程序的命名空间是分开的。如果您在控制台中使用一个您在程序中创建的变量，您将收到一个错误信息（当然，除非您已经通过控制台创建了一个同名变量——但那样您也会使用这个变量，而不是您在程序中使用的那个变量）。

有时您会意外访问一个不存在的变量，例如因为您输入了错误的标识符。然后，您将收到如下错误信息：

`Traceback (most recent call last):` `File "D:\Applications\Anaconda\lib\site-packages\IPython\core\interactiveshell.py", line 2961, in run_code` `exec(code_obj, self.user_global_ns, self.user_ns)` `File "<ipython-input-16-9063a9f0e032>", line 1, in <module>` `y` `NameError: name 'y' is not defined`

这里关键的是最后一行。它告诉我们一个名为`y`的变量，在这里我们尝试访问它，但它根本不存在。

## 21.2 删除变量

一旦创建，变量可以使用`del`命令再次删除。这是有意义的，特别是如果变量占用了大量内存（例如，如果您已经完全读取了一个大文件），并且在您不再需要数据后希望释放内存。

如果您在`Python`控制台中删除一个变量，然后尝试访问它，您将收到一个错误信息：

`>>> del x` `>>> x` `Traceback (most recent call last):` `File "<input>", line 1, in <module>` `NameError: name 'x' is not defined`

错误信息提到`名称` `x`未定义。像许多其他编程语言一样，Python明确区分变量的值和它的名称。名称仅是对值的引用，值存储在内存的某个区域。原则上，名称和值是独立存在的。现在，可能有多个名称指向完全相同的值，也就是说，指向内存中的相同位置。如果该内存位置中的值发生了变化，那么所有这些变量的值也会相应地发生变化。在这种多个名称指向同一内存位置的情况下，如果删除了其中一个名称，值和其他名称（因此也包括变量）将被保留。然后，你将不能再通过被删除的名称来访问该值，只能通过剩余的名称来访问。

Python会计算指向某个值的名称（结果称为`引用计数`）。如果没有名称再指向某个值，Python会删除该值本身。这个过程称为`垃圾回收`。然而，由于通常只有一个名称与变量的值`绑定`，当你调用`del`命令时，该值本身通常也会被删除，相关的内存也会被释放。

## `21.3 变量的基本类型`

本节我们讨论最重要的几种变量类型。我们首先集中讨论只包含一个值的变量。在接下来的章节中，我们将讨论可以同时容纳多个值的更复杂的数据类型。

### `21.3.1 数字（int, float）`

Python中的数字有整数（`int`）或浮动小数（`float`）两种形式。与许多其他编程语言不同，Python中的`int`变量没有固定的值范围，超过这个范围就必须选择一个占用更多内存的数据类型。Python会根据变量所包含的值需要的内存量来为变量保留足够的内存空间。

你可以通过使用`sys.getsizeof(object)`函数查看变量的大小，从而很清楚地看到这一点：

`>>> x = 5 >>> sys.sizeof(x) 14 >>> x = 1000000000000 18`

如你所见，在我们将一个显著更大的值——一万亿，赋给变量而不是`5`之后，内存需求从原来的`14`字节增加到了`18`字节。

你可能会想，为什么即使是像`5`这样的小值仍然需要`14`字节的内存。在许多其他编程语言中，类似的变量仅需要`2`字节（= `16`位）。这可以表示从`0`到`2^(16) = 65,536`之间的数字。那么为什么Python会如此“占内存”？答案与Python存储变量的方式有关，下面的章节会进行讨论。

浮点数的小数分隔符是句点，这在英语中是习惯用法。在Python中，最大的问题是，如果你习惯用逗号而不是句点（在许多欧洲和南美国家很常见），你不会收到错误提示：

`>>>` `pi = 3.1415926535` `>>>` `pi(3, 1415926535)`

Python误解了我们的输入，并创建了一个完全不同类型的变量，即`tuple`。稍后在本章中我们会更详细地讲解这些元组。

### `21.3.2 字符串（str）`

字符串，类型为`str`的变量，可以在Python中用单引号或双引号括起来：

`>>>` `x = "这是一个双引号中的文本。"` `>>>` `x` `'这是一个双引号中的文本。'` `>>>` `y = '这是一个单引号中的文本。'` `>>>` `y` `'这是一个单引号中的文本。'`

能够使用两种类型的引号的优势在于，在Python中你可以轻松地在文本中显示引号，因为这两种不同的引号变体可以避免混淆文本中的引号和用于界定字符串的引号：

`>>>` `quote = '哈姆雷特说：“生存还是毁灭，这是个问题！”'` `>>>` `quote` `'哈姆雷特说：“生存还是毁灭，这是个问题！”'`

正如你所注意到的，Python自动将变量内容的输出括在（单）引号中，以明确表示这是一个字符串。以下示例展示了这一功能的实用性：

`>>>` `x = '5'` `>>>` `x` `'5'` `>>>` `x = 5` `>>>` `x` `5`

在第一次赋值中，变量的内容是一个字符串，在第二次赋值中，它是一个数字，之后可以用在计算中。

在Python中，创建跨越多行的字符串非常容易。只需将文本括在三引号中：

`z = """文本从第一行开始，继续到第二行。"""` `print(z)` 该程序的输出结果如下：文本从第一行开始，继续到第二行。

事实上，换行符在输出中被保留。你不仅可以在脚本模式下使用此功能，即编写程序后再执行，甚至在交互模式下，Python会在你按下`<ENTER>`键后识别出你已经开始编写多行字符串，因此会等待语句的执行（通常是按`<ENTER>`触发），并允许你继续在下一行书写。

在上一章中，你已经接触过这种类型的字符串，称为`docstrings`。文档字符串用于作为程序代码中的文档，但并不是为了进一步处理或输出到程序的最终用户屏幕。

有时你希望在程序代码中包装字符串，而这种包装在输出时不可见；关键是使程序代码更加清晰（记得遵守► Sect. [20.​1.​1](474412_1_En_20_Chapter.xhtml#Sec2)！推荐的每行79个字符限制！）。在这种情况下，你可以使用反斜杠（`\\`）：

`message = 'Hello ' \'world'` `print(message)`

这段代码生成的输出为：

`Hello world`

这意味着并不是有两行不同的字符串，而只是一个字符串，出于实际原因在代码中分布在两行上。

### `21.3.3 真值（bool）`

真值或逻辑值`true`和`false`在`Python`中使用数据类型`bool`表示，`bool`是对19世纪英语数学家和逻辑学家乔治·布尔的致敬，他在形式逻辑的发展中做出了重要贡献。

与其他变量类型不同，类型为`bool`的变量只能取两个值：`True`和`False`。请注意大小写！常量`True`和`False`必须以大写字母书写。如果我们写成`false`，`Python`会认为我们想使用一个名为`false`的变量，而这个变量当然不存在：

`>>> x = false` `Traceback (most recent call last):` `File "<input>", line 1, in <module>` `NameError: name 'false' is not defined` `>>> x = False` `>>> x` `False`

此外，不要使用引号，因为它们会使变量成为`str`变量：

`>>> x = 'False'` `>>> x` `'False'` `>>> type(x)` `<class 'str'>` `>>> x = False` `>>> x` `False` `>>> type(x)` `<class 'bool'>`

`Python`内部将值`True`和`False`存储为`0`和`1`，因此您可以像对待普通数字一样对它们进行计算：

`>>> x = 5 * True` `>>> x` `5`

### `21.3.4 None`

一种特殊的数据类型是`NoneType`。您不能创建自己的这种类型的变量。相反，`Python`已经为您创建了一个类型为`NoneType`的对象，即`None`（多么有创意！）。这允许您将值`None`赋给一个变量，这意味着该变量当前没有真正有意义的值：

`>>> x = None` `>>> x` `None` `>>> type(x)` `<class 'NoneType'>`

但这不是有点尴尬吗？如果变量是数字，我们不可以直接赋值为`0`，或者如果它是字符串的话，赋值为`''`（即一个空字符串）吗？当然，我们可以这样做，但前提是`0`或`''`在内容上没有实际意义。然而，当你测量温度时，例如，或者在一个从−5到+5的范围内调查一个人对某个话题的态度时，值`0`确实可以具有其自身的真实意义。在这种情况下，受访者给出了值`0`，从而表示对该话题的中立态度，还是根本没有回答问题（`None`），这之间是有区别的。为了使这种区别显而易见，使用一个特殊的指示符来表示“没有真实值存在”是有意义的，而这正是`None`值的作用。

顺便说一下，你不能用`None`进行计算：

`>>> None + 1 Traceback (most recent call last): File "<input>", line 1, in <module> TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'.`

如果`None`被作为逻辑表达式进行评估，它被视为`False`。所以，`None`确实没有其他任何用途，除了表明变量不包含真实值。

### 21.3.5 其他数据类型

除了到目前为止讨论的数据类型外，Python本身还知道几种其他数据类型，例如`complex`，这是一种用于表示数学中已知的复数的数据类型，复数由实部和虚部组成。

各种不是标准语言一部分的包（程序库）也提供了自己的数据类型。一个例子是`NumPy`包，这是一个用于高效处理向量和矩阵的库，是在统计和机器学习方法中进行工作的重要基础，Python在这些领域找到了相当大的应用。

`NumPy`不仅提供了一些新的复杂数据类型，还有几种基本数据类型也可以使用。对于已经熟知的数据类型`int`和`float`，例如，`NumPy`有自己的替代品，其特征在于，它们在内存需求上并不随变量内容的变化而变化，正如Python中的标准数据类型那样，而是始终占用固定数量的内存字节。这允许在处理这样的变量时进行非常快速的计算，特别是在处理大量此类变量时，效率计算是一个重要的技能，尤其是在处理大量数据（如机器学习）时。

然而，由于我们在大多数使用案例中可以使用到目前为止讨论的数据类型，我们就先到这里，接下来在下一节中更仔细地观察Python中变量的特性。

## 21.4 变量作为对象

### 21.4.1 变量的属性和方法

Python受到面向对象编程范式的强烈影响。与一些其他也采用这种编程方法的编程语言（如`C++`）不同，在Python中，即使是最简单的变量也是对象。

在`Python`中，变量最终始终是一个`class`的具体实例，例如浮点数的类`float`。类`float`有一整套可以通过该类的具体实例，即变量对象访问的方法和属性。如果你对类和实例/对象的术语不再熟悉，只需翻回几页到►`Sect. [11.​7](474412_1_En_11_Chapter.xhtml#Sec10)`并在继续之前刷新你的知识！

如果你在使用`PyCharm`时，在代码编辑器中输入你已经在程序中使用的变量名，后面跟着一个点，一个小的代码补全菜单会弹出，在这里你可以看到属于该变量类的方法和属性。你也可以在控制台中做同样的事情，输入一个你已经通过`Python`控制台赋值的变量，同样后面跟着一个点。

`The dot`是`Python`中的运算符，它允许你访问对象的方法和属性。因此，当你在变量名后输入一个点时，`PyCharm`期望你使用该变量的方法或属性，并显示相应的列表。你可以在◘`Fig. [21.1](#Fig1)`中看到这个示例。![](../images/474412_1_En_21_Chapter/474412_1_En_21_Fig1_HTML.jpg)

编辑器窗口中的代码补全菜单的截图。编辑器显示文本`x dot`，代码补全菜单显示标识符，如`image`、`real`、`numerator`和`denominator`。

`Fig. 21.1`

整数变量的代码补全菜单，从代码编辑器中调用

菜单中标记为小“m”的条目是类`float`为对象提供的方法，标记为小“p”的条目是属性（“p”代表`property`）。你还可以在右侧的代码补全菜单中看到对象的方法或属性来自哪里。在我们的例子中，所有方法和属性都直接来自类`int`，但有些也会来自更一般的类`object`，类`int`正是从该类派生的。从某种意义上说，类`object`是类`int`的父类，并从中继承了方法和属性。

现在在控制台中创建一个`float`变量，并调用该变量对象的方法`is_integer()`：

`>>> x = 5.3 >>> x.is_integer() False`

该方法检查浮点数是否也是整数，当然在我们的例子中并非如此。类方法`is_integer()`不需要任何函数参数，因为它自动引用我们调用它的对象，即`x`。虽然不需要传递参数给函数，但它仍然必须始终用（空）圆括号调用，以识别它是一个函数。

然而，类`float`不仅具有方法，还有一些属性。其中一个属性是`__class__`。它表示对象的类：

`>>> x.__class__ <class 'float'>`

另外，您也可以使用函数``type(*****object*****)``来确定对象类型，该对象作为参数传递给函数：

``>>>`` ``type(x)``**<class 'float'>**

借助函数``isinstance(*****object*****,** ***class*****)``，它像``type(*****object*****)``一样是Python标准库的一部分，您可以确定一个变量是否属于某种类型；用我们的面向对象术语更准确地说，您可以确定一个变量是否是某个``class``的``instance``。要做到这一点，变量和要检查的类作为参数传递给函数：

``>>>`` ``isinstance(x, str)``False``>>>`` ``isinstance(x, float)``True

让我们更仔细地看看对象的方法，即类为对象提供的函数。稍早之前，我们已经了解了``is_integer()``，这是类``float``的一个方法，它检查当前对象，即我们正在调用其方法的对象，是否是一个整数。如您所知，我们不必将要检查的变量传递给这个特殊函数，因为该方法已经是对象的一部分，因此知道应该处理哪个对象。

现在让我们看看字符串变量：

``text = 'Python中的字符串有许多有趣的方法.'``如果您在``PyCharm``中工作，在脚本编辑器或Python控制台中，您可以在脚本编辑器或Python控制台中键入``text.``（使用点操作符），熟悉的上下文菜单将显示字符串类``str``为您的``text``对象提供的属性和方法。您将立即看到这里有丰富的不同方法可供选择（◘ 图 [21.2](#Fig2)）。![](../images/474412_1_En_21_Chapter/474412_1_En_21_Fig2_HTML.jpg)

在编辑器窗口中，代码补全菜单的截图。编辑器显示文本``text``，代码补全菜单显示标识符，如``upper``、``find``、``join``和``count``。

图 21.2

``str``对象的方法让我们尝试其中的一些：

+   ``lower()``和``upper()``分别将字符串转换为小写和大写字母：``>>>`` ``text = '一段普通文本，包含一些单词和标点符号。````>>>`` ``text.lower()``'一段普通文本，包含一些单词和标点符号。'`` ``>>>`` ``text.upper()``'一段普通文本，包含一些单词和标点符号。'

+   ``isnumeric()``检查字符串是否可以转换为数字：``>>>`` ``text.isnumeric()``False

+   ``count(*****substring*****)``计算作为参数传递给该方法的（部分）字符串``substring``的出现次数；它是区分大小写的，如以下示例所示（仅计算“and”中的“an”）：``>>>`` ``text.count('an')``1

+   `replace(*****old*****,** ***new*****,** ***occurrences*****)` 替换旧字符串的指定次数为新字符串；指定替换的次数是可选的，因此您可以省略它，这将替换`all`的所有出现：`>>>` text.replace('words', 'terms', 1)'一段普通文本，其中包含一些术语和标点符号。'

+   `__len__()` 确定字符串的长度：`>>>` text.__len__()`58`

正如您从前后两个下划线可以看出，这是一个特殊的核心Python方法。`21.1 [20 min]`

`str`类型的对象，即字符串变量，除了这里展示的示例方法之外，还有几个其他有趣的方法。找出`str`对象还提供了哪些方法，并在Python控制台中尝试使用它们。如果您不理解某个方法或无法成功使用它，别过于纠结，继续尝试下一个方法。

您可以在帮助文档中阅读有关方法的详细信息。为此，请在Python控制台中调用`help()`，并在调用方法时在方法前加上`str.`，这样Python就能准确地知道您要查看哪个类的方法（因为可能有多个类具有相同名称的方法），例如 `help(str.isnumeric).`

你可能在练习中注意到，像`upper()`、`lower()`和`replace()`这样的函数并不会修改它们调用的对象，而只是`返回`该对象的一个`修改副本`。如果你想修改原始对象，必须将修改后的版本，也就是方法的返回值，赋给它。我们通过`upper()`来更详细地了解这一点：

`>>>` text = '一段普通的文本，包含一些单词和标点符号。' `>>>` text.upper()`'一段普通的文本，包含一些单词和标点符号。'`>>>` text`'一段普通的文本，包含一些单词和标点符号。'`>>>` text = text.upper()`>>>` text`'一段普通的文本，包含一些单词和标点符号。'

如你所见，调用`text.upper()`方法并不会改变`text`变量。只有将方法的返回值赋给原始变量，才会改变对象`text`。

### `21.4.2 使用构造方法创建变量`

在上一节中，我们看到，变量可以通过第一次给它赋值来创建。但还有另一种创建新变量的方法。正如你现在所知道的，变量是对象，也就是类的实例。像所有类一样，这些对象有一个构造方法，它是一个特殊的方法，用来创建该类型的对象。我们可以使用这些构造方法来创建变量。让我们看一下以下示例：

`>>>` x = int(3)`>>>` x`3` `>>>` type(x)`<class 'int'>`

所以，构造方法返回一个`int`对象，其值是作为参数传入的。这本身可能并不那么有趣；毕竟，我们可以通过简单的赋值`x = 3`轻松实现相同的效果。值得注意的是，我们还可以将一个浮动小数或字符串传递给构造方法，它会从中创建一个`int`对象。在浮动小数的情况下，小数部分会被忽略。如果传递的是一个字符串，文本当然必须能转换为数字，否则会出现错误信息：

`>>>` x = int(3.7) `>>>` x 3 `>>>` x = int('3.7') `>>>` x 3 `>>>` x = int('abc') Traceback (most recent call last): File "<input>", line 1, in <module> ValueError: invalid literal for int() with base 10: 'abc'。

## 21.5 变量转换

在需要更改变量的数据类型时并不罕见。为此，请考虑以下示例，在其中我们将一个整数变量和一个浮动小数变量相加：

`>>>` x = 2 `>>>` type(x) `<class 'int'>` `>>>` x = x + 3.7 `>>>` x 5.7 `>>>` type(x) `<class float'>`

当我们创建变量时，Python 会自动选择`int`作为数据类型，因为我们已经给变量赋了一个整数值。但当我们再加上 3.7 这个浮动小数时，Python 会把类型更改为`float`以适应新值。所以，Python会*隐式*转换类型，而我们不需要进行干预。

现在让我们尝试一些其他的操作：

`>>>` x = 2 `>>>` x = x + '2.7' 报错信息（最近一次调用）： 文件 "<input>"，第 1 行，在 <module> 中 TypeError: 不支持操作数类型：'int' 和 'str'。

如果我们将一个字符串加到变量 `x` 上，Python 将不再隐式地进行转换。也许相反的情况有效，我们将 `x` 定义为字符串并加上一个数字呢？

`>>>` x = '2' `>>>` x = x + 3.7 报错信息（最近一次调用）： 文件 "<input>"，第 1 行，在 <module> 中 TypeError: 只能将 str 类型与 str 类型连接，不能与 float 类型连接。

这个也不起作用。所以，Python 并不会在数字和字符串之间进行隐式转换。然而，我们有时需要将字符串转换为数字，以便进行计算。

让我们通过一个例子来看看。你记得从► 第 [12.2.2](474412_1_En_12_Chapter.xhtml#Sec6) 节中的开尔文到摄氏度的转换吗？在那里我们讨论了一个简单的程序，它接受用户输入的开尔文温度并将其转换为摄氏度。我们现在将在 Python 中开发这个程序。为此，我们使用 `input(prompt)` 函数获取输入，该函数提示用户输入并将输入以字符串的形式返回。掌握了这些知识后，写出如下代码应该是显而易见的：

`temp_kelvin = input('请输入温度（单位：开尔文）：') temp_celsius = temp_kelvin + 273.15 print(temp_kelvin, '开尔文是', temp_celsius, '摄氏度。')`

如果我们运行这个程序并输入一个开尔文温度，我们将得到如下输出：

**报错信息（最近一次调用）：** **文件 "C:/Users/MyUser/Python/var_examples.py"，第 54 行，在 <module> 中。** `temp_celsius = temp_kelvin + 273.15` **TypeError: 只能将 str 类型与 str 类型连接，不能与 float 类型连接**

到目前为止，你已经理解了这里出现的问题：`input()` 函数返回的是一个字符串，但由于 Python 不会隐式地将其转换为数字，因此无法进行计算。我们需要**显式**地进行转换。这正是我们在修改版示例中所做的：

`temp_kelvin = input('请输入温度（单位：开尔文）：')` `temp_celsius = float(temp_kelvin) + 273.15` `print(temp_kelvin, '开尔文是', temp_celsius, '摄氏度。')`

这一次，我们显式地将字符串变量 `temp_celsius` 转换为浮点数，使用了 `float()` 函数。你会立刻发现这是对上一节的引用：`float()` 当然也是 `float` 类的构造方法。所以，当我们将字符串变量 `temp_kelvin` 转换为浮点数时，我们实际上只是在通过调用该类的构造方法来创建一个新的 `float` 对象。我们立即初始化这个新的 `float` 对象，赋予它一个值；这个值也可以是一个字符串，`float` 构造方法会从中创建一个浮点数。因此，Python 中的`显式`转换就是通过类构造方法完成的。它们不仅可以接收创建该类对象的数据类型（在我们这个例子中是 `float`），还可以接收各种其他类型（例如 `str`）。通常，显式转换的形式是：`datatype(value)`。

21.2 [10 min]

写一个程序，获取用户的年龄（以年为单位），并输出用户至少活过多少分钟。

## 21.6 复杂数据类型

### 21.6.1 列表

#### 21.6.1.1 创建和显示列表

与许多其他编程语言不同，Python 并没有数组的概念。相反，Python 有一种更通用的变量类型：字段数组，而数组则是其特例：列表。

列表是 `有序` 的 `任意` 对象的集合。因此，数组也可以理解为列表，因为它无非就是 `相同类型` 对象的有序集合。列表在 Python 中通过方括号创建，如下例所示：

**>>>** `numbers = [1, 2, 3, 4, 5, 6, 7]`**>>>** `first_names = ['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']`

在控制台中输入列表名，会显示列表的内容。列表元素周围的方括号提醒我们这确实是一个列表：

**>>>** `numbers[1, 2, 3, 4, 5, 6, 7]`**>>>** `first_names['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']`

如果你不是在控制台中工作，而是在脚本模式下编写完整程序，那么使用 `print()` 函数输出，它也可以处理列表：

`print(numbers)` `print(first_names)`

单独写列表的标识符，例如`numbers`并不会在程序中产生输出——与在 Python 控制台中不同——正如我们在►节中看到的那样[21.1](#Sec1)。

#### 21.6.1.2 选择列表中的单个元素

现在可以通过索引再次使用方括号访问列表的单个元素：

`>>>` `numbers[3]` `4` `>>>` `first_names[2]` `'Marc'`

Python 中的索引从`0`开始，因此索引为`1`的元素已经是列表中的*第二*个元素。你可以使用*负*索引从后面选择。如果我们想从列表的后面选择第二个名字，可以写：

`>>>` `first_names[-2]` `'Jimmy'`

列表的最后一个元素的索引是`−1`，而不是`−0`，正如你可能期望的那样。

冒号运算符也可以用来指定一个范围作为索引。例如，如果我们想选择第二到第四个名字，可以这样做：

`>>>` `first_names[2:5]` `['Marc', 'Jimmy', 'Cathy']`

具有索引`2`、`3`和`4`的元素，即列表的第三个、第四个和第五个元素被选中。请注意，索引为`5`的元素，即第六个元素，不在选择范围内。索引规格的右边界——反直觉且与其他语言（如 R）不同——不属于所选元素。

就像原始列表一样，选择本身又是一个列表，因为我们选择了多个元素。如果另一方面我们只选择单个元素，选择不再是列表，而是具有该列表相应元素的类型：

`>>>` `type(first_names)` `<class 'list'>` `>>>` `sel = first_names[2:5]` `>>>` `type(sel)` `<class 'list'>` `>>>` `sel = first_names[2]` `>>>` `type(sel)` `<class 'str'>`

当使用索引范围时，一侧也可以保持开放。如果左侧保持开放，系统将从列表的开头选择；如果右侧保持开放，系统将选择到列表的末尾：

`>>>` `first_names = ['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']` `>>>` `first_names[:3]` `['Beverly', 'Thomas', 'Marc']` `>>>` `first_names[3:]` `['Jimmy', 'Cathy']`

你也可以将两个范围边界保持开放（`first_names[:]`），那么列表的所有元素将被简单选择（最终创建列表的副本）。如果你想一步选择多个不连续的元素，例如第一个和第三个元素，在 Python 中并不是那么简单。这就是使用列表推导表达式派上用场的地方，我们将在稍后研究 Python 中循环的实现时讨论。

#### 21.6.1.3 编辑列表

我们刚刚学习的索引不仅可以用来从列表中选择项目以显示或进一步处理，还可以直接修改列表中的项目。在本节中，我们将研究如何修改列表的元素、向列表中添加元素、删除列表中的元素、排序列表，以及将多个列表合并成一个新列表。

修改列表元素：让我们从改变列表项的值开始：`>>>` `first_names = ['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']` `>>>` `first_names[1] = 'Jason'` `>>>` `first_names = ['Beverly', 'Jason', 'Marc', 'Jimmy', 'Cathy']`

甚至整个索引范围也可以像这样赋值：

`>>>` `first_names = ['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']` `>>>` `first_names[3:5] = ['Joe', 'Aimee']` `>>>` `first_names = ['Beverly', 'Thomas', 'Marc', 'Joe', 'Aimee']`

在这种情况下，确保你赋值的值再次是一个列表（也就是用方括号括起来，并且它的长度与要替换的子列表相同）。

21.3 [5 min]

如果赋值的对象不是列表，或者其长度与被替换的子列表不匹配，会发生什么？试试看，并看看你是否能解释结果！

列表，像 Python 中的所有变量一样，都是对象，因此它们有相应的属性和方法。

向列表中添加元素：`append(object)`方法可以用来向列表中添加一个对象。这会直接改变调用`append()`方法的列表实例：`>>>` `first_names = ['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']` `>>>` `first_names.append('Sandy')` `>>>` `first_names = ['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy', 'Sandy']`

如果你想在列表的`任何位置`添加元素，可以使用方法`insert(insert_before_element_index, object)`，并传入你希望新元素位于的位置和元素本身：

`>>>` `first_names = ['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']` `>>>` `first_names.insert(2, 'Sandy')` `>>>` `first_names = ['Beverly', 'Thomas', 'Sandy', 'Marc', 'Jimmy', 'Cathy']` 删除列表中的元素：你可以轻松地删除列表中的项目：`>>>` `first_names = ['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']` `>>>` `first_names.__delitem__(4)` `>>>` `first_names = ['Beverly', 'Thomas', 'Marc', 'Jimmy']` `>>>` `del first_names[2]` `first_names = ['Beverly', 'Thomas', 'Jimmy']`

为了实现这一点，你可以使用类方法`__delitem__(elementindex)`，你只需要传递要删除的元素的索引，或者使用运算符`del`，由于它是一个运算符，因此不需要使用括号！你可以将它和要删除的元素一起调用。你甚至可以使用`del`运算符一次删除多个元素，例如通过调用`del first_names[2:4]`。

正如我们从删除的示例中看到的那样，一些操作可以通过类方法和运算符来实现。这对于我们在上一节中看到的选择操作也同样适用。归根结底，选择`first_names[2]`不过是调用`first_names.__getitem__(3)`方法的结果，这正是Python在你使用方括号进行列表索引时内部处理的方式，而方括号本身也只是一个运算符。

排序列表 你可以通过使用类方法`sort()`和`reverse()`来轻松排序你的列表，具体取决于你是想按升序还是降序排序：**>>>** `first_names = ['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']`**>>>** `first_names.sort()`**>>>** `first_names`['Beverly', 'Cathy', 'Jimmy', 'Marc', 'Thomas']**>>>** `first_names.reverse()`**>>>** `first_names`['Thomas', 'Marc', 'Jimmy', 'Cathy', 'Beverly'] 确定列表的长度 你可以使用`__len__()`方法轻松地确定列表的长度。**>>>** `first_name.__len__()`5

与之前讨论的操作类`list`的方法不同，`__len__()`不会修改列表，它只是返回列表的长度。

合并列表 如果你想将两个列表合并在一起，可以使用加号运算符（**+**）。**>>>** `first_names + numbers`['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy', 1, 2, 3, 4, 5, 6, 7]

在这里，你可以看到结果是一个列表，其中的元素部分是字符串，部分是数字。与许多编程语言中的更专门化数组不同，列表可以包含不同类型的元素。特别地，列表的元素本身可以是列表。我们将在接下来的章节中仔细看看这种情况。

#### 21.6.1.4 列表作为列表的元素

请考虑以下列表：

**>>>** `list_with_sublist = [1, 2, 3, ['a', 'b', 'c'], 4]`

它作为第四个元素（即索引为3的元素）再次包含一个列表。如果我们选择该元素并仔细检查，很快就可以看到这一点：

**>>>** `list_with_sublist = [1, 2, 3, ['a', 'b', 'c'], 4]`**>>>** `list_with_sublist[3]`['a', 'b', 'c']**>>>** `type(list_with_sublist[3])`**<class 'list'>**

要访问我们“子列表”的元素，我们首先使用`list_with_sublist[3]`来选择第四个元素。这个元素又是一个列表。所以，我们应该能够再次从这个（子）列表中选择元素，就像我们对整个列表做的一样。例如，如果我们想选出列表中的第三个元素，即**c**，我们可以进行“二次”索引，如下所示：

**>>>** `list_with_lists[3][2]` 'c' 通过这种方式，列表也可以用来构建多维变量字段。假设我们想要映射如下的矩形值方案：

| 1 | 2 | 3 |
| --- | --- | --- |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

这可以通过嵌套列表轻松映射：**>>>** `three_by_three = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]` **>>>** `three_by_three`[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

然后我们可以通过双重索引来访问坐标行 2，列 1（即我们值方案中的数字 4）（注意索引从 0 开始！）：

**>>>** `three_by_three[1][0]` 4

第一个索引总是行索引，第二个是列索引。虽然多维数组也可以通过列表很好地表示，但如果你处理的是非常大的数据集，且程序速度至关重要，那么你可能会希望使用如 `NumPy` 模块中包含的特殊数据结构。`NumPy` 是从事数据科学工作者的一个重要扩展库。该库还提供了一种特殊的数组数据类型，虽然不如列表灵活（因为它只接受相同类型的元素），但在内存中更加紧凑，访问速度也更快。然而，在这里，为了我们的目的，标准 Python 语言中的列表就足够了。

21.4 [20 min]

尝试一下操作列表！创建列表、选择列表中的项、添加新项、删除项。了解如何操作列表很重要，因为列表在实际的 Python 编程中扮演着重要角色。

#### 21.6.1.5 字符串作为列表

有关列表的一个特殊特点是字符串。在 Python 中，字符串具有类似列表的特性。它们的各个元素（字符）可以通过列表表示法进行读取访问：

**>>>** `message = 'Hello World'` **>>>** `message[1]` 'e'

尝试以这种方式`编辑`字符串字符，例如使用 **`message[1] = 'x'`**，将导致错误信息 **‘str’ object does not support item assignment.**

### 21.6.2 元组

元组是一种与列表在许多方面相似的数据类型。像列表一样，元组是有序的多个对象集合，这些对象不一定必须是相同类型的。与列表的主要区别在于元组是`不可变的`。看看下面的例子，我们从三个整数创建了一个元组：

**>>>** `number = (27, 9, 51)` **>>>** `number(27, 9, 51)` **>>>** `type(number)` **<class 'tuple'>** **>>>** `number[1]` 9 **>>>** `type(number[1])` **<class 'int'>** **>>>** `number[1]=36` **Traceback (most recent call last):** **File "<input>", line 1, in <module>** **TypeError: 'tuple' object does not support item assignment**

注意——与列表不同——初始化元组的元素被括在`圆括号`中。然而，元素的访问方式与列表完全相同，即通过在`方括号`中指定元素的索引；而且，在这里，索引自然从0开始——正如Python中始终如此——因此，**`number[1]`**查询的是元组的`第二`个元素。在最后一步，我们尝试给元组的第二个元素赋值。由于元组是不可变的数据类型，其元素在初始化后无法更改，因此赋值失败。同样，也不能添加新元素。元组在创建时的状态保持不变。

顺便说一下，在创建元组时，你也可以省略括号。因此，我们也可以通过这种方式创建上面**`number`**的元组：

**>>>** `number = 27, 9, 51` **>>>** `number(27, 9, 51)`

-   你可能会问，既然列表可以做所有元组能做的事情，并且列表是可变的，那么为什么还要使用元组呢？元组的主要优势在于，Python可以比列表更快地处理它们。当你想确保数据不会被覆盖时，元组也很有用。如果你在程序中意外尝试这样做，将会收到错误信息，就像你在上面的示例中看到的那样。即使你不常意识到地使用元组，Python在后台也会使用元组。例如，与许多其他语言不同，Python允许你在一条语句中放置多个变量赋值，如下所示：

`>>>` `a, b = 5, 3` `>>>` `a` 5 `>>>` `b` 3

这里的内部过程是，Python首先创建一个元组`(5, 3)`，然后将其元素分配给两个变量`a`和`b`。我们稍后将看到，在Python中——而这在许多其他编程语言中是不可行的——你可以让一个函数/方法返回多个值。“在幕后”这个过程与元组一起进行。

### 21.6.3`字典`

除了列表和元组，另一个复杂的数据类型是字典。术语“字典”很好地描述了这些数据结构的功能。与列表不同，在列表中我们使用相关元素在列表中的索引来选择值，而在字典中使用*键*来实现同样的功能。因此，字典是*关联字段*。如果你不再记得这个概念，最好向后翻几页到► Sect. [11.​6](474412_1_En_11_Chapter.xhtml#Sec9)。

作为一个示例，让我们创建一个字典，存储每个名字（键）对应的年龄（值）。各种键值对用大括号书写，键和值之间用冒号分隔，键值对之间用逗号分隔：

`>>>` `d = {'Thomas': 30, 'Beverly': 19, 'Marc': 28}` `>>>` `d` `{'Thomas': 30, 'Beverly': 19, 'Marc': 28}`

在我们的示例中，键是字符串，值是数字。然而，这并不一定是这样。数字本身也可以是键。甚至元组也可以是键，但列表不行，因为键必须始终是不可变的（记住，元组是不可变的，而列表可以被修改）。所有可能的对象类型都可以作为值，包括列表或字典本身。通过这种方式，也可以构造一个嵌套字典。我们将在以后的练习中更详细地研究这一点。

现在可以通过键来访问单个元素，这与关联字段的使用方式是一致的：

`>>>` `d['Thomas']`30

注意，虽然在创建字典时键值对是用大括号书写的，但在访问字段的单个元素时则使用方括号。

与列表不同，字典是`无序`的元素集合。不能使用数字索引来访问单个元素，因为在无序的数据结构中，元素没有自然的位置来定位和查询。因此，尝试使用数字索引访问元素会导致错误信息：

`>>> d[1] Traceback (most recent call last): File "<input>", line 1, in <module> KeyError: 1`

这个`KeyError`告诉我们，键`1`在字典中不存在。Python将`1`视为一个键，尝试查找相应的值，但发现`1`不在字典的键中。如果我们使用一个字典中没有的名字作为键，也会收到类似的错误信息，例如使用`d['Jacob']`时。

可以通过为新元素进行赋值来轻松向字典中添加元素，将新键与值关联起来：

`>>> d['Cathy'] = 36 >>> d {'Thomas': 31, 'Beverly': 19, 'Marc': 28, 'Cathy': 36}`

当然，我们也可以在这样的赋值操作中使用已有的键，如以下示例所示：

`>>> d['Beverly'] = 22 >>> d {'Thomas': 31, 'Beverly': 22, 'Marc': 28, 'Cathy': 36}`

由于键最终是我们用来访问字典元素的标识符，因此它必须是唯一的。因此，我们不能简单地添加一个已有键的元素。相反，在这种情况下我们会更改已经存在的元素。

不仅是添加元素，使用 `del` 运算符删除元素也和列表中一样简单：

`>>> del d['Thomas'] >>> d {'Beverly': 22, 'Marc': 28, 'Cathy': 36}`

或者，就像列表一样，调用类方法 `__delitem__()` 也是可行的：`d.__delitem__('Thomas')`。与有序列表不同，这个方法接受对应的键作为参数，而不是数字位置索引。

有时候，你可能需要检查某个键是否存在于字典中。这可以通过 `in` 运算符轻松实现。如果你将 `in` 运算符应用于一个键和字典，结果将是一个逻辑值，表示该键是否在字典中。

`>>> 'Cathy' in d True >>> 'Amy' in d False`

当然，键和值也可以从字典中提取。为此，字典类有两个特殊方法：`keys()` 和 `values()`。这些方法的返回值稍微复杂一些，稍后我们会更详细地处理这种对象——可迭代对象。为了方便操作，我们使用 `list()` 方法将它们转换为列表，`list` 类的构造方法：

`>>> list(d.keys()) ['Beverly', 'Marc', 'Cathy'] >>> list(d.values()) [22, 28, 36]`

使用这些列表，我们当然可以做任何列表允许的操作，例如访问特定元素。由于键的列表显然是有序的数据结构，我们可以用数字索引访问其元素。例如，索引为 `1` 的第二个元素（记住：Python 中的索引从 `0` 开始）：

`>>> list(d.keys())[1] 'Marc'`

字典的完整元素也可以提取为列表：

`>>> list(d.items()) [ ('Beverly', 22), ('Marc', 28), ('Cathy', 36) ]`

现在，列表的元素就是字典的单个元素，它们本身是键值对的元组：

`>>> type(list(d.items())[0]) <class 'tuple'> 21.5 [10 min]`

创建一个字典，其中键是数字型产品编号，值是包含每个产品编号的描述、制造商和价格的字典。

### `21.6.4 集合`

我们要查看的最后一种数据类型是`集合`。*集合和字典的共同点是，它们都是`无序`的对象集合。类似于字典的键必须始终唯一，每个集合中的元素也只能出现一次。集合支持数学集合论中的集合操作，例如确定两个集合的交集或并集。*

要创建一个集合，我们使用花括号——类似于字典；不过这次花括号中不包含键值对，而是集合的单个元素：

`>>> friends_thomas = {'Will', 'Beverly', 'Peter', 'Michael'} >>> friends_julia = {'Peter', 'Will', 'Helen', 'Michael', 'Caroline'}`

你可以通过比较两个包含相同元素但顺序不同的集合，轻松验证元素的顺序无关紧要：

`>>> {'Beverly', 'Peter'} == {'Peter', 'Beverly'} True`

在此过程中，我们使用双等号进行比较，正如我们稍后会看到的，双等号是 Python 用于等式比较的操作符（单等号会被 Python 认为是赋值尝试，显然在这里无法使用）。比较的结果`True`确认了集合中元素的顺序无关紧要；这两个集合虽然元素顺序不同，但其余元素相同，因此它们是相同的集合。

使用上述定义的集合，我们现在可以检查，例如，哪些元素在两个集合中都出现，也就是说，哪些人是朱莉亚和托马斯的共同朋友：

`>>> friends_thomas.intersection(friends_julia) {'Will', 'Peter'}`

为此，我们使用类方法`intersection(other_set)`，这是`set`类默认提供的。此时，结果，即交集，依然以`set`形式返回（可以通过花括号轻松识别）。如果我们调用`friends_julia.intersection(friends_thomas)`，结果也将是相同的，顺序颠倒也不会影响交集。

类似地，我们可以使用交集操作符`&`，这是`set`类所支持的：

`>>>` `friends_thomas & friends_julia` `{'Will', 'Peter'}`

交集操作符是与符号（&）并非偶然，因为我们要寻找交集中的所有元素，这些元素同时包含在一个`和`另一个集合中。

`并集`，即包含在一个或两个初始集合中的所有元素，可以通过类方法`union(other_set)`或管道操作符`|`来确定：

`>>>` `friends_thomas.union(friends_julia)` `{'Helen', 'Caroline', 'Michael', 'Will', 'Peter', 'Beverly'}` `>>>` `friends_thomas | friends_julia` `{'Helen', 'Caroline', 'Michael', 'Will', 'Peter', 'Beverly'}`

如您所见，我们的两个集合的并集只包含`Will`和`Peter`的名字一次，尽管它们在`friends_thomas`和`friends_julia`中都出现了。但这正是集合的特点（以及数学中的集合）：集合中的所有元素都是不同的，没有元素可以出现多次。

同样，我们可以检查一个集合是否是另一个集合的`子集`：

`>>>` `friends_thomas.issubset(friends_julia)` `False` `>>>` `{'Michael', 'Beverly'}.issubset(friends_thomas)` `True`

再次，操作符提供了一个便捷的快捷方式，即小于等于操作符：

`>>>` `{'Michael', 'Beverly'} <= friends_thomas` `True` 21.6 [20 min]

查找（例如，通过`help()`函数）集合的其他有趣操作，并进行尝试。可以使用本节中的示例集合`friends_thomas`和`friends_julia`，或者创建自己的集合。

## 21.7 自定义类

### 21.7.1 定义和使用类

我们查看过的所有数据类型都是类，无论是像`int`和`str`这样的基本类型，还是像列表或字典这样的复杂类型。因为Python作为一种编程语言遵循面向对象的范式，我们当然可以自定义定义类。

记住来自► Sect. [11.​7.​2](474412_1_En_11_Chapter.xhtml#Sec12)的`Product`类示例，它捕获了有关产品的所有重要基本信息？这些属性包括名称、更详细的描述、零件编号、制造商名称和价格。我们可以在Python中非常容易地构建这样的类，使用`class`关键字：

`class` `Product`: `name = ''` `description = ''` `item_number = ''` `manufacturer = ''` `price = 0.0`

在冒号后，代码块开始（注意缩进！）并定义类的属性，每个属性都分配了一个初始值。就是这样！现在我们可以使用我们的`Product`类并创建该类型的变量：

`gardenshovel = Product()`

`Product()`是我们类的构造方法，我们在这里就像在► Sect. [21.4.2](#Sec11)中对Python的基本数据类型那样使用它。虽然我们根本没有定义自己的构造函数，但我们的类从Python获得了一个默认的构造函数，它什么也不做，只是创建一个类的对象。稍后，当我们更详细地学习方法/函数时，我们将看看如何编写自己的构造函数，并利用它让我们类的使用者在创建新实例时，比如设置某些属性的值为自己的规格。这正是我们在► Sect. [21.4.2](#Sec11)中做的，当时我们通过`int(56)`调用了`int`类的构造函数，从而创建了一个包含整数值56的新`int`对象。

现在我们已经创建了`Product`类型的对象，可以根据需要自定义它的属性：

`gardenshovel.name = 'Garden shovel, stainless steel'`。`gardenshovel.price = 10.99`

如果你在 `*PyCharm*` 中工作并输入 `gardenshovel.`（包括点操作符！），弹出的下拉菜单将列出我们刚刚定义的属性，作为 `Product` 类的实例，`gardenshovel` 对象将具有这些属性。

你可以轻松验证这些赋值是否成功，通过显示属性的值来检查：

`print(gardenshovel.name)` `print(gardenshovel.price)`

请注意，我们现在不再处于 Python 的交互模式（可以通过语句前缺少提示符 `>>>` 来轻松辨别），尽管我们当然也可以将类定义输入到 Python 控制台中。因此，单纯输入变量的标识符不再足以显示内容（事实上，它完全没有效果）。相反，我们必须显式地调用 `print()` 函数来输出结果。

### 21.7.2 从其他类派生类

在 ► Sect. [11.​7.​3](474412_1_En_11_Chapter.xhtml#Sec13) 中，我们学习了继承的概念，Python 作为一种面向对象的语言，当然也提供了继承机制。在那里，我们将 `Book` 类定义为 `Product` 类的派生类，后者没有默认的 `author` 和 `pages` 这两个特殊属性。为了在 Python 中将一个类从另一个类派生，派生类的类名后面要加上基类的类名，并用括号括起来：

`class` `Book(Product):` `pages = 0` `author = ''`

现在我们可以通过调用 `Book` 类的默认构造函数来创建一个实例，Python 会很友好地提供该构造函数：

`grisham1992` = `Book`()如果你现在在 `*PyCharm*` 中通过输入 `grisham1992` 显示新对象的属性，你会立即看到 `Book` 类的实例不仅拥有自己的属性，如 `pages` 和 `author`，还继承了来自 `Product` 的属性，如 `description` 和 `price`。如图 ◘ [21.3](#Fig3) 所示，`*PyCharm*` 还会显示每个属性来源的类！[](../images/474412_1_En_21_Chapter/474412_1_En_21_Fig3_HTML.jpg)

编辑器窗口中的代码补全菜单截图。编辑器显示了 `grisham 1992` 这本书的属性文本，而代码补全菜单显示了如 `pages`、`price`、`author` 和 `name` 等标识符。

图 21.3

`“Book”` 类的拥有属性和继承属性

现在我们可以随意操作所有属性：

`grisham1992.name` = `'The Pelican Brief'` `grisham1992.price` = `8.99` `grisham1992.author` = `'John Grisham'` `grisham1992.pages` = `478`

Python 中的类不仅可以继承自一个基类，还可以继承自多个基类。例如，还可以有另一个类 `Copyright`：

`class` `Copyright`:`owner` = ''`year` = 1900

然后，我们可以同时将 `Book` 类从 `Product` 和 `Copyright` 两个基类派生：

`class` `Book`(`Product`, `Copyright`):`pages` = 0`author` = ''

通过在我们`Book`类的定义中指定两个基类，我们创建了一个同时继承了两个类的属性和方法的类。因此，我们现在可以使用`Copyright`类带来的属性：

`grisham1992` = `Book`() `grisham1992.owner` = `'Double'` `grisham1992.year` = `1992`21.7 [10 min]

定义一个包含有用客户属性的`Customer`类，并从该类派生出一个包含仅对商业客户相关的附加属性的`BusinessCustomer`类。

### 21.7.3 避免歧义：名称混淆

但是，如果不仅是`Product`类，`Copyright`类也有一个名为`name`的属性呢？派生类`Book`仍然只有一个`name`属性。但是这个属性现在是从哪个“父类”来的呢？是从`Product`的`name`，还是从`Copyright`的`name`？在这种情况下，答案是：来自`Product`，因为Python是从左到右进行搜索的，即“先”查找派生类中“左边”的父类中的属性名。如果第一个父类没有该标识符的属性，Python才会继续在其他父类中查找。

为了完全消除名称混淆，可以选择用双下划线为类属性添加前缀。然后，我们的`Copyright`类的类定义将如下所示：

`class` `Copyright`:`owner` = ''`__name` = ''`year` = 1900

双下划线的效果是，Python会自动通过`__class__attribute__`的标识符来访问属性，在我们的示例中就是`__Copyright__name`：

`grisham1992._Copyright__name = 'Copyright'` `print(grisham1992._Copyright__name)`

这个过程，也称为`name mangling`，可以避免在访问类层次结构中可能重复出现的属性名称时的歧义和误解。

## `21.8 小结`

在本章中，我们学习了Python中的变量及如何使用它们。我们还学习了如何定义类并创建对象作为类的实例。

你应该从本章中记住以下几点：

+   Python知道简单数据类型，最显著的是`int`（整数）、`float`（浮点数）、`str`（字符串）和`bool`（逻辑/真值），以及更复杂的数据类型，最显著的是`list`（不同对象的有序集合）、`dictionary`（无序关联字段）、`tuple`（不可变对象的集合）和`set`（无序唯一对象的集合）。

+   所有数据类型都是类，这些数据类型的变量是对象实例；它们具有属性（或特性）和方法，用于操作和处理对象。

+   变量名区分大小写，这在Python中是普遍的；官方推荐使用小写变量，并用下划线分隔变量名中的多个术语。

+   变量不需要声明。

+   变量可以通过将对象赋值给变量名生成（此时Python自动确定类型），也可以通过使用相应数据类型类的构造方法生成。

+   构造函数通常可以用其他类型的对象作为参数调用；这允许数据类型之间的显式转换。

+   Python隐式转换的相对较少，但在必要时会在`int`和`float`之间进行转换。

+   字符串可以用单引号和双引号括起来。

+   要显示变量的内容，可以在Python控制台中输入其名称；然而，在Python程序中，输出必须始终明确调用（主要使用`print()`函数）。

+   Python中的复杂数据类型在是否可变（可变：`list`、`dictionary`、`set`；不可变：`tuple`）以及其元素是以有序还是无序方式存储（有序：`list`、`tuple`；无序：`dictionary`、`set`）上有所不同。

+   复杂数据类型的元素（在字典的情况下，包括键和值）可以是不同类型的，甚至可以是该复杂数据类型或其他复杂数据类型的对象；例如，可能有一个列表，其中包含列表作为元素，或者一个字典，其键部分是元组，值是列表和其他字典。

+   有序数据类型（列表、元组）的元素可以通过数字索引（即元素编号）访问；第一个元素的索引总是0。

+   冒号运算符可以用来表示索引范围，其中`A:B`表示范围边界`A`（包含）和`B-1`（包含）之间的所有元素。

+   范围边界也可以留空，这相当于“从头开始”（未指定左边界）或“到结束”（未指定右边界）。

+   负数索引意味着：从后面索引，而不是从前面索引。

+   Python 没有一个特殊的数据类型用于数组/字段，而是使用`列表`类型来保存有序形式的任意元素；因此，数组是`列表`的一种特殊情况（即所有元素类型相同的列表）。

+   字符串在读取访问时也表现得像`列表`，因为它们的单个字符可以像`列表`一样通过常用符号进行访问；然而，不能通过这种方式写入字符。

+   您可以使用`class`关键字定义自己的类；类可以从一个或多个“父类”派生，即继承它们的属性和方法。

+   类定义中，属性或方法的双下划线表示该属性/方法也可以通过`_*class*__*attribute*`或`_*class*__*method()*`访问（*名称重整*）；通过这种方式，可以避免由于多重继承引起的属性/方法标识符的歧义。

以下表格概述了最重要的数据类型。对于简单数据类型，可以通过赋值或调用相应类的构造方法进行创建。当然，复杂数据类型如`列表`、`元组`、`字典`和`集合`也可以通过构造器创建，但为了简洁起见，这里不显示构造器的创建方式。

重要数据类型概览

| 数据类型 | 存储内容 | 变量的创建 | 元素的访问 |
| --- | --- | --- | --- |
| `整数` | 整数 | 赋值：`x = 5` 构造器：`x = int('5')` | – |
| `浮点数` | 浮动小数值 | 赋值：`x = 0.5` 构造器：`x = float('5')` | – |
| `字符串` | 字符串 | 赋值：`x = 'Hello World'` 构造器：`x = str(0.5)` | – |
| `布尔值` | 逻辑/真值 | 赋值：`x = False` 构造器：`x = bool('True')` | – |
| `列表` | 有序、可更改的其他对象的组合（可能也是不同类型的） | 元素用逗号分隔并放在方括号中：`x = ['Marc', 'Helen', 'Toby', 'Thomas']` | 用方括号表示索引或索引范围：`x[1]`（返回：`'Helen'`） *`x[2:3]`*（返回：`['Helen', 'Thomas']`） |
| `元组` | 有序的、不可更改的其他对象的组合（可能是不同类型的） | 元素用逗号分隔并放在圆括号中：`x = ('abc', 27.5)` | 用圆括号表示索引：`x(1)`（返回：`27.5`） |
| `字典` | 无序的键值对集合，键和值可以是不同类型的对象；键必须是唯一的 | 用逗号分隔的键值对，键和值之间用冒号分隔：`x = {'Marc' : 27, 'Helen' : 41}` | 用方括号表示键：`x = ['Marc']`（返回：`27`） |
| `集合` | 不可排序的对象集合（可能是不同类型），必须是唯一的（对象在集合中只能出现一次） | 以逗号分隔的元素在大括号中：`x = {'Marc', 'Helen'}` | 由于没有自然顺序且没有访问的键，选择单个元素是没有意义的（您必须已经知道该元素才能访问它） |

## 21.9 练习的解决方案

练习 21.1 `str`对象的其他方法的一些示例是：

+   `find('sub')`：在`str`对象的字符串中搜索`sub`，并返回找到的子字符串的第一个字符的索引，如果未找到子字符串，则返回−1。这个过程是区分大小写的。使用示例：`>>> x = 'Hello world!'` `>>> x.find('wo') 6` `>>> x.find('WO') -1` `>>> x.upper().find('WO') 6`

    在最后的示例中，字符串首先被转换为大写。`x.upper()`返回转换为大写的字符串。这当然又是一个`str`对象。然后使用其`find()`方法进行搜索。这次返回了一个命中。

    可以使用进一步的参数来限制要搜索的字符串范围；帮助中的规范 `x.find('sub'[, start[, end]]) -> int` 意味着由于`start`和`end`是`find()`的可选参数，因此可以指定也可以不指定。这就是为什么它们各自被方括号括起来。注意括号顺序的细微差别：围绕`end`参数的方括号被包含在围绕`start`参数的方括号中。这意味着`end`只能在指定了`start`的情况下被指定，但`start`可以在不指定`end`的情况下使用！

    在`->`之后，您会找到函数返回值的类型，在我们的例子中是`int`，因为索引作为数字返回。

+   `capitalize()`：将字符串的首字母大写（仅首个单词！），并将所有其他字符转换为小写。使用示例：`>>> x = 'hello world'` `>>> x.capitalize() 'Hello world'`

+   `is.lower()`，`is.upper()`：检查字符串是否全为小写或全为大写。使用示例：`>>> x.isupper() False` `>>> x = 'HELLO WORLD'` `>>> x.isupper() True`

+   `center(width, [fillchar])`：创建一个长度为`width`的字符串，由`str`对象的字符串居中。左右两侧用填充字符“填充”（默认情况下，如果未指定，则为空格）。使用示例：`>>> x = 'Hello World'` `>>> x.center(50, '*') '********************Hello World********************' 练习 21.2 一个程序，读取用户的年龄（以年为单位）并将其输出为分钟，可能如下所示：`age = input('Please enter your age in years:')` `minutes = int(age) * 365 * 24 * 60` `print('With', age, 'you have already experienced at least', minutes)` 练习 21.3

让我们首先为具有索引 3 和 4 的列表元素分配一个对象。我们从一个整数开始：

`>>>` `first_names` = `['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']` `>>>` `first_names [3:4]` = 23 `Traceback (most recent call last):` `File "<input>", line 1, in <module>` `TypeError: can only assign an iterable`

我们得到了一个错误信息。通常，Python无法将一个非列表对象分配给列表/从列表选择的元素（除非该选择只包含一个元素）。与预期相反，Python不会简单地用数字 23 替换索引 3 和 4，即`‘Jimmy’`和`‘Cathy’`（索引从 0 开始！）。当我们将数字 23“包装”在列表中时，情况发生了变化：

`>>>` `first_names` = `['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']` `>>>` `first_names[3:4]` = `[23]` `>>>` `first_names` = `['Beverly', 'Thomas', 'Marc', 23]`

现在，两个选中的元素实际上被只包含数字 23 的列表替换了。但由于这个列表比被替换的部分列表要短，我们的列表`first_names`也因此被`缩短`了。

现在让我们尝试其他操作。这次我们用一个字符串替换了部分列表：

`>>>` `first_names` = `['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']` `>>>` `first_names[3:4]` = `'Amy'` `>>>` `first_names` = `['Beverly', 'Thomas', 'Marc', 'A', 'm', 'y']`

与上面`first_names[3:4] = 23`的赋值不同，这次我们没有得到错误信息。但发生了一些看似奇怪的事情：部分列表`first_names[3:4]`被名字`Amy`的字母替换，每个字母都变成了新的列表元素。原因在于字符串也可以被当作列表来解释。因此，赋值`first_names[3:4] = 'Amy'`最终是用一个列表来替换，即用列表`['A', 'm', 'y']`替换。

练习 21.4

`没有解决方案`。

练习 21.5

这里我们现在处理的是一个嵌套字典。为了清晰起见，下面可以看到带有换行符的字典定义（你应该记得，► 第[20.1.2节](474412_1_En_20_Chapter.xhtml#Sec3)中提到，语句可以被包裹在大括号中）：

`>>>` `d = { 12345: {... 'description': '塑料花园椅 "Garden Friend"', ... 'manufacturer': 'Garden Paradise Inc.', ... 'price': 10.99 ... }, 56789: {... 'description': '花园铲，不锈钢', ... 'manufacturer': 'Big G Gardening Tools Inc.', ... 'price': 49.90 ... }}`

访问则通过两个键：

`>>>` `d[12345]['price']` 10.99

表达式 `d[12345]` 返回一个字典，并通过该字典中存在的键来选择该字典中的值。

练习 21.6 其他集合操作的一些示例：

+   `difference(other_set)`：返回存在于`other_set`中但不在调用`difference()`方法的集合中的元素。使用示例：`>>>` `friends_thomas = {'Will', 'Beverly', 'Peter', 'Michael'}` `>>>` `friends_julia = {'Peter', 'Will', 'Helen', 'Michael', 'Caroline'}` `>>>` `friends_julia.difference(friends_thomas)` `{'Caroline', 'Helen'}`

+   `remove(***element***)`：从集合中删除一个元素。使用示例：`>>>` `friends_julia.remove('Helen')` `>>>` `friends_julia` `{'Peter', 'Will', 'Michael', 'Caroline'}`

+   `isdisjoint(***other_set***)`：检查调用`isdisjoint()`方法的集合与另一个集合是否没有交集，即它们没有共同的元素。使用示例：`>>>` `friends_thomas = {'Will', 'Beverly', 'Peter', 'Michael'}` `>>>` `friends_julia = {'Peter', 'Will', 'Helen', 'Michael'}` `>>>` `friends_thomas.isdisjoint(friends_julia)` `False`

练习 21.7

两个类 `Customer` 和 `BusinessCustomer` 可能是这样的：

`class` `Client`: `firstname = ''` `lastname = ''` `street = ''` `city = ''` `zip = ''` `email = ''` `class` `BusinessCustomer`(`Customer`): `company = ''` `payment_terms = 14` `taxid = ''`
