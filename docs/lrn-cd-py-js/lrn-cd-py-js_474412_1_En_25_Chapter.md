© 作者（们），根据 Springer Fachmedien Wiesbaden GmbH 独家许可，隶属于 Springer Nature 2024 J. L. Zuckarelli 使用 Python 和 JavaScript 编程 [https://doi.org/10.1007/978-3-658-42912-6_25](https://doi.org/10.1007/978-3-658-42912-6_25)

# 25. 循环：如何高效地重复程序指令？

Joachim L. Zuckarelli^([1](#Aff2) )(1)德国慕尼黑概述

接下来，我们关注有效重复（几乎）相同程序指令的技巧，这一技巧使得优雅地解决许多否则难以解决的问题成为可能。Python 使用计数（for）循环和条件（while）循环。Python 的一个独特特点是**源自 for 循环**的列表推导式，它能够简洁地构建列表。

本章你将学习：

+   如何构造（计数）**for** 循环

+   如何构造（条件）**while** 循环

+   如何将循环嵌套在彼此内部

+   什么是列表推导式，以及如何使用它们优雅地创建列表

+   如何提前结束循环或单次循环，并且何时这样做是有用的

## 25.1 计数循环（for）

### 25.1.1 简单的 for 循环

for 循环的结构

Python 中的计数循环通过关键字 **for** 引入；因此，以下我们将其称为 **for** 循环。在 Python 中，**for** 循环并不像许多其他语言那样每次循环时递增一个运行变量，而是始终“传递”一个包含可以一个接一个访问的元素的*对象*。这样的对象在 Python 中也叫做*可迭代对象*，因为你可以一步步地“摇动”到下一个元素。

这类对象的例子有列表或元组。它们都有可以被计数循环逐一处理的元素。对象中的元素是否按固定顺序排列并不重要（如列表和元组中的情况）。唯一重要的是，（当然除了最后一个元素）总能找到一个*下一个*元素。例如，集合和字典也是如此，尽管它们的元素不是按顺序存储的，也没有按照程序员可以利用的顺序排列。然而，集合和字典的元素自然有一个内部顺序（通常是元素加入集合或字典的顺序），因此对于这些对象，也总是可以确定一个*下一个*元素。

如果你觉得对象的可迭代性以及遍历其元素有些抽象，不必担心：在以下例子中，你可以看到如何在 Python 中构建简单的 **for** 循环。这里有一个循环，它仅仅在屏幕上输出从 1 到 10 的数字：

**for** i **in** [1,2,3,4,5,6,7,8,9,10]: print(i)

在 Python 中，**for** 循环也有一个运行变量，在我们的例子中是 **i**。它是在 **for** 关键字后面直接定义的。运行变量在每次循环时获取被遍历对象的一个元素值。在我们的例子中，被遍历的对象是一个包含数字 1 到 10 的列表。按顺序，运行变量 **i** 将依次赋值为列表元素的值；第一次循环时是 1，第二次是 2，直到最后一次循环时，运行变量的值为最后一个元素 10。我们的列表是可迭代的，所以 Python 始终知道下一个循环传递中应使用哪个元素。我们还可以在每次循环时，使用运行变量的值来执行代码块，这正是我们在这里例子中所做的：代码块位于 **for** 关键字引入的 *头部* 后面，并以冒号结束。在我们的例子中，代码块只有一条语句，即输出运行变量的值。如果你执行这个例子中的代码，你将得到从 1 到 10 的输出，正如预期的那样。

在实际情况中，像我们在例子中那样显式地指定一个数字列表并不总是可行，尤其是当列表非常长，或者当程序开发时尚不知道列表的边界，而这些边界是由程序中的变量决定的。在这些情况下，**range(*****start*****,** ***stop*****,** ***step*****=1)** 函数是一个有用的工具。它生成一个从 **start** 到 **stop** 之间按 **step** 间隔的数字序列，其中 **step** 是一个可选参数，如果调用时未显式指定，则默认为 1。注意：**stop** 本身不包含在生成的数字序列中。你可能会注意到，这里有一个类似于使用索引范围进行索引的类比；在►第[21.6.1.2节](474412_1_En_21_Chapter.xhtml#Sec16)我们讨论了使用冒号操作符进行这种索引。你可以通过在 Python 控制台中输入 **list(range(1,10))** 来直观地理解这一点。你会得到一个从 1 到 9 的整数序列。**range()** 函数的返回对象是 **range** 类的一个对象，必须先转换为列表才能输出，因为 **range** 类的 **__str__()** 方法（详见►第[21.1节](474412_1_En_21_Chapter.xhtml#Sec1)关于 **__str__()**）并不会直接显示数字序列本身——试试看！不过，这个对象是可以迭代的。

上面的例子可以简化为：

**for** i **in** range(1,11):print(i)

现在考虑以下例子，我们在循环中调整了运行变量的值：

my_range = range(1,11)**for** i **in** my_range:i = 2print(my_range)

最终**print()**语句生成的输出显示，尽管我们将值2赋给了运行变量**i**（它在每次循环时代表**my_range**中的不同元素），但**my_range**对象本身并没有发生变化。然而，这显然没有影响。原因是，在**for**循环中，运行变量始终仅代表当前聚焦元素的*副本*。因此，通过赋值**i=2**，我们并没有改变**range**对象的相应元素，而只是改变了运行变量本身。

for循环示例

现在，输出一系列数字并不一定是**for**循环的特别有用的应用。因此，在下一个示例中，我们来看一个简单的加密算法，也叫做*ROT13*。字符串中的每个字符都可以被解释为一个数字代码，该代码在特定字符集内唯一地标识该字符。例如，在非常常见的UTF-8字符集中，数字代码65代表大写字母“A”，66代表大写字母“B”，依此类推。小写字母从97开始。ROT13算法利用了字母到数字的可转换性，通过将每个字母代码增加一个特定的数字（原始算法中是13）来实现加密。因此，“A”（代码65）变成了“N”（代码78），“B”（代码66）变成了“O”（代码79），依此类推。

我们希望开发一个函数**rot13(s: str, decode: bool, shift: int=13)**，该函数接收字符串参数**s**，根据**bool**类型的**decode**参数来决定是编码还是解码该字符串。默认情况下，它使用字符代码偏移量13，但也可以通过相同名称的参数来设置不同的偏移量。

当然，问题是**for**循环究竟在这里起什么作用。但你可能已经猜到：如你所知，字符串**s**当然可以分解为一个字符列表；我们可以遍历这个列表，从而逐个处理字符串中的每个字符。为此，我们使用**ord(*****character*****)**和**chr(*****code*****)**函数，前者返回给定字符的数字代码，后者返回数字代码对应的字符。

函数**rot13()**可能看起来像这样：

**def** rot13(s: str, decode: bool, shift: int = 13) -> str: s = list(s) res = list() **for** c **in** s: **if** decode == **True**: res.append(chr(ord(c) - shift)) **else**: res.append(chr(ord(c) + shift)) **return** ''.join(res)

**for**循环遍历字符串**s**，我们之前已将其转换为一个包含单个字符的列表。因此，运行变量**c**在每次循环中代表字符串**s**中的一个不同字符。

使用**append()**我们逐渐构建一个新列表，包含编码或解码后的字符串字符。最后，我们使用**join()**将列表中的字符连接成一个字符串，将其附加到一个空字符串（我们为此使用**join()**方法）并将其作为返回值返回。

现在我们可以通过调用 **print(rot13('HELLO WORLD', False))** 来测试这个函数，例如，它会将 **URYY\-d\_YQ** 打印到控制台。使用 **print(rot13('URYY\-d\_YQ', True))** 我们可以再次解码编码后的文本。如果最终结果是 **'HELLO WORLD'**，那么你就知道你的函数工作正常了！

总结这一部分内容时，我们来看看另一个例子。这一次，我们想写一个程序，让用户输入一个目录，然后列出该目录包含的子目录和文件。为此，我们将使用来自标准 Python 包 **os** 的函数。这个包提供了访问操作系统功能和资源的方法，其中包括允许你与文件系统交互的函数。**os** 的优点在于它是跨平台设计的；因此，使用 **os** 函数的程序不仅能在你的 Windows 计算机上运行，也能在 Mac 或 Linux 计算机上运行。你无需担心这些操作系统的具体细节。**os** 包为所有这些系统提供了一个统一的、跨平台的编程接口，抽象了系统的具体实现。

我们的程序代码现在看起来可以是这样的：

**从** os **导入** listdir, sep **从** os.path **导入** isdir, isfile, getsizedirectory = input('请输入一个目录: ')**如果** isdir(directory):**如果** directory[directory.__len__() - 1] != sep:directory = directory + sepprint('\n目录内容:', directory)content = listdir(directory)print('\n----- 目录:')**对于** elem **在** content:**如果** isdir(directory + elem):print(elem)print('\n----- 文件:')**对于** elem **在** content:**如果** isfile(directory + elem):print(directory + elem, '\t大小: ',getsize(directory + elem), sep = '')

你可以从导入的内容看出我们要使用 **os** 模块中的哪些元素。**listdir(*****path*****)** 函数返回指定目录的内容，作为一个列表。常量 **sep** 表示在各个系统中路径规范使用的分隔符，即 Windows 中的反斜杠（**\**），Linux 中的正斜杠（**/**）。最后，使用 **path** 模块中的 **isdir(*****path*****)** 和 **isfile(*****path*****)** 函数，我们可以判断给定的目录或文件路径是否指向一个有效的目录或文件。这两个函数都会返回一个 **bool** 值。最后导入的函数 **getsize(*****filename*****)** 返回指定文件的大小（单位为字节）。请注意：每次指定文件时，必须包含完整的路径，否则文件将无法找到。

这段代码使用了两个 **for** 循环，它们遍历由 **listdir()** 确定的目录内容。第一个循环只处理目录，这样这些目录就会在程序输出的最前面显示，第二个循环只处理文件，它们会显示在输出中目录列表的下面。

25.1 [10分钟]

编写一个函数，从字符串中移除所有元音字母。

25.2 [10分钟]

写一个函数，完全反转一个字符串，并将其转换为大写字母。

### 25.1.2 嵌套的 for 循环

**for**循环也可以相互嵌套。考虑以下示例：

letters = ['A','B','C','D','E','F','G']numbers = [1,2,3,4,5,6,7,8,8,10]**for** b **in** letters:**for** z **in** numbers:print(b + str(z), ' ', end = '')print('\n')

在这里我们看到两个**for**循环：一个*外部*循环遍历从 A 到 G 的字母列表，一个*内部*循环处理从 1 到 10 的数字。内部循环在外部循环的代码块中缩进。每次运行外部循环时，内部**for**构造都会完全执行一次，也就是说，从 1 到 10 的数字都会被处理。之后，外部循环进入下一次迭代，也就是处理下一个字母。你认为这个小程序会输出什么？

运行程序时我们看到的输出如下：

A1 A2 A3 A4 A5 A6 A7 A8 A10B1 B2 B3 B4 B5 B6 B7 B8 B10C1 C2 C3 C4 C5 C6 C7 C8 C10D1 D2 D3 D4 D5 D6 D7 D8 D10E1 E2 E3 E4 E5 E6 E7 E8 E10F1 F2 F3 F4 F5 F6 F7 F8 F10G1 G2 G3 G4 G5 G6 G7 G8 G10

因此，对于当前在外部循环中传递的字母**b from**在列表**letters**中的情况，程序将这个字母与从 1 到 10 的所有数字在内部循环中逐一组合输出；注意函数**print()**中的参数赋值**end = ''**，它使得每次输出后*不会*产生换行符。只有在内部循环完全遍历完后，才会输出换行符（**\n**），然后外部循环进入下一次迭代。请注意，**print('\n')**位于外部循环的缩进级别，而非内部循环的缩进级别。因此，外部循环代码块包含了完整的内部**for**循环和创建换行符的**print()**语句。

当然，不仅仅是两个，甚至更多的**for**循环也可以以这种方式进行嵌套。但是，你必须小心程序的运行时间，因为每增加一个**for**循环，基本上都会将循环的次数乘以它自己的迭代次数。

### 25.1.3 列表推导式

Python 中的一个特殊特性是*列表推导式*。乍一听可能让人觉得很吓人，但它其实只是一个生成列表的**for**循环。对于这种**for**循环，有一种简洁优雅的写法，即列表推导式。

在上一节中，我们使用了 **os** 模块中的 **listdir()** 函数来获取目录内容并将其作为列表，然后在 **for** 循环中使用 **isfile()** 函数检查每个元素，查看它是否是文件（而不是目录）。只有在确认它是文件时，我们才会将该项目输出到屏幕上。对于目录，我们在另一个 **for** 循环中做了相同的操作。通过这种方式，我们可以在输出中清晰地区分目录和文件。其实，最开始就创建两个列表，一个存放文件，一个存放目录，再用两个简单的 **for** 循环显示它们会更容易。这正是使用列表推导式的理想场景。考虑以下写法：

content = listdir(directory)files = [f **for** f **in** content **if** isfile(directory + f)]directories = [f **for** f **in** content **if** isdir(directory + f)]

首先，我们使用 **listdir()** 获取所选目录的内容。然后，我们使用两个列表推导式从列表 **content** 中筛选出文件和目录。列表推导式返回某些内容，即应包含在结果列表中的元素。返回的内容最初会被包含在方括号内，表示正在构造一个列表；在我们的示例中，这就是 **f**。接下来是 **for** 循环，即 **for f in content**。该循环会遍历列表 **content** 中的每个元素。然而，只有那些满足 **if** 定义的条件的元素才会被返回；例如，在第一个示例中，所有 **isfile()** 函数返回值为 **True** 的元素才会被返回。因此，列表推导式会遍历 **content** 中的所有元素（即目录内容的列表），并返回那些是文件的元素。

**if** 条件是可选的。例如，如果我们想要获取目录中所有项目的列表，但需要将它们转换为大写字母，我们可以省略该条件，但在返回结果之前，我们仍然可以通过调用 **upper()** 函数对结果进行修改：

content_capitalized = [f.upper() **for** f **in** content]

这个示例还展示了，列表推导式中由 **for** 循环传入新元素的表达式，可以比 **for** 循环返回的对象本身更复杂；在这种情况下，调用了该对象的方法。

另一个示例是，在下面的情况下，如果变量的值可以被 2 整除（即是偶数），我们将对由 **for** 循环返回的变量进行平方。为此，我们使用了取模运算符 **%**，它返回除法的余数。

squares = [x*x **for** x **in** range(1,11) **if** x % 2 == 0]

在这里，由 **for** 循环传入的表达式只是 **x*x**。

因此，列表推导式通常具有以下形式（我们已经看到，条件是可选的）：

list = [*表达式* **for** *变量* **in** *可迭代对象* **if** *条件*]25.3 [5 分钟]

编写一个列表推导式，汇总从 A 到 Z 的大写字母作为列表。提示：使用我们在 ► 第 [25.1.1](#Sec2) 节中也使用过的 **ord(*****字符*****)** 和 **chr(*****编码*****)** 函数。

如果不使用列表推导式，等效的 **for** 循环会是什么样子呢？

## 25.2 条件循环（while）

Python 允许使用带有条件的循环结构，即 **while** 循环，循环在满足运行条件时继续执行。Python 的 **while** 循环是 *头控型*，意味着条件在每次运行之前都会被检查。如果条件在第一次运行前就没有满足，循环将根本不会执行。

**while** 循环当然可以用来模拟与 **for** 循环相同的行为。在以下示例中，**while** 循环将数字 1 到 10 输出到屏幕：

i = 1**while** i <= 10:print(i)i = i + 1

我们初始化一个变量 **i**，作为运行变量，并将其赋值为 1。在每次运行之前，循环会检查条件是否仍然满足，即 **i** 是否小于或等于 10。如果满足，冒号后面的代码块将被执行，代码块会按常规缩进。然后，循环会跳回循环头，再次检查运行条件。

在这种结构中最常见的错误是忘记增加运行变量（这正是作者在第一次尝试时犯的错误），因为与 **for** 循环不同，**while** 循环不会自动执行此任务。**while** 循环只要满足运行条件就会固执地继续运行。我们必须自己处理其他部分。如果运行条件*始终*满足，就会创建一个无限循环，这通常是不希望的。

**while** 循环真正显示其强大之处的是，当——与上面的示例不同——循环的次数无法提前确定时。例如，因为循环的执行依赖于与用户交互所产生的事件。考虑以下示例。它列出了用户选择的目录中所有的文件，并允许用户打开或启动其中的一个文件。我们通过 **os** 模块中的 **startfile(*****file*****)** 函数来实现后者，这个函数我们在之前的部分已经使用过。在我们这个简单的应用中，用户可以通过一个编号来指定要打开/启动的文件。我们还提供了让用户更改目录或完全退出程序的选项。程序的核心是一个 **while** 循环，在该循环中，我们一遍又一遍地询问用户希望执行的操作（变量 **choice**），并根据用户输入的字母（**'d'** 代表读取目录，**'s'** 代表打开/启动文件，**'q'** 代表退出）作出相应的操作。**while** 循环的条件是用户的选择不同于 **'q'**。只要条件成立，程序就会继续运行，否则程序结束。

以下是完整的程序代码：

**from** os **import** listdir, startfile **from** os.path **import** isfile, isdir choice = '' dir_exists = **False** **while** choice != 'q': choice = input('读取目录 (d)，启动文件 (s)，退出 (q)? ') **if** choice != 'q': **if** choice == 'd': directory = input('请输入目录: ') **if** isdir(directory): dir_exists = **True** files = [f **for** f **in** listdir(directory) **if** isfile(f) == **True**] number = 0 **for** f **in** files: **if** isfile(directory + f): number = number + 1 print(number, ': ', f, sep = '') **else**: print('"', directory, '" 不是有效目录！", "请再试一次。', sep = '') dir_exists = **False** **elif** choice == 's': **if** dir_exists == **True**: number = int(input('请输入文件编号: ')) **if** number >= 1 **and** number <= files.__len__(): startfile(directory + files[number - 1]) **else**: print('没有加载目录！') **else**: print('输入 ', choice, ' 不允许！请再试一次。', sep = '')

当你运行程序时，请注意目录规范必须始终以路径分隔符结尾，即在 Windows 系统中是反斜杠 (**\**)，在 Mac 和 Linux 系统中是正斜杠 (**/**)，否则程序中拼接的文件路径将无效。

在**while**循环内，首先会询问用户想要执行的操作。如果用户选择的操作不是**'q'**，则会检查并处理**'s'**（开始）和**'d'**（读取目录）操作。否则，如果用户输入了**'x'**，则**while**循环内不发生任何事情，循环会跳回检查循环头部的运行条件，并且判断运行条件**choice != 'q'**不再满足。因此，程序在**while**循环的代码块之后继续执行。在我们的示例中，这将终止程序。

如你从这个程序示例中看到的，使用**while**循环，我们可以最终通过等待用户输入、处理输入并再次等待下一个用户输入来实现事件控制，直到用户希望退出程序。►第[22.2节](474412_1_En_22_Chapter.xhtml#Sec2)中的**tkinter**程序中的**mainloop()**函数最终做的就是这些。事件控制因此并非巫术，而是可以通过经典的控制结构，如**while**和**if**来实现的。

25.4 [20分钟]

编写一个程序，使用**convert_temperature()**函数（来自►第[24.1.2节](474412_1_En_24_Chapter.xhtml#Sec3)）将温度在开尔文与摄氏度之间转换（以及反向转换）。程序的用户应当被提供一个操作菜单，**'k'**（摄氏度到开尔文的转换）、**'c'**（开尔文到摄氏度的转换）和**'q'**（退出程序），直到用户输入**'q'**退出程序。

## 25.3 提前退出循环并重新启动

通过语句结束循环

使用**break**和**continue**语句，Python提供了更精确控制**for**和**while**循环流的可能性。调用**break**语句会终止循环，程序执行将继续*在*循环代码块之后。

考虑以下示例：

**while True:** x = input('请输入：') **if** x == 'x': **break** print('您的输入是：', x) print('循环完成。')

这个**while**循环有一个条件（**True**），根据定义这个条件始终为真。原则上，它会一直运行下去。然而，我们加入了一个条件，确保它只在用户输入**'x'**之前运行。当这种情况发生时，循环会通过**break**语句终止。位于循环代码块中的**print()**调用在**break**之后不再执行。

以下函数使用**break**提前退出**for**循环。这在某些情况下是非常有用的，例如在判断某物是否存在时。一旦找到了正在搜索的实例，进一步的循环遍历就没有意义，因为它们已经无法改变搜索的结果。在这种情况下，退出循环是明智的，可以节省计算时间并加快程序执行速度。

以下示例展示了一个函数，该函数检查目录中的文件，查看是否存在大于1 MB（即1,000,000字节）的Excel文件。

**from** os **import** listdir**from** os.path **import** isfile, getsize**def** big_excel(directory: str) -> bool:files = [f **for** f **in** listdir(directory) **if** isfile(directory + f)**and** (f[-5:].lower()== '.xlsx'**or** f[-4:].lower() == '.xls')]res = **False****for** f **in** files:**if** getsize(directory + f) > 1000000:res = **True****break****return** res

为此，首先生成一个Excel文件列表，该列表是通过列表推导式从待搜索的目录中生成的，并作为**directory**参数传递给函数。这个列表推导式检查哪些文件名具有表示Excel文件的扩展名（为了简化起见，我们这里只搜索**.xls**和**.xlsx**文件，忽略其他可能的Excel文件扩展名）。列表推导式因此检查了各个目录项是否为文件，并且其名称是否以**.xls**或**.xlsx**结尾。

然后，**for**-循环遍历由列表推导式生成的列表，并使用**getsize(file)**函数检查这些文件中是否有大于1 MB的文件。一旦找到这样的文件，循环通过**break**退出。在此之前，函数的返回值**res**从其默认值**False**切换为**True**，该默认值在循环开始前已初始化。在循环之后，执行**return**语句，将该值返回给调用者。

当然，文件大小必须超过1 MB的条件本可以包含在列表推导式中，然后完全可以省略**for**-循环（如何做？试试看！）但这个例子展示了如何通过在找到所需内容后立即终止搜索循环，使得搜索更高效。相同的效果也可以通过**while**循环实现，代码应该像这样：

i = 0res = **False****while** i <= files.length() **and** res == **False**:**if** getsize(directory + files[i]) > 1000000:res = **True**i = i + 1

使用**for**-循环的写法似乎更直观一些（并且避免了忘记递增运行变量**i**的风险）。

跳过当前循环并执行下一次

虽然**break**完全退出其所在的循环，而**continue**语句则使循环继续执行下一个循环周期。我们可以在下面的示例中看到这一点，其中我们通过一个**for**-循环遍历1到10之间的数字，但通过使用**continue**提前跳过所有偶数的**print()**语句，直接进入下一个循环周期：

**for** i **in** range(1,10):**if** i % 2 == 0:**continue**print(i)

这里我们使用了*取模运算符* **%**，它返回除法的余数；如果结果是 0，说明是偶数，循环将继续进行下一次迭代，此时循环代码块末尾的**print()**函数不会被执行。只有在奇数情况下，才会执行它，因此屏幕上只会输出奇数。

## 25.4 小结

在本章中，我们学习了**for**和**while**循环，以及基于**for**-循环的列表推导表达式。我们还看到了如何提前退出循环或当前的循环迭代。

请务必记住本章中的以下几点：

+   Python 将 **for** 构造视为一个计数循环，它遍历一个可遍历对象的元素；如果 Python 能够从对象的一个元素或组件移动到下一个元素（例如，列表、元组、集合或字典等对象），那么这个对象就是可遍历的。

+   **for**-循环的基本结构是：**for** ***变量*** **in** ***可遍历对象*** ：***代码块***；**变量**代表每次循环中，***可遍历对象*** 的一个不同元素。

+   对于变量的修改*不会*改变它所代表的可遍历对象的元素。

+   **for**-循环可以任意嵌套。

+   一种特殊的**for**-循环是列表推导表达式。它用非常紧凑的语法生成一个列表；其一般形式是：**list = [*****表达式*** **for 变量 in** ***可遍历对象*** **if** ***条件***]，例如从 1 到 10 的平方偶数列表：**squared = [x*x for x in range(1,11) if x % 2 == 0]**，其中**%**是取模运算符，用于返回除法的余数。

+   条件循环是通过**while**构建的，它们的一般形式是：**while** ***条件*** ：***代码块***。

+   **for**和**while**循环都可以通过**break**语句提前退出。

+   **continue** 语句终止当前的循环迭代，并继续下一次循环。

## 25.5 练习答案

练习 25.1

一个去除字符串中所有元音字母的函数可能是这样的：

**def** remove_vowels(s: str) -> str:res = list()s = list(s)**for** i **in** range(0,s.__len__(),1):**if** s[i] **not in** ('a','e','i','o','u'):res.append(s[i])**return** ''.join(res)

测试函数是否具有预期效果：

print(remove_vowels('Hello world!'))第25.2题为了反转字符串中的字符，首先将字符串转换成一个字符列表，然后通过**for**循环从*后向前*遍历该列表。因此，**range()**函数的增量参数（三个参数中的第三个）为-1。因为**range()**会运行到*指定边界之前*，所以第二个边界也必须是-1，这样最后一个返回的索引值就是0，从而可以访问字符串**s**的第一个字符。**def** invert_capitalization(s: str) -> str: s = list(s) res = list() **for** i **in** range(s.__len__() - 1, -1, -1): res.append(s[i].capitalize()) **return** str(''.join(res))

该函数可以像这样调用：

print(invert_ capitalization('Hello world!'))第25.3题

一个将字母从**A**到**Z**总结为列表的列表推导式可能看起来像这样：

capital_letters = [chr(b) **对于** b **在** range(ord('A'), ord('Z')+1)]

所以我们用变量**b**遍历字符编码，从字母A的编码开始，到字母Z的编码结束（注意：**range()**返回一个值的范围，但不包含指定的右边界/上限，因此需要**+1**）。然后我们使用**chr()**函数将这些编码转换回字母。

一个等效的**for**循环会是这样：

capital_letters = list() **for** b **in** range(ord('A'), ord('Z')+1): capital_letters.append(chr(b))第25.4题

例如，程序可能会是这样：

choice = ''**当** choice != 'q'：choice = input('摄氏度转开尔文（k），开尔文转摄氏度（c），退出（q）？')**如果** choice == 'k'：temp = input('请输入摄氏度温度：')orig_unit = '摄氏度' target_unit = '开尔文' to_celsius = False**elif** choice == 'c'：temp = input('请输入开尔文温度：')orig_unit = '开尔文' target_unit = '摄氏度' to_celsius = True**elif** choice == 'q'：**跳过** **else**：print('"', choice, '" 不是有效的输入，请再试一次。', sep = '')**如果** choice == 'k' **或** choice == 'c'：res = convert_temperature(float(temp), to_celsius)**如果** res != -1000：print(temp, orig_unit, '是', res, target_unit)

请注意，程序使用了来自► Sect. [24.​1.​2](474412_1_En_24_Chapter.xhtml#Sec3)的**convert_temperature()**函数。你需要这个代码来运行程序。另外，请注意，接收用户命令的变量**choice**必须在**while**循环之前初始化。否则，**while**循环在检查运行条件时会遇到一个不存在的变量，这将触发错误信息。
