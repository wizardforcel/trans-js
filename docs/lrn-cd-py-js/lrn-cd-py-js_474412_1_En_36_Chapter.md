© 作者，独家授权 Springer Fachmedien Wiesbaden GmbH，Springer Nature 的一部分 2024 J. L. Zuckarelli《用 Python 和 JavaScript 学习编程》[https://doi.org/10.1007/978-3-658-42912-6_36](https://doi.org/10.1007/978-3-658-42912-6_36)

# 36. 调试与错误处理：我如何以结构化的方式搜索并修复错误？

Joachim L. Zuckarelli^([1](#Aff2) )(1)德国慕尼黑概述

为了总结我们对 JavaScript 的介绍，我们转向一个不太受欢迎但却重要的主题——调试与错误处理。总体来说，JavaScript 在处理运行时错误时比其他编程语言更为健壮。因此，在其他语言中会因为错误消息而中止的程序，在 JavaScript 中只会继续运行。然而，这只是让运行时错误的处理看起来*更容易*；特殊的、不寻常的情况仍然需要你作为程序员提前预见并处理。

为了在整个开发过程中进行调试，现代浏览器中提供的开发者工具包含了多个有用的功能，你应当充分利用这些工具。

本章中你将学习：

+   JavaScript 如何处理运行时错误，以及这对你作为程序员意味着什么

+   如何捕获异常

+   如何使用浏览器调试工具来查找程序中的 bug，特别是如何设置断点、监视变量以及以单步模式运行程序

## 36.1 运行时错误处理

与许多其他编程语言相比，JavaScript 中导致程序终止的运行时错误较少。原因在于，JavaScript 处理一些在其他语言中会抛出异常的情况时，采取了不同的方式，并寻求一种不那么剧烈的解决方案。例如，如果你用**Math.sqrt(-1)**计算负数的平方根，返回值将是**NaN**——*不是一个数字*。如果你用 0 除以某个数，你会得到**Infinity**（如果被除数为负，则返回**-Infinity**）。如果你试图将一个非数字字符串转换为数字（例如使用**Number("abc")**），转换结果同样是**NaN**。在这些情况下，许多其他编程语言会导致服务失败并抛出异常。但在 JavaScript 中并非如此。JavaScript 会顽固地继续运行，只是通过操作结果来表明某些事情并没有按计划进行。

乍一看，这种处理错误的方式对你作为程序员来说是一个好事，因为它减少了程序因某些奇怪的异常而完全崩溃的风险。然而，毫无异常抛出并不意味着你的程序一定能按预期工作；毕竟，考虑到用户将一个本不应为数字的输入错误地转换成了数字，从而产生 **NaN** 值，你的 JavaScript 代码在这种情况下是否仍能产生有用的结果，当前还值得怀疑。因此，作为开发者，你必须通过合适的检查，确保你的程序能够应对所有可能的情形——即使这些情形*不*导致异常。

然而，例外情况当然也会在 JavaScript 中发生。例如，如果你对一个数字变量调用 **toLowerCase()** 方法（该方法将字符串转换为小写），你将得到一个异常，就像你尝试在脚本中访问一个没有实际分配给任何网页元素的 ID 的 HTML 元素时一样（例如我们前一章中的电子表格示例）。然而，这类错误通常并不是由仅在运行时发生的情况引起的，而是可以在开发过程中通过充分的测试发现并修正的。为了应对这类错误，浏览器中开发者工具的调试功能是特别重要的支持工具。我们将在下一节中讨论它们。

虽然在 JavaScript 中，异常的处理不如在许多其他语言中那么重要，但 JavaScript 也支持 Try-Catch 结构。它具有以下语法，因此，如果你还记得我们在 ► 第 [16.2](474412_1_En_16_Chapter.xhtml#Sec2) 节中的讨论，它有一个非常“经典”的结构：

**try** {*// 尝试执行的代码*} **catch** (err) {*// 错误处理的代码*} **finally** {*// 无论如何始终执行的代码*}

**catch** 接受一个错误对象作为参数，你可以从中提取各种信息，最显著的是错误名称（在 **name** 属性中）和错误消息（在 **message** 属性中）。如果你特别关心异常是在代码的哪一行抛出的，可以查询 **err** 对象的 **line** 属性（或者你在脚本中为 **catch()** 的参数起的任何名字）。

顺便提一下，你还可以通过 **throw** 语句自己创建异常。例如，你可以使用异常来测试在除法运算时，除数是否为 0：

**var** a = 10, b = 0; **try** { **if**(b == 0) **throw new** Error('除以 0 是不可能的！'); } **catch** (myError) { console.log('发生错误：', myError.message); }

当然，如果你没有捕获自己的异常，你将在浏览器的 JavaScript 控制台中看到一个合适的错误消息，程序将中止，这也算是一个适当的异常！

## 36.2 开发过程中的故障排除

在开发过程中，为了调试，现代浏览器通常会提供一些工具，我们在►第[29.2.1节](474412_1_En_29_Chapter.xhtml#Sec5)中已经学习过。这些工具包括断点、变量监视和逐步执行。

尽管我们在本节中经常提到 Google *Chrome* 的情况，但你会发现几乎所有其他现代浏览器也有相同或非常相似的工具。即使是功能和工作方式，通常也极其相似。

为了让接下来的讨论更加生动，考虑一下以下这个网页示例，用户可以简单地输入一个数字并点击一个按钮：

**<!DOCTYPE html>**<**html>**<**head>**<title>**Script with errors**</title>**<noscript>**请启用JavaScript！**</noscript>**</head>**<body>**<script** src="witherror.js"**></script>**<**form>**<**p>**数字：**<input** type="text" id="number"**></p>**<**p><span** id="result"**></span>**<**p></p>**<**input** type="button" value="计算"onclick="calculate()"**>**</form>**</body>**</html>**

为了输出计算结果，我们创建了一个带有ID **result** 的 **span** 元素。在网页中，我们包含了脚本 **witherror.js**，其中还包含了当按钮被点击时触发的 **calculate()** 函数。代码如下：

**function** calculate() {**var** num = Number(document.getElementById(**'number'**).value); num = Math.round(num); num = Math.sqrt(**'num'**); var result = document.getElementById(**'result'**); result.innerHTML = **'根号：'** + num;}

如你所见，我们在这里做的只是读取用户输入的数字，将其四舍五入为整数，然后从中求平方根。我们将结果输出到我们的 **span** 元素中。到目前为止，一切正常。

如果你现在在浏览器中打开网页，输入一个数字并点击按钮，你会在网页的**span**元素**result**上看到输出**NaN**。因此，计算的结果显然不是一个数字。要深入了解问题，你当然可以研究程序代码，也许你已经注意到错误（当然，这完全是故意的）；或者你可以简单地在每次操作后通过在程序代码中加入像**console.log(num)**这样的输出语句，将我们在整个脚本中使用的变量**num**输出出来。当然，不管哪种方式都能帮助你找到问题，即使你没有浏览器中的调试工具。临时在程序代码中插入输出语句可能是最流行的调试方法，因为它既简单又有效。然而，特别是当你怀疑错误的代码段非常长时，你可能需要很多调试输出，或者你可能需要逐步将输出移到代码段的更远处，直到找到问题的根源。这样做非常繁琐。在这种情况下，使用浏览器提供的调试工具就显得非常有价值，这也是我们现在要使用的方法。

如果你点击开发者工具中的“Sources”（来源）标签，然后选择你的JavaScript文件，你会在开发者工具区域的中间看到其内容。你可以在◘ 图[36.1](#Fig1)中看到这一点。![](../images/474412_1_En_36_Chapter/474412_1_En_36_Fig1_HTML.jpg)

这是“来源”标签下JavaScript文件的截图。中间的内容页面展示了一组程序代码，左边是一个数字输入框，默认值是NaN，右边是一个计算按钮。

图36.1

Google *Chrome*中的JavaScript调试区域

在开发者工具区域的右侧，你将看到几个可展开和折叠的子区域，其中包括“Breakpoints”（断点）子区域。如果你点击代码显示前的行号，就会在该位置设置一个*断点*。如果你现在执行JavaScript代码，在我们的例子中就是点击网页上的按钮，JavaScript代码会执行直到到达断点。然后就会出现如下图所示的情况◘ 图[36.2](#Fig2)。程序的执行已经在第3行执行之前停止了。在“Scope”（作用域）子区域，你可以看到当前作用域中存在的变量及其值，在我们的例子中，变量**num**的值是36。所以，显然这里一切正常。我们可以将断点移到代码的更下方，并让程序继续执行到下一个断点。◘ 图[36.3](#Fig3)显示了程序在另一个断点，即第6行时的状态。我们可以从右侧的“Scope”子区域看到，**num**此时的值已经变为**NaN**。![](../images/474412_1_En_36_Chapter/474412_1_En_36_Fig2_HTML.jpg)

在“源”标签下的 Javascript 文件截图。中心的内容页面包含一组程序代码。第 3 行从中执行。左侧的数字文本框在调试器中显示为暂停状态。

图 36.2

在 Google *Chrome* 中到达断点

![](../images/474412_1_En_36_Chapter/474412_1_En_36_Fig3_HTML.jpg)

在“源”标签下的 Javascript 文件截图。中心的内容页面包含一组程序代码。第 6 行从中执行。程序在断点处暂停。

图 36.3

到达断点后（在第 4 行的错误之后）

所以，第 3 行和第 4 行之间肯定发生了什么。当然，仔细观察会立刻揭示错误的来源：在第 4 行，**Math.sqrt()** 函数没有传递变量 **num**，而是传递了一个字符串 **'num'**（你之前看到过吗？）。显然，不能从字符串计算平方根；但是由于 JavaScript 相对容错，如前所述，**Math.sqrt()** 只是返回了 **NaN**，而不是抛出异常。

你也可以选择逐步执行程序，而不是移动断点。每次按下 <F9>（“步进”），程序的下一条语句就会执行。通过这种方式，你很容易发现问题出在第 5 行。

一个有趣的调试器功能是可以添加*事件监听器*。这可以在对应的子区域中完成，你可以在 ◘ 图 [36.4](#Fig4) 中看到这里的设置。在这里，你有设置事件断点的选项，即当某个事件发生时触发的断点，例如鼠标点击。在事件驱动的程序流中，这种类型的断点是一个有用的替代方案，尤其是当你有许多事件处理程序响应特定类型事件时，它比绑定到特定行的断点更为有用。![](../images/474412_1_En_36_Chapter/474412_1_En_36_Fig4_HTML.jpg)

在“源”标签下的 Javascript 文件截图。中心的内容页面包含一组程序代码。右侧设置了事件监听器断点。在鼠标标题下选择了点击（Click）。

图 36.4

在 Google *Chrome* 中设置事件断点

因此，断点对于诊断错误非常有用。如果你希望从断点继续执行程序，可以点击调试区域右上方工具栏中的播放按钮。

在右侧的第一个子区域“观察”区域，你可以设置*变量观察*，即输入你想监视的表达式，并在程序执行停在断点时仔细查看其值。你在这里输入的表达式不一定是简单的变量，就像我们在示例中仅监视变量 **num** 的值一样，你也可以输入更复杂的表达式，例如 **Math.sqrt(num)>2.8**（一个布尔表达式）。

## 36.3 摘要

在 JavaScript 部分的最后，我们探讨了错误诊断和处理。

请务必从本章中记住以下几点：

+   JavaScript对运行时错误具有相对较强的容错性，因此它很少以错误信息终止。然而，这并不免除程序员在任何特殊情况下仍需确保程序按预期执行的责任。

+   Try-Catch结构也提供了一种在JavaScript中捕获异常的方式；当发生异常时，**catch()**语句会自动传入一个错误对象，你可以评估该对象以了解更多关于异常的信息。

+   几乎所有现代浏览器的开发者工具都提供了多个有用的调试功能，用于在开发过程中诊断错误；这些调试功能特别包括用于处理断点的函数，用于观察变量内容的功能，以及用于单步执行程序的功能。此外，事件监听器提供了将断点与事件发生本身链接的可能性。

+   实践中最常用的“调试工具”可能是**console.log()**函数。通过这种方式生成的输出可以帮助在许多情况下追踪错误的原因；与此相比，开发者工具中的调试工具尤其（但不仅仅是）在没有明确线索表明错误来源的情况下展现出它们的优势。
