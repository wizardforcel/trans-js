© 作者（们），独家授权给Springer Fachmedien Wiesbaden GmbH，Springer Nature的一部分，2024J. L. Zuckarelli《用Python和JavaScript学习编程》 [https://doi.org/10.1007/978-3-658-42912-6_33](https://doi.org/10.1007/978-3-658-42912-6_33)

# 33. 函数与方法：如何使用程序函数处理数据并触发操作？

Joachim L. Zuckarelli^([1](#Aff2)  )(1)德国慕尼黑概览

接下来，我们将研究函数，它们被认为是JavaScript编程的核心，就像它们在其他各种编程语言中的作用一样。毕竟，你不仅会不断使用JavaScript提供的现成函数，或者从扩展库中获得函数，还会经常编写自己的函数；尤其是事件驱动的JavaScript应用中扮演核心角色的事件处理程序。所以，深入研究函数成为我们探索JavaScript过程中的核心内容也就不足为奇了。

在本章中，你将学到：

+   如何定义和调用函数

+   函数如何处理参数并返回结果

+   函数也是对象，这带来了哪些后果

+   变量的作用域在JavaScript中是如何被切割的——特别是与函数相关的作用域——以及这如何影响变量的可访问性

+   如何通过外部库扩展可用函数，超出标准语言的范围，并且如何找到合适的扩展库

+   什么是框架，它们与库有何不同

## 33.1 使用函数

### 33.1.1 函数的定义

定义函数

在JavaScript中，函数是通过关键字**function**定义的。任何参数都放在函数标识符后的圆括号中，即使函数没有传递任何参数，圆括号也是必须的。当函数被调用时，执行的程序代码会作为代码块放在大括号内。一个简单的函数，它只是在控制台打印“Hello World”，看起来是这样的：

**function** hello() {console.log('Hello World! ');}

现在可以从程序中（或控制台）调用它：

hello();

如果在控制台调用函数时忘记加圆括号，尤其是当函数没有参数时，这种情况很容易发生，你将看到函数的源代码。

作为对象的函数

JavaScript中的函数本身就是对象，类型为**function**，这可以轻松验证：

**>** typeof(hello)"function"

由于它们是对象，它们也可以被分配给其他变量对象：

**>** greeting = hello**>** greetings()Hello World!

如果我们在这里写了**greeting = hello()**，我们实际上是将**hello()**的*值*赋给了变量**greeting**，因为**hello()**不过是调用了同名的函数。（正如我们稍后将看到的，这个函数值会是**undefined**，因为该函数没有显式返回值）。

作为对象，它们还拥有若干方法和属性；例如，**toString()**函数会将函数的源代码作为字符串返回：

**>** greeting.toString()"function hello() {console.log('Hello World!');}"

在这里，函数名称（**greeting**）后不能使用圆括号，因为我们不想*调用*函数并获取其返回值，而只是想访问函数对象的方法和属性。

函数作为对象的特性在其他地方也很明显，我们可以像处理任何其他对象一样处理它们。在►第[31.5.2节](474412_1_En_31_Chapter.xhtml#Sec13)中，我们看到过如何使用**var**关键字创建对象。这正是我们可以用函数对象做的事情：

**var** hello = **function**() {console.log('Hello World!');}

在这里，我们用函数表达式初始化一个变量**hello**，该表达式由关键字**function**引入。此后，**hello**是一个可调用的对象，可以通过**hello()**来执行。

因为**hello**现在是一个真正的对象，我们也可以向它添加属性——这看起来可能有些奇怪。

**>** hello.counter = 5**>** typeof(hello)"function"**>** hello.counter5

这个对象仍然是**function**类型，但现在有了一个额外的属性——**counter**。当我们在►第[31.5.5节](474412_1_En_31_Chapter.xhtml#Sec16)中使用构造函数创建对象时，我们做了类似的事情（可以回顾一下**Product**对象类型的构造函数）。构造函数最终通过使用**this**关键字写入当前对象的属性。

由于函数本质上是对象，它们也可以作为其他对象的属性使用，从而使这些对象拥有可调用的*方法*。假设我们想要开发一个对象，用于保存一个日期，并将日期拆解为组成部分，同时拥有一个**display()**方法，可以以响应式格式输出日期。我们可以按如下方式定义这个对象：

**var** shortdate = {day: 0, month: 0, year: 0, display: **function**() {console.log(**this**.year + '/' + **this**.month + '/' + **this**.day)}}

注意关键字**this**。我们在►第[31.5.5节](474412_1_En_31_Chapter.xhtml#Sec16)中已经遇到过它，它用于建立当前上下文的引用，在该上下文中（如这里）调用属性或方法。因此，使用**this.day**我们可以访问当前上下文中的**day**属性，而这个上下文就是对象定义的上下文。如果省略**this**关键字，JavaScript将无法理解**day**代表的是什么，因为在**display()**函数内部没有定义名为**day**的变量。在此声明之后，我们可以通过输入日期组件，然后调用**display()**函数来操作对象：

shortdate.day = 14;shortdate.month = 12;shortdate.year = 2025;shortdate.display();

这个方法调用会输出**2025/12/14**。

所以，正如你所看到的，我们可以非常轻松地用可调用的方法填充一个对象，因为这些方法最终只是对象的属性，而它们是**function**类型的属性。它们与对象的其他属性的区别仅在于它们是可调用的。

高级话题 I：函数中的函数

JavaScript的一个特殊功能是函数也可以在函数内部定义。一个简单的（尽管在内容上并不非常有意义）例子：

**function** helloWorld() {**function** hello() {console.log('Hello');}**function** world() {console.log('World!');}hello();world();}

在这里，我们在函数**helloWorld()**内定义了两个进一步的函数**hello()**和**world()**，它们分别在控制台输出内容。然后，两个函数都被调用。这样，控制台中会生成两行**Hello**和**World!**。

另外，我们也可以通过对象赋值来创建（“子”）函数：

**function** helloWorld() {hello = **function**() {console.log('Hello');}world = **function**() {console.log('World!');}hello();world();}

在函数内部定义函数，乍一看可能像是一个语法上的花招，但在处理代码模块时，这种第二种变体有实际的应用。

顺便问一下，如果我们在（“子”）函数的定义中写了**this.hello = function...**和**this.world = function...**会发生什么呢？那我们就会为**helloWorld**对象开发一个*构造函数*，为对象提供两个属性，即这两个函数。然后我们可以创建这种类型的对象，并访问它们的两个（函数）属性（即方法）：

hi = **new** helloWorld();hi.hello();高级话题 II：匿名函数

函数通常有一个名称，通过这个名称可以被调用。然而，也可以定义没有自己名称的函数，或者*匿名*函数。

一个简单的例子是这样：

(**function**() {console.log('Hello World')}) ()

你首先会看到圆括号中包含一个函数定义，但没有函数标识符。括号表达式返回一个函数（一个函数对象），我们会*立即再次调用它*。这可以通过结尾的括号对看出。它们是通常用于调用“普通”函数时使用的括号，虽然没有参数。这种方式下，函数不需要任何名称，仍然可以被调用，但在我们的例子中，只能在其定义的直接上下文中调用，因为否则我们就缺少可以触碰它的“把手”。

对于“语法美食家”来说，有一种方法可以创建这样的“把手”，我们之前用过。我们将匿名函数赋值给一个对象。为了做到这一点，让我们再次看看上面的一个例子：

**var** hello = function() {console.log('Hello World!');}

在这里，我们创建了一个名为**hello**的变量，但赋给它的函数没有标识符。如果你在控制台输入*变量*的名称，将会显示该函数的源代码；然而，函数中并没有显示函数标识符：

**>** hellof () {console.log('Hello World!');}

尽管这看起来有点令人困惑，但我们创建了一个名为**hello**的对象，它代表一个函数，但该函数本身是匿名的，因此没有名字。然而，如果我们使用函数标识符来定义该函数，我们仍然会得到一个函数对象；不过，这次函数是有名字的：

**>** var hello = function hello() {console.log('Hello World!');}**>** hellof hello() {console.log('Hello World!');}

因此，我们不一定要在定义后立即调用匿名函数，也可以将其捕获在对象中。就像“函数中的函数”一样，匿名函数在构建整个代码模块时也非常有用。在“日常编程”中，通常使用的是带有函数标识符的函数。

### 33.1.2 返回值

函数可以使用**return** 语句返回对象。以下函数生成并返回一个介于 0 和 10 之间的随机数：

**function** getRandomNumber() {**var** randomNumber;randomNumber = Math.round(Math.random()*10,0);**return** randomNumber;}

**return** 语句也可以像函数一样编写，而不是使用关键字**return**，在我们的例子中就是**return(randomNumber)**。

没有**return**语句的函数会完成它们的工作（在我们的例子中是打印一些内容到控制台），但返回**undefined**：

**>** function hello() {console.log('Hello World!');}**>** res = hello()Hello World**>** resundefined

### 33.1.3 函数的参数和参数列表

参数和实参的基础

数学函数是赋值规则，它们将一个值赋给一个或多个参数。到目前为止，我们只考虑了完全没有参数的函数。然而，通常情况下，函数之所以有用，正是因为你可以在调用它们时传递参数，从而控制它们的行为或传递数据供其处理。

从术语上讲，我们到目前为止的描述比 JavaScript 中常见的要宽泛一些。在这里，区分*参数*和*实参*并不罕见。参数是列在函数*定义*中的抽象值，函数接受这些值，而实参则是在函数*调用*时实际传递给函数的具体值。

在 JavaScript 中，参数在函数定义中指定时没有类型。这意味着程序员必须自己进行必要的类型检查。

之前用来将温度从开尔文转换为摄氏度的示例，使用函数参数后将变成这样（但没有检查参数的类型）：

**function** kelvinToCelsius(kelvin) {**return** kelvin - 273.15;}

**kelvin** 是函数的 *参数*。如果稍后我们调用该函数，比如传入温度 54 的开尔文温标，那么 54 就是参数 **kelvin** 的 *实参*。函数定义中的多个参数会用逗号分隔。

在函数内部修改参数

在 JavaScript 中，当参数的数据类型是基本数据类型（如 **number**、**string** 或 **boolean**）时，参数始终以 *值* 的形式传递；因此，如果将一个变量传递给函数，并且函数修改了传入的参数，那么原始变量并不会改变。从某种意义上说，函数是操作传入的值的副本，而不是变量本身。所以，传递是通过 *值* 完成的。

然而，如果你传递了一个更复杂的对象并对其进行了更改，那么传递给函数的对象会发生改变。这时，传递是通过 *引用* 完成的。

以下示例说明了这种区别：

**function** Product(price, name) {**this**.price = price;**this**.name = name;}**var** chair = new Product(24.99, 'Garden chair');**var** purchased = false;**function** setPrice(article, price) {article.price = price;}**function** purchase(purchaseStatus) {purchaseStatus = true;}在这个示例中，我们再次使用了对象类型 **Product**，其构造函数首先被调用来创建一个名为 **chair** 的 **Product** 对象，并初始化一些属性，包括价格，设置为 **24.99**。我们还创建了一个 **boolean** 变量 **purchased**，表示某物是否已售出，初始值为 **false**。以下是两个函数的定义：**setPrice(article, price)**，它修改传递给它的产品的价格（作为第一个参数），以及 **purchase(purchaseStatus)**，它接受一个 **boolean** 类型的变量作为销售指示符，并将其设置为 **true**（或者不设置，正如我们将看到的）。让我们在控制台中尝试这两个函数：**>** **setPrice(chair, 50.89)** **>** **purchase(purchased)** **>** **chair.price 50.89** **>** **purchased false**

如你所见，椅子的价格发生了变化，但状态指示符 **purchased** 保持了其原始值。**purchased** 是一个 *原始值*，它不能作为函数（**purchaseStatus**）的参数进行更改；而对象 **chair** 则可以在函数的代码中被修改，如果它作为参数 **article** 传递给函数的话。

带参数调用函数

在调用函数时，也可以通过参数名来传递参数；例如，我们可以将开尔文到摄氏度的转换函数调用为 **kelvinToCelsius(kelvin=54)**。通过参数名传递实参可以使参数与实参之间的赋值关系更加清晰，并且这一方式也允许按照不同于函数定义中参数顺序的顺序传递实参。

JavaScript在参数数量方面非常灵活：如果给函数传递了*过多*的参数，“多余”的参数会被简单地忽略。关于*过少*参数的处理，我们进入了默认值和可选参数的主题。

处理默认值和可选参数

参数可以像大多数其他编程语言一样被赋予默认值，当调用函数时如果没有提供该参数的具体值，即没有传递实际的参数值，则始终使用默认值。

然而，与许多其他编程语言不同，这个默认值并不是使参数可选的原因。实际上，*所有*参数在JavaScript中都是可选的。如果参数没有默认值，且在函数调用中没有被指定，则自动赋值为**undefined**。在我们的示例中，调用上面提到的温度转换函数**kelvinToCelsius()**是完全有效的，但会返回**NaN**（*非数字*），因为在这种情况下，JavaScript将**kelvin**参数的值假定为**undefined**，而**undefined**不能用于数学计算。

将函数作为函数的参数

函数的参数可以是任何对象类型。它们甚至可以是函数对象本身。通过我们之前讨论的内容，这不应该让你感到惊讶。然而，我们希望通过一个示例来说明这一点，展示它是JavaScript的一个非常有用的特性。

考虑以下两个函数，它们分别以不同方式将学生的名字和姓氏连接起来：

**function** lastFirst(firstname, lastName) {**return** lastName + ', ' + firstName;}**function** firstLast(firstName, lastName) {**return** firstName + ' ' + lastName;}

现在我们可以开发一个**showMark()**函数，除了显示学生的名字外，还负责显示考试成绩：

function showMark(firstName, lastName, mark, displayName) {console.log(displayName(firstName, lastName) + ': ' + mark);}

现在我们可以如下调用**showMark()**：

**>** showNote('Beth', 'Hathaway', 'A+', lastFirst);Hathaway, Bath: A+**>** showNote('Beth', 'Hathaway', 'A+', firstLast);Beth Hathaway: 1.0

因此，**showMark()**使用作为参数传入的**displayName**函数。这使得**showMark()**非常灵活。只要传入的函数按照名字和姓氏的顺序处理，它就可以以不同的方式显示名字。

处理可变数量的参数

JavaScript提供了一种方便的方法来访问函数的参数，而无需使用参数的名称。这在你无法预先知道用户会传递多少参数的情况下尤其有用。在以下简单的示例中，我们有一个可以接受多个字符串作为参数的函数，它将这些字符串组合成一个新闻滚动条，并使用**+++**作为分隔符：

**function** newsTicker() {**var** ticker = Array.from(arguments).join(' +++ ');console.log(ticker)}

现在可以像这样调用，例如：

**>** newsTicker('Eagles at 49ers 35:38', 'Chiefs at Bengals 23:20')Eagles at 49ers 35:38 +++ Chiefs at Bengals 23:20

我们可以返回*任何其他数量*的配对，而不是仅仅两个比赛结果。我们的**newsTicker()**函数能够应对这种情况，尽管乍一看它根本没有接收任何参数！然而，由于 JavaScript 允许传递比函数定义中参数更多的参数，我们可以根据需要随心所欲地将任何数量的足球比赛结果传递给我们的新闻播报器。

Arguments 在某些方面表现得像一个数组。例如，你可以通过**arguments[0]**、**arguments[1]**等访问传递给函数的单个参数。然而，**arguments**并不是真正的数组。除了**length**属性（返回传递的参数数量）之外，**arguments**没有其他常见的数组属性和方法。为了我们的目的，我们必须先将它转换为**Array**类型，这样我们就可以使用**join()**函数来连接单个元素。这里我们使用**Array对象**的**from()**函数，它将类数组对象（如**arguments**）转换为真正的数组。

33.1 [5 分钟]

定义一个**Product**对象，包含产品名称和价格作为属性，并为该对象开发一个方法，应用一个价格折扣，这个折扣由调用者作为参数指定。如果调用者没有指定折扣，则假定价格应该减少 20%。

33.2 [5 分钟]

编写一个可以传入**Product**对象（如前一个任务中的对象）的函数，并应用作为参数传递的折扣。该函数不应是对象的方法。修改后的产品对象的“返回”可以通过哪两种方式完成，为什么？

33.3 [5 分钟]

开发一个函数，接受不定数量的参数，并返回按字母顺序排序的数组。

33.4 [5 分钟]

编写一个函数，向控制台输出。将结果函数对象分配给另一个变量。然后使用这个其他变量调用该函数。

### 33.1.4 函数中的变量作用域

尤其是与函数相关时，变量的有效范围起着重要作用。使用**var**在函数内声明的变量是*局部*变量，仅存在于该函数的代码块中。它们不能在函数外部访问。

然而，如果在函数内访问一个变量*没有*使用**var**，那么只有在不存在同名的全局变量（即在函数外声明的变量，“高一级”）时，才会创建一个新的局部变量。

考虑以下简单示例：

**var** factor1 = 3, factor2 = 5;**function** multiply() {**var** factor2 = 7;result = factor1 * factor2;factor1 = 11;factor3 = 200;**return** result;}console.log(multiply());console.log(factor1);console.log(factor2);console.log(factor3);

这个小程序产生了四个输出：

21115200

在函数**multiply()**中创建了一个*局部*变量**factor2**，它使用**var**声明，其值（7）与在函数外部声明并初始化的同名全局变量（5）不同。

调用函数后，我们将变量**factor2**的值输出到控制台。这样做时，我们自动访问了*全局*变量**factor2**，因为同名的局部变量在**multiply()**函数结束时不再存在。然而，在函数内进行乘法计算时，使用的是值为7的局部变量。在某种意义上，它屏蔽了全局变量**factor2**；因此它不可见。当在语句**result = factor1 * factor2**中访问变量**factor2**时，局部变量会自动被使用。只有当没有局部变量时，才会查找全局变量，并且在**factor1**的情况下，找到了一个。然后给这个变量赋了一个新值。由于没有使用**var**关键字，赋值发生在全局变量上。因此，这个变量值的变化在函数外部也是可见的，正如控制台中的第二个输出所示。如果赋值前使用了**var**，我们就不是给全局变量赋值，而是创建了一个*新的局部*变量**factor1**。然后，值11会被赋给这个局部变量，而不影响全局变量**factor1**，它会在局部变量的作用下保持不可见，并在**multiply()**函数执行完毕后保留原有值。

这正是发生的情况，正如你在第三个输出中看到的，变量**factor2**仅在函数内部看似被赋予了一个新值；这个新值被赋给了新的*局部*变量**factor2**，因此全局变量的值并没有因为赋值而发生改变。

第四个输出很有趣。它访问了变量**factor3**，这个变量首次在我们的**multiply()**函数中使用。我们已经说过，函数内没有使用**var**关键字访问的变量是全局变量。正是这种情况发生在**factor3**上：通过赋值**factor3 = 200**，我们创建了一个全局变量，尽管赋值发生在*函数内*。而且由于**factor3**是一个全局变量，我们可以在函数外部毫无问题地访问它存储的值。

顺便说一下，传递给函数的参数始终是局部变量。如果存在同名的全局变量，它将被函数“遮蔽”，即不可见。如果你通过标识符访问该变量，你实际上是在操作同名的局部变量，即函数的参数。

33.5 [10 分钟]

执行以下程序后，变量**x**、**y**、**y1**、**y2**和**z**的值分别是多少？为什么？

x = 5;z = 3;**function** allOthers(x, y) {y1 = x;x = null;var y2 = y;z = 1;}allOthers(6,2);

## 33.2 使用模块/库

### 33.2.1 开发和使用自有模块

使用模块意味着包含外部的代码。外包代码尤其有意义，如果你希望在不同的程序中使用该代码。例如，如果你开发了一个实用函数，并希望不仅在原始设计它的程序中使用，还希望在其他程序中使用，最简单的做法是将这个函数外包到它自己的模块中，然后在所有需要访问该函数的程序中包含这个模块。

包含另一个JavaScript文件最简单的方法是使用**script**元素将其包含在网页中。让我们通过一个例子来具体看看。

在► 第[33.1.2节](#Sec3)中，我们开发了一个返回0到10之间随机数的函数**getRandomNumber()**。假设由于这个函数很方便，我们希望在不同的脚本中使用它，我们想将它放入自己的模块中。为此，我们首先创建一个新的JavaScript文件**mymodule.js**，并将函数放在其中。此外，我们在模块中定义一个名为**fixedNumber**的变量。这将使我们的文件**mymodule.js**看起来像这样：

**function** getRandomNumber() {**var** randomNumber;randomNumber = Math.round(Math.random()*10, 0);**return** randomNumber;}fixedNumber = 4;

函数**getRandomNumber()**和变量**fixedNumber**是从另一个名为**moduleapplication.js**的JavaScript程序中访问的：

document.write('随机数：', getRandomNumber());document.write('<p></p>');document.write('固定数值：', fixedNumber);

该脚本又被嵌入到一个简单的网页中：

**<!DOCTYPE html>**<**html>****<head>****<title>**带有自有模块的脚本**</title>****<noscript>**请启用JavaScript！**</noscript>****</head>****<body>****<script** src="mymodule.js"**></script>****<script** src="moduleapplication.js"**></script>****</body>****</html>**

为了使我们在**mymodule.js**中定义的函数和变量可以在实际的程序中使用（该程序位于**moduleapplication.js**文件中），我们需要在网页中包含该模块，并且必须在**moduleapplication.js**之前包含它。由于脚本是按顺序处理的，如果我们在后面才包含该模块，在从**moduleapplication.js**访问时，模块内容将不可用。所以，请注意顺序！

现在，当我们打开网页时，得到的输出如下所示：

随机数：2固定数：4

同样地，你现在可以在其他项目中包含模块**mymodule.js**，并在那里访问函数**getRandomNumber()**，而不必在新项目的主代码文件中重复该函数的代码。

JavaScript处理模块的能力随着时间的推移不断扩展。虽然最初这一能力仅限于将几个源文件包含到网页中（就像我们刚刚做的那样），但随着新语言标准的推出，真正的模块化成为可能。这使得更加精确地控制模块导出哪些对象并可以再次被其他模块（以及JavaScript应用程序本身）导入变得可能。导入时，还提供了各种选项来处理命名冲突，防止模块提供的对象（例如函数）与导入代码中已存在的对象的标识符冲突。

然而，这些考虑因素超出了JavaScript开发入门的范围。对我们来说，知道如何通过将代码拆分成单独的脚本文件，然后将它们嵌入到HTML页面中来实现代码模块化就足够了。

### 33.2.2 查找和集成外部模块/库

与某些其他编程语言（例如Python通过*Python包索引*，见► 第[23.3.3节](474412_1_En_23_Chapter.xhtml#Sec10)）不同，JavaScript没有一个中央或准官方平台，你可以在上面找到在开发自己应用程序时有用的代码。然而，当然也有一些非常活跃的JavaScript社区“热点”；首先是*GitHub*，我们已经在► 第[13.2节](474412_1_En_13_Chapter.xhtml#Sec2)中查看过，它是一个基于Linux发明者*Linus Torvalds*开发的版本控制工具*git*的开发者交流和协作平台。在这里，你将找到大量的*仓库*，即代码档案，包含无数有用的函数和类。

在使用第三方代码之前，请通过仓库中的**LICENSE**文件了解许可情况！大多数将作品公开在*GitHub*上的开发者都会使用一些知名的标准许可证，例如*GNU通用公共许可证*、*创意共享许可证*或*MIT许可证*，每种许可证通常都有多个变种和版本。方便的是，*GitHub*总是为你提供这些标准许可证的摘要，显示你可以对代码做什么，不能做什么。因此，你完全不需要经常阅读冗长的法律文本就能理解你被允许如何使用其他开发者的先前作品。*GitHub*已经为你完成了这项工作。

*GitHub 仓库* 通常包含大量文件。如果你发现这些文件的描述（仓库代码视图中的中间列）看起来很奇怪，不要感到惊讶。这个列并不包含文件的描述，而是解释文件最后一次更改的注释。实际上，最重要的文件通常位于仓库的**\dist**目录；它们是*可分发*文件，即那些用于分发和生产环境的代码文件。如果你想阅读代码，建议查看**\src**目录。这是因为**\dist**中的代码通常会去除不必要的字符（例如空格和注释），以尽可能减小文件大小并提高使用这些代码的网页的性能。有时代码会被混淆（请回到几页前的►第29.1.2节，我们讨论了混淆）。当然，你也可以直接使用**\src**目录中的代码。

让代码对你可用的最简单方法是通过“关闭或下载”按钮下载 ZIP 文件，然后在你的计算机上解压。它包含了整个仓库。虽然拥有代码是必要的，但理解如何使用它也同样重要。各个项目的**README**文件以及**\doc**文件夹中的其他文件通常会提供相关信息。

除了*GitHub*，当然还有许多其他来源可以获取 JavaScript 模块，例如► [*javascripting.com*](http://javascripting.com)。此外，通过模式为“我怎么做...”的定向互联网搜索，通常也能找到指向可以下载模块的答案。或者，你可以向 ChatGPT 提问类似“哪些 JavaScript 模块可以*在网站上实现滚动新闻跑马灯*？”（将斜体部分替换为你自己的兴趣主题）。

顺便提一句，最流行的 JavaScript 库之一是*jQuery*，它特别简化了与浏览器对象模型的交互（例如，选择和修改 HTML 元素）。

## 33.3 框架

*框架*在如今使用 JavaScript 进行专业应用开发中起着重要作用。框架与普通的程序库/模块的不同之处在于，它们为应用程序提供了一个框架，当需要时会调用开发者编写的代码。而在使用库时，是开发者的代码在需要时调用库。因此，在框架的背景下，人们谈论的是*控制反转*。框架在实践中扮演着重要角色，因为它们使程序员能够集中精力开发应用程序的核心功能，其他更加标准的任务，如处理登录和会话管理，或者从数据库中检索数据并在基于模板的页面中显示这些数据，则交由框架来处理。

一些著名的 JavaScript 框架包括*Angular*、*React*和*Vue*。深入研究它们的结构和用法超出了本书的范围。然而，使用框架的前提是掌握 JavaScript 基础，这正是本书这一部分的内容。所以，学习完这一部分后，你将具备坚实的基础，以便在需要时进入框架的使用领域。实际上，对于大多数“私人用户区”（爱好编程者这个说法并不太好！）的用途而言，使用标准的 JavaScript（可能通过一些 GitHub 上的库增强）而不使用框架就足够了，因为虽然框架功能强大，但也带来了某种程度的“额外开销”，并且强制要求一种结构，对于较小的项目来说，这种结构并不必要。

## 33.4 总结

本章我们研究了函数，了解了函数是如何定义和使用的。此外，我们还探讨了如何通过外部库扩展函数的作用域，并探讨了框架是什么，以及它们与“传统”库的区别。

一定要从本章中记住以下几点：

+   函数通常使用关键字**function**定义。

+   你可以使用参数（当被调用时，具体值被称为参数值），这些参数可以设置默认值。

+   JavaScript 在调用函数时对传递参数非常灵活；例如，函数可以使用比它的参数更多或更少的参数来调用；因此，几乎每个函数的参数都是可选的。

+   参数可以通过位置参数传递，即根据它们在参数列表中的位置，或者通过关键字参数传递，即指定它们参数的标识符。

+   函数可以使用**return**语句（或**return()**函数）返回值。如果函数没有显式地返回值，则返回**undefined**。

+   在 JavaScript 中，函数是**function**类型的对象。

+   因此，它们也可以被赋值给变量。特别是，方法可以通过这种方式为对象定义；JavaScript对象的方法本质上不过是对象的一个属性，即一种（可调用的）**function**类型属性。

+   由于函数是对象，因此它们可以作为参数传递给其他函数。

+   在函数内用关键字**var**定义的变量是局部变量，一旦函数执行完毕，它们就会消失；因此，它们在主程序中不可见。函数参数也被视为局部变量。任何具有相同名称的全局变量都被这些局部变量“屏蔽”，无法访问。

+   如果在函数内部创建变量时没有使用关键字**var**，则会创建一个全局变量，该变量在函数外部也可见。如果已存在同名的全局变量，则会访问该变量。

+   除了JavaScript的标准功能外，你还可以使用扩展库；虽然这些库没有像许多编程语言那样的官方来源，但有一些平台，例如► [javascripting.​com](http://javascripting.com)，在这些平台上，开发者提供了大量用于各种用途的库。

+   框架在实际（至少是专业的）JavaScript开发中起着重要作用，因为它们大大减少了开发复杂应用时的工作量，使开发者可以集中精力处理核心内容。它们提供了一个框架，开发者可以在其中嵌入自己的代码。框架组织应用的流程，在必要时调用开发者的代码。因为在这里——与“通常”不同——应用的控制权不在开发者手中，而在于框架，所以也称为“控制反转”。

## 33.5 练习的解决方案

练习33.1Product = {name: '花园椅', price: 24.99 };Product.discount = function(discountPercent = 20) {**this**.price = **this**.price * (1-discountPercent/100);}

首先，我们创建一个具有属性**name**和**price**的对象。然后，我们将函数**discount()**添加到该对象；更准确地说，我们将一个函数对象赋值给属性**discount**，这个属性将包含指定的代码。从此以后，可以通过标识符**discount**调用该函数对象，即作为方法**discount()**调用。

类似地，我们当然也可以通过构造函数创建我们的**Product**对象，就像我们在►第33.1.3节中看到的那样。我们可以在构造函数中包含**discount**属性的定义，并直接将函数对象赋值给**this.discount**，而不是**product.discount**。

练习33.2**function** discount(prod, discountPercent = 20) {prod.price = prod.price * (1-discountPercent/100);*// return prod;*}

这个函数不是**Product**对象的方法。它只是接受一个**Product**对象并调整其价格。这是可能的，因为在 JavaScript 中，对象作为函数参数是*按引用传递*的，这意味着我们可以直接通过**prod**参数访问传递的对象。如果参数是*原始类型*，比如数字或字符串，情况就不同了。在这种情况下，参数值是*按值传递*的；我们对这些参数做的修改将不会影响传递的变量。

我们可以不使用*按引用传递*的方式，而是通过**return**语句将修改后的**Product**对象返回给调用者（在上面的解决方案建议中已被注释掉）。顺便提一下，如果参数是原始值并*按值传递*，这种可能性也同样存在。

练习 33.3

这个函数可能如下所示：

**function** arrayCreateAndSort() {**return** Array.from(arguments).sort();}

这里我们使用**arguments**对象，它包含传递给每个函数的参数值。尽管它本身并不是一个真正的数组，但可以通过**Array.from()**函数将其转换为数组，然后进行排序。

之后，我们可以像这样调用该函数，例如：

**>** arrayCreateAndSort('Hello', ', ', 'I', 'will', 'be', 'a', 'sorted', 'array')[",", "array", "be", "hello", "I", "one", "sorted", "to", "will"]练习 33.4**va**r myFunction = **function**() {console.log('这是实际被调用的函数。');}**var** myFunction2 = myFunction;myFunction2();

这里我们首先将一个函数表达式赋值给变量**myFunction**；因此，变量**myFunction**是一个**function**类型的对象。像任何其他对象一样，我们现在可以将这个对象赋值给另一个变量，在我们的例子中是变量**myFunction2**。通过这个变量，我们可以调用该函数。与每个函数调用一样，即使函数不接受任何参数，也必须指定圆括号。

练习 33.5我们的程序结果是以下变量值：

+   **x = 5**：**x**作为全局变量被初始化为值5。在函数内部，具有相同名称的参数被设置为零。然而，函数的参数是*局部变量*。因此，如果我们在函数内部访问**x**，我们访问的并不是全局变量**x**，而是与调用函数时传入的参数**x**同名的局部变量（它在函数体结束时会消失）。因此，全局变量的值保持不变。

+   **y**不存在：变量**y**也是函数内部的*局部变量*。当函数完全执行完毕后，它就不再存在了。由于没有同名的全局变量存在，我们在函数执行完毕后无法再访问名为**y**的变量。

+   **y1 = 6**：变量 **y1** 在函数内部创建，但没有使用关键字 **var**。因此，当 **y1 = x** 被赋值时，会创建一个新的 *全局* 变量，且在函数执行完毕后该变量仍然存在。

+   **y2** 不存在：与 **y1** 类似，**y2** 也是通过赋值在函数内部创建的，但使用了关键字 **var**。因此，这个赋值操作并不会创建一个全局变量，如同 **y1** 的情况，而是创建了一个 *局部* 变量。

+   **z = 1**：**z** 是一个全局变量，在函数被调用时它的值为 3。在函数内部，**z** 被赋值为 1。由于赋值操作没有使用关键字 **var**（否则会创建一个新的局部变量），因此我们实际上是在操作 *全局* 变量。
