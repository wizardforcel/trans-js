© 作者，Springer Fachmedien Wiesbaden GmbH 独家授权，Springer Nature 2024 J. L. Zuckarelli 《用 Python 和 JavaScript 学习编程》 [https://doi.org/10.1007/978-3-658-42912-6_11](https://doi.org/10.1007/978-3-658-42912-6_11)

# 11. 我如何存储数据以便使用？

Joachim L. Zuckarelli^([1](#Aff2) )(1) 慕尼黑，德国 概述。

程序处理数据。这些数据可以从用户输入或文件、数据库或其他来源读取。我们将在接下来的章节中详细讨论这些过程。本章讲的是别的内容：所有数据必须存储在计算机的内存中，以便可以进行处理。这是通过变量的形式来实现的。但不用担心：即使这些变量与数学中的变量有很多相似之处，您也不需要深入研究数学原理，就能理解如何在编程时安全地使用变量。

本章您将学习以下内容：

+   变量是什么以及如何创建它们。

+   数据变量可以存储哪些类型。

+   如何将许多相同类型的变量组合成变量字段（`数组` 和 `哈希`）。

+   如何将反映某个现实世界对象（例如，一辆具有 `品牌`、`最高速度` 和 `标价` 属性的汽车）属性的不同变量组合成一个对象，并随后如何操作这些属性（面向对象编程范式）。

## 11.1 变量作为数据的占位符。

变量是我们在程序中记录数据的工具。与数学中的变量一样，变量充当 `占位符`，我们可以通过它们的名称来访问它们，就像在►第[10章](474412_1_En_10_Chapter.xhtml)讨论的 `标识符` 一样。顾名思义，变量的内容是可变的，因此我们可以在变量中存储不同的数据（一个接一个），但是无论变量当前的内容是什么，都可以通过它们的标识符访问。

变量类似于一个我们标记的盒子。标签或名称或标识符始终保持不变，即使我们改变盒子的内容。盒子的内容应与标签相匹配，否则会引起混乱。变量也是如此。

一般来说，我们在选择变量名称时相对自由。然而，正如你在上一章中所看到的，仍然有一些特定于语言的基本规则必须遵守。这些规则通常规定了变量名称中可以出现哪些字符（某些特殊字符，如`%`或`#`，通常是不允许的）。此外，许多编程语言还规定了变量名开头可以或必须包含的字符。例如，在`R`中，变量名不能以数字开头，而在`PHP`中，变量名`必须`以美元符号（`$`）开头。然而，正如你从上一章记得的那样，遵循这些“硬性”规则不仅很重要，而且变量的命名要有意义并且`一致`。在这个上下文中，有意义意味着你可以通过变量名了解它的内容或目的；而一致则意味着你应该尽可能以相同的方式形成变量名，例如，始终以相同的方式对复合变量名的各个部分进行大小写处理。假设你正在开发一个网上商店，并希望将一个顾客在过去`12个月`内下的订单数量存储在一个变量中。这个变量可以命名为`CountOrders12Months`，也可以是`CntOrd12M`、`cntOrd12M`、`Count_Orders_12_Months`，或者其他形式。可能性很多，创造力几乎没有限制。为了程序代码的可读性和可理解性，重要的是你要思考出一种命名规则，然后尽可能一致地遵循这一规则。

## `11.2 变量的数据类型`

### `11.2.1 不同类型的数据需要不同类型的变量`

到目前为止，我们还没有讨论变量可以存储什么样的`信息`，比如数字或文本。对于你的编程语言的编译器或解释器来说，这一点是有区别的，至少有两个原因。

其一，编译器或解释器需要为变量分配内存。显然，一段长文本（例如，一个街道名称）需要的内存比一个数字（例如，门牌号）要多。如果你先给一个变量赋一个数字，比如门牌号`58`，编译器或解释器会确保为存储数字分配足够的内存。如果你接着给同一个变量赋予一段长文本，例如地址`"Times Square, Manhattan, NY"`，最初分配的内存就不再足够。必须找到额外的内存空间，可能是在内存中的完全不同位置。

其次，不同的数据类型可以进行不同的操作。例如，你可以将一个数字乘以另一个数字。但对于文本而言，这些操作是没有意义的。在最坏的情况下，如果你对变量所包含的数据类型进行不允许的操作，程序甚至可能崩溃。因此，时常检查一个变量中的数据是否为“正确”的类型，即是否具有正确的数据类型，在编程中是有意义的。

变量的数据类型描述了它可以存储什么类型的信息。在这方面，数据类型指定了一个变量应该保存 `整数`、`分数` 还是 `文本`。然而，在实践中，数据类型不仅在它们涵盖的数据类型上有所不同。它们在可以存储的数据范围或信息长度方面也有所不同：一个为文本设计并为其提供10个字符的变量，将会把“Peter Miller”存储为“Peter Mill”（其中空格也算作一个字符）。在一个值范围为 `0` 到 `65,535` 的 `整数` 变量中（这个值范围可以用两个字节来表示），你将无法存储负数账户余额 `–254 USD`。同样，一个值范围从 `–32,768` 到 `32,767` 的 `整数` 变量（也需要两个字节的内存）将无法处理 `50,000 USD` 的账户余额。因此，数据类型有不同的值范围，这些范围就像它们所针对的基本信息类型一样，限制了它们可以存储的数据。在浮点数数据类型的情况下，比如像 `3.1415926` 这样的分数十进制数，另一个特点则是精度或小数位数。精度很重要。无论你和竞争对手一起获得滑雪或速度滑冰世界锦标赛的金牌，还是在这位竞争者之后名列第二，都可能取决于结果是否以百分之一秒为单位进行测量（如果两名运动员的成绩相同，则两人都会被宣布为冠军），或者千分之一秒是否也被考虑在内，并且两者之间的微小差距才显现出来。

### `11.2.2 重要数据类型`

基本数据类型在大多数编程语言中非常相似。通常有以下几种数据类型：

`整数`

这些数据类型接受 `整数`，例如 `–4`、`–3`、`–2`、`0`、`1`、`2`、`3`、`4`。可选地，还有只接受正整数（包括零）的数据类型，即自然数。在许多编程语言中，`整数`数据类型的名称通常包括`integer`一词，或者它的缩写。此类数据类型的经典名称有 `integer` 或 `int`。对于具有特别大值范围的 `整数` 数据类型，即能够存储非常大数字的类型，它们通常也被称为 `bigint`、`long int` 或简称 `long`。

`浮点值`

浮动点数据类型可以表示分数的小数数字，例如`1.7`或`3.141459`。当然，整数也可以表示为浮动点数，例如将`4`表示为`4.0`。因此，所有整数也可以存储在浮动点变量中。

如果是这样，问题自然就来了，为什么需要整数变量，而不是总是使用浮动点变量。原因主要在于浮动点值的内存需求更大，因为它们不仅需要存储小数点前的数字，还要存储小数点后的分数部分，或者即便小数点后的部分始终为零（就像整数一样），也需要为其存储留出空间。问题在于，我们的编译器或解释器无法预先知道我们只想存储整数值。因此，它总是预留足够的内存来存储一个浮动小数。如果你同时需要大量这样的浮动点变量，内存需求就会明显增加。

在不同的编程语言中，浮动点数据类型有多个名称，例如`real`（表示实数）或`float`。在大多数语言中，有一个类似于`integer`和`long integer`的浮动点数据类型，它提供更高的精度（即更多的小数位）和更大的数值范围。在大多数情况下，像`double`甚至`long double`这样的名称已经表示了更高的精度。

字符与字符串

单个字符，如字母，与整数并没有太大区别，因为计算机可以理解的每个字符，即属于其`字符集`的一部分，也可以编码为数字。众所周知的字符集有`ASCII`或`Unicode`。尽管字符与数字之间有着紧密的联系，大多数编程语言为单个字符提供了特殊的数据类型，通常其名称基于“字符”一词。因此，许多语言为单个字符定义了`char`类型。

整篇文本最终都是字符的序列，或称`字符串`。因此，一些编程语言并没有单独的字符字符串类型，而是通过将多个单独的字符变量串联在一起构建字符串。在这里，一个复杂的数据类型是由一个简单的数据类型构成的，多个简单数据类型的变量实际上是串联在一起的。这种串联方式称为`数组`，我们稍后将更深入地讨论这种结构。

其他语言则有专门的字符串数据类型，通常简单地称为`string`。这在一定程度上将程序员与字符串的本质隔离开来，即字符串是由多个字符拼接在一起的。对于程序员而言，它“感觉”就像是文本是一个单一的变量，而不是由在字段中排列的多个单独变量组成的。

然而，字符串往往不仅包含字母、数字和特殊字符（如标点符号、`#, <`、`>`、`*****`、`~`），还包含所谓的转义序列。这些是特殊的控制指令。实际上，最重要的一个是表示换行符的`\\n`。反斜杠（`\`）告诉解释器或编译器，后面的字符不是字母，而是控制语句；`n`本身代表`新行`。因此，字符串`"Mr./Mrs.\nFirstName Name\nStreet\nZIP City"`将被解释为：

`Mr/MrsFirstName NameStreetZIP city`

每当遇到转义序列`\n`时，就会插入一个换行符。虽然转义序列标记了字符串中换行的位置，但某些程序功能——例如用于将字符串输出到屏幕上的功能——会“理解”该编码并相应地执行。除了`\n`，还有几个其他转义序列，例如`\t`表示制表符跳转。转义序列还解决了另一个常见问题：在大多数编程语言中，字符串由单引号（`'`）或双引号（`"`）包围。那么，如果一个字符串应该包含引号，该怎么做呢？例如，如何让引号在字符串中成为`真实字符`？考虑以下字符串：

`"他说，"我爱你！""`

它被双引号包围，但包含一个本身使用双引号的引号。通常，解释器或编译器会拒绝执行此操作。它首先会识别字符串`"He said: "`。然而，接着（而不会被理解为字符串）是`I love you!`，后面跟着一个空字符串（`""`）。`I love you!`可能会引发问题，因为它在相应的编程语言中不是一个有效的语句，因此在字符串外，解释器或编译器会尝试将其解释为一个语句。那么该怎么做呢？除了简单地使用单引号包裹字符串中的引号外，还可以通过转义“内部”的双引号，如下所示：

`"他说：\"我爱你！\""`

反斜杠告诉解释器或编译器，后面的引号应该被理解为`字符串的一部分`，而不是它的分隔符。

但是，如果字符串中应该有一个反斜杠呢？例如，在这个字符串中：

`"\n 是一个转义序列。" `

转义序列`\n`通常会导致字符串中出现不希望的换行符。反斜杠的屏蔽也有助于解决这个问题，只不过这次是屏蔽了现有的反斜杠本身，因为它应该被理解为文本的一部分，而不是控制语句的开始。因此：

`"\\n 是一个转义序列。"`

这个字符串会产生正确的输出。特别是在Windows系统上编写路径时，转义反斜杠本身非常重要，例如 `C:\\Home\\My source codes`。一个常见的错误原因是，像这样的字符串中忘记了转义。

转义序列在许多编程语言中使用，例如在`C`、`Python`、`Perl`或`R`中。

真值/逻辑值

几乎所有编程语言都有一个特殊的数据类型，用于表示语句的真值内容，即`true`或`false`。在这个上下文中，我们通常称之为`boolean`（以19世纪的英语数学家和逻辑学家`George Boole`命名）或`logical`变量。与我们迄今为止考虑的数据类型不同，布尔变量仅允许存储两种不同的值：`true`和`false`。这与可以存储`任何`整数的整数变量完全不同。在大多数编程语言中，这两个真值有特殊标识符，通常是`true`和`false`，以便布尔变量可以轻松赋值或比较，而这些赋值和比较在程序代码中也易于阅读。由于有易于理解的标识符`true`和`false`，编程语言通常只存储`1`和`0`作为布尔变量的值。从这个意义上说，布尔变量大多只是整数变量，编译器或解释器负责确保它们仅有两个可能的值，这些值通常可以通过特殊标识符方便地访问，通常只是`true`和`false`。

在编程语言中，布尔数据类型通常被称为`bool`、`boolean`或`logical`。

其他数据类型

这些数据类型几乎可以在所有现代高级语言中找到，尽管它们的名称、值范围和精度不同。此外，大多数编程语言还有几种其他更复杂的数据类型，通常基于你刚刚了解的简单类型。

一些语言，例如，有（至少）一种特殊数据类型用于日期或时间。如果你想存储日期和时间，似乎没有其他选择，只能将天、月、年、小时、分钟和秒作为整数存储，然后将它们“组装”成某种复杂数据类型。这确实是一个常用的解决方案，但还有其他方法。例如，使用UNIX操作系统的系统，其时间从1970年代开始，仅使用一个整数来表示自1970年1月1日0:00 GMT以来经过的秒数。例如，千年之交，即2000年1月1日0:00，在纽约市对应的Unix时间为946,702,800。这个时间概念也被称为`UNIX Epoch`。因此，日期也可以用一个数字表示，但在许多编程语言中，它被视为一种单独的数据类型，尽管最终它是一个整数。

这个例子也很好地说明了数据类型中值范围的作用。运行在`UNIX`上的系统没有遇到2000年问题。然而，它们将在2038年1月19日星期二3:14:08 `UTC`遇到麻烦。原因是，`UNIX`使用的数据类型（至少在老旧系统中）来存储时间将会达到`2,147,483,647`，也就是它的值范围的上限。这个数据类型无法存储更大的数值。那么，1秒钟后，3:14:09会发生什么呢？以秒为单位的日期值会回跳到其最小值`–2,147,483,648`。根据`Unix`的时间线，这对应的是1913年12月的某个时间。`Unix`的开发者当然知道这一点，但接受了它；从1970年代的角度来看，2038年还很遥远，并且当时并没有更大值范围的数据类型可用。

但是这个例子很好地说明了，你必须考虑你打算使用的数据类型是否足够满足预期的用途，或者是否需要一个具有更大数值范围的数据类型（如果你有这样的选择，而不是像`UNIX`开发者那样没有选择）。

日期/时间是许多编程语言中存在的一个数据类型，它与上述讨论的其他数据类型一起存在。此外，通常还有其他数据类型，例如枚举类型。在这些类型的变量中，可以存储分类数据，即只能有特定值的数据，例如人的性别、最高学历或汽车颜色。从这个意义上说，它们与`boolean`变量类似，不同之处在于它们的可能值个数通常超过两个。通常，这类`枚举`（`集合`或`因子`）是编程语言中的特殊数据类型，尽管“底层”它们本质上是以`整数`形式存储的（每个类别/值由一个特定的数字表示）。

日期值、字符串和枚举都是基于更简单数据类型的数据类型的例子。当我们讨论字符串时，您已经了解到它可以被视为由一系列字符组成的字段，作为将变量组合成更复杂数据类型的一种方式。除了字段，我们稍后还会仔细研究另一种可能性，其核心思想是将`不同`类型的变量组合成一个对象。这样的对象通常代表一个具有核心属性的实际对象，例如一辆车，它可以通过其年龄（`integer`）、品牌（`string`）和颜色（`enumeration`）等特征来描述。

### 11.2.3 改变数据类型：变量转换

有时，您需要更改变量的数据类型。这称为`converting`变量。例如，假设您为在线书店编写了软件。您的程序的用户刚刚输入了他想购买的书籍数量的信息（通常是一本，但有时可能是两本，一本给自己，一本作为礼物）。在结账页面上，您希望向用户显示他们总共订购了多少本书。如果您将数量读入整数变量，这很简单。然而，如果您使用了字符串变量，这就变得问题重重。您的加法将无法成功。为什么这两个变量之间的差异如此重要？

数据类型，如您在前面的章节中所见，是由变量可以持有的值的范围类型定义的，并且（如果适用）还由（浮点）值存储的精度定义。但是还有另一个特征可以区分数据类型：变量的类型可以进行哪些操作的问题。可以对整数进行加法运算是显而易见的。但字符串呢？您能在数学意义上将两个字符串`"apples"`和`"pears"`相加吗？当然不可以。但`"2"`和`"1"`这两个字符串呢？这些可能是我们在线商店示例中两本书的数量。这两个字符串能加在一起吗？答案是，可能让您感到惊讶的是：不能。

编译器或解释器处理您的程序代码时，根本不关心变量中到底包含什么。它只是一串字符，对计算机来说完全没有意义。无论字符串包含字母、数字，还是任何特殊字符如美元符号或下划线，都无关紧要。编译器或解释器对内容不感兴趣。因此，字符串不允许进行加法运算。但如果您现在知道通过在线商店网站读取的字符串变量肯定包含数字，您当然还是想对它们进行计算。该怎么办呢？

解决此问题的关键是改变变量的类型。许多编程语言提供特殊语句，允许您做到这一点，并执行`explicit type conversion`。然而，一些语言也具有`implicit type conversion`。在某种意义上，它们并不像之前描述的那样无知，但如果您想计算例如`"2" + 1`（其中`"2"`是字符串值），它们会仔细查看变量及其内容，并会认识到在我们的示例中，如果将字符串`"2"`转换为数字，则可以进行计算。然后，转换会自动执行，而无需您通过特殊语句干预。

另一个例子是以下计算：`TRUE – 1`：这里，从布尔值中减去一个整数值。遵循严格类型概念的语言会因为出现错误而拒绝此计算。而支持隐式转换的语言则会认识到`TRUE`在大多数语言中最终被表示为值`1`，因为它作为真值被内部存储。因此，`TRUE – 1`的值可以被确定。从这个意义上讲，甚至可以说是正确的：`TRUE – 1 = 0 = FALSE`。

严格要求数据类型的语言，几乎不进行隐式转换，并且可能连显式转换也很少允许，被称为`强类型`语言。在这里，变量的数据类型扮演着重要角色。与此相对的是一些语言，程序员不需要指定变量的类型，而是通过隐式转换，数据类型会自动适应，以便尽可能地执行所需的操作。这些语言被称为`弱类型`语言。在极端情况下，甚至可以执行没有任何意义的操作而不报错：比如 `3 + "My name"`（其中`3`是一个数字，`"My name"`是一个字符串），这时可能简单地返回 `3`。当然，`"My name"` 到数字的类型转换会失败，但这种编程语言如此弱类型，它仍然会尽最大努力“继续计算”。

看起来很诱人的做法同时也充满风险。显然，如果我们在线商店的用户输入了一本书的数量为 `3`，而另一册书的数量为 `"Tom Peterson"`，这将是很糟糕的，因为我们无法真正使用这些信息。在最坏的情况下，我们的程序会遇到问题，产生不合逻辑的结果，甚至完全崩溃。对变量是否适合进行所需操作进行更多的“控制”，不应被视为对自身编程自由的限制。它仅仅是帮助编写更安全、更稳定的程序代码，并在早期（理想情况下是在开发和测试阶段，而不是在运行时）检测错误的一个工具。

## 11.3 创建与初始化变量

在上一节中，你看到变量可以根据其数据类型进行区分，即根据它们能够存储什么类型的信息以及能够覆盖哪些值的范围。现在，问题来了——如何创建一个变量以便能够使用它？不同编程语言中，变量的“诞生”方式是不同的。大致来说，可以将语言分为两种类型：一种是你必须在第一次使用之前显式地创建变量；另一种是在你第一次使用时，变量会自动创建。

前者类型的语言包括 `C`、`Visual Basic for Applications (VBA)` 和 `JavaScript`。假设我们希望在这两种语言中将值 `10` 赋给一个名为 `piececount` 的整数变量。但在此之前，变量必须先被创建。程序员称这一过程为 `声明`，即告知编译器或解释器从现在开始使用该变量。然后，编译器或解释器会负责变量创建的技术部分。

在 `C` 语言中，变量声明及赋值 `10` 的写法如下：

`int piececount; piececount = 10;`

`int piececount` 不仅声明了一个新变量 `piececount`，还指定了它的类型为 `int`，这是 `C` 中的整数数据类型。在这条声明之后，编译器知道有一个名为 `piececount` 的整数变量，从此可以在程序中使用它。如果没有这条声明，`piececount = 10` 这样的赋值语句会导致错误信息，编译器会指出它不知道变量 `piececount`，因此无法给它赋值。

在 `VBA` 中，相同的代码部分如下所示：

`Dim piececount As Integer piececount = 10`

与 `C` 不同（在 `C` 中声明时会指定变量的类型），这里使用了一个特殊的关键字来声明变量，即 `Dim`，来源于 `to dimension`。这实际上非常好，因为当变量被创建时，内存会根据变量的数据类型需求进行分配。就此而言，内存是根据需求进行 `维度化` 的。

一些语言，如 `JavaScript`，需要声明变量，但不指定类型：

`var piececount; piececount = 10;`

在这里，编译器或解释器根据变量的使用情况决定需要哪种数据类型。通过赋值 `piececount = 10`，可以清楚地知道这必须是一个整数变量。如果以后给该变量赋值一个需要不同数据类型的值，例如通过赋值 `piececount = "Not specified"`，则该变量的数据类型会在后台相应地发生变化，而你作为程序员并不会注意到任何变化。与 `C` 或 `VBA` 不同，这里的类型是 `隐式` 的。而在 `C` 和 `VBA` 中，类型必须 `显式` 指定；因此我们也称这些语言为 `显式类型` 编程语言。

你可能会问，JavaScript 中的声明是否真的那么有用，因为变量的类型根本没有指定。如果必须指定类型，可以认为编译器或解释器可以检查变量是否意外地被赋予了由于数据类型不匹配而无法接受的值。这一额外的检查提供了安全性，并且可能防止程序出现麻烦的错误和奇怪的行为。在上述声明之后，`C` 编译器会拒绝处理像 `piececount = "Not specified"` 这样的赋值，并会中止并报错。这样，程序员会意识到自己在代码中某种程度上存在不一致的操作。

在`JavaScript`中声明变量的必要性对程序员有何益处？还是仅仅是语言发明者设计的一种花招，目的是让使用者感到疯狂？如你所想，这并非如此。强制程序员注册他的变量是有意义的，因为这样，编译器或解释器就知道`哪些变量标识符`是被允许的。如果你接着输入错误，就像作者在写这些代码时曾发生过几次，比如在代码中写了`pieccount = "Not specified"`（注意缺少了`e`），JavaScript解释器会识别出你试图访问一个不存在的变量。这是因为你声明的变量名称不同。这样，你会迅速发现问题的根源并能及时修复。如果编程语言没有强制声明，那么语句`pieccount = 10`会直接创建一个名为`pieccount`的新变量。在这种情况下，你可能会遇到一些麻烦，无法确定为什么程序没有按预期运行。揭示真正的原因——实际上你正在处理两个不同的变量——会比编译器或解释器提前给出“提示”时花费更多时间。

所以有时候接受更严格的规定是非常有帮助的。这种严格性使得问题更容易被发现和定位。如果你的编程语言提供切换到更严格模式的可能性（例如在`VBA`中，可以通过一个特殊选项强制声明变量），你应该接受这个建议，尽管乍一看这似乎是更多的控制和更少的自由。

一些编程语言对用户施加的严格性有时还包括，变量只能在程序的开头进行声明，这样可以改善程序结构，从而提高代码的可读性。

在我们上述的例子中，我们在声明后直接为`variable`赋值。但是如果我们不这样做，但仍然在后面使用该`variable`，例如在屏幕上输出其内容，那么会显示什么呢？换句话说，`variable`“出生”时的值是什么？在过去，`variables`在声明后往往会有一个随机值，即操作系统释放的内存区域中当前存在的值，这个值是由之前使用同一内存区域但没有“清理”的程序留下的残余。因此，对任何程序员来说，一个非常重要的建议是始终在开始时为他的`variables`加载一个值，即`initialize`它们，或给它们一个明确的、已知的内容。这可以防止程序由于“奇怪”的`variable`内容而崩溃或表现得不可预测。

今天，大多数编程语言会自动初始化`variables`，数值`variables`初始化为`0`，字符串初始化为空字符串。一些语言甚至对用户未显式初始化的`variables`有一个特殊值，比如在`JavaScript`中的`undefined`。这个值表示该`variable`尚未具有真实的值，因为它还没有被初始化。许多语言还有另一个值，表示用户故意留空该`variable`的值（想想在调查中未回答的问题，例如）。在`JavaScript`中，例如，这个值是`null`（与数字`0`不同），在`Delphi/Object Pascal`中是`nil`，在`R`中是`NA`（表示`not available`）。如果`variable`有这样的值，这表明该`variable`确实被使用，只是它不包含显式的值。换句话说：没有值也是一种值！

尽管在今天的许多编程语言中，严格来说不再需要初始化，但这是一个好习惯。通常，初始化可以在声明时直接完成，例如在`C`中。我们上面的例子可以简化为：

`int piececount = 10;`

## 11.4 不那么变量的：`常量`

另一种语言元素，通常在声明时直接初始化的是`constants`（常量）。`Constants`在程序中通过特定名称（即其标识符）表示的值与`variables`（变量）类似。然而，与`variables`不同的是，一旦`constants`的值被设定，就不能在程序的后续过程中更改。这保护了`constant`的值不被意外覆盖。通常，`constants`必须在声明时用其（此后称为`constant`）值初始化。以下是来自Pascal的一个例子：

`const pi = 3.14159;`

在`C`语言中，`constant`（常量）声明与`variable`（变量）声明看起来是一样的，只是多了`const`关键字：

`const int pi = 3.14159;`

## 11.5 变量/数组的有序字段

到目前为止，我们一直在创建单个变量。然而，大多数编程语言也支持`arrays`（数组）变量。数组是同类型变量的有序集合，这些变量可以通过相同的名称进行访问。字段中的各个值通过索引来访问。

在我们假设的在线商店的例子中，我们可以将点击历史记录，即客户查看的产品序列，存储在一个数组中。这在分析客户行为并为客户提供个性化的产品推荐时非常重要，正如今天许多在线商店所做的那样。

在这个例子中，我们的字段可以称为`history`。在这个字段中，我们将按顺序存储客户查看过的产品的ID。假设这些ID是整数值。那么我们就有了一个整数变量的字段。现在我们可以使用`index`来访问字段中的各个`elements`。我们可以通过`history[5]`这种方式来访问点击历史中的第五个元素。在方括号中，你可以看到要访问的元素的编号，在本例中是当前客户查看的第五个产品。

当然，我们也可以用单个变量来实现整个过程：例如，我们可以创建`history1`、`history2`、`history3`、`history4`、`history5`、`history6`等变量，将考虑中的产品顺序存储在这些变量中。然而，这样做有一些缺点。首先，在许多语言中，变量必须显式声明。如果你设想有一个点击历史记录，假设有30个产品，你会在声明变量时进行大量的输入。另外，几乎所有支持字段的语言都有非常高效的机制来遍历这些字段，即通过逐步移动标识字段元素的索引。这种方式可以一步一步地遍历整个字段。从编程的角度来看，这种方式非常简洁优雅，代码量也少。如果你使用独立的单个变量，解决方案会复杂得多，而且更需要维护（比如说，如果你只想快速将历史记录长度从30个产品增加到100个产品）。

尽管几乎所有现代高级语言都提供字段，语言之间在一个重要方面有所不同；即`first`字段元素的索引值是什么。在许多语言中，字段的索引从0开始。然后`history[0]`将是用户查看的第一个产品的产品ID。

字段/数组也可以是多维的。在我们的例子中，我们可以将所有访客的点击历史存储在一个字段中；我们会使用一个二维字段，可以将其视为一个表格或矩阵。行表示用户，列表示他们查看的产品ID。然后，`history[3][1]`将是网站访客3查看的第一个产品的ID（假设我们的字段索引从1开始）。要访问字段的元素，我们现在需要两个索引作为坐标，准确描述我们想要在二维表格中到达的位置。

字段的维度当然不仅限于二维。我们可以轻松地添加第三维、第四维、第五维等。只要我们始终记住哪个索引（因此哪个维度）表示存储信息时使用的“坐标”，这一切都不成问题。例如，除了用户之外，我们还可以存储日期（1 = 周一，7 = 周日），从而增加一个第三维。我们的字段结构将是`history[day][user][productid]`，通过`history[2][3][1]`我们将获得用户3在星期二查看的第一个产品的ID。

不详细讨论，我们在前几段中引入了一种符号表示法，用于通过索引访问字段的单个元素：我们将索引号放在方括号中。这实际上是许多编程语言的做法，但并非所有语言都如此：有些语言将索引放在`圆括号`中。然而，索引的可能性不仅仅限于指定一个索引号。许多编程语言还允许使用其他索引方法，例如通过排除进行索引：在这种方法中，您并不是指定要选择的字段元素的索引，而是相反，指定不想选择的那些元素。这通常通过在索引前加上负号来实现。`history[–5]`将表示整个字段，除了第五个元素外。然而，在一些编程语言中，负值有不同的含义，即字段是从末尾开始索引的。在这种情况下，`history[–5]`将是倒数第五个元素。一些编程语言还允许指定一个完整的索引范围：例如，`history[5:9]`将获取字段中的第五、六、七、八和九个元素。`history[from:to]`的符号不仅节省了输入工作，尤其是在选择的限制`from`和`to`尚不确定时，它使得使用程序先确定这些值的变量变得更容易（例如，通过用户输入）。

在编程语言中，字段的世界相对多彩。然而，它们中的大多数具有以下共同原则：

+   字段是由多个单一变量组成的（不过，这一基本定义也有例外）：在统计语言`R`中，一维字段，即所谓的向量，甚至是标准；单个变量只是这种向量的特例，即长度为一的向量）。

+   字段中的变量都具有相同的类型（例如，它们都是字符串，或都是数字）。

+   字段可以是一维的，也可以是多维的。

+   可以通过指定要选择的元素，使用数值索引访问字段的单个元素。

+   创建字段时（如果必须声明变量），必须指定字段的维度以及字段变量的类型。

然而，除此之外，不同编程语言中处理字段的方式可能差异巨大。我们已经了解了其中的一些差异。总的来说，除了其他方面，不同编程语言中可能会有以下问题处理得非常不同：

+   数值索引是从`0`开始还是从`1`开始。

+   是否使用圆括号或方括号进行索引。

+   除了简单地指定元素编号之外，还有哪些索引选项可用。

+   是否有可用的函数用于处理字段（例如，确定字段的长度或删除字段中的元素）。

+   字段允许使用哪些数据类型。

+   字段的最大大小。

接下来，让我们看看在一些编程语言中如何实际声明和使用字段。在所有情况下，我们都希望创建一个包含六个变量的字段，用于存储一组人的姓名。然后，我们希望将第二个名字设置为`"Sophie"`。

首先是`Visual Basic for Application (VBA)`：

`Dim names(6) As String` `names(1) = "Sophie"` JavaScript 中相同：`var names = [];` `names[1] = "Cathy"`

如您所见，在 JavaScript 中，数组的大小不必预先指定。索引在这里也从`0`开始。

最后是`Delphi`：

`var names: array[1..6] of string;` `names[2] = "Cathy";`

在这里，索引的值范围可以显式设置。我们将其设置为从`1`到`6`。因此，第二个元素的索引为`2`。

最后，需要提到的是，在某些编程语言中，字符串变量被理解为单个字符的字段。然后，可以通过常规索引访问字符串中的单个字符。以下是 C 和 Python 的示例；首先是 C 版本：

`char my_name[] = "Thomas";` `printf("第三个字符：%c", my_name[2]);`

然后是`Python`：

`my_name = "Thomas"` `print("第三个字符：", my_name[2])`

在这两种情况下，我们获取索引为`2`的字符，即第三个字符（因为这两种编程语言的字段索引都是从`0`开始的），并显示它。两种语言都将字符串视为字段，但`C`语言比`Python`语言更严格。

## `11.6 变量的关联字段/哈希表`

除了经典的有序字段/数组外，一些编程语言还知道第二种类型的字段，称为`关联字段`，有时也叫`哈希表`、`字典`或`映射`。

关联字段由一组`无序`的`键值对`组成。可以使用键来访问相应的值。这些键值对例如可以由客户的姓名（键）和他最后一次订单的订单值（值）组成。与有序字段/数组中的条目不同，关联字段中的条目没有自然顺序；它们不需要顺序，因为每个元素都通过一个明确定义的键来访问。

让我们来看一个支持关联字段的两种语言的例子：Perl —— 关联字段在这里称为`哈希表` —— 以及 Python，它们称之为`字典`。首先是 Perl 版本：

`my` %`ordervalues` = (`"Thomas_Schultz"` => 43.99,`"Jim_Scott"` => 19.49,`"Mary_McGregor"` => 68.99,);`$ordervalues{" Mary_McGregor"}` = 8.99;`print('Last order of Thomas Schultz was: $bestellwerte{" Jim_Scott "}')`;

正如你所看到的，代码的上半部分首先创建了一个新的`hash`字段，名为`ordervalues`（在 Perl 中，当谈论字段作为“整体”时，哈希标识符总是以百分号开头）。该哈希字段立即初始化了三个键值对。在操作符`=>`的左边是键，在本例中是客户的姓名，操作符右边是最后的订单值。在代码的后面部分，哈希字段的一个特殊元素被访问，一次是修改值，另一次是显示屏幕上的值。正如预期的那样，访问不是通过数字索引（毕竟哈希字段中的元素是未排序的），而是通过键，在这种情况下是客户的姓名。

现在，用 Python 语言实现相同的功能：

`ordervalues` = `{"Thomas_Schulz" : 43.99," Jim_Scott" : 19.49," Mary_McGregor" : 68.99,}` `ordervalues['Mary_McGregor']` = 8.99 `print("Last order of Thomas Schultz was: ", ordervalues['Thomas_Schultz'])`

即使两种语言的确切语法略有不同，但在处理`哈希表`或`字典`（在 Python 中称为关联字段）时的相似之处是显而易见的。可以清楚地看到，如何轻松地在关联字段中查找值——事实上，就像查字典一样。

支持关联字段的语言通常配有一整套工具，用于分析和操作这些字段。例如，程序员可以使用常规的函数或操作符来一次性提取所有键或所有值，或者确定字段的大小，即它包含的键值对数量。

11.1 [3 min]

变量声明是什么意思？

11.2 [3 分钟]

说出声明变量的两个优点。

## 11.7 `对象`

在过去的两节中，我们处理了字段。字段让你能够以有序的方式存储大量相似的信息，并且可以再次访问它们。这在许多情况下非常有用，但通常不是处理数据最简单或最自然的方式。

在本节中，你将学习一种处理相关数据的方法，这种方法非常基础，甚至构成了一个独立的编程范式。许多编程语言已经采用了这种方法，或多或少都融入了它。由于它塑造了许多流行语言，如`C++`、`Java`、`JavaScript`、`Python`和`Kotlin`，因此在实践中极其重要。

我们讨论的是`面向对象编程`（简称OOP）。我们将在本节中深入讨论它，并且这一部分并非完全没有动机，因为本书第三和第四部分介绍的两种编程语言也属于`面向对象语言`的广泛类别。在不少当代人的眼中，`面向对象`与“难以理解”和“复杂”这些属性联系在一起。然而，在阅读完本节内容后，你会发现这些担忧完全是没有根据的。

### 11.7.1 世界由对象构成

假设我们想为一个在线商店编写一个类似目录的产品展示界面。每个产品都有一组我们希望展示的属性，例如：名称、描述、项目编号、制造商、价格和数量。利用前面章节的知识，我们可以将这些属性映射为单独的字段/数组。例如，会有一个数组`itemnumbers`，`itemnumbers[187]`将是第187个商品的项目编号。如果我们想获取同一商品的描述，我们将使用数组元素`descriptions[187]`。

这里的主要标准因此是各自的属性。我们查询该属性的产品由索引指示，在我们的例子中是`187`。然而，这种方法有点人造，因为实际上我们通常不是从属性开始，而是从它的承载者开始。

当我们编写我们的目录视图时，我们面临的问题是我们面前有一个`product`，需要显示它的所有相关属性。我们从产品开始，问自己这个产品有哪些属性。于是，我们提取名称、描述、项目编号以及我们希望在目录列表中显示的所有其他属性，并为该特定产品展示这些属性。我们始终从各个可能的角度（其属性）观察同一个`object`，即产品。当你去二手车经销商那里查看他们院子里的待售汽车时也是如此。你查看一辆车，检查模型、颜色、年龄、状况、价格及其他对你评估重要的参数。然后你查看下一辆车，再查看另一辆车。但你总是从一个对象——汽车——开始，查看其各自的特征。

你可能已经注意到，这种推理归结为：世界显然不是按属性组织的，而是按对象组织的，无论是产品、汽车、房屋、企业、按钮、电子邮件，还是学生。所有这些物理和非物理对象最终都是属性的总结。从这个意义上说，人或人们所扮演的角色（如“学生”角色）也可以是对象。我们不应对这里的语言选择过于苛刻，尽管起初可能会觉得将客户或同事视为“对象”有些奇怪。但如果我们将对象定义为一组属性，那么很明显，在这个广泛的意义上，人、动物、植物和神也都是“对象”。

但如果世界是按对象而非属性组织的，为什么这没有在编程中反映出来？为什么我们在明显关注单个属性的字段中工作，而不是在作为不同属性整体集合的对象中？在1960年代，美国计算机科学家`Alan Kay`和其他面向对象编程的先驱们也问过自己这个问题，并因此在真正意义上带来了范式转变。遵循这一新范式的第一种编程语言之一是`Kay`的`Smalltalk`。

在面向对象编程的概念中，对象处于前景；它体现了这种方法的组织原则。决定我们如何处理数据的不是属性，而是属性的承载者——对象。

### 11.7.2 `类`

让我们遵循面向对象的方法，定义一个具有以下属性的对象`product`：

`product.name` `product.description` `product.itemnumber` `product.manufacturer` `product.price`

我们通过商店出售的所有产品都有这些属性。为了认识到这些属性都描述了对象“`product`”，我们通过在前面加上`product`来总结它们。

现在让我们在语言学上更精确一些。我们在这里定义的是我们对`任何`产品的看法，从某种意义上讲，它是`产品的模板`；这就是我们眼中产品的样子，这些是从我们角度看它们的基本特征。这样一个抽象的模板，描述了一个对象具备哪些属性，在面向对象编程中被称为`类`。我们提供的每一个实际产品，在这些属性上都有不同的取值，例如名称“花园铲，不锈钢”以及价格10.99美元。那些实际的对象，其属性是基于我们的类来建模的，称为该类的`实例`。因此，从某种意义上讲，实例是类中所表达的抽象概念的具体化。我们所有的产品在每个属性上都会有不同的值，所以实例的数量和产品的数量一样多。但所有的产品都属于同一个类，它们都是产品。

在下一步中，我们会更加正式地定义我们的类，就像在编程语言中一样：

`Class` `Product` `Begin` `name : String` `description : String` `itemnumber : Integer` `manufacturer : String` `price : DecimalNumber` `End`

类的属性——在这个语境中我们也称之为`属性`——位于限制性关键字`Begin`和`End`之间。这里的代码片段并不是用任何现有的编程语言编写的，而是作为“伪代码”来表达的，正如我们在本书的这一部分中多次使用伪代码来说明基本原理。这里的重点仅仅是以一种形式化且易于理解的方式描述类定义可能的样子。之后，你将看到如何在一些真实的编程语言中构建类定义，一旦你理解了这一伪代码中的基本概念，你就能立即应对它们。

现在我们已经定义了类应包含哪些属性以及这些属性的具体数据类型，我们可以创建一个类的实例，即一个变量，它（按照类定义的方式）代表一个具体的产品。一旦创建了类型为`product`的新变量，我们就可以开始调整它的属性：

`GardenShovel : Product` `GardenShovel.name = "花园铲，不锈钢"` `GardenShovel.price = 10.99`

要访问我们`Product`类中`GardenShovel`实例的属性，我们使用点运算符，形式为`实例.属性`。这种表示法在许多编程语言中都很常见。

使用`Product`，我们创建了自己的数据类型，它比我们在前几节学习的内建数据类型更复杂，因为它存储了不同的值。然而，我们可以像使用“内建”数据类型（例如整数或逻辑值）一样使用它。例如，我们可以创建该类型的变量并为其赋值（不是为整个变量赋值，而是为各个属性赋值，这些属性当然是基础变量）。

### `11.7.3 继承`

有时候，我们有一些对象是其他对象的特殊案例。例如，书籍是一种特殊的产品。它具有我们产品所拥有的所有属性，包含一个名称（书名）、一个制造商（出版社），当然还有一个价格。此外，它还有一些其他属性，我们也应该在我们的网上商店中展示，例如作者和页数。毕竟，这些信息可能会影响客户的购买决策。

现在，为了将我们的特殊产品“书籍”表示为一个类，面向对象编程中有一个称为`inheritance`的技巧。与这个术语可能暗示的相反，没有人必须死才能继承。然而，基本思想很简单：作为产品的特殊案例，我们的书籍简单地“继承”了产品的所有属性，并且在作者和页数的基础上获得了两个额外的属性。这两个属性使得书籍独特。因此，我们的书籍是一个产品，但并不是每个产品都是书籍。有些产品只有产品的标准属性，而没有作者和页数的特殊属性；这些属性是书籍所独有的。

当然，我们可以将书籍具有的额外属性直接包含在`Product`类中。但对于不是书籍的具体实例，我们应该为这些属性赋予什么值呢？如果我们对其他特殊产品类别（例如服装或园艺家具）给予特别处理，会发生什么？这将导致适用于所有产品的属性数量大大增加，而仅适用于单一产品类别，`Product`类会变得非常混乱。

使用继承更简单且更优雅。我们创建一个新的类`Book`，它继承了上述定义的`Product`类的所有属性，并额外添加了页数和作者这两个属性。类`Book`的定义可以如下所示：

`Class Book Inherits Product Begin author : String pages : Integer End`

如果将这个类的定义与`Product`类的定义进行比较，您会注意到这里添加了关键字`Inherits`，后面是我们类`Book`要继承的属性的类。我们现在当然可以创建我们类的实例，即具体的变量，并更改它们的属性。

`Grisham1992 : BookGrisham1992.name = "The Pelican Brief"Grisham1992.price = 8.99Grisham1992.author = "John Grisham"Grisham1992.pagenumber = 478`

如您所见，在这段代码中，我们不仅根据书籍的特殊属性（即作者和页数）来编辑变量`Grisham1992`，还根据产品的标准属性（即名称和价格）进行了编辑。这些属性在`Book`类的定义中并没有明确出现。然而，书籍从更一般的类`Product`继承了这些属性，`Book`类就是从`Product`类派生出来的。

最终，我们建立了一个`类层次结构`，其中`Product`是超类，`Book`是子类。`类`层次结构当然可以有多个层次；例如，我们可以将小说和百科全书作为书籍的进一步子类，并为它们提供一些不包含在`book`类中的特殊属性。同样，我们当然可以通过将书籍以外的其他产品类别（例如，服装和园艺家具）建模为直接从`Product`类派生出来的单独类，来扩展这个层次结构。

接下来，让我们来看一下我们的两个类，`Product`和`Book`，在两种实际编程语言中会是什么样子；我们先从`C++`开始：

`class` Product{char designation[30]; char description[200]; long itemnumber; char manufacturer[30]; float price;} `class` Book : `public` Product{char author[50]; int pages;} `// 稍后在主程序中...` Book grisham1992; Product gardenshovel; gardenshovel.name = "花园铲， 不锈钢"; gardenshovel.price = 10.99; grisham1992.name = "鹈鹕简报"; grisham1992.price = 8.99; grisham1992.author = "约翰·格里isham"; grisham1992.pages = 478;

当然，即使你不熟悉`C++`的特定语法，你对面向对象编程的概念以及我们的伪代码的理解，依然能帮助你理解这个程序片段中发生的事情。

现在让我们看看`Delphi/Object Pascal`中的相同内容：

`type` TProduct = `Class`(TOBject) `property` Name : String; `property` Description : String; `property` ItemNumber: Longint; `property` Manufacturer : String; `property` Price : Single; `end`; TBook = `Class`(TProduct) `property` Author : String; `property` Pages : Integer; `end`; `// 稍后在主程序中...` `var` GardenShovel : TProduct; Grisham1992 : TBook; GardenShovel.Name = "花园铲， 不锈钢"; GardenShovel.Price = 10.99; Grisham1992.Name = "鹈鹕简报"; Grisham1992.Price = 8.99; Grisham1992.Author = "约翰·格里isham"; Grisham1992.Pages = 478;

在这里，我们遵循了典型的Delphi表示法，类（以及一般所有定义的除基本数据类型外的数据类型）都以“T”开头，我们的两个类分别叫做`TProduct`和`TBook`。在`Class`关键字后，继承自的类会用括号写出来，这就是类层级中上一级的类。这里有趣的是，类`TProduct`也从更高一级的类继承了属性，即从`TObject`类继承。这个类是类层级中的最高类，所有其他类最终都是从它派生出来的。

从这些示例中，你可以看到不同编程语言中的类定义可能有其独特之处，但它们仍然有很多相似之处。通过我们迄今为止了解的几个面向对象编程的基本思想，你已经能够理解各编程语言中类定义的含义，而不需要对它们所用的编程语言有详细的了解。

### `11.7.4 方法`

在上一节的示例中，我们通过给类的属性赋值，直接修改了我们类的属性。对于面向对象编程的“纯粹教义”来说，这是亵渎。根据“纯粹教义”，属性不能直接编辑，而只能通过所谓的`方法`来进行修改。`方法`是可调用的子程序，你可以向其传递某些值，这些值称为`参数`，然后方法会以某种方式处理这些值，例如将“传递的”值赋给类属性。

为了使这个例子更具体一点，我们假设我们的`Product`类有一个`setPrice()`方法，可以用来编辑价格。该方法将价格作为参数传入，然后方法确保类的`price`属性相应地被更改。类定义看起来会是这样的：

`Class` `Product` `Begin` `name` : `String` `description` : `String` `itemnumber` : `Integer` `manufacturer` : `String` `price` : `DecimalNumber` `setPrice(newprice: DecimalNumber)` `End`

我们的原始类已经通过`setPrice()`方法进行了扩展。这个方法接受一个参数`newprice`，即我们希望为产品设置的价格，它是一个十进制/浮动点数。然后我们可以在程序的后面创建`Product`类的新实例，并使用`setPrice()`方法初始化价格，下面的例子中，价格为`10.99`美元：

`GardenShovel` : `Product` `GardenShovel.setPrice(10.99)`

现在我们可以看到与我们到目前为止所熟悉的基本数据类型（如`integer`或`character string`变量）之间的明显区别。面向对象编程中的类不仅包含数据值，还通过方法包含处理这些数据的工具。但这只是一个表面上的区别。事实上，即使是许多面向对象语言中的基本数据类型，本身也是类，它们向外界提供一组方法。例如，`DecimalNumber`类可能提供一个`round()`方法；如果`price`是一个`DecimalNumber`对象，也就是`DecimalNumber`类的一个实例，那么例如`price.round(2)`将把变量`price`的值四舍五入到小数点后两位。

那为什么这么复杂呢？为什么我们不能直接给类实例的属性赋值呢？为什么需要一个特殊的方法，而且这个方法还必须自己开发？在上面的例子中，为了简单起见，我们没有使用这个方法，而是假设`setPrice()`方法已经在某个地方编写并可以使用；因此，在类定义中提供一个提示（即`prototype`），表明该方法应该是类的一部分就足够了。但实际上，这个方法背后的代码，即在调用该方法时执行的代码，当然也必须自己开发。那么，为什么为了改变一个值而付出这么大的努力呢？我们本可以通过简单的赋值操作来完成。

面向对象编程的支持者会认为，使用方法能够将类的内部数据结构与外部世界隔离开来，即与使用该类的程序员隔离。程序员无需担心如何将各种数据映射到类中；毕竟，他们并不直接编辑类的属性，而是通过方法进行操作。类的开发者可以更改类的属性，但只要提供给类用户的方法没有变化，用户是不会注意到这些更改的。从他们的角度看，一切保持不变。程序员无需重写软件，而是可以继续使用现有代码而无需进行任何更改。

使用方法的一个优势是，代码的模块化以及类的开发者与在程序中使用该类的程序员之间的分工变得更简单。类的开发者负责通过方法提供的功能，而作为该类“消费者”的程序员只需调用始终以相同方式使用的方法，无需担心它们的具体功能。这种编程方式通过提供`编程接口`的形式，将外部的方法暴露给程序，能够使程序变得`更稳健`，即不容易受到变化的影响。

另一个有助于面向对象编程稳健性的因素是，方法可以自然地确保执行`仅允许的操作`。假设我们的程序员想要将值`–10.99`赋给属性`gardenshovel.price`。如果他可以轻松地给属性`price`赋值，他也可以给它赋一个负值。然而，这在程序后续阶段可能会产生不利影响，例如当客户需要“结算”负的发票金额时，客户最终将收到退款。方法在此处可以发挥其优势：我们的`setPrice()`方法可以检查传递给它的价格参数是否大于`0`。如果是，那么属性`price`将被设置为该值。否则，也就是如果价格为负值，则该属性将被设置为`0`。通过这种方式，方法能够防止意外设置无效的价格，比如负值价格。通过验证价格，方法有助于提高程序的稳定性；换句话说，程序不再容易被“破坏”，它变得更具抗错能力。

在几乎所有面向对象的语言中都有一个特殊的方法，叫做`构造函数`。构造函数在创建类的新实例时会自动调用。它可以用来初始化类的一些重要属性，可以使用默认值，也可以使用作为参数传递给构造函数的方法。如果我们要在`Product`类中包含这样的构造函数，类定义可能会像这样：

`Class` `Product` `Begin` `name : String` `description : String` `itemnumber : Integer` `manufacturer : String` `price : DecimalNumber` `setPrice(newprice: DecimalNumber)` `Product(startprice : DecimalNumber, name : String)` `End`

新增的部分是类有了一个构造函数`Product()`。它的名称与类名相同，并且接受两个参数，价格和产品名称。通过这两个数据，构造函数可以在创建该类的新实例时初始化`price`和`name`这两个属性。为此，当然必须在创建实例时使用这两个参数来调用构造函数；例如，这可能是这样写的：

`GardenShovel` : `Product(10.99, "园艺铲，不锈钢")`

正如你所看到的，我们在这里声明了一个`Product`类型的变量，和之前的例子一样，但这次构造函数被调用时需要提供价格和名称这两个必要参数。

### `11.7.5 多态`

这个术语可能听起来像是某种疾病，但`多态`绝对不是负面的现象；相反，它是面向对象编程提供的一种非常实用的功能。`多态`与继承的概念密切相关。你还记得，类可以“继承”其方法和属性给派生类。在前面的章节中，我们定义了一个`Book`类，它继承了更通用的`Product`类的所有属性和方法，同时也可以拥有一些在“父类”`Product`中没有的自己的属性和方法。

现在我们可以定义一个方法来显示产品的属性，即创建一种产品档案。我们可以将这个方法放入通用类`Product`中。通过继承，它也会适用于从`Product`派生出来的`Book`类。然而，显示方法会忽略书籍的特殊属性，比如作者或页数，这些都是`Book`类的属性。这些属性仅是`Book`类的一部分，而不是`Product`类的一部分，因此我们放在`Product`类中的显示方法自然无法访问这些属性。前面例子中的园艺铲子，作为`Product`类的实例，是没有页数属性的！

然而，如果我们有一个显示方法，它可以简单地返回每个产品的正确显示，不论我们处理的是什么类型的产品，那将是很实用的。理想情况下，我们会调用显示方法`showProduct()`，它将自动为每种类型的产品输出正确的信息。

这正是`polymorphism`所允许的。`Polymorphism`意味着从彼此派生的类可以有相同名称的方法，但它们执行的功能各不相同。如果随后为特定对象调用该方法，即类的实例，则自动执行属于`相应类`的方法。在我们的示例中，作者和页数属性也会被显示。

这种多态的`showProduct()`方法设计可能如下所示：

`Class Product Begin` `name : String` `description : String` `itemnumber : Integer` `manufacturer : String` `price : DecimalNumber` `showProduct()` `setPrice(newprice: DecimalNumber)` `Product(startprice : DecimalNumber, name : String) End` `Class Book Inherits Product Begin` `author : String` `pages : Integer` `showProduct() End`

如您所见，两个类，“父类”`Product`和派生的“子类”`Book`，各自都有一个`showProduct()`函数。我们调用该方法时，执行哪个函数取决于我们为其调用方法的对象是`Product`的实例，还是其派生类`Book`的实例。

所以，如果我们声明两个对象

`GardenShovel : Product` `Grisham1992 : Book`

然后为每个对象调用`showProduct()`方法，

`GardenShovel.showProduct()` `Grisham1992.showProduct()`

最终调用了两个不同的方法；对于对象`GardenShovel`，调用了类`Product`的方法，因为`GardenShovel`是其实例；对于对象`Grisham1992`，调用了派生类`Book`的方法，因此`showProduct()`也能正确显示页数和作者。

多态方法的好处在于，我们不必关心`GardenShovel`和`Grisham1992`实际上是什么类型的对象。我们只需固执地调用`showProduct()`方法，所发生的总是针对相关对象类的最佳情况；方法名相同使得这一切成为可能。

在与多态相关的讨论中，反复出现的一个术语是`overloading`。人们谈到类`Product`的`showProduct()`方法被派生自`Product`的类重载，每个类都有自己的`showProduct()`方法，以最佳考虑其特性。这两个术语很好地描述了这种情况：“多态”指的是同一个方法可以有许多（希腊语`poly`）形式（希腊语`morphía`）；而“重载”描述了同一个函数被赋予多次不同含义的过程。

### 11.7.6 访问权限

为了总结我们对面向对象编程的观察，我们来看看最后一个特性，这再次强调了面向对象编程的动机，即严格分离类的开发与使用。

有一种方法可以限制对类的属性和方法的访问。具体设计可能因编程语言而异，但通常至少有以下的访问权限梯度：

+   `Private`: 处于此访问限制下的方法和属性只能被同一类的方法使用。它们对外界“不可见”；作为使用类的用户，您无法访问这些方法和属性。然而，您可以调用的方法（如果它不是私有的）可以使用这些方法和属性，但您无法直接这样做。因此，私有方法和属性被保护在外部世界之外。`private`的访问保护非常适合定义不被外部调用但只供类的其他方法使用的辅助变量或辅助方法。

+   `Protected`: 被声明为`protected`的方法和属性可以被所属类和派生类使用，但不能被在其程序中使用这些类的程序员使用。

+   `Public/open`: 方法和属性的访问限制为`public`，可以从任何地方访问，包括自身类、派生类以及类的用户。

下面是我们示例的扩展以作说明：`Class Product Begin Public name : String description : String itemnumber : Integer manufacturer : String showProduct() setPrice(newprice: DecimalNumber) Product(startprice : DecimalNumber, name : String) Private price : DecimalNumber End`

这里我们已经将属性`price`声明为私有属性。`setPrice()`方法则是公共方法。因此，作为类的开发者，我们不希望有人直接编辑我们的属性`price`。因此，我们将其保护为私有。然而，同一类中的方法可以访问并修改它的值。`setPrice()`就是这样一个方法。它是一个可以从类外部调用的公共方法。因此，使用我们类的程序员现在可以通过接口方法`setPrice()`来编辑`price`属性，但不能直接通过赋值来修改。

通过这种方式，可以很容易地控制哪些类的部分应对外可见并作为类功能的接口，哪些不应该。

`11.3 [5 min]` 以下陈述是对还是错？

1.  `(a)`

    面向对象编程是尽可能以“自然”的方式表示现实世界事物的尝试。

1.  `(b)`

    方法是属于类的函数，可以改变该类实例的属性。

1.  `(c)`

    类实例的所有属性可以通过赋值直接从程序中更改。

1.  `(d)`

    使用面向对象编程使得程序更加清晰，但也使得对程序的调整变得更加困难。

1.  `(e)`

    继承意味着你可以在不同的程序中重复使用类的定义。

`11.4 [3 min]`

描述类与实例之间的区别。

`11.5 [3 min]`

类定义的基本元素是什么？

`11.6 [3 min]`

为什么多态在面向对象编程中是一个有用的方法？

## `11.8 学习新编程语言的路线图`

当你学习一门新的编程语言时……

你将会发现：

+   语言是否对标识符区分大小写，即变量和函数的名称，

+   语言提供了哪些基本数据类型（特别是数字、字符串、逻辑/布尔值），

+   语言是否需要声明变量，如果需要，如何声明

+   如何为变量赋值，

+   语言是否，及如何，变量可以（显式地）转换数据类型，编程语言本身是否已经（隐式地）执行了某些转换，

+   语言是否支持类似变量的字段（`数组`），如果支持，如何创建字段并访问它们的元素（特别是字段元素的索引是从`0`开始还是从`1`开始），

+   语言是否支持可以通过键访问其值的关联字段，如果支持，如何创建这些字段并访问它们的元素，

+   该语言中其他常见的复杂数据类型有哪些，

+   语言是否支持面向对象编程，如果支持，如何访问类属性和方法，如何定义类，特别是如何从现有类派生类。

## 11.9 练习的解决方案

练习 11.1

在需要变量声明的语言中，变量通过声明注册到解释器/编译器；它会为变量预留必要的内存，并在需要时为变量赋初始值。之后，变量可以在程序中使用。声明变量时，会指定变量的标识符（名称）以及在某些语言中，还会指定其数据类型。

练习 11.2

变量声明的需求使得解释器/编译器能够标识未声明变量的使用。由于未声明的变量通常是程序代码中打字错误的结果，这可以防止意外创建并操作新的变量，同时应访问的变量保持完全不变。因此，强制声明变量使得程序代码变得更加健壮。如果声明时已经指定了类型，并且该类型之后不能更改，那么如果意外为变量赋予了“不合适”的类型，解释器/编译器会报告错误。这同样避免了错误，使程序代码更加健壮。

练习 11.3

1.  (a)

    正确。

1.  (b)

    正确。

1.  (c)

    错误。在许多编程语言中，可以通过将类实例的属性定义为`private`来屏蔽外部访问。这些属性只能通过同一类的方法进行编辑，对于外界而言几乎是不可见的，因此程序员无法直接访问这些属性。

1.  (d)

    错误。面向对象编程有助于使程序元素彼此更加独立。因为程序员只通过定义好的方法（如有需要，还可以直接访问属性）来操作类实例，所以类的内部实现对程序员来说不再是关注点。因此，只要类的`interface`在外部保持不变，类的开发者就可以随意修改内部实现，而基于该类的程序仍然语法正确。这种更强的模块化有助于代码的适配。

1.  (e)

    错误。继承意味着可以从一个类派生出更多的类，这些类“继承”了其方法和属性。通过这种方式，一个类可以优雅地扩展，特别是用于更具体的用途时。

练习 11.4

类是对象（或对象类型）的抽象定义，包含该类型对象的属性和方法，像一个模板一样工作。根据这个模板，具体的对象，即类的实例，得以形成，因此作为类的映像，它们拥有类中的所有方法和属性。

练习 11.5

本质上，类定义由类的标识符（名称）以及属于该类的属性和方法组成。这些可以通过相应的关键字提供访问权限限制（参见►`第 11.7.6 节`）。如果该类是从另一个类派生的，那么对“父类”的引用也是类定义的一部分（参见►`第 11.7.3 节`）。

`练习 11.6`

`多态`允许不同类型（`类`）的对象提供特定的方法。这使得可以将该方法适应于各自类的具体特性。当通过继承创建类层次结构时，这一点尤其有趣。如果现在在这个类层次结构中的某个类的实例上调用该方法，将使用该对象实例类的特殊实现。如果该类没有该方法的特殊实现，则使用同名方法的下一个更高层类的实现。这确保了总是使用最适合该类特性的实现方法，但在必要时可以使用属于更高层类的方法。这意味着不同的对象类型可以被不同地处理，但仍然向外部世界提供相同的接口（即，同名的方法）。程序员不必考虑他或她应该实际调用哪个类的哪个方法；他或她只需为对象实例调用该方法，解释器/编译器会为他或她澄清在这种情况下应该使用哪个方法。
