© 2024 J. L. Zuckarelli, 独家许可给Springer Fachmedien Wiesbaden GmbH，Springer Nature的一部分《使用Python和JavaScript学习编码》 [https://doi.org/10.1007/978-3-658-42912-6_3](https://doi.org/10.1007/978-3-658-42912-6_3)

# 3. 什么是编程语言？

Joachim L. Zuckarelli^([1](#Aff2) )(1)德国慕尼黑概述

编程最终意味着给计算机指令。这是通过一种特殊的语言完成的，这种语言既被我们作为程序员所理解，也被计算机所理解：编程语言。编程语言和自然语言有很多相似之处，但它们也有一些重要的区别。

在本章中，我们讨论编程语言，因此也涉及如何使计算机理解我们，以及计算机如何理解我们并执行我们的指令这一关键问题。

## 3.1 面向人类的语言，面向机器的语言

到目前为止，我们讨论了*什么*是编程以及*为什么*学习它是有意义的。现在只剩下*如何*去做的问题了。我们如何编程？我们到底如何告诉计算机算法，也就是它需要处理的步骤顺序？

无论如何，算法必须以计算机能够理解的方式写下来。正如我们所知，计算机以二进制模式工作，它们最终只能区分两种状态：零和一，开和关，有电压和无电压。因此，自然会认为我们必须以二进制方式编写程序，才能让计算机理解它们。幸运的是，事实并非如此。如果你从程序员身后看，你会看到他们编写的文本基本上是人类可读的。在这些文本中，你会看到许多英语术语。一个典型的程序文本行可能是这样的：

**if** value <0 **then** print "Value is less than zero"

尽管许多使用的术语在英语中是熟悉的，但程序员使用的语言是*人工*语言，*编程语言*。还有其他不是编程语言的人工语言，例如由波兰眼科医生*卢德维克·莱泽·扎门霍夫*开发的世界语*Esperanto*，或是《星际迷航》中的外星人克林贡种族的母语*Klingon*。

像人类语言一样，编程语言也有语法，*句法*，它描述了哪些表达方式是允许的，哪些是不允许的。尽管如此，编程语言与人类语言在很多方面仍有显著差异。

1.  1.

    编程语言在语法/句法和所使用的术语及其含义（称为*语义*）方面不如自然语言复杂。对你来说，好消息是你不需要学习那么庞大的词汇量！

1.  2.

    语法规则必须严格遵守，否则你将无法被理解。这是坏消息。在正常的对话场合，即使句子在语法上不完全正确，人类对方也能理解。这一点很重要，考虑到只有母语者和有丰富经验的人才能真正无误地掌握一门语言。但这种内部错误修正或容错理解，通常需要我们与智慧相关的心理表现。现在的问题——正如你可以猜到的——是计算机根本不智能。它们对错误没有容忍度，只接受并理解正确的句子。这正是编程困难并时常让人沮丧的原因，尤其是当计算机不愿意（或根本不能，因为它没有自由意志）理解你时。由于语言必须如此精确，它的表述常常显得生硬，这使得它完全无法作为日常语言使用。这就引出了下一个话题。

1.  3.

    编程语言不是为了被口头使用而设计的。两个程序员在午餐时不会用编程语言交谈。但当然，程序员有时会说得很奇怪，因为他们谈论的是用编程语言写的程序部分，并且引用程序中的部分内容来进行交流。

1.  4.

    严格意义上的编程语言（虽然有些描述性语言可以视作例外）并不是用来传递信息的，而仅仅是为了向计算机发出指令。

因此，尽管编程语言作为人工语言，在语法和词汇方面设计得比自然语言简单得多，但使用这些语言的作者，即程序员们的工作，却是相当复杂和庞大的。以下是一些例子：

+   控制 NASA 阿波罗 11 登月舱并成功将尼尔·阿姆斯特朗和巴兹·奥尔德林送上月球的程序，大约有 4 万行；也就是 645 页正常的书面文字。

+   微软 Windows 3.1 操作系统约有 250 万行；大约 40,000 页。

+   办公软件套件 Microsoft Office 2013 的功能来自约 4400 万行程序代码，打印出来大约是 694,000 页。

+   社交网络 Facebook 基于约 6100 万行程序代码，因此大约有 984,000 页。

+   根据 Google 的一位开发人员说，所有 Google 应用程序加起来大约有 20 亿（！）行；打印出来大约是 32,300,000 页。

做个比较：歌德的 *浮士德* 有 12,111 行，相当于 195 页。比较这些不同程序之间的差异并不容易，因为：

1.  1.

    不同的编程语言在进行相同操作时需要的代码行数不同，

1.  2.

    个人编程风格各不相同，

1.  3.

    程序代码的格式化方式（这会影响代码的可读性，从而影响其“可维护性”）可能有所不同。

所有这些因素都会影响程序的大小。

然而，您已经可以看到，软件程序通常是庞大且有时极其复杂的作品。

## 3.2 编程语言的翻译与执行

在上一章中，我们曾提到大多数编程语言使用英语术语。这主要是因为编程语言的发展主要是在英语国家推动的，尽管第一种真正的编程语言是德国人*Konrad Zuse*的发明，我们稍后会提到他。当然，也可以很容易设计一种编程语言，其命令全部借用其他语言，如西班牙语、法语或中文。然而，很明显，通常不会这么做，除非出于教学目的，因为英语作为世界通用语的主导地位，以及每位新编程语言创作者都希望看到自己的作品尽可能广泛传播的可理解愿望。

然而，我们仍然没有解决计算机无法处理英语或任何其他人类语言的问题。但如果计算机只理解零和一，那么它是如何处理基于英语的编程语言的呢？显然缺少的步骤是在用人类可读的编程语言编写程序指令与计算机执行这些指令之间的某个环节。

这个任务由*编译器*完成。编译器将程序翻译成计算机可以直接理解的语言——*机器语言*。这种机器语言只知道一组非常有限的基本命令，例如将单个值加载到处理器的寄存器中，即可以供处理器操作的小型存储元件。

这有点像需要向一个不了解情况的人解释路线。而一个熟悉这个地方的人，只需根据“去时代广场，我们在那里见”这条指示，就能轻松找到去集合地点的路，而你需要将方向指示拆解成更基本的组成部分，才能让不熟悉的人理解。例如，你可以说“直走到第二个红绿灯，然后左转。然后再直走直到下一个交叉口。在那里右转，继续走直到你看到广场。”机器语言也一样。它是由程序员用编程语言编写的程序，通过拆解成基本的处理器操作生成的指令流。人类可读的程序可能包含许多“快捷方式”以及对已经知道的指令序列的引用，但对于处理器来说，所有这些都必须简化为它可以执行的基本操作。这些机器码直接在计算机的处理器上运行。如果你使用Windows操作系统，你可能已经熟悉**.exe**和**.com**文件。这些是已经翻译成计算机可以理解并直接执行的机器代码的程序。

*解释器*的工作方式略有不同。解释器（本身就是一个程序）逐步执行程序；它“解释”程序代码。显然，解释器最终必须将程序传递给计算机，以机器语言执行，否则计算机无法理解它。但在解释器的情况下，这种翻译发生在程序运行时（正如程序员所说，“运行时”）。因此，程序本身并不*直接*在计算机上运行，而是通过解释器进行中介。然而，这也意味着：你不能随便在任何地方运行程序，始终需要解释器才能让程序源代码在计算机上运行。

编译，或者将人类可读的程序代码翻译成计算机能够理解的机器语言，通常具有速度优势，因为翻译本身需要时间，并且由编译器提前完成。在运行时，便不再需要花费时间进行翻译。对于我们的目的，代码执行速度的考虑并不是特别重要，但在涉及计算密集型或时间关键型应用（比如在重症监护医学中的监控系统）时，这些考虑无疑是高度相关的。

编译器和解释器之间仍然存在一种中间地带。它是这样工作的：首先，一个*字节码编译器*从程序的源代码生成“中间代码”。这与机器语言非常相似，但与处理器架构无关。机器语言的问题在于它依赖于处理器的具体构建方式。不同类型的处理器只理解“它们自己的”机器语言。而字节码则是机器无关的，因此可以在一种系统类型上生成，然后在其他类型的系统上执行。这样的代码被称为“可移植的”。字节码的生成是在程序开发过程中完成的。在运行时，即时编译器（JIT编译器）会从字节码生成特定于机器的代码。在某种程度上，JIT编译器就是一个字节码解释器。它读取“预编译”的字节码，并将指令传递给处理器，指令的格式是针对所使用系统的机器语言。这比直接执行未经翻译的源代码要快，后者通常是经典的解释器所做的。

这种结合在开发期间使用字节码编译器并在运行时使用即时编译器（JIT）的方式的最显著例子就是流行的Java编程语言。（Java的JIT编译器也被称为“运行时环境”，因为它们构成了Java程序执行的环境。）得益于其适应各自系统的JIT编译器，Java不仅能够在具有不同操作系统的计算机上运行，如Windows、MacOS或Linux，还能在各种其他设备上运行，如汽车或冰箱。

通常，编程语言是否是编译型语言或解释型语言是一个重要特性。然而，也有一些语言基本上是解释型的，但仍然可以进行字节码编译。解释器也可以将那些特别计算密集或经常被遍历的代码部分，甚至有时是所有代码，直接编译成可执行的机器码；这种方式也被称为JIT编译。因此，世界的确更加丰富多彩，计算机科学中的编译器构建本身是一门艺术（和学科）。

## 3.3 从机器语言到高级语言

编译和解释的方式很好。但问题来了：难道不能直接用机器语言编写程序吗？当然，这是可以的，但这并不容易，反而极其繁琐，而且结果会非常难以理解。此外，程序必须以考虑运行该程序的处理器特性为前提来编写。如果你突然希望它在完全不同的系统架构上运行，你可能需要在许多地方进行大量修改。因此，不推荐用机器语言编程。然而，在计算机的早期阶段，这正是所需要的。最终，即使是*查尔斯·巴贝奇*和同事们的诱饵卡程序，也是用机器语言编写的软件，如果巴贝奇的*解析机*在他生前建造完成，它本可以直接理解这些代码。

为了至少简化直接用机器语言编写程序的麻烦，*汇编语言*自20世纪40年代起出现。汇编语言本质上是机器代码的一种可读形式。对于（可管理的）大量机器指令，创建了简短的指令（*助记符*），这些指令可以一对一地转换为机器代码。换句话说：汇编指令与处理器的指令集完全对应。用汇编语言编程仍然极为繁琐。例如，一个汇编指令是：MOV AL, 6Fh

这告诉计算机：将值111（6Fh在十六进制数字系统中表示111，即十六进制数系统中的111）加载到处理器寄存器AL中。为了使用用高级语言编写的简单指令，例如：

print "Hello World!"

在汇编语言中，这需要一系列这样的操作。然而，最重要的是，使用汇编语言仍然依赖于各自的处理器架构。

使用*高级语言*则更为简便。高级语言从处理器架构中抽象出来，因为它们的解释器或编译器会处理目标处理器的特性，从而使开发者免去这项任务。他只需要编写一次程序；之后它可以被翻译成完全不同处理器架构的机器语言。

高级语言与汇编代码和（更甚于）机器代码不同，它们更易于阅读，因为它们使用英文术语来表示指令。这些命令中的许多结合了一整套机器命令，这意味着编译后，一行高级语言代码可能会生成多条不同的机器代码指令。当然，程序员不再需要担心这些细节。因此，几乎所有现代使用的编程语言都是高级语言，也就不足为奇了。

第一种简单的高级语言是在1940年代由德国工程师*孔拉德·祖泽*开发的，名为*Plankalkül*。通过*Plankalkül*，祖泽实现了一项突破性的进展，本应为现代软件开发铺平道路。然而，由于第二次世界大战，祖泽的工作长时间未受到关注。*Plankalkül*的首次实现（即可用的技术实现）发生在1975年，由*约阿希姆·霍曼*在其博士论文的背景下完成。

而高级语言的突破则出现在*ALGOL*（*算法语言*）上，它是在1950年代末至1960年代初由美国开发的，主要用于学术目的，且在很大程度上与*孔拉德·祖泽*的开创性工作无关。在此之前，1950年代，美国计算机科学家*格雷斯·霍普*设计了第一个可用的编译器。*霍普*于1992年去世，死后被追授总统自由勋章，这是美国的最高平民荣誉奖项，她还参与了编程语言*COBOL*（*面向商业的通用语言*）的开发。*COBOL*是一种在商业领域广泛使用的语言。与*FORTRAN*（*公式翻译*）一起，*FORTRAN*由*约翰·巴克斯*于1957年开发，主要用于技术和科学工作，二者共同构成了早期真正实用的高级语言的集合。
