© 作者（们），独家授权给 Springer Fachmedien Wiesbaden GmbH，隶属于 Springer Nature 2024 J. L. Zuckarelli《使用 Python 和 JavaScript 学习编码》 [https://doi.org/10.1007/978-3-658-42912-6_24](https://doi.org/10.1007/978-3-658-42912-6_24)

# 24. 条件语句与事件处理：如何控制程序流程并使程序响应用户操作及其他事件？

Joachim L. Zuckarelli^([1](#Aff2)  )(1)德国慕尼黑概述

接下来，我们将看看如何在 Python 程序中进行分支——根据情况，有时执行代码的某一部分，有时执行另一部分。通过这种方式，我们的程序流程变得非常有趣，而不是简单地一遍又一遍地执行完全相同的 Python 语句序列。

本章你将学到：

+   如何使用 If-Else 语句结构在程序代码中进行分支

+   如何嵌套使用 If-Else 语句结构

+   如何使用 elif 语句考虑多个备选条件

+   如何构建 If-Else 语句结构的条件，并且可以使用哪些比较运算符

+   如何使用逻辑运算符将多个条件组合成一个整体条件

+   如何让程序响应事件

## 24.1 If-Else 语句结构

### 24.1.1 简单的 If-Else 语句结构

让我们回顾一下温度单位开尔文与摄氏度之间的转换。在上一章（► 节 [23.​1.​3](474412_1_En_23_Chapter.xhtml#Sec4)）中，我们定义了以下函数：

**def** kelvin_to_celsius(kelvin: float) -> float:return kelvin - 273.15

假设现在我们想通过减少出错输入的可能性来改进这个简单的函数。正如你所记得，开尔文温度不能是负数。绝对零度是 0 K，即 -273.15 °C。更低的温度在物理上是不可行的。在 0 K 时，根本没有热量，因此无法再变得更冷。因此，如果我们想防止函数因为输入无效而返回无效值，我们需要检查函数参数 **kelvin** 是否大于或等于 0。如果 **kelvin** 小于 0，即无效，函数应该做出响应，可以通过在控制台显示错误消息，或者返回一个特殊的错误代码，让调用我们函数的程序员能够检查转换是否成功。我们选择后者，这更可取，因为它允许程序员按自己的方式处理错误，而仅仅显示错误消息不会给用户其他选择，除了重新启动程序。

现在，为了使我们的函数能够应对不正确的输入，我们需要添加一个 If-Else 语句结构，检查 **kelvin** 值是否无效，即小于 0，在这种情况下返回一个错误指示符，例如 None。调整后的函数可能看起来像这样：

**def** kelvin_to_celsius(kelvin: float) -> float: **if** kelvin < 0: res = None **else**: res = kelvin - 273.15 **return** res

你可以看到我们在这里构建了一个程序提示：关键字**if**后面跟着需要检查的条件，在我们的例子中是判断开尔文温度是否小于0\. 如果条件满足，接下来的代码块将被执行，代码块—就像函数的代码块一样—在冒号后开始并缩进。在我们的示例中，代码块只包含一个语句，即将**None**赋值给一个名为**res**的中间变量，但当然这里也可以有任何数量的进一步语句。接下来是—与**if**具有相同缩进级别的—**else**关键字，后面跟着一个只有在**if**条件不满足时才会执行的代码块。**else**分支从某种意义上说是**if**条件的逻辑反义；每当**if**条件不满足时，程序会直接跳转到**else**，而不执行**if**代码块中的程序代码。在我们的示例中，跳转到**else**代码块意味着我们的开尔文参数有效，因此可以转换为摄氏度值。

在If-Else结构后的**return**语句无论如何都会执行，不论程序是进入**if**分支还是**else**分支。通过这种方式，我们确保存储在**res**中的函数值始终会被返回，这个值—取决于程序走的是**if**分支还是**else**分支—要么包含转换后的摄氏度值，要么包含错误指示符**None**。

在我们的主程序中，我们现在可以将这个函数集成进来，例如，像这样：

kelv = input('请输入一个开尔文温度：') cel = kelvin_to_celsius(float(kelv)) **if** cel is None: print('您输入的开尔文温度无效！') **else**: print(round(float(kelv), 2), '开尔文等于', round(cel, 2), '摄氏度。')

如你所见，我们要求用户输入一个开尔文温度，进行转换，然后检查是否存在错误；根据是否存在错误，我们要么输出错误信息，要么输出转换后的摄氏度值。

你会注意到我们用来将变量**cel**与错误指示符**None**进行比较的双等号。Python与许多其他语言一样，区分了*赋值运算符* **=** 和 *比较运算符* **==**。数学中的不等号（≠）在Python中等价于比较运算符**!=**，即“*不等于*”，因为感叹号在许多编程语言中作为逻辑运算符*NOT*，用于反转一个表达式的真假。在这个例子中，表示左右两边的值是否相等。

If-Else结构中的**else**分支也可以省略。因此，我们的函数**kelvin_to_celsius()**也可以像这样：

**def** kelvin_to_celsius(kelvin: float) -> float: res = None **if** kelvin >= 0: res = kelvin - 273.15 **return** res

这种函数的表述与前一种选项完全相同。我们首先将变量 **res** 设置为 None，即错误值。因此，如果现在没有发生任何事情，函数会返回错误值。但如果 kelvin 参数是有效值，则会发生其他情况。此时，**res**（当前是错误代码）的值会被转换为摄氏度后的值。

顺便说一下：我们本可以将检查用户输入是否合法的整个逻辑从函数 **kelvin_to_celsius()** 移到主程序中，并在输入有效时仅调用该函数。否则，会输出相应的错误信息。

24.1 [15 min] 修改文本编辑器代码，来自 ► 第 [22.​4](474412_1_En_22_Chapter.xhtml#Sec22) 节，以便

1.  (a)

    只有当文件名确实存在时（即用户没有在文件打开对话框中点击“取消”而不选择文件），文件才会在打开时读取，在保存时写入。

1.  (b)

    如果尚未指定文件名，点击“保存”会自动打开“另存为”对话框。

通过这些改动，你可以避免在运行控制台中出现那些讨厌的错误信息，例如，当用户在没有先指定文件名的情况下点击“保存”时；在这种情况下，Python会尝试将内容写入一个空文件名（''），这显然会失败。

处理程序执行过程中可能导致错误的情况是使用 If-Else 结构进行分支的常见用途。

### 24.1.2 嵌套的 if-else 结构

现在假设我们想将函数 **celsius_to_kelvin()** 转换为一个函数 **convert_temperature(temperature: float, toCelsius: bool)**，它可以将温度值从开尔文转换为摄氏度，或从摄氏度转换为开尔文。一个新的 **bool** 类型参数 **toCelsius** 应该指定转换的方向。如果这个参数值为 **True**，则将开尔文转换为 *摄氏度*，否则反之。并且，在新函数 **convert_temperature()** 中，我们希望确保只有合法的温度值可以作为参数传入，即如果是开尔文值（**toCelsius == True**），则温度应大于0；如果是摄氏度值（**toCelsius == False**），则温度应大于−273.15°。

我们的函数可能看起来像这样：

1 **def** convert_temperature(temperature: float,toCelsius: bool) -> float:  

我们现在可以例如通过以下方式调用该函数：

print(convert_temperature(100, False)) 将 100°C 转换为开尔文。

如果你仔细观察这个函数，你会注意到这里嵌套了两个 If-Else 结构：外层的检查（第2行）用户想要将温度转换成哪个方向，并根据需要进行分支；内层的结构（第3行和第8行）检查参数 temperature 在各自的程序分支中是否具有有效的值。如果条件成立，就会执行转换并存储在局部变量 **res** 中（第5行和第10行），否则（在温度无效的情况下）**res** 会被赋值为错误值 **None**（见第[21.​3.​4](474412_1_En_21_Chapter.xhtml#Sec7)节）（第6行和第11行）。

“外层”的 **if** 和 “外层”的 **else** 都后跟一个代码块（当然是缩进的），而该代码块又包含了另一个 If-Else 结构。从理论上讲，嵌套的深度没有限制，但实际上，随着嵌套深度的增加，代码会变得越来越难以阅读，几乎就像一个自然语言句子，开头有许多从句，然后迅速关闭并在句尾结束。为了清晰起见，建议在嵌套超过两个结构时加上适当的注释，尤其是为了说明各个 **else** 条件属于哪个条件。同样的，如果 **if** 和 **else** 块中的代码较长（如上例中，这些代码块每个只有一行），因为你会阅读大量代码，然后突然遇到一个 **else**，而不再清楚它属于哪个 **if** 条件。

顺便提一下：我们本可以将“外层”条件简化为 **if toCelsius**，而不需要写成 **if toCelsius == True**；因为如果没有指定比较值，Python 默认会与 **True** 进行比较，所以可以省略与 **True** 的比较。

### 24.1.3 具有复合条件的 If-Else 结构

我们本可以像这样编写上一节的 **temperature_convert()** 函数：

1 **def** convert_temperature(temperature: float, toCelsius: bool) -> float: 2 **if** toCelsius == **True and** temperature >= 0: 3 res = temperature - 273.154 **else**: 5 **if** toCelsius == **False and** temperature >= -273.15: 6 res = temperature + 273.157 **else**: 8 res = None 9 **return** res

这个函数的表达式与上面的函数实现相同，但在嵌套的 If-Else 结构方面有不同的组织方式。“外层”结构同时检查两个条件，即是否需要转换为摄氏度（**toCelsius == True**）*并且*指定的（开尔文）温度是否允许（**temperature >= 0**）。这两个部分条件通过**and**结合成一个总条件，只有当*两个*部分条件都为真时，总条件才为真。在这种情况下，会执行转换（第3行）。但如果至少有一个部分条件不为真，即**toCelsius == False** *或* **temperature < 0**（甚至可能两个条件都不成立！），程序会继续执行外层 If-Else 结构中的**else**块（第4行）。

这里又检查了一个复合条件，即是否需要从摄氏度转换为开尔文，并且参数温度是否适用于此转换。如果两个部分条件都成立，转换就会进行（第6行）。但如果这个条件也不成立，程序将跳转到最“内层”的**else**块：由于**toCelsius**只能取**True**或**False**（至少当函数被“正确”调用时），现在只有可能是参数**temperature**的值不适合要求的转换。因此，在这种情况下，变量**res**会被赋予错误值**None**（第8行）。

在这个例子中，我们通过逻辑*与*连接了两个部分条件。除了**and**，其他重要的逻辑运算符还包括：

+   **or**，逻辑*或*，通过它将两个条件链接在一起，使得总条件成立时，*任何一个*条件或*两个*条件成立时。

+   **not**，逻辑*非*，用来反转一个语句的真假。

所以条件**toCelsius == True and temperature >= 0**本来可以写成——尽管有些别扭——**not(toCelsius == False or temperature < 0)**。这样，整体条件就要求不能成立的是**toCelsius**等于**False**，或**temperature < 0**，或者两者都成立。换句话说：只有当**toCelsius == True**且**temperature >= 0**时，整体条件才成立，接下来的代码块（即从开尔文到摄氏度的转换）才会被执行。顺便提一下：你不总是需要用逻辑运算符来连接复合条件。例如，可以用**if** x >= 0 **and** x < 10

Python（与许多其他编程语言不同）也允许使用更简洁的表示法

**if** 0 <= x < 10

这会进行完全相同的检查，即检查变量**x**的值是否至少为0且小于10。

24.2 [10 min]

编写一个函数**age_in_seconds(age_years: int) -> int**，该函数将一个以**age_years**参数传入的年龄（单位为年）转换为秒数；该函数因此计算并返回已经历的*最小*秒数。如果参数**age_years**不是整数变量，或年龄小于0或大于120，则应输出特定的错误信息。

如果你不记得如何检查一个值是否是整数，请滚动回►第[21.4.1节](474412_1_En_21_Chapter.xhtml#Sec10)。

### 24.1.4 If-Else结构与替代条件（elif）

有时候，你可能需要检查多个相似的条件。许多其他编程语言提供了Switch-Case结构，正如我们在►第[14.6节](474412_1_En_14_Chapter.xhtml#Sec6)中看到的那样。Switch-Case非常适合检查一个表达式（例如，变量）是否等于多个不同的值。Python中没有这种结构。然而，使用**elif**关键字，可以非常高效地检查多个替代条件，以补充If-Else结构的**if**条件；这种表述方式比传统的Switch-Case结构更灵活。

例如，假设你开发了一个程序，允许用户选择一个文件，并指定对文件执行的操作。这样，文件可以被重命名、删除、复制到另一个目录或移动到那里。为了选择所需的操作，用户只需输入所需操作的首字母，即**r**（重命名）、**d**（删除）、**c**（复制）或**m**（移动）。在用户输入该操作请求后，它将存储在**str**类型的变量**action**中。那么，判断用户希望执行哪种操作的条件是什么呢？使用如►第[24.1.2节](#Sec3)中的嵌套If-Else结构，我们可以选择以下表述：

**if** action == 'r':# 如果用户输入了'r'，执行的代码#（重命名文件）**else**:**if** action == 'd':# 如果用户输入了'd'，执行的代码#（删除文件）**else**:**if** action == 'c':# 如果用户输入了'c'，执行的代码#（复制文件）**else**:**if** action == 'm':# 如果用户输入了'm'，执行的代码#（移动文件）**else**:# 如果用户输入了其他内容，执行的代码

这种嵌套的表述依次检查用户输入了哪个操作代码。如果没有输入**'r'**，则接着检查**'d'**，如果也没有输入**'d'**，则检查**'c'**，以此类推。由于存在嵌套，整个结构看起来有些混乱。借助**elif**关键字，可以更清晰地组织程序的这一部分：

**if** action == 'r':# 重命名**elif** action == 'd':# 删除**elif** action == 'c':# 复制**elif** action == 'm':# 移动**else**:# 无效的操作代码

使用**elif**时，可以在与初始**if**同一层级上检查更多的条件。如果既没有**if**条件成立，也没有**elif**条件成立，那么（可选的）**else**代码块将被执行。如果某个**elif**条件成立，则执行该代码块，并在**else**代码块之后继续执行程序，即在整个If-Elif-Else结构之后继续。其他的**elif**条件将不再检查，因为**elif**表示的是*备选*条件。通过这种方式，一个复杂且难以理解的结构可以被替换为一个非常清晰、易于阅读的符号。

24.3 [10 min]考虑下面程序片段中的If-Elif-Else结构。

1.  (a)

    程序提取运行后，若初始时**a = 100**，**b = 50**，则变量**a**和**b**的值会是多少？

1.  (b)

    程序提取运行后，若初始时**a = 110**，**b = 40**，则变量**a**和**b**的值会是多少？

1.  (c)

    哪些**a**和**b**的值组合最终会导致**b = 0**？

如果在子任务（a）和（b）中没有直接得到解决方案，可以将代码输入到Python中并尝试运行。**if** a > 90 **and** b <= 20:b = 15**elif** b < 10:b = 0**elif** (a > 90 **and** b < 50) **or** (a == 100 **and** b > 50):b = 20**if** a >= 100 **or** b <= 50:a = 5**else:**a = 25**elif** a >= 90 **or** b <= 50:b = 5**else**:b = 10a = 20

## 24.2 事件

类似于If-(Elif-)Else结构，*事件*用于控制程序的流程，比如能够响应用户输入。然而，与If-(Elif-)Else结构不同，事件并不会简单地从程序的开始到结束线性执行，分支到某些部分并“跳过”其他部分。相反，事件会调用一个特定的函数——*事件处理器*，并执行其包含的代码。

这一点在我们的**tkinter**程序中体现得非常好，例如在► 第[22.2.6节](474412_1_En_22_Chapter.xhtml#Sec20)的计算器应用程序中。例如，**equal_press()**函数就是一个事件处理器，当用户点击等号按钮时，它会被调用。当事件处理器中的代码完全处理完毕后，程序会跳回程序的主循环——在**tkinter**程序中，这是函数**mainloop()**。在这个循环中，程序“等待”下一个事件发生，并为该事件定义了事件处理器。一旦发生了这个事件，事件处理器就会获得控制权；事件处理器执行完毕后，程序会返回到“潜伏”状态。我们将在► 第[25.2节](474412_1_En_25_Chapter.xhtml#Sec5)中，使用简单的方法来构建一个带有主循环和事件处理器的程序，该程序将在Python（运行）控制台中运行，也就是说，不需要图形用户界面。

## 24.3 总结

在本章中，我们讨论了如何在程序代码中构建分支，使得并非总是执行整个代码，而是根据条件，只执行某些特定部分。实现这一功能的核心工具是 If-Else 结构和事件。

请务必掌握本章中的以下要点：

+   If-Else 结构使得程序代码的某些部分的执行可以依赖于条件；**if**（以及**else**）后面跟着在条件（或其替代条件）满足时需要执行的代码块；**else**分支也可以省略；一般结构为：**if** ***condition: code_block*** **else:** ***code_block***。

+   If-Else 结构可以相互嵌套。

+   使用**elif**可以制定多个进一步的条件，这些条件只有在**if**条件及可能的其他前置**elif**结构未被满足时才会被检查。

+   条件通常通过比较运算符形成；检查相等性的运算符是双等号（**==**），单等号用于赋值；不等式运算使用**!=**。

+   可以使用逻辑运算符（特别是**and**、**or**、**not**）将多个（子）条件连接起来，形成复合条件。

+   事件通过定义一个特殊的函数（事件处理器）来处理，该函数会在事件被触发时被调用。事件在具有图形用户界面的程序中尤为有用。

## 24.4 练习解答

练习 24.1

（事件处理器）函数**saveas_press()**、**save_press()**和**open_press()**需要进行调整。补充的 If-Else 结构在下面的示例解答中用斜体标出：

**def** open_press():**global** filenamefname = askopenfilename(defaultextension = 'txt',filetypes = [('Text files', '*.txt'),('All files', '*.*'),],title = 'Open File....',initialdir = 'C:\\Windows')**if** fname != '':textfile = open(fname, 'r')text.delete(1.0, END)text.insert(1.0, file.read())textfile.close()status['text'] = 'File "' + fname + '" opened.'filename = fname**def** saveas_press():**global** filenamefname = asksaveasfilename(defaultextension = 'txt',filetypes=[('Text files', '*.txt'),('All files', '*.*'),],title = 'Save File As...',initialdir = 'C:\\Windows')**if** fname != '':textfile = open(fname, 'w')textfile.write(text.get(1.0, END))textfile.close()status['text'] = 'File "' + fname + '" saved.'filename = fname**def** save_press():**global** filename**if** filename != '':textfile = open(filename, 'w')textfile.write(text.get(1.0, END))textfile.close()status['text'] = 'File "' + filename + '" saved.'**else**:saveas_press()练习 24.2

函数的一个可能的表述如下所示：

**def** age_in_seconds(age_years: int) -> int:**if** **not** isinstance(alter_years, int):print('Error: The age is not an integer value!')**else**:**if** age_years < 0 **or** age_years > 120:print('Error: Implausible age information!')**else**:return age_years * 365 * 24 * 60 * 60

首先，**isinstance()** 函数在外层的 If-Else 结构中被用来检查参数 **age_years** 是否不是（!）一个整数值。如果是这种情况，则会发出错误信息并退出函数。我们在这里利用了 **isinstance** 返回 **bool** 值的事实，并且 Python 默认将条件中的表达式与 **True** 进行比较。或者，我们也可以写成 **if not isinstance(age_years, int) == True** 或 **if isinstance(age_years, int) != True**。

然而，如果 **age_years** 确实是一个整数值，内层的 If-Else 结构会检查年龄是否超出了合理范围。如果是这种情况，函数再次退出并发出错误信息。如果这个障碍也成功克服，函数将返回年龄的秒数。

然后，您可以例如调用该函数：

print(age_in_seconds(38))练习 24.3

1.  （a）

    **a = 100**, **b = 5**（适用的条件：**a >= 90 或 b <= 50**）

1.  （b）

    **a = 5**, **b = 20**（适用的条件：**(a > 90 且 b < 50) 或 (a == 100 且 b > 50)** 和 **a >= 100 或 b <= 50**）

1.  （c）

    无。为此，条件 **a >= 95 且 b < 15** 必须满足。但这是 **a > 90 且 b <= 20** 的一个替代条件。任何满足 **a >= 95 且 b < 15** 的 **a** 和 **b** 的组合也会满足 **a > 90 且 b <= 20**。因此，替代条件永远不会生效，它是“死代码”。
