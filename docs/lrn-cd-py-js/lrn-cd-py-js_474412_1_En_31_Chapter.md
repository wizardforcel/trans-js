© 作者，独家授权Springer Fachmedien Wiesbaden GmbH，Springer Nature的一部分 2024 J. L. Zuckarelli《使用Python和JavaScript学习编程》 [https://doi.org/10.1007/978-3-658-42912-6_31](https://doi.org/10.1007/978-3-658-42912-6_31)

# 31. 变量与对象：如何存储数据以供处理？

Joachim L. Zuckarelli^([1](#Aff2) )(1)德国慕尼黑概述

现在是时候看看我们如何在JavaScript中处理变量和对象，以便能够暂时存储数据进行处理。这正是本章的内容。

在本章中，您将学习：

+   JavaScript的基本数据类型（称为原始类型）

+   如何处理基本数据类型的变量（创建它们、赋值、转换等……）

+   如何从任何数据类型创建字段（数组），以及如何处理它们

+   基本数据类型与真正的JavaScript对象有何区别

+   JavaScript中的面向对象与其他面向对象语言中的工作方式有何不同

+   如何在JavaScript中创建和编辑对象

+   JSON是什么，它为什么如此重要，以及如何将JavaScript对象转换为JSON，反之亦然

## 31.1 变量声明

变量*应该声明*在JavaScript中，即在第一次使用之前进行注册。声明变量是良好的编程习惯，尽管通常只需简单的值赋值就足以创建一个变量，严格来说并不要求正式声明。然而，如果您尝试访问一个既未声明也未事先赋值的变量，您会收到错误消息。

一个常见问题是，如果变量声明不是强制的，您可能会因为拼写错误而不小心在程序中创建了一个新变量。例如，如果您想给现有变量**amountInvoice**赋值，但不小心在赋值时写成了**amountIvoice**，您将会遇到问题，尤其是在继续使用原本意图的变量标识符**amountInvoice**时，然而它从未接收到预期赋值。相反，新创建的变量**amountIvoice**保存了该值。您可以通过在*严格模式*下运行JavaScript来避免这种问题，在严格模式下，未声明的变量会导致错误消息。可以通过在脚本（或函数）中引入一个特殊语句作为第一条语句来为整个脚本（或单个函数）开启严格模式：

'use strict';

尝试为您在脚本中尚未声明的变量赋值；您会立即收到错误消息。现在去掉**'use strict'**语句并重新运行脚本——没问题，变量将在第一次赋值时被创建。

在JavaScript中，变量的正式声明是通过使用关键字**var**，后跟一个或多个由逗号分隔的变量标识符完成的。变量可以在声明时初始化值，但不是必须的。

**var** x = 0.5, y, z = '一条消息';

值得注意的是，变量在声明时是没有指定类型的。JavaScript 会根据在声明时（如果初始化了变量）或稍后分配的值自动识别变量应属于何种类型。程序员说 JavaScript 是弱类型的。 当然，我们可以并且有时必须通过转换显式指定变量的类型。我们将在►第[31.3节](#Sec7)中讨论这个问题。通过简单地为变量赋予不同类型的值，也可以更改变量的类型。JavaScript 会自动调整变量的类型以适应新值（动态类型）。关键字**var**可以在程序中多次出现，并且不必出现在整个程序源代码的开头。然而，最好将变量声明合并在开头，以便跟踪已注册的变量。

## 31.2 基本数据类型

JavaScript 有几种基本数据类型，包括数字（**number**）、字符串（**string**）和逻辑值（**boolean**）。这些（以及其他一些特殊类型）之所以被称为*基本*类型，是因为它们*不是对象*本身，而是*原始类型*。所有其他类型的变量都是 JavaScript 中的对象，因此具有可以操作它们的属性和方法。基本数据类型则没有，但有时——正如我们将看到的——它们的行为几乎像“真实”对象一样，奇迹般地表现出来。

### 31.2.1 数字（number）

整数和浮点数

**number** 是用于表示数字的数据类型，无论这些数字是整数还是小数，即浮点数。JavaScript 始终为存储数字预留 64 位，即 8 字节。因此，一个**number**变量能够存储的数字范围取决于所需的精度，即存储小数位所需的内存大小。反过来，可能的精度取决于小数点前整数部分的大小：如果整数部分非常大，那么小数位就会占用较少的内存。

Infinity

一个**数字**变量可以拥有的特殊值是**无限大**。如果你在 JavaScript 中将一个数字除以 0，你不会收到错误消息——与许多其他语言不同——而是会得到**Infinity**或**-Infinity**。打开 JavaScript 控制台并输入以下代码（此处的大于符号表示控制台提示符，因此不需要输入）：

**>** 1/0Infinity操作符

当然，您可以对数字执行通常的算术运算，包括四种基本算术运算。此外，**%** 是一个*模运算符*，返回除法的整数余数。所有这些运算符都是*二元*运算符，将两个值处理为一个新值。然而，在这个上下文中还有几个*一元*运算符，它们作用于单个值。在这种情况下特别有趣的是常见于 JavaScript 程序中的*递增*（**++**）和*递减*（**--**）运算符，它们无论变量是否有除 0 以外的小数部分，都将**number**变量的值增加或减少 1。因此，**variable++** 是对赋值**variable = variable + 1**更紧凑的表示方式。

数字对象的方法

**number**变量有（显然）可调用的方法，尽管数量可控制。“显然”是因为**number**变量实际上是一个*原始值*，即一个基本数据类型的变量，因此*不是*一个对象，即一个类的实例，我们期望它具有属性和方法。在►章节 31.3.2中，我们将看到这种显然矛盾的行为如何产生。

在**number**变量的可用方法中，一个例子是**toExponential()**，这是一个将数字转换为指数表示法并将其作为字符串返回的方法。变量本身在此过程中不会更改。

**>** myNumber = 50000**>** scientific = myNumber.toExponential()**>** scientific"5e+4"**>** typeof myNumber"number"**>** typeof scientific"string"

在这里，您首先看到我们可以使用点运算符（就像在 Python 中一样）访问对象的方法（和属性），调用方法始终需要指定括号，即使根本不向方法传递任何参数。

使用**typeof** ***objectinstance***，您将学习另一个有用的运算符，它返回变量的类型作为字符串。它不是数学运算符，但仍然是（一元）运算符。正如您所见，**toExponential()** 返回一个包含格式化数字的字符串。

除了**toExponential()**之外，可以应用于**number**的另一个方便的方法是**toFixed(*****places*****)**，它将数字四舍五入到指定的小数位数，并再次将结果作为字符串返回：

**>** myNumber = 3.14159**>** myNumber.toFixed(3)"3.142"

常量值（*字面量*）在 JavaScript 中的行为也像对象一样。但是，要访问这些对象的方法，您需要将值写在圆括号中，就像下面的示例中那样，您可以轻松地在控制台中尝试：

**>** (3.14159).toFixed(3)"3.142"31.1 [3 min]

展示 JavaScript 中无穷大加一仍然是无穷大。

### 31.2.2 文本（字符串）

分配字符串

字符串可以用单引号或双引号括起来：

**var** message = "Hello world", message2 = 'Hello world again';console.log(message, message2);

由于在JavaScript中，类似于Python，提供了两种不同的字符串定界符，其中一个可以用来定界字符串，另一个可以在字符串中用作“引号”：

**var** message = "程序员大声喊道：'Hello world'"; 转义

然而，有时，在一个字符串中，你可能希望用来标记字符串开始和结束的字符也成为字符串的一部分。在这种情况下，必须使用*转义*。正如我们之前看到的，想要在字符串中具有不同功能的字符，前面会加上一个反斜杠（**\**）。在我们的示例中，我们可以这样转义双引号：

**var** message = "程序员大声叫道：\"Hello world\"";

通过在前面加上反斜杠，双引号字符不再被解释为JavaScript程序中的字符——即字符串的定界符。相反，它被视为字符串的一部分。最后一个引号没有被转义，因此实际标记了字符串的结束。

然而，转义不仅可以用来禁用某些字符的正常控制功能，以便将它们作为字符串的一部分包含在内；转义还可以用来赋予通常在字符串中不起眼的字符不同的功能，从而将它们转变为控制语句。考虑以下示例：

**>** console.log('有些事情需要被看','到 \n与一点 \t 距离。'); 有些事情你需要被看，带着一点距离。

同样，我们看到两个反斜杠被用来进行转义：一旦字母**n**被转义，**\n**会在此处将换行符插入到字符串中。**\t**会插入一个制表符。在这两种情况下，一个本来没有特殊功能的字母被转变为控制语句。

但是，如果你使用反斜杠来转义一个完全没有特殊控制功能的字符，比如**i**，会发生什么呢？好消息是，什么都不会发生：

**>** console.log('转义\i但不知道为什么。'); 转义i，但不知道为什么。

然而，反斜杠本身并不会显示出来，它是一个特殊的控制指令，用于赋予下一个字符一个特殊的意义（如果它有的话）。这自然引出了下一个问题，也就是如何在字符串中表示一个反斜杠。毕竟，在Windows下工作的程序员会使用反斜杠作为路径分隔符。解决方案很简单：反斜杠本身只是被转义：

**>** console.log('文件位于C:\\Windows\\System。'); 文件位于C:\Windows\System。处理单个字符

在JavaScript中，字符串的各个字符可以像（只读）字段/数组中的元素一样进行访问。JavaScript中的数组索引从0开始表示第一个字符。访问时，索引会被括在方括号中：

**>** var message = 'Hello world'**>** message[1]"e"**>** typeof message[1]"string"

正如可以轻松验证的那样，字符串中的一个字符本身也是一个字符串。在 JavaScript 中没有专门的数据类型来表示单个字符。包含字符串字符的数组是只读的，因此无法对其进行写操作。因此，你*不能*使用类似**message[2] = 'z'**的语句来替换字符串中的字符。要做到这一点，你必须使用可用于**string**类型变量的方法，我们将在下面学习这些方法。我们将在►第[31.4节](#Sec10)中更详细地介绍数组操作的细节。

字符串连接

虽然字符串不能像数字那样进行计算，但**string**变量也支持加号操作符（**+**）。在字符串的上下文中，它用于连接多个字符串：

**var** message = "Hello" + " " + 'World';console.log(message);

正如你所看到的，使用单引号或双引号来界定字符串没有区别。

与加号不同，其他算术运算符不能应用于字符串。如果你这么做，你不会得到错误信息，但你会得到返回值**NaN**（*非数字*），我们将在►第[31.2.4节](#Sec6)中更详细地讲解它。这表示我们对一个非数字的东西应用了一个设计用来处理数字的运算符（试试看！）。

字符串的方法和属性

如果你在 JavaScript 控制台中创建了一个**string**变量，然后输入它的名称并跟上一个点操作符，弹出菜单将显示该字符串可用的方法和属性列表。

一个特别重要的属性是**length**，即字符串的长度：

**>** var message = 'Hello World'**>** message.length10

所以，如果你想访问字符串的单个字符，可以使用**message[message.length-1]**来获取字符串的最后一个字符（因为索引从0开始！）。

你可以使用字符串的**charAt(*****index*****)**方法来访问单个字符，而不是通过字符数组来访问：

**>** var message = 'Hello world '**>** message.charAt(message.length-1);"t"除了**charAt()**，**string**还提供了其他许多有用的方法：

+   **indexOf(*****searchString*****,** ***fromPosition*****)**：在调用该方法的字符串中搜索**searchString**，从**fromPosition**索引开始；这里，**fromPosition**是一个可选参数，因此可以省略，默认从字符串的开头开始搜索。**indexOf**的返回值是**searchString**在被搜索字符串中的起始索引，若未找到**searchString**，则返回-1：**>** message.indexOf("el")2**>** message.indexof("tel")-1

+   **replace(*****search*****,** ***replaceBy*****)**：搜索字符串中的**search**并将每个匹配项替换为字符串**replaceBy**：**>** message.replace("Hello", "Hi")"Hi word"

+   **toUpperCase()**, **toLowerCase()**：分别将字符串转换为大写和小写：**>** message.toUpperCase("HELLO WORLD"**>** message.toLowerCase();"hello world"

+   **trim()**, **trimLeft**, **trimRight()**：分别从字符串中移除前后空白、仅前导空白和仅尾随空白：**>** message = " " + message + " "" Hello World "**>** message.trim();"Hello World"**>** message.trimLeft()"Hello World "**>** message.trimRight()" Hello World"

使用这些方法时，请注意，被调用的方法所作用的变量不会发生改变，而是由方法创建并返回一个新的、更改后的字符串。所以，你必须自己处理这个返回值。

### 31.2.3 逻辑值（boolean）

JavaScript 中第三个重要的基本数据类型是逻辑/布尔值。它们只能取常量 **true** 和 **false** 的值（注意小写！），在内部用 1 表示 **true**，用 0 表示 **false**。当你用常量进行计算时，这一点变得清晰：**>** true * 55**>** false - 1-1

### 31.2.4 特殊类型和值（null, undefined, NaN）

null

JavaScript 知道两个特殊值，可以表示一个变量没有值：**undefined** 和 **null**。

如果一个变量故意没有真实值——例如，在问卷调查中，受访者故意遗漏的选择问题答案——则使用（准）“值” **null**：

questionAge = **null**;

**null** 因此是一个特殊的值常量，表示一个变量故意“空”，即当前不持有“真实”值。如果将 **null** 赋给一个之前持有“真实”值的变量，它会将其对象类型更改为一般的 **object**：

**>** var mynumber = 5**>** typeof mynumber"number"**>** mynumber = null**>** typeof mynumber"object"

不要被这个弄混：**null** 是一个具有相同名称的基本数据类型的变量。事实上，**typeof** 仍然返回 **“object”** 是严格来说不对的，这源自 **typeof()** 函数的历史实现。

undefined

**undefined** 类似于 **null**，也表示一个变量没有真实值。然而，**undefined** 不意味着“故意为空”，而是意味着“未触碰”或“尚未赋予另一个值”。变量在初始化后会携带 **undefined** 值，容易检查：

**>** var value**>** console.log(value)undefined

**undefined** 不仅仅在 JavaScript 中作为当前未初始化变量的“内容”使用，也用于其他上下文中，表示某物“缺失”，而没有人有意识地决定使用“空”内容。特别是在没有返回真实值的函数返回值中，通常会出现这种情况。

从技术上讲，**undefined** 和 **null** 一样，是同名基本类型的一个真实变量，但只有这一个变量：

**>** typeof undefined"undefined"NaN

**NaN** 是 *Not a Number*（不是数字）的缩写，表示一个数字变量并未包含有效的数字值，尽管它应该包含。通常，**NaN** 是由于不正确的算术操作（例如对负数开方）返回的结果：

**>** Math.sqrt(-1) NaN

有趣的是，**NaN** 并不是像 **undefined** 那样独立类型的真实变量，而只是数字变量的一种特殊值，如下面的代码所示：

**>** var x = Math.sqrt(-10) **>** typeof x "number"

你无法使用 **NaN** 进行计算，因为对它应用的每个计算操作都会返回 **NaN**：

**>** NaN + 3 NaN

使用 **isNaN(*****expression*****)**，可以检查一个表达式（变量、计算规则、函数调用等）是否具有值 **NaN**：

**>** isNaN(Math.sqrt(-100)) true **>** isNaN(Math.sqrt(100)) false

## 31.3 转换变量

### 31.3.1 隐式转换

我们已经看过一个隐式类型转换的例子，即开发者未明确指示的类型转换，见 ► Sect. [31.2.3](#Sec5)，即 **boolean** 变量在计算中表现得像值 1（对于 **true**）和 0（对于 **false**）。因此，在这种情况下，JavaScript 在适当的时候自动进行了类型转换。

隐式类型转换在与字符串相关的实际操作中起着重要作用。

**>** x = 3; y = "4"; z = "5" **>** x * y 12 **>** y * z 20

如你所见，JavaScript 在计算时没有任何问题，即使变量 **y** 和 **z** 实际上是字符串。在计算过程中，这些值会被隐式地转换为数字（类型 **number**）。

之所以在这里这么顺利地工作，主要是因为在处理字符串时，应用的（算术）操作符没有任何意义。然而，当我们执行加法时，情况就大不相同了：

**>** x + y "34" **>** y + z "45"

在这种情况下，JavaScript 假定操作的“目标类型”应该是 **string**（字符串）。因此，**+** 操作符被解释为字符串连接操作符，并且 **number** 类型的变量 **x** 被转换为字符串以便连接；**y** 和 **z** 默认已经是字符串，不需要进一步转换。

因此，在处理包含数字的字符串时，要小心。

31.2 [5 min] 以下运算的结果是什么？如果不确定，可以尝试并解释结果：1. (a)

    **'ab' + "def"**

1.  (b)

    **'98' + "5"**

1.  (c)

    **'98' + 5**

1.  (d)

    **'98' + "5.3"**

1.  (e)

    **'98' * 5**

1.  (f)

    **'98' * false**

1.  (g)

    **'98' * 'false'**

如果你希望将上一节中的字符串变量 **y** 和 **z** 中包含的两个数字视为 **number** 值并进行相加，那么仅仅使用加号操作符连接这两个变量是不够的，因为这会导致字符串拼接。因此，需要进行*显式*转换，在连接前将值转换为数字。JavaScript 提供了 **Number(notNumberValue)** 函数来完成此操作：

**>** y='4'; z='5' **>** Number(y) + Number(z) 9

**Number()** 是一个返回基本 **number** 值的函数。同时，**Number()** 也是 **Number** 类的构造函数。通过形式为 **variable = new Number()** 的赋值操作（我们将在 ► 第[31.5.4节](#Sec15) 和 [31.5.5节](#Sec16) 中详细讨论这种符号），你可以创建一个 **Number** 类的对象。这些对象包含了我们在 **number** 变量上下文中已经使用过的所有属性和方法。这正是像 **number** 这样的基本数据类型获取其属性和方法的方式：当我们访问基本 **number** 数据类型的属性或方法时，尽管该数据类型是*原始的*，因此并不真正代表一个对象，应该没有方法或属性，JavaScript 会在后台将变量转换为 **Number** 类型的对象。然后，这些相关的属性和方法就可以在这个对象上使用了。完成工作后，JavaScript 的自动垃圾回收机制会处理掉这个现在不再使用的对象，留下原始的基本变量。这个“技巧”使得 JavaScript 即使对于基本数据类型，也能够让它们看起来像是真正拥有属性和方法的对象。这就是我们对 JavaScript “幕后工作”的简要了解。

对应的函数同样存在于 **String(notStringvalue)** 和 **Boolean(notBooleanvalue)** 中，适用于另外两个基本数据类型。在下面的示例中，我们将字符串 **‘true’** 转换为一个真正的 **boolean 变量**。

**>** trueval = 'true' **>** typeof trueval "string" **>** trueval = Boolean(trueval) **>** typeof trueval "boolean"

顺便提一下，正如你可以轻松尝试的那样，如果忽略大小写规则，像是写 **"True"** 或 **"TRUE"** 这样的字符串，**Boolean()** 函数依然完全不受影响，转换仍然能够正常工作。这是因为 **Boolean()** 会将所有不是 **0**、**null**、**undefined** 或 **NaN** 的值评估为 **true**。因此，**Boolean("hello")** 也会返回 **true**！而贪吃的 **Boolean()** 会评估你传给它的所有内容，**Number()** 却挑剔得多：如果你调用 **Number()** 并传入一个无法转换为数字的参数，函数将拒绝工作并返回 **NaN**。

除了**Number()**和**String()**，用于字符串和数字之间转换的函数还有一些特殊的函数。**parseInt(string)**和**parseFloat(string)**都可以将字符串处理为数字，表面上看与**Number()**做的是一样的。然而，**parseInt()**和**parseFloat()**的特别之处在于，它们还可以处理并非完全是数字的字符串，只要数字部分位于字符串的开头：

**>** parseInt('3 twins are one too many')3**>** parseInt('3.1415926535 is the number Pi')3

第二个示例还表明，**parseInt()**——顾名思义——只处理字符串开头部分的整数。如果字符串开头找不到可以解释为数字的部分，则返回**NaN**。

在转换的相反方向——从数字到字符串——也有一些特殊的函数可用来帮助控制数字作为字符串的表示方式。**number**（实际上是**Number**对象，如我们现在所知道的）的**toString(*****number system*****)**方法，允许你指定要转换成的数字系统的基数；因此，**number system = 2**会导致二进制表示，**number system = 16**则会得到十六进制表示：

**>** someNumber = 156**>** someNumber.toString(2)"10011100"**>** someNumber.toString(16)"9c"

你可以使用**Number**对象的**toFixed(*****decimals*****)**和**toExponential(*****decimals*****)**方法来影响传统表示法和科学表示法中的小数位数：

**>** number = 156.27813**>** number.toFixed(2)"156.27"**>** number.toExponential(3)"1.562e+2"

在科学计数法表示中，指数被选择为使得小数点前面始终显示一个数字。

## 31.4 数组

创建数组并访问数组中的单个元素

JavaScript中的数组类似于其他一些语言中的列表（包括Python，见►第[21.6.1](474412_1_En_21_Chapter.xhtml#Sec14)节）。它们不仅可以包含任何类型的元素，而且元素的类型也可以是*不同*的。甚至数组本身也可以是其他数组的元素。通过这种方式，可以创建多维数组，而这是JavaScript默认不支持的。

创建数组最简单的方式是直接用*数组字面量*的形式指定其元素。元素用方括号括起来：

**>** primes = [1,3,5,7,11,13]

同样，数组中的对象也可以具有不同的类型：

**>** multipleTypes = [false, 'Caroline', 28.3]

通过数字索引访问单个元素，索引——与许多其他语言一样——也从0开始，并用方括号指定。所以，如果我们想访问刚才创建的数组的第二个元素（“Caroline”），可以这样做：

**>** multipleTypes[1]"Caroline"

因此，**multipleTypes[0]** 将返回数组的第一个元素，即 **false**。

数组的元素也可以为空；更准确地说，它们可以是 *空白*，因此它们的值是 **undefined**：

**>** multipleTypes = [false, , 'Caroline', 28.3]**>** multipleTypes[false, *empty*, 'Caroline', 28.3]

如果查看数组的内容，***empty*** 会被显示出来——至少在 Google *Chrome* 的 JavaScript 控制台中——对于那些被留空的数组元素。然而，通过直接显示它，容易让人相信该元素的内容确实是 **undefined**：

**>** multipleTypes[1]undefined

数组不是基本数据类型，不是 *原始类型*，而是 *对象*。因此，数组不仅可以像上面那样通过赋值数组字面量来创建，还可以通过调用数组类型的构造函数 **Array()** 来创建。上述使用的数组也可以通过这种方式构造：

**>** multipleTypes = new Array(false, undefined, 'Caroline', 28.3)

被留空的数组元素必须显式赋值为 **undefined**，因为如果它真的留空，会导致错误消息。我们已经在► 第 31.3.2 节看到过 **new** 关键字；在► 第 [31.5.4](#Sec15) 和 [31.5.5](#Sec16) 节中，我们将更详细地讨论它的含义。

顺便说一句：如果你仅指定一个正整数作为 **Array()** 构造函数的参数，那么你得到的不是一个包含一个元素的数组，而是一个创建了指定元素数量的完全空数组。

从数组中选择多个元素

数组作为对象提供了许多有用的属性和方法。在接下来的内容中，我们将使用其中的一些属性和方法来更深入地操作数组。我们先从数组中选择元素开始。

我们已经看到如何通过指定元素索引来访问数组元素。但如果要一次选择多个元素怎么办呢？与 Python 不同，JavaScript 没有操作符可以一次“抓取”整个索引值范围。然而，**Array** 类有一个方法 **slice(*****from*****,** ***to*****)**，可以用来实现相同的效果。在这种情况下，从索引值 ***from*** 开始，返回的是所有在索引值 **to** 之前的索引值，但不包括这个元素本身。考虑以下示例：

**>** prime = [1,3,5,7,11,13]**>** prime.slice(2,4)[5, 7]

因此，选择了索引值为 2 和 3 的元素（因为索引是从 0 开始的，这意味着选择的是数组中的第三个和第四个元素）。

***to*** 参数也可以省略。在这种情况下，返回的是从索引位置 **from** 开始的数组的其余部分：

**>** prime.slice(3)[7, 11, 13]

**slice()** 的 **from** 和 **to** 参数也可以是负值。在这种情况下，选择是从数组的末尾开始，数组的最后一个元素的索引值为 -1：

**>** prime.slice(-3,-1)[7, 11]

请注意，这里选择的元素也是在第二个索引位置之前的元素。

确定和改变数组的长度

**length**属性可以用来确定数组的长度：

**>** multipleTypes = new Array(false, undefined, 'Caroline',28.3, undefined)**>** multipleTypes.length5

这个属性也可以被改变，因此我们可以通过将一个新的、更小的值赋给它的长度来缩短数组：

**>** multipleTypes.length = 3[false, empty, 'Caroline']

如果我们之后“扩展”数组，之前“切掉”的元素不会重新出现，但新元素将被填充为**undefined**（在Google Chrome的表示中为**empty**）：

**>** multipleTypes.length = 5[false, 空, 'Caroline', 空 x 2]

数组字面量也是一个**Array**对象，因此我们也可以访问数组字面量的对象属性和方法。与**number**或**string**不同的是，字面量*不需要*用圆括号括起来：

**>** [1,3,5,7,11,13].length6更改数组中的元素、向数组中添加元素或从数组中删除元素

迄今为止，除了改变数组的长度外，我们一直以*只读方式*处理数组。当然，你也可以使用我们已经学过的选择技术来*更改*数组元素的值：

**>** primes = [1,3,5,7,11,13]**>** primes[2] = '素数系列中的间隙'**>** primes[1, 3, '素数系列中的间隙', 7, 11, 13]

你可以使用**splice(*****from*****,** ***count*****)**方法从数组中*删除*元素。***count***个元素从索引位置***from***（包括该元素）开始被删除。**splice()**方法返回一个包含被删除元素的数组：

**>** primes.splice(2,3)['素数间隙', 7, 11]**>** primes[1, 3, 13]

与提供给基本类型**number**和**string**的方法不同，**splice()**会修改它被调用的原始数组。

顺便说一下，参数**count**是可选的：如果**count**没有使用，**splice**会删除从索引位置**from**开始的整个数组。

**splice()**不仅可以用来删除元素，还可以用来插入元素。第二个参数（**count**）后面可以跟任意数量的值，这些值会*插入*在索引位置**from**的元素之后；然而，参数**count**指定的**count**个元素仍然会先被删除：

**>** primes = [1,3,5,7,11,13]**>** primes.splice(1, 2, '间隙 1', '间隙 2')[3, 5]**>** primes[1, "间隙 1", "间隙 2", 7, 11, 13]

如果你只想插入而不删除，将参数**count**设置为 0：

**>** primes.splice(3, 0, '间隙 3')[]**>** primes[1, '间隙 1', '间隙 2', '间隙 3', 7, 11, 13]

**splice()**，因为没有从数组中删除任何元素，所以该函数返回一个空数组作为返回值。

除了**splice()**，**Array**对象还有其他方法可以用来向数组添加元素或从数组中删除元素。**push()**方法将元素追加到数组的末尾，并返回数组的新长度作为函数值。**pop()**方法删除数组的最后一个元素，并返回被删除元素的值：

**>** primes.push(57)8**>** primes[1, 'Gap 1', 'Gap 2', 'Gap 3', 7, 11, 13, 57]**>** primes.pop()57**>** primes[1, 'Gap 1', 'Gap 2', 'Gap 3', 7, 11, 13]

**shift()**和**unshift()**方法与**push()**和**pop()**非常相似，但它们操作的是数组的开头，而不是末尾（试试看！）。

合并数组

两个数组可以方便地使用**concat(*****otherArray*****)**方法连接。这个方法会将数组***otherArray***的元素添加到调用**concat()**方法的数组的最后一个元素之后。然而，调用**concat()**方法不会改变原数组，而是返回一个新的合并数组，可以将其保存在一个变量中：

**>** primes = [1,3,5,7,11,13]**>** evenNumbers = [2,4,6,8,10]**>** myNumbers = primes.concat(evenNumbers)**>** myNumbers[1, 3, 5, 7, 11, 13, 2, 4, 6, 8, 10]排序数组

你可以使用**Array**对象的**sort()**方法按照元素的值将数组元素按字母顺序升序排列：

**>** primes = [1,3,5,7,11,13]**>** primes.sort()**>** primes[1, 11, 13, 3, 5, 7]

你可能已经注意到，**sort()** 将数组的元素视为字符串，因此会把 3 排在 13 后面，这是数字排序所不会出现的顺序。如果不希望这种行为，可以进行修改。实际上，**sort()** 方法有一个可选的参数，允许你指定一个函数，该函数接受两个值（我们称之为**x**和**y**）作为参数，并且在排序顺序中当**x**应排在**y**之前时返回一个正值，而在相反的情况下返回一个负值。因此，通过指定一个比较规则来决定任意两个值中，哪个应当先出现在排序顺序中，哪个应当排在后面，你可以微调**sort()**函数的行为。为了实现数字排序，我们可以编写一个辅助函数**greater(x,y)**，如果**x > y**，它返回一个正值，否则返回一个负值。表达式**(x-y)>0**是一个逻辑表达式，也就是说，它根据**x**和**y**的比较结果返回**true**或**false**。这样，我们的数字排序就可以如下进行：

**>** greater = function(x, y) {return (x - y) > 0;}**>** primes.sort(greater)**>** primes[1, 3, 5, 7, 11, 13]

我们将在后面的章节中更详细地讲解函数的定义。

要按降序排序值，我们可以使用**Array**对象的**reverse()**方法。它只是简单地翻转数组中的元素。如果我们将此方法应用于先前使用**sort()**排序的数组，我们将得到一个降序排序：

**>** primes.sort(greater).reverse()

带有两个点运算符的表示法可能看起来有些奇怪，但实际上是非常合逻辑的：表达式**primes.sort(greater)**返回一个**Array**对象，该对象又具有**reverse()**函数。可以使用常规的点符号调用该函数。当然，你也可以将整个操作分为两步来进行。

**sort()**和**reverse()**不仅返回各自操作的结果作为函数值，还会修改它们被调用的数组。在这一点上，它们与**splice()**相似，而与**concat()**不同。

显示数组为字符串

使用**join()**和**toString()**方法，**Array**对象提供了两种将其元素合并为字符串的方法。原始数组不会被这两种方法修改。**join()**和任何JavaScript对象提供的**toString()**方法基本上有相同的效果，但**join()**更为灵活，因为它可以使用一个可选参数来指定数组元素之间的分隔符，而**toString()**则固执地使用逗号作为分隔符：

**>** primes = [1,3,5,7,11,13]**>** primes.toString()"1,3,5,7,11,13"**>** primes.join()"1,3,5,7,11,13"**>** primes.join('-')"1-3-5-7-11-13"

**join()**方法和**concat()**方法之间存在混淆的危险：与**join()**的名称可能暗示的不同，这里并不是*将两个不同的数组*连接起来，而是连接*数组中的不同元素*。

顺便说一下：如果你“添加”两个数组，你也会得到一个包含两个数组所有元素的字符串；但要小心，因为在两个数组之间不会插入任何分隔符，也就是说，在第一个数组的最后一个元素和第二个数组的第一个元素之间没有分隔符（因此示例中的“数字”**132**）：

**>** primes = [1,3,5,7,11,13]**>** evenNumbers = [2,4,6,8,10]**>** primes + evenNumbers"1,3,5,7,11,132,4,6,8,10"将字符串分解为数组

就像你可以使用**join()**和**toString()**方法将数组转换为字符串一样，也可以将字符串拆分并使单个部分成为数组的元素。在以下示例中，考虑字符串**friends**，它包含一个以逗号分隔的名称列表：

**>** friends = 'Thomas,Marc,Sharon,Hazel'

借助**split()**方法，字符串现在可以拆分为单个名称，并将这些名称“喂入”数组中。**split()**的参数是分隔符字符，用于分隔字符串的各个部分，在我们的示例中是逗号：

**>** friendsArray = friends.split(',')**>** friendsArray['Thomas', 'Marc', 'Sharon', 'Hazel']重复：使用数组表示法访问字符串字符

在 JavaScript 中，正如我们在►第 31.2.2 节中所见，字符串是一种基本数据类型，属于*原始类型*，因此不是对象。如你所记得，字符串的单个字符仍然可以像访问数组元素一样被访问：

**>** var message = 'Hello World!'**>** message[1]"2"**>** message[message.length-1]"!"

在最后一条命令中，我们访问了字符串中的最后一个字符（记住，索引是从 0 开始的！）。然而，你不能使用数组符号来修改字符串的单个字符。虽然这样的尝试不会导致错误信息，但尝试的修改不会生效。字符串在某种意义上是“只读数组”。

31.3 [5 min]

创建一个值为**"Hello World"**的字符串。选择这个字符串中的第六个和第八个字符，然后从字符串中删除这些字符。

## 31.5 对象

### 31.5.1 JavaScript 中的面向对象编程

JavaScript 中的面向对象编程与大多数其他面向对象语言有所不同。JavaScript 本身并不直接识别面向对象编程的核心基本概念——*类*。相反，JavaScript 采用了一种基于*原型*创建对象的方法。“原型”和“类”乍一看可能并没有太大区别，因为面向对象编程中的类也有一个原型函数，用于派生自它们的对象（这些对象在某种意义上是根据类的“原型”构建的）。然而，实际上，这两种方法有很大的不同。

两个例子：与典型的面向对象语言中的类不同，在 JavaScript 中，属性和方法可以直接添加到单个对象（在传统面向对象术语中，你会说：添加到类的实例）中，而这些属性和方法并不包含在原型定义中。因此，在不从基类派生额外类的情况下，同一类型（类）的不同对象实例可以在其方法和属性上有所不同。在其他面向对象语言中，同一类型（类）的所有对象会有相同的结构，表现为可用的方法和属性（后者当然可能赋予不同的值）。JavaScript 的原型方法与其他面向对象语言的类方法之间的另一个区别在于，JavaScript 中类的结构并未明确描述；直到 ECMAScript 2015 版本之前（但这并未改变原型方法），没有描述类型（类）作为方法和属性集合的语法结构，正如我们在 Python 中看到的那样。相反，JavaScript 中的类型定义完全封装在类型的构造函数中，并通过其对其他对象原型的引用来“继承”方法（在原型方法中，继承属性并没有什么意义，除非你想要以面向对象编程的精神添加*静态*属性，即所有对象实例共享相同的值）。

如果上一段看起来非常技术性且较难理解，不用担心，我们将在接下来的章节中避开 JavaScript 自身的原型方法的大部分细节。深入探讨这些内容将大大超出本书快速学习语言*最重要*基本概念、并能够应用它们的目的。

与本书的 Python 部分不同，我们在这里避免处理继承问题，因此不会从其他对象或其原型派生对象。即使没有完全掌握 JavaScript 独特但非常灵活的面向对象方法（特别是如果你来自“经典”的面向对象思维方式），你也能够很好地掌握大多数应用场景。

### 31.5.2 直接创建对象

在 JavaScript 中创建对象的最简单方法是声明一个变量，在该变量中不仅赋值，还可以（通常是一个或多个）为该（对象）变量赋予多个属性。为了演示这一点，我们将使用已经多次使用的产品定义示例。

可以通过以下赋值轻松地在 JavaScript 中创建具有相同属性的对象：

**var** product = {name: '园艺铲，不锈钢', price: 10.99}

如你所见，这里声明了一个名为**product**的变量，并在声明时直接为其赋值。赋值的内容是产品的属性。大括号表明**product**是一个自定义对象。大括号中指定的每个属性由标识符（在我们的示例中是**name**和**price**）和在冒号后分配给该属性的值组成。多个属性在对象声明中由逗号分隔。

产品的属性也可以分配变量（因此，当前值被分配给该属性）；特别是，属性的值可以是其他对象。

在实践中很少遇到，但语法上是允许的，也可以将属性标识符用（单引号或双引号）括起来：这使你可以在属性标识符中包含空格，例如：

**var** product = {'Name of the product': 'Garden shovel, stainless steel', price: 10.99}

这样，你可以为属性添加标识符，否则在 JavaScript 中会被认为是非法的，比如**#hastag**（由于第一个字符的原因，非法）。你还可以使用其他保留关键字，比如**var**，作为属性标识符。然而，这种做法也相对少见，因为它会导致代码可读性差且更容易出错。

与“独立”变量一样，JavaScript 本身决定属性必须具有的数据类型；在我们的示例中，**name**将是**string**类型，**price**是**number**类型。

### 31.5.3 访问对象的属性

对象不过是*关联数组*：由键值对组成的属性数组。

那么，方法呢？从面向对象编程的角度来看，我们将对象理解为包括属性（特性）和方法，即函数的构造体，通过这些方法可以操作属性。然而，方法不能同时是属性。那么，如何才能使 JavaScript 中的对象实际上仅仅是一个只有属性的关联数组呢？诀窍在于，JavaScript 中函数也是对象，并且它们是**function**类型的对象。但我们在上一节中看到，对象属性的值可以是另一个对象，从而也可以是一个函数。

如果对象最终是一种关联数组，那么它们的属性（也包括方法）可以通过指定键，即属性标识符来访问。为此，必须用引号和方括号来指定。完成上一节中对象声明的 JavaScript 控制台操作后，现在可以轻松访问**product**对象的**price**属性：

**>** product['price'] 10.99

键当然也可以是一个变量本身：

**>** property = 'price' **>** product[property] 10.99

这种表示法清楚地展示了 JavaScript 对象作为关联数组的特性。

然而，在实践中，另一种常见的访问方法是通过点操作符，这也是许多其他面向对象语言中所熟知的：

**>** product.price10.99

这种访问方式只在对象属性的标识符是有效的JavaScript标识符时才有效，也就是说，不能包含空格，且不能以除下划线和美元符号以外的特殊字符开头。然而，始终推荐选择符合常规规则的标识符。

### 31.5.4 使用Object构造函数创建对象

在►第[31.5.2](#Sec13)节中，我们通过将一组键值对，即对象的属性，赋值给变量来创建了一个对象。在本节中，我们将学习创建对象的第二种方法。为此，我们利用了这样一个特性：JavaScript中所有对象层次结构中的对象都派生自基本类型**object**。因此，我们首先通过调用构造函数来创建一个**object**类型的变量（关于JavaScript构造函数的更多内容将在下一节介绍）。请注意构造函数的首字母大写：

**>** var product = new Object()**>** typeof product"object"通过这个我们创建了一个空对象。如果你在控制台输入**product**，你可以看到弹出窗口中显示的内容，这时我们原本认为是空的对象，实际上已经包含了一整套属性和方法，即**object**类型默认的那些属性和方法。但我们希望给这个对象添加我们标准的**product**属性**name**和**price**。现在我们可以通过简单的赋值来完成：**>** product.name = '园艺铲，不锈钢'; **>** product.price = 10.99;

你可以很容易验证我们的**product**对象确实拥有**name**和**price**这两个属性，并且其值分别为：

**>** product.name"园艺铲，不锈钢"**>** product.price10.99

### 31.5.5 使用构造函数创建对象

最后——也是最重要的一种——生成对象的方法是编写一个构造函数来创建该对象。在前一部分，我们也使用了构造函数，即构造函数**Object()**。在这一部分，我们将自己构建一个构造函数，用来创建我们自己的对象类型。

我们希望我们的**product**对象拥有两个属性，**name**和**price**；这些属性应该在创建对象时直接指定。我们可以通过如下的构造函数来实现：

**function** product(price, name) {this.price = price;this.name = name;}

构造函数接收两个值作为参数，然后通过关键字**this**将它们赋值给新创建对象的属性。**this**指的是当前对象，它表示在其上下文中使用的对象。在我们的例子中，this指的是我们新创建的**product**对象。这样，我们也完成了我们这个非常简单类型的定义。现在，我们可以通过调用刚刚开发的构造函数来创建该类型的实例：

**>** gardenShovel = new product(10.99,'Garden shovel, stainless steel')

注意关键词 **new**。它确保创建一个新的对象。如果构造函数在没有这个关键词的情况下被调用，则不会创建新的对象，而是简单地返回 **undefined**。

### 31.5.6 JSON

即使你不使用 JavaScript，仍然有可能在某个时刻遇到 JSON 数据格式。例如，它通常用于互联网 API 中，用于从 Web 服务中检索信息。这类接口通常会以 JSON 格式将结果返回给调用的应用程序。仅次于 XML，它是互联网上第二重要的数据交换格式。JSON 是*JavaScript 对象表示法*（JavaScript Object Notation）的缩写，因此，在我们结束对 JavaScript 中对象的讨论时，重点关注这个流行的数据交换格式也就不足为奇了。

我们已经在►第 [31.5.2](#Sec13) 节中遇到过 JSON 格式，在那里我们直接以字面量的形式创建了对象。那里使用的表示法，键值对被放在花括号内并用逗号分隔，这实际上就是一种 JSON 格式的表示法。

请考虑以下来自 JSON 数据集的片段：

{'customer01': {'First name': 'Phil','Last name': 'Philipson','Address': {'Street': '1 Philly Drive','ZIP': 19145,'City': 'Philadelphia''State': 'PA'}},'customer02': {'First name': 'Auric','Last name': 'Goldfinger','Address': {'Street': '450 Gold Avenue','ZIP': 40121,'City': 'Fort Knox''State': 'KY'}}}

这个 JSON 对象（由外部的花括号界定）包含两个（子）对象，**customer01** 和 **customer02**，它们具有不同的字段。其中一个字段，地址，本身就是一个由不同字段组成的对象。字段名，即键值对中的键，在 JSON 中用引号括起来，这—如前所述—在 JavaScript 中也是语法允许的。

使用 **JSON.stringify(*****object*****)** 函数，你可以将任何对象转换为 JSON 字符串，这也叫做 *序列化*；反之，**JSON.parse(string)** 允许你将 JSON 字符串（例如，作为 Web API 调用结果返回的字符串）转换成一个真正的 JavaScript 对象。

尽管 JSON 的起源与 JavaScript 紧密相关，但如今几乎所有常见的编程语言都提供了处理 JSON 格式数据的函数，这也强调了 JSON 作为数据交换格式的流行。这种流行无疑源于 JSON 允许以一种语法简洁的方式表示层次化的对象结构，这种方式即使没有 JSON 知识的人也能很容易地读取。

31.4 [5 分钟]

创建一个包含你直系家庭成员姓名和年龄（以年为单位）的对象数组。然后访问并显示该数组中第二个人的姓名。最后，将这个数组转换为 JSON 字符串。

31.5 [10 分钟]

创建两个对象，每个对象包含一个客户地址。一次通过直接创建对象，向变量分配键值对；一次通过通用的对象构造函数 **Object()** 来创建。

## 31.6 总结

本章我们讨论了 JavaScript 中的基础变量和对象。

确保从本章中记住以下几点：

+   在 JavaScript 中，变量并非必须声明，但良好的编程实践是声明变量。

+   主要的基础数据类型有 **number**（数字，包括整数和浮点数）、**string**（字符串）和 **boolean**（布尔值）。

+   字符串可以用单引号或双引号括起来；可以通过简单的数组表示法 (**string[*****characterIndex*****]**) 访问字符串中的单个字符，但仅限于只读模式。

+   对于那些本身不是对象的基础数据类型，存在与之同名的对象原型（但首字母大写，例如 **Number**），它们提供有用的属性和方法；如果需要，JavaScript 会在后台自动将基础数据类型临时转换为对应类型的对象，以便你像访问基础数据类型的属性或方法一样访问这些属性和方法。

+   特殊值 **undefined** 用于表示变量尚未定义值（或者函数没有返回实际的返回值），而 **null** 用于表示有意识地决定某个变量应该保持“空”值。

+   JavaScript 已经在必要时进行隐式转换。

+   在转换字符串时需要小心：加号操作符用于连接两个字符串，但如果字符串中包含数字并且需要进行数值相加，而没有事先显式地转换为**数字**类型，可能会导致不期望的结果。

+   通过基础数据类型所属的对象类型构造函数，可以显式地进行基础数据类型之间的转换，例如使用 **Number(*****string*****)**。

+   数组是可以存储不同数据类型变量（也可以是对象）的列表；数组的各个元素通过 **array[*****elementIndex*****]** 来访问，索引从 **0** 开始。

+   JavaScript 在其核心定义中并不识别任何类；面向对象特性是通过原型实现的，基于原型的形式可以创建对象；可以向对象的实例添加额外的属性和方法，这些属性和方法是原型在构造时未包含的。

+   对象可以通过将逗号分隔的元素/属性列表（键值对表示法）直接分配给变量，形式为大括号中的键值对，例如：**object = {*****property1*****:** ***value1*****,** ***property2*****:** ***value2*****}**。类似地，可以先通过对象构造函数 **Object()** 创建一个“空”对象，形式为 **object = new Object()**，然后逐步在其中创建属性，通过赋值形式 ***object*****.*****property*** **=** ***value***。

+   你也可以通过调用相应对象类型的构造函数来创建对象，例如 ***object*** **= MyObject()**。

+   你可以使用点操作符访问对象的元素/属性，符号为 ***object*****.*****property***，或者像处理（关联）字段一样，使用数组表示法 ***object*****["*****property"*****]**。

+   *JavaScript 对象表示法*（*JSON*）是互联网数据交换的常见格式。它完全对应于用于直接创建对象的表示法，即通过逗号分隔的键值对列表，放置在大括号中。因此，任何 JSON 文档都可以通过 **JSON.parse(*****jsonDocument*****)** 转换为 JavaScript 对象，反之，任何 JavaScript 对象也可以通过 **JSON.stringify(*****object*****)** 表示为 JSON 文档。

## 31.7 练习解答

练习 31.1 **>** Infinity + 1 Infinity **>** Infinity + 1 == Infinity true

在这里我们使用特殊值 **Infinity**，它也可以用于计算。顺便说一下，从第二个输入中你可以看到，正无穷加一等于正无穷（双等号是比较操作符）。因此，比较结果为真，相应地返回值 **true**。

练习 31.2

1.  (a)

    **'abc' + 'def' = 'abcdef'**。字符串通过加号操作符连接。

1.  (b)

    **'98' + '5' = '985'**。加号操作符在这里也将两个字符串连接起来。它们恰好包含数字并不重要。

1.  (c)

    **'98' + 5 = '985'**。这里第二个加数是一个实数。然而，加号作为 *字符串连接操作符* 在表达式处理中具有优先权。因此，JavaScript 会隐式地将数字 **5** 转换为字符串，以便能够与字符串 **'98'** 连接。

1.  (d)

    **'98' + '5.3' = '985.3'**。同样，如果字符串包含小数，使用加号操作符会导致字符串连接。

1.  (e)

    **'98' * 5 = 490**。乘法操作符对字符串没有意义。因此，由于字符串操作在这里不适用，JavaScript 会隐式地将字符串 **"98"** 转换为数字，以便能够执行有效的操作。

1.  (f)

    **'98' * false = 0**。常量**false**在内部被评估为值**0**。由于字符串的乘法没有意义，JavaScript尝试进行数值操作，并为此将字符串**"98"**转换为数字。

1.  (g)

    **'98' * 'false' = NaN**。在这里，即使是JavaScript也认输了。乘法显然是数值操作，但JavaScript这里接受了两个字符串。结果是*不是数字*。这两者并没有被转换为数值，尽管**"98" * "5"**会发生这种情况（试试看！）。

正如你所看到的，如果不了解完整的规则集，预测JavaScript的隐式转换并不容易。因此，最好不要依赖隐式转换，而是确保在需要的地方进行显式转换。

练习31.3

字符串在*读取访问*时表现得像数组，因此我们可以像数组一样选择其中的字符：

**>** message = 'Hello World'**>** message[5]" "**>** message[7]"o"

然而，就写访问而言，字符串不像数组那样工作。因此，使用数组方法**splice()**删除元素是不行的。实现所需效果的一种方法是使用**slice()**将字符串“切片”，从而使得位于索引位置**5**和**7**的字符被去掉。请注意，slice**()**总是选取直到*指定的第二个索引之前*的部分：

message = message.slice(0,5) + message.slice(6,7) + message.slice(8, message.length)练习31.4

我们创建一个数组，其元素是我们存储为键值对的对象，使用通常的对象表示法：

**>** family = [{name: 'Mark', age: 28}, {name: 'Cathy', age: 54}, {name: 'Ben', age: 57}]

我们通过首先使用索引（**family[1]**）从数组中选择人物对象，然后访问其**name**属性来获取第二个人的名字，通常我们使用点表示法来实现：

**>** family[1].name"Cathy"

全局JSON对象的**stringify()**方法帮助将数据转换为JSON字符串。

**>** JSON.stringify(family)"[{"name":"Mark","age":28},{"name":"Cathy","age":54},{"name":"Ben","age":57}]"练习31.5

直接在对象表示法中生成，作为一个用逗号分隔的键值对列表：

**>** var customer1 = { customerNumber: 14527,name: 'Peterson', firstName: 'Carl',street: '54 Wellington Drive', zip : '02113',city: 'Boston, MA' }**>** var customer2 = { customerNumber: 19321,name: 'Hamilton', firstName: 'Beth',street: '21 Eagle's Square', zip : '10012',city: 'New York, NY' }

生成通过首先让通用的**Object()**构造函数创建一个“空”对象，然后为其添加我们的属性：

**>** var customer1 = new Object()**>** customer1.customerNumber = 14527**>** customer1.name = 'Peterson'**>** customer1.firstName = 'Carl'**>** customer1.street = '54 Wellington Drive'**>** customer1.zip = '02113'**>** customer1.city = 'Boston, MA'

**customer2**的流程是类似的。
