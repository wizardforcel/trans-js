© 作者（们），独家授权 Springer Fachmedien Wiesbaden GmbH，Springer Nature 2024 J. L. Zuckarelli 《用 Python 和 JavaScript 学习编程》 [https://doi.org/10.1007/978-3-658-42912-6_13](https://doi.org/10.1007/978-3-658-42912-6_13)

# 13. 如何使用程序函数编辑数据并触发操作？

Joachim L. Zuckarelli^([1](#Aff2))(1) 德国慕尼黑 概览

在大多数编程语言中，执行实际工作的都是小型子程序，即所谓的函数。它们帮助读取数据、修改数据、再次输出数据等。你可以访问编程语言提供的标准函数，安装来自互联网的附加函数库，或编写自己的函数。这就是本章的内容。

在本章中，你将学到以下内容：

+   什么是函数

+   如何在程序代码中定义函数

+   如何调用函数并指定它们的行为

+   在使用函数时，变量的作用域扮演着什么角色

+   如何在面向对象编程中使用函数，以及在许多语言中函数作为对象本身的优势

+   函数是如何在库中进行分组的，以及如何找到合适的、免费的库

+   什么是框架，它们与库有什么不同

+   什么是应用程序编程接口（APIs），以及如何使用它们。

## 13.1 函数

什么是函数？

就像在数学中一样（不用担心，我们不会过度使用这个比较！），函数是映射规则，将称为`参数`的值映射到另一个值，即它们的`函数`或返回值。例如，函数`f(x) = x²`将一个值`x`映射到它的平方；因此，将一个值`x`作为参数传递给函数，并从函数那里接收一个处理后的值（在这个例子中，就是参数的平方）作为返回值。

编程语言中的函数遵循相同的基本原则，然而，区别在于并非所有函数都会返回值。我们已经在伪代码中使用过一个名为`showProduct()`的函数，该函数在屏幕上执行输出操作。这个函数没有返回值。它只是执行一个特定的操作，即在屏幕上显示，但不会进一步处理传递给它的参数数据。某些编程语言严格区分有返回值的函数和没有返回值的`过程`。然而，我们在这里不会做这样的区分，而是始终称之为“函数”。在一些编程语言中，函数总是返回一个值；如果它们没有“真实”的返回值，则会返回一个特殊的值，表示没有“真实”的结果（例如，JavaScript 中的`undefined`或 C/C++ 中的`void`）。

函数的定义

函数通常由`function head`和`function body`组成。头部通常包含函数标识符（名称）和函数期望的参数列表。函数体是每当函数被调用时执行的代码块。它包含函数的“核心”部分；它所包含的源代码描述了函数的作用。

考虑一个简单的伪代码示例，它是一个将两个数字相乘的函数：

`Function multiply(number1, number2) Begin result = number1 * number2 return(result) End`

为了让编程语言知道函数定义的开始，它以关键字`Function`开头。接下来是函数标识符和函数的两个参数，`number1`和`number2`。函数体由两条语句组成，一条计算函数的实际结果，另一条调用`return()`，返回函数结果。两条语句形成了一个`code block`，这个代码块以关键字`Begin`开始，以关键字`End`结束。几乎所有编程语言都有代码块。它们通常由特殊的关键字（如我们伪代码中的英语关键字`Begin`和`End`）或符号（如大括号`{`和`}`）来分隔。一些语言，如Python，完全不使用任何特殊的关键字或符号，而是通过将代码块中的所有行进行一致的缩进来标识代码块。

但是回到我们的函数定义。它的程序代码本身并不执行任何操作。函数只有在程序中被调用时才会出现。在我们的示例中，这看起来可能是这样的：

`show(multiply(3, 57.8))`

通过这个调用，我们将数字3和57.8相乘，并立即输出结果。这里发生的事情是，程序的执行分支到`multiply`函数的定义。函数体中包含的代码会被执行，函数参数`number1`和`number2`取传递的因子值——在这个例子中是3和57.8。乘法的结果通过`return()`返回，这使得程序执行离开函数体并返回到主程序。通过执行该函数，函数的返回值现在取代了函数调用的位置。这可以再次作为参数传递给另一个函数，在我们的例子中是`show()`。通过`multiply()`函数后，程序代码实际上简化为：

`show(173.4)`

由于函数调用在执行后会被返回值替代，函数调用也可以被赋值给变量：

`value = multiply(3, 57.8)`

许多编程语言要求函数必须在第一次调用之前定义，因此函数定义必须在程序代码中位于第一次调用之前的“较高”位置。

注意：函数也可以定义为没有参数。例如，一个仅仅清除屏幕显示的函数不需要传递任何进一步的信息。在大多数编程语言中，即使是这样的函数，也必须使用圆括号进行调用，其中通常包含参数的值。在这种情况下，圆括号是空的，但语言的解释器/编译器仍然会识别这是一个函数调用，而不是对同名变量的访问。

程序中函数调用的顺序在图◘ `13.1`中以示意图形式展示。![](../images/474412_1_En_13_Chapter/474412_1_En_13_Fig1_HTML.jpg)

一个调用函数的示例。主程序包含更多的表达式和`My Function`。`My Function`被调用，它包含表达式和返回语句。

图 `13.1`

调用函数

可选参数

有时，你希望通过一个参数让用户控制函数的行为，但将其预设为一个默认值。如果函数调用者没有为相关参数指定值，则使用默认值。

假设我们想要设计上述的`multiply()`函数，使得`number1`始终与数字`pi`（3.14159…）相乘，除非在函数调用中显式传递了`number2`的值。那么我们需要在函数头部指定这个默认值：`Function multiply(number1, number2 = 3.14159)`。现在，调用`multiply`也可以像这样：

`two_pi = multiply(2)`

在这个上下文中，`number2`被称为`optional`参数，因为在调用函数时可以省略它。

带有标识符的函数参数传递

在许多编程语言中，调用函数时的参数也可以通过它们的标识符来指定。这看起来可能是这样的：

`value = multiply(number1 = 3, number2 = 57.8)`

这些`keyword arguments`的优势在于，当调用具有多个参数的函数时，哪个值属于哪个参数会更加清晰；因此，调用者不必记住参数的顺序。因为现在可以使用参数的标识符，解释器/编译器不再依赖于参数的顺序。在这种情况下，我们称之为`positional arguments`，以区别于关键字参数。因此，你也可以偏离实际的参数顺序；有效的函数调用也可以是以下形式：

`value = multiply(number2 = 57.8, number1 = 3)`

另一个优点是，通过在调用函数时使用参数标识符，程序代码变得更易于理解，从而也更易于维护。

变量的作用域

在大多数编程语言中，函数可以说是过着“独立生活”。它们是一个独立的、隔离的世界。回想一下我们`multiply()`函数的定义。在这个函数内部，创建了一个名为`result`的变量，用于保存两个数字的乘积。这个变量仅存在于函数内部。在函数调用结束时，即当函数完全运行时，变量`result`也会消失。它无法从主程序中访问。因此，也可以说它的`scope`仅限于函数体。

假设我们的主程序看起来像这样：

`value = multiply(3, 57.8)show(result)`

语句`show(result)`将导致一个错误信息（或者，根据语言的不同，返回一个默认值像`0`），因为在主程序的作用域中没有名为`result`的变量。这个变量在`multiply()`函数的作用域中。由于其作用域有限，`result`被称为`local variable`。另一方面，变量`value`是在主程序中创建的，适用于任何地方。这类变量被称为`global variables`，与局部变量相区别。它们可以从任何地方访问，甚至可以在我们的`multiply()`函数内访问。然而，最佳实践是避免在函数内部访问全局变量（也称为`side effects`），因为这使得函数更容易受到程序其余部分变化的影响，尤其是全局变量标识符的变化。

但是，如果`multiply()`函数本身使用了一个名为`value`的变量，例如，如果函数的核心指令是`value = number1 * number2`呢？那么我们就有了两个名为`value`的变量，一个是局部的（在`multiply()`函数内部），一个是在主程序中的全局变量。那么，当在程序代码的某处使用标识符`value`时，访问的是哪一个？一般来说，编程语言首先在本地环境中查找具有此标识符的变量，如果在那里找不到，再查找全局环境。所以，如果在`multiply()`函数内部使用变量`value`，将使用局部变量，即在当前作用域中定义的那个。而从主程序访问`value`则会导致访问全局变量。

函数参数通常表现得像局部变量，它们也只能从函数代码内部访问。

按引用而不是按值传递参数

考虑我们`multiply()`函数的以下稍微修改的变体：

`Function multiply(number1, number2, AsReference result) Begin result = number1 * number2 End`

这次，我们的函数没有返回值；相反，计算结果被赋值给一个作为参数传递的变量，但与`number1`和`number2`不同，它使用了关键字`AsReference`。通常，函数的参数作为原始值的副本传递。考虑以下对我们函数的调用示例：

`number1 = 3 value = 0 multiply(number1, 57.8, value) show(value)`

这里，函数的第一个参数本身是一个变量。它的值在`multiply()`函数内部作为`number1`参数存在，但仅作为原始变量的副本。如果我们在函数体内调整`number1`的值，这将不会影响主程序中的`number1`变量。只有`multiply()`函数体中的局部变量`number1`的值会发生变化。

这在`value`变量的情况下有所不同。它不是作为值传递给函数，而是作为所谓的`reference`传递。这意味着在函数内部对这个变量的修改会影响原始变量；在这个例子中，我们使用这个变量来“返回”计算结果。一些编程语言允许变量按`值传递`或按`引用传递`，而有些语言只允许按值传递。

函数定义的示例

到目前为止，我们只在伪代码中编写了函数定义。因此，下面是原始`multiply()`函数在真实编程语言中的两种实现，分别是`PHP`和`Pascal`。

首先是`PHP`版本：

`function multiply($number1, $number2){$result = $number1 * $number2;return $result;}`

语句`return`在某些语言中不是一个函数，而是一个关键字（因此“参数”周围没有圆括号）。

然后是`Pascal`中的相同代码：

`function multiply(number1, number2: real): real; var result: real; begin result = number1 * number2; multiply = result; end;`

`Pascal`是强类型的编程语言。这里的变量始终具有固定的类型声明。因此，函数的两个参数`number1`和`number2`以及函数本身（在函数头部末尾）都有类型规格：在所有情况下，它们都是浮点数（`real`）。这不仅明确了函数期望的参数类型，也明确了其返回值的类型。

在`Pascal`中，`return`语句不像在许多其他具有`return`关键字或`return()`函数的编程语言中那样工作，而是通过将函数值赋给函数标识符来实现的（在`Pascal`中，赋值使用`=`作为赋值操作符）。

面向对象编程中的函数

在►节 `[11.​7.​4](474412_1_En_11_Chapter.xhtml#Sec14)` 中，我们看到在面向对象编程的上下文中，函数也可以是类的一部分。正如你可能记得的那样，这类函数通常被称为`方法`。这些方法总是与类的具体对象实例一起调用，即与根据类的“模板”创建的对象一起调用。因此，方法的调用可能看起来像这样：

`object.method(arguments)`

根据编程语言的不同，方法定义可以是类定义的一部分，也可以在类定义外部。然而，无论如何，在类定义中总会有一个方法的引用（通常是方法头），正如我们在►节 `[11.​7.​4](474412_1_En_11_Chapter.xhtml#Sec14)` 中看到的那样（如果有必要，可以返回几页）。

除了作为方法的函数可以是对象（或其类）的一部分之外，函数和对象通常还有另一种关系。在许多编程语言中，函数`是`对象。在这些语言中，存在一个特殊的类（通常是`function`），所有函数都是该类的对象（即实例）。因此，它们也可以具有属性，比如它们的参数或函数体，即实际的代码。当函数本身是对象时，这带来了一些显著的影响。例如，函数本身可以作为其他函数的参数。此外，类定义在逻辑上是非常严格的；严格来说，它们仅由属性组成。唯一的区别是，有些属性，即方法，是`可调用`的，而其他属性（即“正常”的值属性）则不可调用。

13.1 [3 min]

以下函数定义（伪代码形式）有什么问题：

a. **函数** `exponential(base)` **开始** `return(base^exponent)` **结束** b. **函数** `exponential(base, exponent)` **开始** `result = base^exponent` **结束** 13.2 [3 min]

假设我们有一个如下定义的函数：

**函数** `introduce(name, age)` **开始** `show("我的名字是 ", name, " , 我 ", age, " 岁。")` **结束**

以下两种调用函数的方式有什么不同，为什么第一个和第三个调用实现了期望的功能，而第二个没有？

`introduce("Mary", 25)` `introduce(25, "Mary")` `introduce(age = 25, name = "Mary")` 13.3 [5 分钟]

考虑以下程序片段：

`age_person = 25` **函数** `getolder(age_person)` **开始** `age_person = age_person + 1` `show("新年龄：", age_person)` `return(age_person)` **结束** `age_new = getolder(age_person)` `show("当前年龄：", age_person)` `show("getolder()函数的结果：", age_new)`

1.  (a)

    该程序生成什么输出，为什么？

1.  (b)

    有哪两种方法可以修改程序，使得新的年龄（比原来高一岁）也能反映在全局变量 `age_person` 中？

## 13.2 库

程序员的工具箱：库

作为程序员，你可以（如前一节所示）自行开发函数。如果你希望`重用`程序代码，这总是有意义的，因为函数的好处是它们可以将特定功能从实际程序中分离出来，并可以在任何地方、任何时间调用。

当然，编程语言通常会附带一组丰富的标准函数，你可以用它们来执行许多常见任务。然而，这些标准函数往往不足以满足你的需求。例如，发送电子邮件、网页抓取（`web scraping`）或训练神经网络的函数通常不包含在标准语言范围内。在这些及其他使用场景中，如果你不想自己开发所需的功能，就需要通过从其他地方安装所需的函数来扩展语言的功能范围。

查找合适的库

一些编程语言，如 Python、R 和 JavaScript，拥有非常广泛且充满活力的 `生态系统`，有大量开发者将他们开发的功能免费提供给其他人。这通常以一组专注于某一主题的函数的形式发布。根据编程语言的不同，这些集合通常被称为 `库`、`模块`、`包` 或 `发行版`。为简便起见，我们在此统一称之为“库”。在某些情况下，这些库会被汇集在一个由负责该编程语言开发的组织集中管理的平台上。

例如，以下情况就是如此：

+   Python 与 `Python 软件包索引`（`PyPI`，► [https://pypi.org/](https://pypi.org/)），

+   Perl 与 `综合 Perl 存档网络`（`CPAN`，► [https://www.cpan.org/](https://www.cpan.org/)），

+   PHP 与 `PHP 扩展社区库`（`PECL`，► [https://pecl.php.net/](https://pecl.php.net/)），

+   R使用`Comprehensive R Archive Network`（`CRAN`，► [https://​cran.​r-project.​org](https://cran.r-project.org)）。

根据设计，加入这些中央目录的过程通常伴随着（主要是自动化的）质量控制，确保例如库的程序代码是可执行的，并且至少有最低限度的文档。

然而，对于许多编程语言来说，这样一个集中管理的库平台并不存在。开发者们通常会将自己的作品上传到`GitHub`。`GitHub`是一个跨语言平台，允许开发者通过将源代码存储在`repository`中与他人共享代码。在`GitHub`之下是版本管理工具`Git`，它由Linux发明者`Linus Torvalds`开发，能够以优雅的方式对源代码的变更进行版本控制。如果需要，开发者可以轻松地将单个代码文件甚至整个`repository`恢复到以前的状态。开发者还可以使用`GitHub`创建自己的源代码`branches`，在其中开发新功能，并最终将它们`merge`回原始版本，前提是原始版本的开发者允许这么做。凭借这些功能以及其他一系列特性，`GitHub`促进了不同开发者之间的协作，基于底层版本管理工具`Git`。`GitHub`完全不依赖于特定语言；对于今天大多数使用中的编程语言，你都可以在该语言的`repository`中找到代码。对于那些将源代码以开源许可证发布的开发者来说，使用`GitHub`在写本书时是免费的。想要将代码对外界保密的公司和组织需要为私有环境支付费用。尽管还有一些与`GitHub`类似的平台存在，但`GitHub`仍然是最受欢迎的。

当然，`GitHub`不仅被那些在没有中心库平台的语言中工作的开发者使用。许多开发者在`GitHub`上运行`repository`，并非为了库，而是为了他们在任何类型的开发项目上的日常工作，或是与其他开发者交换信息。如果他们确实开发了库，他们通常只会将最终版本发布到像`PyPI`或`CRAN`这样的中心库平台上。有时候，开发者也不想受到中心库平台的严格规则和自动化质量检查的限制，因此只在`GitHub`上提供他们的库。

因此，`GitHub`和中心库平台都是寻找帮助你解决特定问题的库的好地方，这并不奇怪。不过，这种搜索有时并不是完全简单的，原因有几个。平台的搜索功能各不相同，每个库的可用信息也有所不同。因此，有时找到一个库并判断它是否适合解决你的问题并不容易。这种评估进一步复杂化，因为通常会有多个库可能适合。即使在中央管理的库平台上，对于许多任务也存在几个在一定程度上相互竞争的库。推荐两种方法。一种是`trial and error`；下载并使用“候选者”，以确定哪个库最适合你的问题。另一种是在互联网上搜索，在相关论坛（如`Stack Overflow`）中，您可以定期找到有关许多库的信息。这在你想通过示例了解如何使用该库时尤其有用。库的文档在范围和质量上各不相同，因此像`Stack Overflow`这样的论坛在使用已找到的合适库时也能提供良好的帮助。

除此之外，像`Stack Overflow`这样的论坛通常是识别解决问题的库候选者的良好首选——如果你不能或不想直接通过中心库平台或在`GitHub`上搜索。这是因为论坛中的问题通常是按照“我如何解决这个问题……”或“我如何让它……”的结构来组织的，答案中往往包含一个或多个可以帮助解决此类问题的库的引用。许多开发者更喜欢这种论坛搜索，而不是直接在中心库平台或`GitHub`上搜索，因为这些论坛中的示例和用户评论通常提供了宝贵的额外信息。

不用说，你也可以使用像`ChatGPT`这样的AI助手来搜索合适的库。例如，询问：“我想写一个读取网站数据的Python程序（`webscraping`）。有哪些库可用，它们有什么不同，哪些特别适合初学者？”

安装和导入/加载库

一旦你找到了合适的库，你所需要做的就是安装它（如果编程语言对此有要求）并将其包含在程序代码中。包含的方式是通过一个语句，该语句要么将库整体导入，要么将其中的单个元素（例如单个函数或类）导入程序代码。在某些情况下，可以指定一个名称，用于标识已导入的元素，这有助于避免与已存在的变量、类、对象或函数的标识符冲突。

一个来自`Python`的（假设的）示例：

`from somelibrary import aclass as my_class import somelibrary`

第一个语句仅将类`aclass`导入程序代码，并将其通过标识符`my_class`进行访问。第二个替代语句导入整个`library`（在此情况下没有分配不同的标识符）。

在`Pascal`中更容易

`uses somelibrary;`

或`R`

`library(somelibrary)`

在每个情况下，整个`library`（库）都会被提供。

## 13.3 框架（Frameworks）

在`web开发`领域，经常会讨论`framework`（框架），尤其是在网页开发方面。术语“`framework`”（框架）和“`library`”（库）有时并不十分明确区分。尽管`framework`的功能和用途超出了本书讨论的范围，但至少应该更详细地探讨这两个概念的区别。`Library`（库）包含程序员可以在需要时访问的功能，以执行特定任务。因此，主动权在程序员手中。`Framework`（框架）则不同。`Framework`控制整个应用程序的流程，并在必要时调用程序员的代码。`Framework`因此形成了，正如术语所暗示的那样，一个框架，程序员“只需”填充。这在网页开发领域尤其实用，因为有许多重复的任务，例如用户登录的身份验证、数据库的连接，或在模板页面中输出数据。所有这些任务都可以由`framework`接管。它们已经作为功能内置在程序员正在使用的`framework`中。程序员只需开发与其应用程序特定的内容。通过`framework`和开发者之间的这种劳动分工，应用程序的控制实际上是反转的（这就是为什么在与`frameworks`相关时，有人也会谈论`inversion of control`）：`Framework`控制应用程序，开发者提供应用程序特定的程序代码，然后`framework`在合适的地方调用。这使开发者能够集中精力处理重要问题，而将所有相对无聊的“附属工作”留给`framework`。

知名的`frameworks`（框架）包括`AngularJS`和`React`（用于`JavaScript`）、`django`（用于`Python`）、`CakePHP`和`Zen`（用于`PHP`）以及`Ruby on Rails`（用于`Ruby`）。

由于本书的重点是学习编程基础，因此我们在这里不会涉及`frameworks`。然而，使用`frameworks`的前提是，当然需要了解底层语言，而这正是我们在本书中讨论的内容。

## 13.4 应用程序编程接口（APIs）

另一个人人都在谈论的术语是`应用程序编程接口`，简称API。首先，API正如其名字所示，实际上就是`编程接口`。从这个意义上说，一个提供特定目的功能集的库，也提供了一个编程接口，它由可以在程序中访问的库函数组成。

当人们今天谈论 API 时，他们通常指的是特定的编程接口，例如 `Web API`，通过这些接口你可以访问 web 服务的功能和数据。如今，许多 web 服务为开发者提供了编程接口。例如，Google 提供的 `GoogleMaps API`，如果你将城市名称传递给该 API，它会返回该城市的地理坐标。在这里，API 用于获取 web 服务提供的信息。同样，API 也可以用来让 web 服务触发特定的操作。例如，Twitter 的 API 允许你发布推文。你只需要一个可以使用该 API 的账户，并在程序中写出相应的指令，指向该 API 并发送推文。

因此，API 可以用于查询数据并触发功能。如今，互联网上有成千上万的 web 服务提供 API，这些 API 可以被访问。网站 `ProgrammableWeb`（► [https://​www.​programmableweb.​com/​apis/​directory](https://www.programmableweb.com/apis/directory)）提供了一个 API 提供商的概览，虽然不完全，但至少非常全面。无论你是想在程序中使用 `PayPal` 处理支付，还是查看最新的足球比赛结果，凭借今天提供的 web API，几乎没有什么愿望无法实现。

从技术上讲，`Web API` 主要与 `超文本传输协议`（HTTP）一起工作，可以像网页一样进行调用。例如，要访问 `GoogleMaps API` 获取芝加哥的地理位置，一个程序只需要发出如下形式的 HTTP 请求 ► [https://​maps.​googleapis.​com/​maps/​api/​geocode/​json?​address=​Chicago&​key=​XX](https://maps.googleapis.com/maps/api/geocode/json?address=Chicago&key=XX)，其中 `key` 是一个参数，用于验证调用 API 的用户身份是否合法。然后，Google 会返回坐标，格式为 JSON，这是一种在 `Web API` 中极为流行的数据交换格式，因为它易于生成且易于阅读，稍后我们会在 ► 第 [31.​5.​6](474412_1_En_31_Chapter.xhtml#Sec17) 节详细了解。如果你将这个请求直接输入到网页浏览器中，你也会得到 JSON 格式的结果，但会收到一条错误信息，因为 `XX` 不是一个有效的 API 用户密钥：

`{"error_message" : "提供的 API 密钥无效。","results" : [],"status" : "REQUEST_DENIED"}`

然而，一个程序并不需要使用网页浏览器通过 API 向 web 服务发出此类请求。相应的 HTTP 请求可以通过大多数编程语言内部触发（通常使用提供相应功能的库），并且返回的结果可以在程序用户无需了解任何细节的情况下进行处理。

我们不会继续详细讨论 Web API，因为本书的重点是编程基础。然而，掌握了这些基础后，进一步学习如何将 Web API 融入到程序中就变得非常容易。此时，最重要的是理解 Web API 是一种用于扩展程序功能的多用途工具。最终，它们的工作方式与库函数相似；它们被调用（尽管方式稍有不同），触发某个操作或检索信息，并返回一个值（通常是一个 JSON 对象）。在两者之间，编程接口（API）的基本概念是相同的。

## 13.5 学习新编程语言的路线图

如果你正在学习一门新的编程语言……

你将发现：

+   函数是如何定义的；特别是，如何使用可选参数，如何（以及是否）将参数按引用传递而不是按值传递，以及函数如何返回值，

+   函数是如何被调用的；特别是，当调用函数时，参数是否可以通过名称传递，

+   变量的作用域是如何设计的，以及是否可以在函数内部访问全局变量（特别是当它与局部变量同名时）

+   存在什么好的库参考资源以及如何搜索合适的库；特别是，是否存在一个集中管理的平台，这个平台实际上是搜索合适库时的主要联系点，

+   如何将库（或其元素）包含到你的程序中，并访问它们的功能。

## 13.6 练习解答

练习 13.1

1.  (a)

    在`return()`语句中使用了参数`exponent`，但是该参数并没有出现在函数头部的参数列表中。因此，函数头应该正确写作`function exponential(base, exponent)`。

1.  (b)

    这次，参数`exponent`被包含在函数头的参数列表中。然而，函数没有返回值。计算了一个变量`result`，但它没有通过`return()`返回。必须将`return(result)`语句作为函数的最后一条语句添加。

练习 13.2

`**introduce("Mary", 25)** 按照预期调用函数。函数头部参数列表中的第一个参数是姓名，第二个参数是年龄。` `introduce(25, "Mary")` `在调用函数时交换了参数的顺序。现在，第一个参数` `(**name**)` `被赋值为` `25`，`第二个参数` `(**age**)` `被赋值为` `"Mary"`。`在最好的情况下，函数会输出一个看起来有些奇怪的文本，但在最坏的情况下，它会因预期的参数类型和传入值不匹配而终止并报错。最后，调用` `introduce(age = 25, name = "Mary")` `也会交换参数顺序，但通过指定参数名称，传入的值如何分配给函数的参数变得清晰，因此，函数调用时参数顺序的不同不再是问题。`

`练习 13.3`

1.  `(a) 程序将输出以下内容：` `New age of the person: 26Current age: 25Result of the function getolder(): 26`

    `函数` `getolder()` `增加了传入参数` `age_person` `的值，并将其作为函数值返回。同名的` *全局* `变量` `age_person` `保持不变。函数作用域内优先使用的是该参数，它被视为` *局部* `变量。`

1.  `(b) 第一种可能性是将函数` `getolder()` `的返回值捕获到全局变量` `age_person`：` `age_person = getolder(age_person)`

    `另一种方式是将函数的` `age` `参数定义为通过` *引用* `传递的参数（如果所使用的编程语言允许）。然后，函数头部会像这样定义：` `Function getolder(AsReference age_person)`。`这样，` `age_person` `参数仍然被视为局部变量（它不能在函数代码块外部访问），但是对它的修改会立即反映到传入的变量（即` `age`）。`因此，` `getolder()` `函数最终能够修改全局变量` `age`。`
