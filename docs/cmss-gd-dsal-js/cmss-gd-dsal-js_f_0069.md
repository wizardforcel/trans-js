## 服装标签

假设我们正在为一家服装制造商编写软件。我们的代码接受一个新生产服装项的数组（以字符串形式存储），并为每个所需的标签生成文本。

具体而言，我们的标签应包含物品名称及其尺寸，范围从1到5。例如，如果我们有数组`["紫色衬衫", "绿色衬衫"]`，我们希望为这些衬衫生成如下标签文本：

| ​  | [ |
| --- | --- |
| ​  | `"紫色衬衫 尺寸: 1",` |
| ​  | `"紫色衬衫 尺寸: 2",` |
| ​  | `"紫色衬衫 尺寸: 3",` |
| ​  | `"紫色衬衫 尺寸: 4",` |
| ​  | `"紫色衬衫 尺寸: 5",` |
| ​  | `"绿色衬衫 尺寸: 1",` |
| ​  | `"绿色衬衫 尺寸: 2",` |
| ​  | `"绿色衬衫 尺寸: 3",` |
| ​  | `"绿色衬衫 尺寸: 4",` |
| ​  | `"绿色衬衫 尺寸: 5"` |
| ​  | ] |

这是用于为整个服装项数组创建文本的代码：

| ​  | `**函数** markInventory(clothingItems) {` |
| --- | --- |
| ​  | `**常量** clothingOptions = [];` |
| ​  |  |
| ​  | `**对于** (**常量** item **在** clothingItems中) {` |
| ​  | `**对于** (**让** size = 1; size < 6; size += 1) {` |
| ​  | `clothingOptions.push(${item} *尺寸:* ${size});` |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `**返回** clothingOptions;` |
| ​  | } |

让我们来确定这个算法的效率。`clothingItems`是正在处理的主要数据，因此`N`是数组`clothingItems`的大小。

这段代码包含嵌套循环，因此很容易将该算法的复杂度声明为`O(N²)`。然而，我们需要更仔细地分析这个情况。虽然包含嵌套循环的代码通常是`O(N²)`，但在这种情况下并非如此。

当每个循环都围绕`N`时，会产生`O(N²)`的嵌套循环。然而，在我们的例子中，虽然外层循环运行`N`次，内层循环始终运行固定的五次；也就是说，无论`N`是多少，这个内层循环始终会运行五次。

因此，虽然外层循环运行`N`次，但内层循环对每个`N`字符串运行五次。这意味着我们的算法运行了`5N`次，但由于大O符号忽略常数，这可以简化为`O(N)`。
