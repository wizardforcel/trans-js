## 时间与空间之间的权衡

这是一个接受数组并返回是否包含任何重复值的函数（你可能在第 4 章中见过这个函数，[`使用大 O 加速你的代码`](f_0040.xhtml#chp.speeding_up)）：

| ​  | `function` hasDuplicateValue(`array`) { |
| --- | --- |
| ​  | `for` (`let` i = 0; i < `array.length`; i += 1) { |
| ​  | `for` (`let` j = 0; j < `array.length`; j += 1) { |
| ​  | `if` (i !== j && `array[i]` === `array[j]`) { |
| ​  | `return` `true`; |
| ​  | } |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `return` `false`; |
| ​  | } |

这个算法使用了嵌套循环，时间复杂度为 O(N²)。我们将此实现称为版本 #1。

这是第二个实现，版本 #2，它采用哈希表和仅一个循环：

| ​  | `function` hasDuplicateValue(`array`) { |
| --- | --- |
| ​  | `const` `existingValues` = {}; |
| ​  |  |
| ​  | `for` (`const` `value` `of` `array`) { |
| ​  | `if` (!`existingValues[value]`) { |
| ​  | `existingValues[value]` = `true`; |
| ​  | } `else` { |
| ​  | `return` `true`; |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `return` `false`; |
| ​  | } |

版本 #2 从一个空的哈希表 `existingValues` 开始。然后我们遍历 `array` 中的每一项，当我们遇到每个新项时，将其作为键存储在 `existingValues` 哈希表中。（我们将值任意设为 `true`。）然而，如果我们遇到一个已经是哈希表中键的项，我们就返回 `true`，因为这意味着我们找到了重复值。

那么，这两种算法中哪种更高效呢？这完全取决于你是考虑时间还是空间。就时间而言，版本 #2 显著更高效，因为它只有 O(N)，而版本 #1 的时间复杂度为 O(N²)。

然而，在空间方面，版本 #1 实际上比版本 #2 更高效。版本 #2 占用的空间可达到 O(N)，因为它创建了一个哈希表，可能包含传递给函数的所有 N 个值。相比之下，版本 #1 除了原始数组之外不消耗任何额外内存，因此空间复杂度为 O(1)。

让我们看看两个版本的`hasDuplicateValue`之间的完整对比：

| 版本 | 时间复杂度 | 空间复杂度 |
| --- | --- | --- |
| 版本 #1 | O(N²) | O(1) |
| 版本 #2 | O(N) | O(N) |

我们可以看到，版本 #1 在内存方面更高效，但版本 #2 在原始速度方面更快。那么我们该如何决定选择哪种算法呢？

答案当然是，这要视情况而定。如果我们需要我们的应用程序非常快速，并且有足够的内存来处理，那么版本 #2 可能更可取。另一方面，如果我们处理的是需要节省内存的硬件/数据组合，而速度不是我们最大的需求，那么版本 #1 可能是正确的选择。就像所有技术决策一样，当存在权衡时，我们需要看到全局。

让我们看看这个相同函数的第三个版本，看看它与前两个版本的比较：

| ​  | ​`function`​ `hasDuplicateValue(array)` { |
| --- | --- |
| ​  | array.sort((a, b) => a - b); |
| ​  |  |
| ​  | ​`for`​ (​`let`​ i = 0; i < array.length - 1; i += 1) { |
| ​  | ​`if`​ (array[i] === array[i + 1]) { |
| ​  | ​`return`​ ​`true`​; |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | ​`return`​ ​`false`​; |
| ​  | } |

这个实现，我们称之为 Version #3，首先对数组进行排序。然后它迭代数组中的每个值，并检查是否与下一个值相同。如果是，我们找到了一个重复值。然而，如果我们到达数组末尾而没有两个连续的值相同，我们就知道数组中没有重复值。

让我们分析 Version #3 的时间和空间效率。

在时间复杂度方面，这个算法是 O(N log N)。我们可以假设 JavaScript 的排序算法是 O(N log N)，因为已知的最快排序算法都是这样。额外的 N 步迭代数组在排序步骤面前是微不足道的，因此 O(N log N) 是整体速度的总和。

空间是一个稍微复杂的问题，因为各种排序算法消耗不同数量的内存。我们在书中遇到的一些最早的算法，比如冒泡排序和选择排序，消耗的额外空间为零，因为所有排序都是原地进行的。有趣的是，较快的排序确实会占用一些空间，原因稍后会解释。大多数快速排序的实现实际上占用 O(log N) 的空间。

所以让我们看看 Version #3 与前两个版本的比较结果：

| Version | Time Complexity | Space Complexity |
| --- | --- | --- |
| Version #1 | O(N²) | O(1) |
| Version #2 | O(N) | O(N) |
| Version #3 | O(N log N) | O(log N) |

事实证明，Version #3 在时间和空间之间取得了有趣的平衡。在时间上，Version #3 比 Version #1 快，但比 Version #2 慢。在空间上，它比 Version #2 更有效率，但比 Version #1 效率低。

那么，为什么我们可能想要使用 Version #3 呢？如果我们关心时间和空间，这可能是我们的解决方案。

最终，在每种情况下，我们需要知道我们可以接受的最小速度和内存限制。一旦我们理解了约束条件，就可以从各种算法中选择，以便为我们的速度和内存需求提供可接受的效率。

到目前为止，你已经看到我们的算法在创建额外的数据（例如新的数组或哈希表）时可能会消耗额外的空间。然而，即使算法没有执行这些操作，它也可能消耗空间。如果我们没有预料到，这可能会给我们带来麻烦。
