## 二次问题

这是一个实际示例，我们可以在这里用快速的 `O(N)` 算法替换慢的 `O(N²)` 算法。

假设你正在开发一个分析人们对产品评分的 JavaScript 应用，用户的评分范围从 `0` 到 `10`。具体来说，你正在编写一个函数来检查评分数组中是否包含任何重复的数字。这将在软件的其他部分用于更复杂的计算。

例如，数组 `[1, 5, 3, 9, 1, 4]` 中有两个 `1`，因此我们会返回 `true`，以指示数组中存在重复数字。

可能首先想到的方法之一是使用嵌套循环，如下所示：

| ​  | `function` hasDuplicateValue(`array`) { |
| --- | --- |
| ​  | `for` (`let` i = 0; i < `array.length`; i += 1) { |
| ​  | `for` (`let` j = 0; j < `array.length`; j += 1) { |
| ​  | `if` (i !== j && `array[i]` === `array[j]`) { `return` `true`; } |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `return` `false`; |
| ​  | } |

在这个函数中，我们使用变量 `i` 遍历数组中的每个值。当我们关注 `i` 中的每个值时，我们会运行一个第二个循环，使用 `j` 查看数组中的所有值，并检查位置 `i` 和 `j` 的值是否相同。如果相同，则表示我们遇到了重复值，我们返回 `true`。如果我们完成所有循环而没有遇到任何重复项，我们返回 `false`，因为我们知道数组中没有重复项。

虽然这确实有效，但效率如何？既然我们对大 O 符号有了一定了解，让我们退一步看看大 O 对这个函数的看法。

请记住，大 O 表示算法相对于 `N` 个数据值所需的步骤数。要将此应用于我们的情况，我们需要问自己：对于提供给我们 `hasDuplicateValue` 函数的 `N` 个值，我们的算法在最坏情况下将需要多少步骤？

为了回答前面的问题，我们需要分析我们的函数采取了哪些步骤，以及最坏的情况会是什么。

前面的函数有一种类型的步骤，即比较。它反复比较 `array[i]` 和 `array[j]` 以查看它们是否相等，因此表示一个重复对。在最坏的情况下，数组中没有重复项，这将迫使我们的代码完成所有循环并耗尽每个可能的比较，然后才返回 `false`。

基于此，我们可以得出结论，对于数组中的 `N` 个值，我们的函数将执行 `N²` 次比较。这是因为我们执行一个外部循环，必须迭代 `N` 次以遍历整个数组，对于每次迭代，我们必须再用内部循环迭代 `N` 次。也就是说，`N` 步骤 * `N` 步骤，等于 `N²` 步骤，这使得我们的算法为 `O(N²)`。

我们实际上可以通过向函数添加一些代码来证明我们的函数需要 `N²` 步骤，这些代码跟踪算法的步骤数量：

| ​  | `function` hasDuplicateValue(`array`) { |
| --- | --- |
| ​  | `let` steps = 0; `// count of steps` |
| ​  | `for` (`let` i = 0; i < `array.length`; i += 1) { |
| ​  | `for` (`let` j = 0; j < `array.length`; j += 1) { |
| ​  | `steps += 1;` `// increment number of steps` |
| ​  | `if` (i !== j && `array[i]` === `array[j]`) { |
| ​  | `return`​ `true`; |
| ​  | } |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `console.log(steps);` `// print number of steps if no duplicates` |
| ​  | `return`​ `false`; |
| ​  | } |

这段新增的代码将在没有重复项时打印出所用的步骤数。例如，如果我们运行`hasDuplicateValue([1, 4, 5, 2, 9])`，我们将在JavaScript控制台看到输出为25，这表明对数组中的五个元素进行了二十五次比较。如果我们对其他值进行测试，我们会看到输出始终是数组大小的平方。这是经典的 O(N²)。

通常（但并不总是），当一个算法将一个循环嵌套在另一个循环中时，该算法是 O(N²)。因此，每当你看到一个嵌套循环时，O(N²)的警报应该在你的脑海中响起。

现在，我们的函数是 O(N²) 这一事实应该让我们警觉。这是因为 O(N²) 被认为是相对较慢的算法。每当你遇到一个慢算法时，花点时间考虑是否有更快的替代方案是值得的。可能没有更好的替代方案，但让我们首先确认一下。
