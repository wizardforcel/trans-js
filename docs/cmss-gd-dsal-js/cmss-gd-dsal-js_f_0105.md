## 递归类别：重复执行

在解决各种递归问题的过程中，我开始发现问题的不同类别。一旦我学会了一种有效的技巧来处理某个类别，当我遇到另一个属于同一类别的问题时，我能够应用相同的技巧来解决它。

我发现最简单的类别是算法目标是重复执行一项任务的情况。

上一章的NASA航天器倒计时算法就是一个很好的例子。代码会打印出一个数字，例如10，然后是9，再到8，一直打印到0。虽然函数打印的数字每次都不同，但我们将代码的本质归结为它在重复执行一项任务——即打印数字。

这是我们实现该算法的方式：

| ​  | `function` countdown(number) { |
| --- | --- |
| ​  | console.log(number); |
| ​  |  |
| ​  | `if` (number === 0) { |
| ​  | `return`; |
| ​  | } `else` { |
| ​  | countdown(number - 1); |
| ​  | } |
| ​  | } |

我发现对于这类问题，函数的最后一行代码是一个简单的对函数的再次调用。在之前的代码片段中，这表现为`countdown(number - 1)`。这一行只做一件事：进行下一次递归调用。

上一章的目录打印算法是另一个例子。这个函数重复执行打印目录名称的任务。

我们的代码看起来像这样：

| ​  | `import` { readdirSync, lstatSync } `from` `fs`; |
| --- | --- |
| ​  | `import` { join } `from` `path`; |
| ​  |  |
| ​  | `function` printSubdirectories(directoryName) { |
| ​  | `for` (`const` fileName `of` readdirSync(directoryName)) { |
| ​  | `const` pathName = join(directoryName, fileName); |
| ​  | `if` (lstatSync(pathName).isDirectory()) { |
| ​  | console.log(pathName); |
| ​  | `printSubdirectories(pathName);` |
| ​  | } |
| ​  | } |
| ​  | } |

在这里，最后一行代码是`printSubdirectories(pathName)`，这也是一个简单的递归函数调用，重新触发它。

### 递归技巧：传递额外参数

让我们再尝试解决一个“重复执行”类别的问题。我们要编写一个算法，接收一个数字数组，并将数组中的每个数字加倍。请注意，我们不会生成一个新数组；相反，我们将在原地修改该数组。

原地修改

让我们看看原地修改的概念，以防不够清楚。

一般来说，操作数据有两种基本方法。让我们以将数组中的值加倍为例。如果我有一个数组`[1, 2, 3, 4, 5]`，想要将其“加倍”以生成数组`[2, 4, 6, 8, 10]`，我可以做两件事之一。

第一个选项是创建一个包含加倍数据的新数组，但保留原始数组不变。请看以下代码：

| ​  | `const`​ `a` = [1, 2, 3, 4, 5]; |
| --- | --- |
| ​  | `const`​ `b` = `doubleArray(a)`; |

由于`doubleArray`函数创建并返回一个全新的数组，如果我们检查`a`和`b`的值，我们会得到以下结果：

| ​  | `a`; ​*// [1, 2, 3, 4, 5]*​ |
| --- | --- |
| ​  | `b`; ​*// [2, 4, 6, 8, 10]*​ |

原始数组`a`未被修改，而`b`持有一个全新的数组。

第二个选项称为就地修改，意味着函数实际更改传入函数的原始数组。

在就地修改中，如果我们现在检查`a`和`b`，我们会发现：

| ​  | `a`; ​*// [2, 4, 6, 8, 10]*​ |
| --- | --- |
| ​  | `b`; ​*// [2, 4, 6, 8, 10]*​ |

就地函数修改了`a`，而`b`只是指向与`a`相同的数组。

我们选择创建一个新数组还是就地修改原数组取决于我们，具体要根据项目的上下文。我们将在第19章讨论更多关于就地算法的内容，参见[​*处理空间限制*​](f_0189.xhtml#chp.dealing_with_space_constraints)。

这个算法也是一个我们重复执行任务的算法。具体来说，我们重复将一个数字翻倍。我们从第一个数字开始并将其翻倍。然后我们转向第二个数字并将其翻倍——依此类推。

让我们尝试在JavaScript中编写这个算法，我们称之为`doubleArray()`。我们知道最终行将是递归调用，因此让我们包含该行：

| ​  | `function`​ `doubleArray(array)` { |
| --- | --- |
| ​  | `doubleArray(array);` |
| ​  | } |

接下来，我们需要添加实际将数字翻倍的代码。但我们要翻倍哪个数字呢？让我们尝试翻倍第一个数字：

| ​  | `function`​ `doubleArray(array)` { |
| --- | --- |
| ​  | `array[0] *= 2;` |
| ​  | `doubleArray(array);` |
| ​  | } |

好的，我们已经将索引0的数字翻倍，但我们该如何继续翻倍索引1的数字呢？

现在，如果我们使用循环而不是递归，我们将使用一个变量来跟踪索引并将其不断增加1，类似这样的方式：

| ​  | `function`​ `doubleArray(array)` { |
| --- | --- |
| ​  | `let`​ `index` = 0; |
| ​  |  |
| ​  | `while`​ (`index` < `array.length`) { |
| ​  | `array[index] *= 2;` |
| ​  | `index` += 1; |
| ​  | } |
| ​  | } |

在我们的递归版本中，唯一的函数参数是数组。我们需要某种方式来跟踪和增加索引。我们该如何实现这一点？

现在让我们看看下一个技巧…

让我们传入额外的参数！

让我们修改函数的开头，以便它接受两个参数——数组本身和一个索引来跟踪。这里是代码：

| ​  | `function`​ `doubleArray(array, index)` { |
| --- | --- |

目前，当我们调用这个函数时，需要传入数组和起始索引，这将是0：

| ​  | `doubleArray([1, 2, 3, 4, 5], 0);` |
| --- | --- |

一旦我们将索引作为函数参数，就可以在进行每次递归调用时增加和跟踪索引。这里是代码：

| ​  | `function` `doubleArray(array, index) {` |
| --- | --- |
| ​  | `array[index] *= 2;` |
| ​  | `doubleArray(array, index + 1);` |
| ​  | `}` |

在每次调用中，我们再次将数组作为第一个参数传入，但同时传递一个增加的索引。这允许我们像在经典循环中一样跟踪索引。

我们的代码现在还不完美。一旦索引超过数组的末尾并尝试乘以一个不存在的数字，我们的函数就会抛出错误。为了解决这个问题，我们需要我们的基本情况：

| ​  | `function` `doubleArray(array, index) {` |
| --- | --- |
| ​  | `// 基本情况：当索引超过数组的末尾时` |
| ​  | `if` (index >= array.length) { `return`; } |
| ​  |  |
| ​  | `array[index] *= 2;` |
| ​  | `doubleArray(array, index + 1);` |
| ​  | `}` |

我们可以用以下代码测试这个函数：

| ​  | `const` `array = [1, 2, 3, 4];` |
| --- | --- |
| ​  | `doubleArray(array, 0);` |
| ​  | `console.log(array);` |

我们的递归函数现在已完成。然而，如果我们的编程语言支持默认参数，如JavaScript所示，我们可以让事情变得更美观。

现在，我们需要像这样调用函数：

| ​  | `doubleArray([1, 2, 3, 4, 5], 0);` |
| --- | --- |

诚然，将`0`作为第二个参数传入并不美观——这只是为了实现我们保持索引的技巧。毕竟，我们总是希望从`0`开始。

然而，我们可以使用默认参数，这样就可以简单地以原来的方式调用该函数：

| ​  | `doubleArray([1, 2, 3, 4, 5]);` |
| --- | --- |

这是我们更新后的代码，以使其正常工作：

| ​  | `function` `doubleArray(array, index=0) {` |
| --- | --- |
| ​  | `// 基础案例：当索引超出数组的末尾` |
| ​  | `if` (index >= array.length) { `return`; } |
| ​  |  |
| ​  | `array[index] *= 2;` |
| ​  | `doubleArray(array, index + 1);` |
| ​  | `}` |

我们在这里更新的只是将默认参数设置为`index=0`。这样，当我们第一次调用这个函数时，就不必传入索引参数。然而，我们仍然可以在所有后续调用中使用索引参数。

使用额外函数参数的“技巧”是在编写递归函数时常用的技术，也是一个方便的方法。
