## 数组示例

在下一个示例中，我们创建一个函数，该函数从数组中提取一个小样本。我们期望有非常大的数组，因此我们的样本只是数组中的第一个、中间和最后一个值。

这是此函数的实现。看看你能否识别其在大`O`中的效率：

| ​  | `function` sample(array) { |
| --- | --- |
| ​  | `if` (array.length === 0) { `return` `null`; } |
| ​  |  |
| ​  | `const` first = array[0]; |
| ​  | `const` middle = array[Math.floor(array.length / 2)]; |
| ​  | `const` last = array[array.length - 1]; |
| ​  |  |
| ​  | `return` [first, middle, last]; |
| ​  | } |

在这种情况下，传入此函数的数组是主要数据，因此我们可以说`N`是此数组中的元素数量。

然而，我们的函数在步骤数量上与`N`无关。读取数组的开头、中点和最后索引每次都只需一步，无论数组的大小如何。同样，找出数组的长度并将其除以`2`也只需一步。

由于步骤数量是恒定的——也就是说，无论`N`是什么，它保持不变——因此此算法被视为`O(1)`。
