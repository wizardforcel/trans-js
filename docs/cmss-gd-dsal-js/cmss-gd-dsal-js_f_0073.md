## 密码破解器

你是一个黑客（当然是道德黑客），正在试图破解某人的密码。你决定采用暴力破解的方法，编写一些代码来生成给定长度的所有可能字符串。下面是你写的代码：

| ​  | `function` everyPassword(length) { |
| --- | --- |
| ​  | `let` string = `'a'`.repeat(length); |
| ​  | `console.log(string);` |
| ​  |  |
| ​  | `while` (string !== `'z'`.repeat(length)) { |
| ​  | `let` stringToBase36 = parseInt(string, 36); |
| ​  | `stringToBase36 += 1;` |
| ​  | `string = (stringToBase36.toString(36)).replace(/0/g, 'a');` |
| ​  | `console.log(string);` |
| ​  | `}` |
| ​  | `}` |

这段代码中有一些复杂的魔法，幸好我们目前不需要理解。这是因为我们不关注这段代码如何工作，而是关注这段代码的作用。

当我们调用`everyPassword`函数时，我们传入一个整数，这个整数成为变量长度。

如果长度是`3`，代码将返回范围内的所有可能字符串，介于`"aaa"`和`"zzz"`之间。运行这段代码将打印以下内容：

| ​  | `aaa` |
| --- | --- |
| ​  | `aab` |
| ​  | `aac` |
| ​  | `aad` |
| ​  | `aae` |
| ​  |  |
| ​  | ... |
| ​  |  |
| ​  | `zzx` |
| ​  | `zzy` |
| ​  | `zzz` |

如果长度是`4`，你的代码将打印所有长度为`4`的可能字符串：

| ​  | `aaaa` |
| --- | --- |
| ​  | `aaab` |
| ​  | `aaac` |
| ​  | `aaad` |
| ​  | `aaae` |
| ​  |  |
| ​  | ... |
| ​  |  |
| ​  | `zzzx` |
| ​  | `zzzy` |
| ​  | `zzzz` |

如果你尝试运行这段代码，即使长度仅为`5`，你可能需要等待一段时间才能完成。这是一个慢算法！那么我们如何用大 O 表示它呢？

让我们来分析一下。

如果我们只打印字母表中的每个字母一次，将需要`26`步。

当我们打印每个二字符组合时，我们得到了`26`个字符乘以`26`个字符。

在打印每个三字符组合时，我们得到了`26 * 26 * 26`个组合。

你看到了这个模式吗？

| 长度 | 组合 |
| --- | --- |
| 1 | `26` |
| 2 | `26²` |
| 3 | `26³` |
| 4 | `26⁴` |

如果我们从`N`的角度来看，如果`N`是每个字符串的长度，组合的数量就是`26^N`。

因此，在大 O 表示法中，我们将其表示为`O(26^N)`。这是一个极其缓慢的算法！事实上，即使是一个“仅仅是”`O(2^N)`的算法也是非常慢的。让我们看看与我们目前看到的其他算法相比，它在图表上是怎样的：

![images/big_o_in_everyday_code/different_big_os.png](images/big_o_in_everyday_code/different_big_os.png)

正如你所看到的，`O(2^N)`在某一点上甚至比`O(N³)`更慢。

从某种意义上说，`O(2^N)`正好与`O(log N)`相反。在`O(log N)`（比如二分搜索）算法中，每次数据翻倍，算法会多一步。而在`O(2^N)`算法中，每次添加一个数据元素，算法的步骤会翻倍！

在我们的密码破解器中，每次我们将`N`增加一时，步骤数会乘以`26`。这需要耗费大量时间，这也是暴力破解密码如此低效的原因。
