## 搜索

这里再次展示一个二叉搜索树：

`![images/binary_trees/bst_4.png](images/binary_trees/bst_4.png)`

在二叉搜索树中搜索的算法如下：

1.  指定一个节点作为当前节点。（在算法开始时，根节点是第一个当前节点。）

1.  检查当前节点的值。

1.  如果我们找到了我们要找的值，那就太好了！

1.  如果我们要找的值小于当前节点，则在其左子树中搜索。

1.  如果我们要找的值大于当前节点，则在其右子树中搜索。

1.  重复步骤1到5，直到我们找到所搜索的值，或者到达树的底部，在这种情况下，我们的值一定不在树中。

假设我们想搜索`61`。让我们看看需要多少步骤，通过视觉方式来走一遍。

在搜索树时，我们必须始终从根开始：

`![images/binary_trees/bst_6.png](images/binary_trees/bst_6.png)`

接下来，计算机自问：我们要搜索的数字（`61`）大于还是小于这个节点的值？如果我们要找的数字小于当前节点，则在左子节点中查找。如果大于当前节点，则在右子节点中查找。

在这个例子中，因为`61`大于`50`，我们知道它一定在右边，所以我们搜索右子节点。在下图中，我们已经遮蔽掉了所有我们排除的节点，因为我们知道`61`不可能在那些节点中：

`![images/binary_trees/bst_7.png](images/binary_trees/bst_7.png)`

“你是我的妈妈吗？”算法问道。因为`75`不是我们要找的`61`，所以我们需要下移到下一层。而且因为`61`小于`75`，我们将检查左子节点，因为`61`只可能在该子树中，如下图所示：

`![images/binary_trees/bst_8.png](images/binary_trees/bst_8.png)`

`56`不是我们要找的`61`，所以我们继续搜索。因为`61`大于`56`，我们在`56`的右子节点中搜索`61`：

`![images/binary_trees/bst_9.png](images/binary_trees/bst_9.png)`

我们找到了！在这个例子中，找我们想要的值花了四步。

### 搜索二叉搜索树的效率

如果你再看看我们刚才走过的步骤，你会注意到每一步都消除了我们搜索中剩余节点的一半。例如，当我们开始搜索时，我们从根节点开始，而我们想要的值可能在根的任何后代中。然而，当我们决定继续搜索，例如选择根的右子节点时，我们就从搜索中排除了左子节点及其所有后代。

因此，我们可以说，在二叉搜索树中的搜索是 `O(log N)`，这正是对任何在每一步中消除剩余一半值的算法的恰当描述。（不过，我们很快会看到，这仅适用于完全平衡的二叉搜索树，即最佳情况。）

### `Log(N) 层`

这里还有另一种描述为什么在二叉搜索树中的搜索是 `O(log N)` 的方式，这将揭示出二叉树的另一个特性：如果平衡二叉树中有 `N` 个节点，则大约会有 `log N` 层（即行）。

为了理解这一点，假设树中的每一行都完全填满了节点，并且没有任何空位置。如果你仔细想想，每当我们向树中添加一个新的完整层时，树的节点数量大约会翻倍。（实际上，我们是在翻倍节点并加一。）

例如，一棵具有四个完整层次的二叉树有十五个节点。（去数一数吧。）如果我们添加一个完整的第五层，这意味着我们要为第四层的八个节点各添加两个子节点。这意味着我们添加了十六个新节点，基本上将树的大小翻倍。

结果表明，每增加一层，树的大小就会翻倍。因此，包含 `N` 个节点的树将需要 `log(N)` 层来容纳所有节点。

在二叉搜索的背景下，我们注意到 `log(N)` 的模式是，在每一步搜索中，我们可以消除剩余数据的一半。二叉树所需的层数也遵循这一模式。

假设我们有一棵需要容纳三十一节点的二叉树。在第五层，我们可以容纳十六个节点。这大约处理了数据的一半，剩下我们仍需要为十五个节点找位置。在第四层，我们处理了八个节点，还剩下七个未被计算。在第三层，我们处理了四个节点，依此类推。

确实，`log 31` 大约是 5。因此我们得出结论，具有 `N` 个节点的平衡树将有 `log(N)` 层。

既然如此，理解为什么搜索二叉搜索树需要多达 `log(N)` 步骤是非常合理的：因为每一步搜索都会让我们向下移动一层，我们最多需要与树中的层数相等的步骤。

无论你怎么理解，搜索一棵二叉搜索树的时间复杂度是 `O(log N)`。

现在，虽然在二叉搜索树中的搜索是 `O(log N)`，但在有序数组中的二分搜索也是如此，其中我们选择的每个数字也会消除剩余可能值的一半。因此，从这个角度来看，搜索二叉搜索树的效率与在有序数组中进行二分搜索相同。

二叉搜索树真正超越有序数组的地方在于插入。我们很快就会讨论到这一点。

### 代码实现：搜索二叉搜索树

要实现搜索操作，以及其他二叉搜索树操作，我们将大量使用递归。你在第10章中学习过，[`*递归回溯*`](f_0096.xhtml#chp.recursion)，递归是处理具有任意深度的数据结构时的关键。树就是这样一种数据结构，因为它可以有无限多个层级。

这是我们如何使用递归在JavaScript中实现搜索。虽然我们可以选择使用循环来替代，但搜索的递归代码更简洁优雅：

| ​  | `function` search(`searchValue`, node) { |
| --- | --- |
| ​  | `if` (!node ` | | ` node.value === `searchValue`) { |
| ​  | `return` node; |
| ​  | } |
| ​  |  |
| ​  | `if` (`searchValue` < node.value) { |
| ​  | `return` search(`searchValue`, node.`leftChild`); |
| ​  | } `else` { |
| ​  | `return` search(`searchValue`, node.`rightChild`); |
| ​  | } |
| ​  | } |

这个搜索函数接受我们要查找的`searchValue`和一个将作为搜索基点的节点。第一次调用`search`时，节点将是根节点。然而，在后续的递归调用中，节点可能是树中的另一个节点。

我们的函数处理四种可能的情况，其中两种是基准情况：

| ​  | `if` (!node ` | | ` node.value === `searchValue`) { |
| --- | --- | --- | --- |
| ​  | `return` node; |
| ​  | } |

一个基准情况是当节点包含我们要查找的`searchValue`时，此时我们可以返回该节点，而不进行任何递归调用。

另一个基准情况是当没有节点时。这在我们检查其他情况后会更有意义，因此让我们稍后再回到这一点。

下一个情况是当`searchValue`小于当前节点的值时：

| ​  | `if` (`searchValue` < node.value) { |
| --- | --- |
| ​  | `return` search(`searchValue`, node.`leftChild`); |
| ​  | } |

在这种情况下，我们知道如果它存在于树中，`searchValue`一定会在该节点的左侧后裔中找到。因此，我们在该节点的左子节点上递归调用`search`函数。

下一个情况是反向；当`searchValue`大于当前节点时：

| ​  | `else` { |
| --- | --- |
| ​  | `return` search(`searchValue`, node.`rightChild`); |
| ​  | } |

在这种情况下，我们递归调用`search`在当前节点的右子节点上。

现在，当我们在当前节点的子节点上进行这些递归调用时，请注意我们并没有检查当前节点是否有任何子节点。这就是第一个基准情况出现的地方：

| ​  | `if` (!node ... |
| --- | --- |

也就是说，如果我们在一个实际上并不存在的子节点上调用了`search`，我们最终会返回`null`（因为`node`变量实际上会包含`null`）。如果`searchValue`在我们的树中不存在，这种情况就会发生，因为我们会试图访问应该找到`searchValue`的`node`，但我们的搜索碰到了死胡同。在这种情况下，返回`null`是合适的，表示`searchValue`不在树中。
