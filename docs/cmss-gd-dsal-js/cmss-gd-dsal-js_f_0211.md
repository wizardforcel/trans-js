## 第6章

这些是该节中找到的练习的解决方案，参见[​`练习`​](f_0063.xhtml#optimizing.for.optimistic.scenarios.exercises)。

1.  在`Big O`符号中，`2N² + 2N + 1`被简化为`O(N²)`。去掉所有常数后，我们留下`N² + N`，但我们也丢掉`N`，因为它的阶数低于`N²`。

1.  由于`log N`的阶数低于`N`，所以它简化为`O(N)`。

1.  这里需要注意的重要一点是，一旦我们找到一对和为`10`的数字，函数就会立即结束。那么，最佳情况是前两个数字相加等于`10`，因为我们可以在循环开始之前结束函数。平均情况下，可能是两个数字在数组的中间。最坏情况下则是没有任何两个数字相加等于`10`，在这种情况下，我们必须完全耗尽两个循环。这个最坏情况是`O(N²)`，其中`N`是数组的大小。

1.  该算法的效率为`O(N)`，因为数组的大小为`N`，循环遍历所有`N`个元素。

    该算法即使在数组末尾之前找到“X”也会继续循环。如果我们在找到“X”后立即返回`true`，可以使代码更高效：

    | ​  | `function containsX(string) {` |
    | --- | --- |
    | ​  | `for (const char of string) {` |
    | ​  | `if (char === 'X') { return true; }` |
    | ​  | } |
    | ​  |  |
    | ​  | `return false;` |
    | ​  | } |
