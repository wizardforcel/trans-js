## 识别模式

对于代码优化和算法开发而言，最有用的策略之一是发现当前问题中的模式。通常，发现一个模式可以帮助你突破问题的复杂性，并开发出简单的算法。

### 硬币游戏

这是一个很好的例子。我称之为“硬币游戏”的游戏有两个玩家，他们以以下方式竞争：他们从一堆硬币开始，每个玩家可以选择从堆中移走一个或两个硬币。拿走最后一个硬币的玩家会输。好玩吧？

事实证明，这并不是一场随机机会的游戏，凭借正确的策略，你可以迫使对手拿走最后一个硬币并输掉游戏。为了让这一点更清晰，我们从一些非常小的硬币堆开始，看看游戏是如何进行的。

如果堆中只剩下一个硬币，轮到的玩家就会输，因为他们别无选择，只能拿走最后一个硬币。

如果剩下两个硬币，轮到的玩家可以强制获胜。这是因为他们可以只拿走一个硬币，从而迫使对手拿走最后一个硬币。

当剩下三个硬币时，轮到的玩家也可以强制获胜，因为他们可以移走两个硬币，迫使对手拿走最后一个硬币。

现在，当剩下四个硬币时，当前玩家陷入困境。如果他们移走一个硬币，对手将得到三枚硬币，而我们之前已经确定，拥有这三枚硬币的玩家可以强制获胜。类似地，如果当前玩家移走两个硬币，剩下两个硬币的对手同样可以强制获胜。

如果我们要编写一个函数，计算在给定大小的硬币堆中你是否可以赢得游戏，我们应该采取什么方法？仔细考虑后，我们可能会意识到可以利用子问题来帮助计算任何数量硬币的准确结果。这使得自顶向下的递归非常适合解决这个问题。

这里有一个递归方法的 JavaScript 实现：

| ​  | ​`function` gameWinner(numberOfCoins, currentPlayer=`*'你'*`) { |
| --- | --- |
| ​  | ​`let` nextPlayer; |
| ​  |  |
| ​  | ​`if` (numberOfCoins <= 0) { |
| ​  | ​`return` currentPlayer; |
| ​  | } |
| ​  |  |
| ​  | ​`if` (currentPlayer === `*'你'*`) { |
| ​  | nextPlayer = `*'他们'*`; |
| ​  | } `else` `if` (currentPlayer === `*'他们'*`) { |
| ​  | nextPlayer = `*'你'*`; |
| ​  | } |
| ​  |  |
| ​  | ​`if` (gameWinner(numberOfCoins - 1, nextPlayer) === currentPlayer |
| ​  | ` | | ` gameWinner(numberOfCoins - 2, nextPlayer) === currentPlayer) { |
| ​  | ​`return` currentPlayer; |
| ​  | } `else` { |
| ​  | ​`return` nextPlayer; |
| ​  | } |
| ​  | } |

这个`gameWinner`函数接受一个硬币数量和当前玩家（“你”或“他们”）。然后该函数返回“你”或“他们”作为游戏的赢家。当函数第一次被调用时，`currentPlayer`是“你”。

我们将基本情况定义为`currentPlayer`被分配到0个或更少的硬币。这意味着其他玩家拿走了最后一枚硬币，而当前玩家默认赢得了游戏。

然后我们定义一个`nextPlayer`变量，它跟踪下一个将要进行游戏的玩家。

然后我们进行递归。我们递归调用我们的`gameWinner`函数，在当前堆的硬币数量比当前堆小1和2的硬币堆上，看看下一个玩家在这些场景中会赢还是输。如果`nextPlayer`在这两种情况下都输，那么`currentPlayer`就会赢。

这不是一个简单的算法，但我们做到了。现在让我们看看能否优化它。

为了满足我们的前提条件，我们首先需要弄清楚我们算法的当前速度。

你可能已经注意到这个函数进行了多次递归调用。如果你脑海中响起了警报，那是有充分理由的。这个函数的时间复杂度高达`O(2^N)`，这可能是令人难以忍受的慢。

我们可以通过使用你在第12章中学到的记忆化技术来改进这一点，`[*动态规划*](f_0112.xhtml#chp.dynamic_programming)`，这可以将速度提高到`O(N)`，其中`N`是起始堆中的硬币数量。这是一个巨大的改进。

但让我们看看是否可以进一步提升算法的速度。

要确定我们是否可以进一步优化我们的算法，我们需要问自己认为最佳的 Big O 是什么。

因为`N`只是一个单一的数字，我可以设想我们可以设计一个仅需`O(1)`时间的算法。由于我们实际上不需要处理`N`个项目在数组中或其他任何事情，如果有人告诉我他们为硬币游戏找到了一个仅需`O(1)`的算法，我会相信他们。所以让我们争取达到`O(1)`。

但是我们怎么能做到这一点呢？这就是找到模式可以提供帮助的地方。

### 生成示例

虽然每个问题都有独特的模式，但我发现了一种找到模式的技巧，这对所有问题都有帮助，那就是生成大量示例。这意味着我们应该取一些示例输入，计算它们各自的输出，看看是否能检测到一个模式。

让我们把这个应用到我们的案例中。

如果我们绘制出硬币堆大小为1到10时谁赢的情况，我们会得到这个表：

| 硬币数量 | 胜利者 |
| --- | --- |
| 1 | 他们 |
| 2 | 你 |
| 3 | 你 |
| 4 | 他们 |
| 5 | 你 |
| 6 | 你 |
| 7 | 他们 |
| 8 | 你 |
| 9 | 你 |
| 10 | 他们 |

当我们以这种方式列出时，模式变得清晰。基本上，从1个硬币开始，每第三个数字会让对手胜利。否则，你就是赢家。

所以如果我们取硬币的数量并减去`1`，每个`"他们"`都会落在一个可被`3`整除的数字上。此时，我们可以根据一次简单的除法计算确定谁将获胜：

| ​  | `function` gameWinner(`numberOfCoins`) { |
| --- | --- |
| ​  | `if` ((`numberOfCoins` - `1`) % `3` === `0`) { |
| ​  | `return`​ `'他们'`; |
| ​  | } `else` { |
| ​  | `return`​ `'你'`; |
| ​  | } |
| ​  | } |

这段代码的意思是，如果在减去`1`之后，`numberOfCoins`能被`3`整除，赢家就是`"他们"`。否则，`"你"`就是赢家。

由于这个算法只包含一个数学操作，它在时间和空间上都是`O(1)`。它也简单得多！这是一个真正的双赢。

通过生成许多硬币堆（作为输入）并查看谁将赢得比赛（作为输出），我们能够识别出硬币游戏的工作模式。然后我们能够利用这个模式深入问题的核心，将一个缓慢的算法变为瞬时的。

### 和交换问题

这是一个我们可以结合模式识别和神奇查找来优化算法的例子。

下一个问题，称为和交换问题，描述如下：

我们想要编写一个接受两个整数数组的`function`。举个例子，假设这些就是我们的数组：

![images/tips_for_code_optimization/two_arrays.png](images/tips_for_code_optimization/two_arrays.png)

当前，`array1`中的数字加起来为`20`，而`array2`中的数字加起来为`18`。

我们的`function`需要找到来自每个数组的一个数字，交换后使两个数组的和相等。

在这个例子中，如果我们交换`array1`中的`2`和`array2`中的`1`，我们将得到：

![images/tips_for_code_optimization/swap_2_and_1.png](images/tips_for_code_optimization/swap_2_and_1.png)

这样，两者的和现在将相同——即`19`。

为了简单起见，我们的`function`实际上不会执行交换，而是返回我们需要交换的两个索引。我们可以用一个包含这两个索引的数组来实现。因此，在这种情况下，我们将`array1`的索引`2`与`array2`的索引`0`交换，所以我们将返回一个数组`[2, 0]`。如果没有可能的交换使得两个数组相等，我们将返回`null`。

我们可以通过使用嵌套循环来编写这个算法；也就是说，当我们的外部循环指向`array1`中的每个数字时，内部循环可以遍历`array2`中的每个数字，并测试如果我们交换这两个数字，两个数组的和是否相等。

要开始优化这一点，我们必须首先满足知道我们当前算法的Big O的前提条件。

由于我们的嵌套循环方法对于第一个数组的每个`N`个数字都会访问第二个数组的`M`个数字，因此这个算法的复杂度是`O(N * M)`。（我之所以提到`N`和`M`，是因为这两个数组可能大小不同。）

我们能做得更好吗？为了找出答案，让我们确定我们认为的最佳可能Big O。

看起来我们绝对需要至少访问两个数组中的每个数字一次，因为我们需要了解所有数字。但这可能是我们需要做的全部。如果是这样的话，这将是`O(N + M)`。让我们将其视为我们最理想的Big O，并朝这个目标努力。

接下来，我们需要尝试挖掘问题中隐藏的任何模式。同样，挖掘模式的最佳技术是提出多个示例并寻找它们之间的模式。

因此，让我们看看几个不同的示例，交换数字将导致两个数组具有相等的和，如[`图示`](#fig.ch20.multiple_swap_examples)所示。

![`images/tips_for_code_optimization/multiple_swap_examples.png`](images/tips_for_code_optimization/multiple_swap_examples.png)

在查看这些示例时，一些模式开始显现。有些模式可能看起来很明显，但我们还是来看看它们。

一个模式是，为了实现相等的和，较大的数组需要用一个较大的数字与较小数组中的较小数字进行交换。

第二个模式是，通过单次交换，每个数组的和变化量是相同的。例如，当我们用一个`7`与一个`4`交换时，一个数组的和减少`3`，而另一个数组的和增加`3`。

第三个有趣的模式是，交换总是使两个数组的和恰好落在它们开始时的和的中间。

在第一个例子中，`array1`是`18`而`array2`是`12`。当进行正确的交换时，两个数组的和达到了`15`，正好是`18`和`12`之间的中间。

当我们进一步思考时，这第三种模式是其他模式的逻辑延伸。由于交换会使两个数组的和同样变化，因此使它们的和相等的唯一方法是相遇于中间。

基于此，如果我们知道两个数组的和，我们应该能够查看其中一个数组的任何数字并计算它应该与哪个数字交换。

让我们再次考虑这个例子：

![`images/tips_for_code_optimization/second_example.png`](images/tips_for_code_optimization/second_example.png)

我们知道，要使交换成功，两个数组的和需要落在中间。`18`和`12`之间的确切中间是`15`。

让我们查看`array1`中的不同数字，找出我们想与其交换的数字。我们可以称这个数字为其对应数字。让我们从`array1`中的第一个数字开始，即数字`5`。

我们想用哪个数字来与`5`交换呢？我们知道`array1`需要减少`3`，而`array2`需要增加`3`，所以我们需要将`5`与一个`2`交换。恰好`array2`中不包含`2`，因此`5`无法成功与`array2`中的任何数字交换。

如果我们查看`array1`中的下一个数字，它是一个`3`。我们必须将其与`array2`中的`0`交换，以使两个和相等。可惜，`array2`中不存在`0`。

`array1`中的最后一个数字是7。我们可以计算出我们想用4交换7，以使两个和都为15。幸运的是，`array2`中确实包含4，因此我们可以成功交换。

那么，我们如何在代码中表达这种模式呢？

好吧，我们可以首先使用这个计算来确定数组和需要移动多少：

| ​  | `shiftAmount = Math.floor((sum1 - sum2) / 2);` |
| --- | --- |

在这里，`sum1`是`array1`的和，而`sum2`是`array2`的和。如果`sum1`是18而`sum2`是12，我们得到的差是6。然后我们将其除以2以确定每个数组需要移动多少。这就是`shiftAmount`。

在这种情况下，`shiftAmount`是3，这意味着`array2`需要增加3以达到目标和。（同样，`array1`需要减少3。）

所以我们可以通过首先计算两个数组的和来开始构建我们的算法。然后我们可以循环遍历其中一个数组的所有数字，并在另一个数组中寻找对应的数字。

如果我们迭代`array2`中的每个数字，例如，我们知道当前数字必须与其对应的数字交换，该数字是当前数字加上`shiftAmount`。例如，如果当前数字是4，寻找其对应数字时我们加上`shiftAmount`（3），得到7。这意味着我们需要在`array1`中找到一个7来与当前数字交换。

所以，我们已经弄清楚，我们可以查看任一数组中的任何数字，并确切知道它在另一个数组中应该是什么对应数字。但这有什么帮助呢？难道我们仍然需要使用嵌套循环，使算法的复杂度为O(N * M)吗？这意味着对于一个数组中的每个数字，我们必须在整个另一个数组中搜索对应的数字。

这是我们可以调用神奇查找的地方，问自己：“如果我能以O(1)的时间神奇地找到所需的信息，我能让我的算法更快吗？”

确实，如果我们能以O(1)的时间找到一个数字在另一个数组中的对应数字，我们的算法会快得多。我们可以通过采用通常的方法，即引入我们的老朋友哈希表来实现快速查找。

如果我们首先将一个数组中的数字存储在哈希表中，那么在遍历另一个数组时，我们可以立即以O(1)的时间找到任何数字。

这是完整的代码：

| ​  | `function`​ `sumSwap(array1, array2) {` |
| --- | --- |
| ​  | `const`​ `hashTable = {};` |
| ​  | `let`​ `sum1 = 0;` |
| ​  | `let`​ `sum2 = 0;` |
| ​  |  |
| ​  | `for`​ (`const`​ `[index, num]` ​`of`​ `array1.entries()) {` |
| ​  | `sum1 += num;` |
| ​  | `hashTable[num] = index;` |
| ​  | `}` |
| ​  |  |
| ​  | `for`​ (`const`​ `num` ​`of`​ `array2) {` |
| ​  | `sum2 += num;` |
| ​  | `}` |
| ​  |  |
| ​  | `// 如果输入由整数构成且差值`​ |
| ​  | `// 两个和之间是奇数，因此不可能找到`​ |
| ​  | `// 一个正好在中间的整数，因此不可能进行交换：`​ |
| ​  | `if`​ (`Math.abs((sum1 - sum2) % 2) === 1) {` |
| ​  | `return`​ `null`; |
| ​  | `}` |
| ​  |  |
| ​  | `const`​ `shiftAmount` = `Math.floor((sum1 - sum2) / 2);` |
| ​  |  |
| ​  | `for` (`const` [`index, num`] `of` `array2.entries()`) { |
| ​  | `if`(`hashTable[num + shiftAmount]` &#124;&#124; `hashTable[num + shiftAmount] === 0`) { |
| ​  | `return`​[`hashTable[num + shiftAmount], index]; |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `return` `null`; |
| ​  | } |

这种方法比我们原来的`O(N * M)`方法快得多。如果我们认为`array1`为`N`，`array2`为`M`，我们可以说这个算法在`O(N + M)`时间内运行。虽然我们确实遍历`array2`两次，技术上是`2M`，但由于我们忽略常数，它变为`M`。

这种方法占用额外的`O(N)`空间，因为我们将数组`array1`中的所有`N`个数字复制到哈希表中。再次强调，我们牺牲了空间来获得时间，但如果速度是我们的主要关注点，这是一项巨大的胜利。

无论如何，这是另一个例子，展示了发现模式如何让我们直击问题核心，并开发出简单快速的解决方案。
