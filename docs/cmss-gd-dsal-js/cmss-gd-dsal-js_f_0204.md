## 练习

以下练习为你提供了优化代码的机会。这些练习的解决方案可以在章节`[​第20章](f_0225.xhtml#tips.for.code.optimization.solutions)`中找到。

1.  你正在开发分析运动员的软件。以下是两个不同运动的玩家数组：

    | ​  | `const basketballPlayers = [` |
    | --- | --- |
    | ​  | `{ firstName: 'Jill', lastName: 'Huang', team: 'Gators' },` |
    | ​  | `{ firstName: 'Janko', lastName: 'Barton', team: 'Sharks' },` |
    | ​  | `{ firstName: 'Wanda', lastName: 'Vakulskas', team: 'Sharks' },` |
    | ​  | `{ firstName: 'Jill', lastName: 'Moloney', team: 'Gators' },` |
    | ​  | `{ firstName: 'Luuk', lastName: 'Watkins', team: 'Gators' },` |
    | ​  | `];` |
    | ​  |  |
    | ​  | `const footballPlayers = [` |
    | ​  | `{ firstName: 'Hanzla', lastName: 'Radosti', team: '32ers' },` |
    | ​  | `{ firstName: 'Tina', lastName: 'Watkins', team: 'Barleycorns' },` |
    | ​  | `{ firstName: 'Alex', lastName: 'Patel', team: '32ers' },` |
    | ​  | `{ firstName: 'Jill', lastName: 'Huang', team: 'Barleycorns' },` |
    | ​  | `{ firstName: 'Wanda', lastName: 'Vakulskas', team: 'Barleycorns' },` |
    | ​  | `];` |

    如果仔细观察，你会发现有些玩家参与了多种运动。`Jill Huang`和`Wanda Vakulskas`都参与了篮球和足球。

    你需要编写一个函数，接受两个玩家数组，并返回同时参与两项运动的玩家数组。在这种情况下，结果将是以下内容：

    | ​  | `["Jill Huang", "Wanda Vakulskas"]` |
    | --- | --- |

    尽管有些玩家的名字和姓氏相同，但我们可以假设只有一个人拥有特定的全名（即名字和姓氏）。

    我们可以使用嵌套循环的方法，将一个数组中的每个玩家与另一个数组中的每个玩家进行比较，但这将导致运行时间为`O(N * M)`。你的任务是优化函数，使其只需运行`O(N + M)`。

1.  你正在编写一个函数，该函数接受一个从`0`、`1`、`2`、`3`……直到`N`的不同整数数组。然而，该数组会缺少一个整数，你的函数需要返回缺失的那个。

    例如，这个数组包含从`0`到`6`的所有整数，但缺少`4`：

    | ​  | `[2, 3, 0, 6, 1, 5]` |
    | --- | --- |

    因此，函数应该返回`4`。

    下一个例子包含从`0`到`9`的所有整数，但缺少`1`：

    | ​  | `[8, 2, 3, 9, 4, 7, 5, 0, 6]` |
    | --- | --- |

    在这种情况下，函数应该返回`1`。

    使用嵌套循环的方法将消耗`O(N²)`的时间。你的任务是优化代码，使其运行时间为`O(N)`。

1.  你正在开发一些股票预测软件。你编写的函数接受一个数组，该数组表示某种股票随时间变化的预测价格。

    例如，看看这个包含七个价格的数组：

    | ​  | `[10, 7, 5, 8, 11, 2, 6]` |
    | --- | --- |

    它预测某只股票在接下来的七天内将有这些价格。（在第`1`天，股票收盘价为`$10`；在第`2`天，股票收盘价为`$7`；依此类推。）

    你的函数应该计算出从一次“买入”交易后紧接着进行一次“卖出”交易所能获得的最大利润。

    在这个例子中，如果我们在股票价值为`$5`时买入，并在其价值为`$11`时卖出，将能赚取最多的钱。这每股带来的利润为`$6`。

    请注意，如果我们多次买入和卖出，我们可能会赚到更多的钱，但目前这个函数专注于从一次购买后进行一次销售所能获得的最大利润。

    现在，我们可以使用嵌套循环来找到每个可能的买入和卖出组合的利润。然而，这将是O(N²)，对我们的高效交易平台来说太慢。你的任务是优化代码，使函数的时间复杂度仅为O(N)。

1.  你正在编写一个接受数字数组并计算数组中任意两个数字的最高乘积的函数。乍一看这很简单，因为我们只需找到两个最大的数字并将它们相乘。然而，我们的数组可能包含负数，可能看起来像这样：

    | ​  | `[5, -10, -6, 9, 4]` |
    | --- | --- |

    在这种情况下，实际上是两个最低数字`-10`和`-6`的乘积产生了最高的乘积`60`。

    我们可以使用嵌套循环来计算每一对可能的数字乘积，但这将需要O(N²)的时间。你的任务是优化这个函数，使其达到快速的O(N)。

1.  你正在创建一款软件，分析来自数百人身体温度读数的数据。这些读数来自健康和生病的人，范围从95到105华氏度。

    这里有一组温度读数的示例数组：

    | ​  | `[98, 99, 95, 105, 104, 98, 101, 99, 100, 97]` |
    | --- | --- |

    你需要编写一个函数，将这些读数从最低到最高进行排序。

    如果你使用经典的排序算法，比如`快速排序`，这将需要O(N log N)。然而，在这种情况下，可以编写一个更快的排序算法。

    是的，没错。尽管你已经了解到最快的排序算法是O(N log N)，但这个案例不同。为什么？在这种情况下，温度读数的可能性是有限的。在这种情况下，我们可以在O(N)的时间内对这些值进行排序。可能是N乘以一个常数，但这仍然被视为O(N)。

1.  你正在编写一个接受无序整数数组并返回其中最长连续序列长度的函数。该序列由逐渐增加1的整数构成。例如，看看这个数组：

    | ​  | `[10, 5, 12, 3, 55, 30, 4, 11, 2]` |
    | --- | --- |

    最长的连续序列是`2-3-4-5`。这四个整数形成了一个递增序列，因为每个整数都比前一个大1。虽然还有一个`10-11-12`的序列，但它只有三个整数。在这种情况下，函数应该返回`4`，因为这是从该数组中可以形成的最长连续序列的长度。

    这里还有一个例子：

    | ​  | `[19, 13, 15, 12, 18, 14, 17, 11]` |
    | --- | --- |

    这个数组的最长序列是`11-12-13-14-15`，所以该函数会返回`5`。

    如果我们对数组进行排序，那么我们可以仅遍历一次数组来找到最长的连续序列。然而，排序本身需要`O(N log N)`的时间。你的任务是优化该函数，使其只需`O(N)`的时间。

版权所有 © 2024, The Pragmatic Bookshelf。
