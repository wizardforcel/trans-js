## 递归类别：计算

在前面的部分，我们讨论了第一类递归函数——那些反复执行任务的函数。在本章的其余部分，我将详细阐述第二类一般类别：基于子问题执行计算。

许多函数的目标是执行计算。返回两个数字之和的函数，或在数组中找到最大值的函数，都是例子。这些函数接收某种输入并返回涉及该输入的计算结果。

在第10章，[`Recursively Recurse with Recursion`](f_0096.xhtml#chp.recursion)，我们发现递归特别擅长处理具有任意深度层级的问题。递归的第二个优势是能够基于手头问题的子问题进行计算。

在我定义什么是子问题之前，让我们回顾一下前一章的阶乘问题。如你所学到的，6的阶乘如下：

`6 * 5 * 4 * 3 * 2 * 1`

要编写一个计算数字阶乘的函数，我们可以使用一个经典的循环，从1开始并逐步构建。也就是说，我们将2乘以1，然后将3乘以结果，然后是4，依此类推，直到达到6。

这样的函数可能看起来像这样：

| ​  | `function` factorial(n) { |
| --- | --- |
| ​  | `let` product = 1; |
| ​  |  |
| ​  | `for` (`let` num = 1; num <= n; num += 1) { |
| ​  | product *= num; |
| ​  | } |
| ​  |  |
| ​  | `return` product; |
| ​  | } |

然而，我们可以以不同的方式处理这个问题：我们可以基于其子问题计算阶乘。

子问题是应用于较小输入的同一问题的版本。让我们将此应用于我们的情况。

如果你考虑一下，`factorial(6)`将是6乘以`factorial(5)`的结果。

因为`factorial(6)`是：

`6 * 5 * 4 * 3 * 2 * 1`

而`factorial(5)`是：

`5 * 4 * 3 * 2 * 1`

我们可以得出`factorial(6)`等价于：

`6 * factorial(5)`。

也就是说，一旦我们得到了`factorial(5)`的结果，我们可以简单地将该结果乘以6来得到`factorial(6)`的答案。

由于`factorial(5)`是可以用来计算更大问题的较小问题，因此我们称`factorial(5)`为`factorial(6)`的子问题。

这是上一章的实现：

| ​  | `function` factorial(number) { |
| --- | --- |
| ​  | `if` (number <= 1) { |
| ​  | `return` 1; |
| ​  | } `else` { |
| ​  | `return` number * factorial(number - 1); |
| ​  | } |
| ​  | } |

这里的关键行是`return number * factorial(number - 1)`，其中我们将结果计算为`number`乘以我们的子问题，即`factorial(number - 1)`。

### 计算的两种方法

我们已经看到，在编写一个进行计算的函数时，有两种潜在的方法：我们可以尝试从“底向上”构建解决方案，或者我们可以通过基于问题的子问题进行计算，从“顶向下”攻击问题。实际上，计算机科学文献中将底向上和顶向下的术语用来描述递归策略。

事实是，这两种方法都可以通过递归实现。我们之前看到的底向上方法使用了经典的循环；我们也可以使用递归来实现底向上策略。

为此，我们需要利用传递额外参数的技巧，如下所示：

| ​  | `function` factorial(n, i=1, product=1) { |
| --- | --- |
| ​  | `if` (i > n) { `return` product; } |
| ​  |  |
| ​  | `return` factorial(n, i + 1, product * i); |
| ​  | } |

在这个实现中，我们有三个参数。`n`，如之前所述，是我们正在计算阶乘的数字。`i`是一个简单的变量，从1开始，在每次调用时增加1，直到达到`n`。最后，`product`是我们存储计算结果的变量，在此过程中不断乘以每一个后续数字。我们不断将`product`传递给后续的调用，以便在过程中跟踪它。

虽然我们可以使用递归以这种方式实现底向上方法，但这并不特别优雅，并且在使用经典的`loop`时并没有增加太多价值。

当我们从底向上进行计算时，我们无论是使用循环还是递归，所采用的策略是相同的。计算方法是一样的。

但是要采用自上而下的方法，我们需要递归。因为递归是实现自上而下策略的唯一方法，所以它是使递归成为强大工具的关键因素之一。
