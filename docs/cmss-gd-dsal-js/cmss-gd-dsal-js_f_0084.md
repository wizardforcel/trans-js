## 哈希表的速度

虽然哈希表非常适合配对数据，但它们也可以用于加速你的代码——即使你的数据并不是成对存在的。这就是事情变得令人兴奋的地方。

这是一个简单的数组：

| ​  | `const array = [61, 30, 91, 11, 54, 38, 72];` |
| --- | --- |

如果你想在这个数组中查找一个数字，需要多少步？

因为数组是无序的，你必须执行线性搜索，这需要`N`步——你在书的开头就学过这个。

不过，如果我们运行一些代码将这些数字转换为看起来像这样的哈希表，会发生什么呢？

| ​  | `const` hashTable = {61: `true`, 30: `true`, 91: `true`, |
| --- | --- |
| ​  | 11: `true`, 54: `true`, 38: `true`, 72: `true`} |

在这里，我们将每个数字存储为一个键，并为每个数字分配布尔值`true`作为关联值。

现在，如果我让你在这个哈希表中搜索某个数字作为键，这需要多少步？

好吧，我可以使用这个简单的代码：

| ​  | `hashTable[72]` |
| --- | --- |

我可以在一步内查找数字`72`。

换句话说，通过使用`72`作为键进行哈希表查找，我可以在一步内确定`72`是否存在于哈希表中。推理非常简单：如果`72`是哈希表中的一个键，我会得到`true`，因为`72`的值是`true`。另一方面，如果`72`不是哈希表中的一个键，我会得到`undefined`。

由于进行哈希表查找只需要一步，因此我可以在一步之内找到哈希表中的任何数字（作为键）。

你能看到其中的魔力吗？

通过这种方式将数组转换为哈希表，我们可以将查找从`O(N)`降低到`O(1)`。

使用哈希表的方式非常有趣。尽管哈希表通常用于自然配对的数据，但我们这里的数据并不是配对的。我们只关心单个数字的列表。

虽然我们确实为每个键分配了一个值，但值是什么并不重要。我们为每个键使用了`true`作为值，但任何任意值（即“真实”值）都能达到相同的效果。

这里的窍门是通过将每个数字作为键放入哈希表，我们可以在后续步骤中以一步之内查找这些键。如果我们的查找返回任何值，则表示该键本身必定存在于哈希表中。如果返回`undefined`，那么该键一定不在哈希表中。

我将以这种方式使用哈希表称为“将其作为索引使用”。（这是我自己的术语。）书籍末尾的索引告诉你某个主题是否可以在书中找到，而不是让你翻遍所有页面来寻找。同样，我们创建哈希表作为一种索引；在我们的例子中，它是一个告诉我们某个特定项是否包含在原始数组中的索引。

让我们使用这种技术来提升一个非常实用的算法的速度。

### 数组子集

假设我们需要确定一个数组是否是另一个数组的子集。以这两个数组为例：

| ​  | [`"a"`, `"b"`, `"c"`, `"d"`, `"e"`, `"f"`] |
| --- | --- |
| ​  | [`"b"`, `"d"`, `"f"`] |

第二个数组`["b", "d", "f"]`是第一个数组`["a", "b", "c", "d", "e", "f"]`的子集，因为第二个数组的每个值都包含在第一个数组中。

不过，假设我们的数组是这样的：

| ​  | [`"a"`, `"b"`, `"c"`, `"d"`, `"e"`, `"f"`] |
| --- | --- |
| ​  | [`"b"`, `"d"`, `"f"`, `"h"`] |

第二个数组不是第一个数组的子集，因为第二个数组包含值`"h"`，而这个值在第一个数组中不存在。

如何编写一个比较两个数组的函数，以便告知我们一个数组是否是另一个数组的子集？

我们可以通过使用嵌套循环来实现这一点。本质上，我们将遍历较小数组的每个元素，并对较小数组中的每个元素开始第二个循环，遍历较大数组的每个元素。如果我们发现较小数组中的某个元素不在较大数组中，则我们的函数将返回`false`。如果代码通过了循环，意味着它从未遇到较小数组中不在较大数组中的值，因此返回`true`。

这里是这个方法的 JavaScript 实现：

| ​  | `function` isSubset(array1, array2) { |
| --- | --- |
| ​  | `let` foundMatch; |
| ​  | `let` largerArray; |
| ​  | `let` smallerArray; |
| ​  |  |
| ​  | `// 确定哪个数组较小：` |
| ​  | `if` (array1.length > array2.length) { |
| ​  | largerArray = array1; |
| ​  | smallerArray = array2; |
| ​  | } `else` { |
| ​  | largerArray = array2; |
| ​  | smallerArray = array1; |
| ​  | } |
| ​  |  |
| ​  | `// 遍历较小数组：` |
| ​  | `for` ( `const` i `of` smallerArray) { |
| ​  | `// 暂时假设当前值来自` |
| ​  | `// 较小的数组在较大的数组中未找到：` |
| ​  | foundMatch = `false`; |
| ​  |  |
| ​  | `// 对于较小数组中的每个值，遍历` |
| ​  | `// 较大数组：` |
| ​  | `for` ( `const` j `of` largerArray) { |
| ​  | `// 如果这两个值相等，意味着当前` |
| ​  | `// 较小数组中的值在较大数组中存在：` |
| ​  | `if` (i === j) { |
| ​  | foundMatch = `true`; |
| ​  | `break`; |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `// 如果当前值在较小数组中不存在` |
| ​  | `// 在较大数组中，返回 false：` |
| ​  | `if` (!foundMatch) { `return` `false`; } |
| ​  | } |
| ​  | `// 如果我们到达循环的末尾，意味着所有` |
| ​  | `// 较小数组中的值存在于较大数组中：` |
| ​  | `return` `true`; |
| ​  | } |

当我们分析这个算法的效率时，我们发现它是 O(N * M)，因为它的运行次数是第一个数组中的项数乘以第二个数组中的项数。

现在，让我们利用哈希表的力量，显著提高我们算法的效率。让我们抛弃最初的方法，从头开始。

在我们新的方法中，在确定哪个数组更大、哪个更小之后，我们将运行一个单独的循环遍历`largerArray`，并将每个值存储在一个哈希表中：

| ​  | ​`const`​ `hashTable` = {}; |
| --- | --- |
| ​  |  |
| ​  | ​`for`​ (​`const`​ `value` ​`of`​ `largerArray`) { |
| ​  | `hashTable`[`value`] = ​`true`​; |
| ​  | } |

在这个代码片段中，我们在`hashTable`变量内创建了一个空的哈希表。然后我们迭代`largerArray`中的每个值，并将数组中的项添加到哈希表中。我们将项本身作为键，`true`作为值。

对于早期的示例`["a", "b", "c", "d", "e", "f"]`，一旦我们将其通过这个循环处理后，得到的哈希表看起来是这样的：

| ​  | {​*"a"*​: ​`true`​, ​*"b"*​: ​`true`​, ​*"c"*​: ​`true`​, ​*"d"*​: ​`true`​, ​*"e"*​: ​`true`​, ​*"f"*​: ​`true`​} |
| --- | --- |

这成为我们的“索引”，将使我们能够在后续查找这些项时实现 O(1) 的效率。

现在，这里是精彩的部分。一旦第一个循环完成，我们有了这个可以使用的哈希表，我们就可以开始第二个（非嵌套的）循环，迭代`smallerArray`：

| ​  | ​`for`​ (​`const`​ `value` ​`of`​ `smallerArray`) { |
| --- | --- |
| ​  | ​`if`​ (!`hashTable`[`value`]) { ​`return`​ ​`false`​; } |
| ​  | } |

这个循环检查`smallerArray`中的每个项，看看它是否作为一个键存在于`hashTable`中。记住，`hashTable`存储了来自`largerArray`的所有项作为它的键。因此，如果我们在`hashTable`中找到一个项，这意味着该项也在`largerArray`中。如果我们在`hashTable`中找不到一个项，这意味着它也不在`largerArray`中。

因此，对于`smaller_array`中的每个项，我们检查它是否是`hashTable`中的一个键。如果不是，这意味着该项不包含在`largerArray`中，因此`smallerArray`不是`largerArray`的子集，我们返回`false`。（然而，如果我们能够通过这个循环，这意味着`smallerArray`是`largerArray`的一个子集。）

让我们把这一切放在一个完整的函数中：

| ​  | ​`function`​ `isSubset`(`array1`, `array2`) { |
| --- | --- |
| ​  | ​`const`​ `hashTable` = {}; |
| ​  | ​`let`​ `largerArray`; |
| ​  | ​`let`​ `smallerArray`; |
| ​  |  |
| ​  | ​*// 确定哪个数组更小:*​ |
| ​  | ​`if`​ (`array1`.length > `array2`.length) { |
| ​  | `largerArray` = `array1`; |
| ​  | `smallerArray` = `array2`; |
| ​  | } ​`else`​ { |
| ​  | `largerArray` = `array2`; |
| ​  | `smallerArray` = `array1`; |
| ​  | } |
| ​  |  |
| ​  | ​`for`​ (​`const`​ `value` ​`of`​ `largerArray`) { |
| ​  | `hashTable`[`value`] = ​`true`​; |
| ​  | } |
| ​  |  |
| ​  | `for` (`const` `value` `of` `smallerArray`) { |
| ​  | `if` (!`hashTable`[`value`]) { `return` `false`; } |
| ​  | } |
| ​  |  |
| ​  | `return` `true`; |
| ​  | } |

现在，这个算法花费了多少步骤？我们遍历了较大数组中的每个项一次以构建哈希表。

我们遍历了较小数组中的每个项，每个项只需花费一步在哈希表中查找。请记住，哈希表查找只需一步。

如果我们说`N`是两个数组合并后的总项数，我们的算法是`O(N)`，因为我们只访问了每个项一次。我们对每个较大数组的项花费了一步，然后对每个较小数组的项也花费了一步。

这比我们第一个算法的`O(N * M)`要好得多。

这种将哈希表用作`index`的技术在需要在数组中进行多次搜索的算法中经常出现；也就是说，如果你的算法需要不断在数组内部搜索值，每次搜索将需要最多`N`步。通过创建数组的哈希表`index`，我们将每次搜索缩减为仅一步。

正如我指出的，使用哈希表作为`index`的这个技术特别有趣，因为我们甚至没有处理自然配对的数据。相反，我们只想知道`key`本身是否在哈希表中。当我们使用`key`在哈希表中进行查找并收到任何值（无论它多么任意）时，这意味着该`key`必定存在于哈希表中。
