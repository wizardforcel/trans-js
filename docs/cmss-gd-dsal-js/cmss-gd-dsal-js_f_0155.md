## 堆

堆有几种不同类型，但我们将专注于二叉堆。

二叉堆是一种特定类型的二叉树。提醒一下，二叉树是每个节点最多有两个子节点的树。（上一章的二叉搜索树就是一种特定类型的二叉树。）

现在，即使是二叉堆也有两种类型：`max-heap`和`min-heap`。我们现在将使用`max-heap`，但正如你稍后会看到的，两者之间的区别微不足道。

以后，我将简单地将这种数据结构称为堆，尽管我们具体在处理的是二叉`max-heap`。

堆是一种满足以下条件的二叉树：

+   每个节点的值必须大于其每个后代节点的值。这个规则被称为堆条件。

+   该树必须是完整的。（我稍后会解释这个的意思。）

让我们先从堆条件开始，逐步解析这两个条件。

### 堆条件

堆条件说明每个节点的值必须大于其每一个后代的值。

例如，以下树满足堆条件，因为每个节点都大于其任何后代，如`[图示](#fig.ch16.basic_heap)`所示。

![`images/heaps/basic_heap.png`](images/heaps/basic_heap.png)

在这个例子中，根节点`100`没有比它更大的后代。同样，`88`大于它的两个子节点，`25`也是如此。

以下树不是一个有效的堆，因为它不满足堆条件：

![`images/heaps/invalid_heap.png`](images/heaps/invalid_heap.png)

如你所见，`92`大于其父节点`88`，这违反了堆条件。

注意堆的结构与二叉搜索树非常不同。在二叉搜索树中，每个节点的右子节点都大于它。然而，在堆中，一个节点永远没有比它更大的后代。正如人们所说：“二叉搜索树不等于堆。”（大致是这样。）

我们也可以构建一个具有相反堆条件的堆，即每个节点的值必须小于其所有后代的值。这样的堆被称为`min-heap`，我之前提到过。我们将继续关注`max-heap`，其中每个节点必须大于其所有后代。归根结底，无论堆是`max-heap`还是`min-heap`都是微不足道的，因为这两种堆的其他特性是相同的；它们只是堆条件相反。否则，基本思想是相同的。

### 完全树

现在，让我们来看堆的第二个规则——树必须是完整的。

完整树是一个完全用节点填充的树；没有缺失的节点。因此，如果你从左到右读取树的每一层，所有节点都是存在的。然而，底行可以有空位，只要这些空位右侧没有节点即可。这最好通过示例来说明。

以下树是完整的，因为树的每一层（即每一行）都完全填充了节点：

![images/heaps/complete_tree.png](images/heaps/complete_tree.png)

以下树不是完整的，因为在第三层有一个空位置（而且在那个空位置右侧还有其他节点存在）：

![images/heaps/incomplete_tree.png](images/heaps/incomplete_tree.png)

现在，下一个树实际上被认为是完整的，因为它的空位仅限于底行，并且在空位右侧没有找到任何节点：

![images/heaps/also_complete_tree.png](images/heaps/also_complete_tree.png)

堆是满足堆条件并且也是完整的树。这里再给出一个堆的例子：

![images/heaps/foundational_heap.png](images/heaps/foundational_heap.png)

这是一个有效的堆，因为每个节点都大于它的任何子孙节点，并且树也是完整的。尽管底行确实有一些空隙，但这些空隙仅限于树的最右侧。
