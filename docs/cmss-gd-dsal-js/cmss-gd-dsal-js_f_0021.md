## 集合：单一规则如何影响效率

让我们探索另一种数据结构：`集合`。`集合`是一种不允许包含重复值的数据结构。

`集合`有不同的类型，但在这里我将讨论基于`数组`的`集合`。这个`集合`就像一个`数组`——它是一个简单的值列表。这个`集合`与经典的`数组`之间唯一的区别是，它不允许重复值的插入。

例如，如果你有一个`集合`[`'a'`, `'b'`, `'c'`]，并尝试添加另一个`'b'`，计算机将不允许这样做，因为`集合`中已经存在一个`'b'`。

当你需要确保没有重复数据时，`集合`是非常有用的。

例如，如果你正在创建一个在线电话簿，你不希望同一个电话号码出现两次。实际上，我现在在本地电话簿上正面临这个问题：我的家庭电话号码不仅为我列出，而且错误地列为某个名为`Zirkind`的家庭的电话号码。（是的，这是真的。）让我告诉你——接到寻找`Zirkind`的人的电话和语音邮件真让人烦恼。更重要的是，我相信`Zirkind`家也在想为什么没人打电话给他们。当我拨打`Zirkind`家，告诉他们这个错误时，我的妻子接了电话，因为我拨打了自己的号码。（好吧，最后那部分从未发生过。）要是生成电话簿的程序使用了`集合`就好了…

无论如何，基于`数组`的`集合`是一个额外限制为不允许重复的`数组`。虽然不允许重复是一个有用的特性，但这一简单限制也使得`集合`在四个主要操作中的效率有所不同。

让我们分析在基于`数组`的`集合`中进行读取、搜索、插入和删除操作。

从`集合`读取与从`数组`读取完全相同——计算机只需一步就能查找特定索引中包含的内容。正如我之前所描述的，这因为计算机可以即时访问`集合`中的任何索引，因为它可以轻松计算和访问其内存地址。

搜索`集合`也与搜索`数组`没有区别——在`集合`中搜索一个值最多需要`N`步。而删除操作在`集合`和`数组`之间也是相同的——删除一个值并将数据向左移动以填补空缺最多需要`N`步。

然而，插入是`数组`和`集合`的分歧所在。让我们先探讨在`集合`末尾插入一个值的情况，这对于`数组`来说是最佳场景。我们看到，对于`数组`，计算机可以在一步内将一个值插入到末尾。

然而，对于`集合`，计算机首先需要确定这个值是否已经存在于`集合`中——因为这就是`集合`的作用：防止重复数据被插入。

现在，计算机如何确保新数据不已经包含在集合中呢？请记住，计算机并不知道数组或集合的单元中包含哪些值。因此，计算机首先需要搜索集合，以查看我们想要插入的值是否已经存在。只有当集合尚未包含我们新的值时，计算机才会允许插入操作进行。

因此，向集合中的每次插入都首先需要进行搜索。

让我们通过一个例子来看看这如何运作。想象一下，我们之前的购物清单存储为一个集合——这将是一个不错的选择，因为我们毕竟不想重复购买同样的东西。如果我们当前的集合是[`"apples"`，`"bananas"`，`"cucumbers"`，`"dates"`，`"elderberries"`]，我们想将`"figs"`插入到集合中，计算机必须执行以下步骤，首先搜索`"figs"`。

第1步：在索引0搜索`"figs"`：

![images/understanding_arrays/array_19.png](images/understanding_arrays/array_19.png)

它不在那里，但它可能在集合的其他地方。我们需要确保`"figs"`在任何地方都不存在，然后才能插入它。

第2步：搜索索引1：

![images/understanding_arrays/array_20.png](images/understanding_arrays/array_20.png)

第3步：搜索索引2：

![images/understanding_arrays/array_21.png](images/understanding_arrays/array_21.png)

第4步：搜索索引3：

![images/understanding_arrays/array_22.png](images/understanding_arrays/array_22.png)

第5步：搜索索引4：

![images/understanding_arrays/array_23.png](images/understanding_arrays/array_23.png)

现在我们已经搜索了整个集合，我们可以确定它不包含`"figs"`。此时，完成插入是安全的。这就引出了我们的最后一步：

第6步：在集合的末尾插入`"figs"`：

![images/understanding_arrays/array_24.png](images/understanding_arrays/array_24.png)

在集合的末尾插入一个值是最理想的情况，但我们仍然需要对原本包含五个元素的集合执行六个步骤。也就是说，我们必须在执行最后的插入步骤之前搜索所有五个元素。

换句话说：在一个集合的末尾插入将需要最多`N + 1`步，针对`N`个元素。这是因为需要`N`步进行搜索，以确保该值不已存在于集合中，然后再进行一步实际的插入。与此相比，在常规数组中，插入仅需一步。

在最坏的情况下，如果我们要在集合的开头插入一个值，计算机需要搜索`N`个单元，以确保集合中不包含该值，再需要`N`个步骤将所有数据向右移动，最后再执行一步插入新值。总共是`2N + 1`步。与此相比，在常规数组的开头插入仅需`N + 1`步。

现在，这是否意味着你应该避免使用`sets`，仅仅因为`sets`的插入速度比普通的`arrays`慢？绝对不是。`Sets`在你需要确保没有重复数据时非常重要。（希望有一天我的`电话簿`能修好。）但当你没有这样的需求时，`array`可能更合适，因为`arrays`的插入效率高于`sets`的插入。你必须分析自己应用的需求，并决定哪种数据结构更适合。
