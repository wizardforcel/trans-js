## 递归的效率

在我们第二个改进版的`max`函数中，该函数会根据数组中值的数量递归调用自身。我们称之为`O(N)`。

到目前为止，我们看到的`O(N)`案例涉及循环，其中一个循环运行`N`次。然而，我们也可以将`Big O`的相同原则应用于递归。

正如你所回忆的，`Big O`回答了一个关键问题：如果有`N`个数据元素，算法将需要多少步骤？

由于改进后的`max`函数对数组中的`N`个值运行`N`次，因此其时间复杂度为`O(N)`。即使该函数本身包含多个步骤，例如五个，其时间复杂度也会变为`O(5N)`，最终简化为`O(N)`。

在第一版中，函数在每次运行时（除了基例）会自我调用两次。让我们看看这对不同数组大小的影响。

以下表格显示了在不同大小的数组中`max`被调用的次数：

| N 元素 | 调用次数 |
| --- | --- |
| 1 | 1 |
| 2 | 3 |
| 3 | 7 |
| 4 | 15 |
| 5 | 31 |

你能看到这个模式吗？当我们将数据增加一个时，算法所需的步骤大约翻倍。正如我们在讨论[*密码破解器*](f_0073.xhtml#sect.password-cracker)时所学到的，这就是`O(2^N)`的模式。我们已经知道这是一种极慢的算法。

然而，改进后的`max`函数仅对数组内的元素数量调用`max`。这意味着我们的第二个`max`函数的效率为`O(N)`。

这是一个强有力的教训：避免额外的递归调用是保持递归快速的关键。乍一看，对我们代码的一个非常小的修改——仅仅将计算结果存储在一个变量中——最终使我们的函数的速度从`O(2^N)`改变为`O(N)`。
