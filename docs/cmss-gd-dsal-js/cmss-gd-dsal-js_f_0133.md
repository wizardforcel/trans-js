## 读取

正如你所知，计算机可以在 O(1) 时间内从数组中读取。但现在让我们计算从链表中读取的效率。

如果你想读取链表中第三个项目的值，计算机不能一步到位，因为它不会立即知道在计算机内存中哪里可以找到它。毕竟，链表的每个节点可能在内存中的任何地方！我们的程序立即知道的只是链表第一个节点的内存地址；它并不知道其他节点的位置。

因此，要从第三个节点读取，计算机必须经历一个过程。首先，它访问第一个节点。然后，它跟随第一个节点的链接到第二个节点，再跟随第二个节点的链接到第三个节点。

因此，要到达任何节点，我们始终需要从第一个节点开始（这是我们最初可以访问的唯一节点），并沿着节点链一直走到我们想要的节点。

结果是，如果我们要从链表中的最后一个节点读取，所需的步骤将是 N 步，对于 N 个节点而言。与能够在 O(1) 时间内读取任何元素的数组相比，链表在最坏情况下读取时间为 O(N) 是一个主要的劣势。但是别担心，链表会有它们闪耀的时刻，正如我们很快会看到的。

### 代码实现：链表读取

让我们继续在 `LinkedList` 类中添加一个读取方法：

| ​  | `read(index) {` |
| --- | --- |
| ​  | `let` currentNode = `this`.firstNode; |
| ​  | `let` currentIndex = 0; |
| ​  | `while` (currentIndex < index) { |
| ​  | `currentNode = currentNode.nextNode;` |
| ​  | `currentIndex += 1;` |
| ​  |  |
| ​  | `if` (!currentNode) { |
| ​  | `return` `null`; |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `return` currentNode.data; |
| ​  | } |

如果我们想从链表中读取第四个节点，例如，我们将通过传入节点的索引来调用我们的方法，如下所示：

| ​  | `list.read(3);` |
| --- | --- |

让我们逐步了解这个方法的工作原理。

首先，我们创建一个名为 `currentNode` 的变量，指向我们当前访问的节点。由于我们将从头节点开始访问，我们可以这样说：

| ​  | `let` currentNode = `this`.firstNode; |
| --- | --- |

请回忆一下，`firstNode` 是 `LinkedList` 类的一个实例变量。

我们还跟踪 `currentNode` 的索引，以便知道何时到达所需的索引。我们从 0 开始，因为第一个节点的索引是 0：

| ​  | `let` currentIndex = 0; |
| --- | --- |

然后我们启动一个循环，只要 `currentIndex` 小于我们要读取的索引，就持续运行：

| ​  | `while` (currentIndex < index) { |
| --- | --- |

在每次遍历循环中，我们访问链表中的下一个节点，并将其设为新的 `currentNode`：

| ​  | `currentNode = currentNode.nextNode;` |
| --- | --- |

我们还将 `currentIndex` 增加 1：

| ​  | `currentIndex += 1;` |
| --- | --- |

在每次遍历的末尾，我们检查是否已经到达链表的末尾，如果我们尝试读取的索引不在链表中，则返回 `null`：

| ​  | `if` (!currentNode) { |
| --- | --- |
| ​  | `return`​ `null`; |
| ​  | } |

这是有效的，因为列表的最后一个节点实际上会有一个`nextNode`为`null`，因为最后一个节点从未被分配自己的`nextNode`。这样，当`currentNode`指向最后一个节点时，我们执行`current = currentNode.nextNode`，`currentNode`就变成了`null`。

最后，如果我们跳出循环，那是因为我们达到了期望的索引。我们可以通过以下方式返回节点的值：

| ​  | `return` currentNode.data; |
| --- | --- |
