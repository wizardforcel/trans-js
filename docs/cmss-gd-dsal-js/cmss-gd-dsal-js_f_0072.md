## 获取所有产品

我们下一个示例是一个接受数字数组并返回每对数字乘积的算法。

例如，如果我们传入数组`[1, 2, 3, 4, 5]`，该函数返回：

| ​  | `[2, 3, 4, 5, 6, 8, 10, 12, 15, 20]` |
| --- | --- |

这是因为我们首先将`1`与`2`，`3`，`4`和`5`相乘。然后我们将`2`与`3`，`4`和`5`相乘。接下来，我们将`3`与`4`和`5`相乘。最后，我们将`4`与`5`相乘。

注意一些有趣的事情：当我们将`2`与其他数字相乘时，我们只需将其与右边的数字相乘。我们不需要回过头将`2`与`1`相乘，因为那已经在将`1`与`2`相乘时处理过了。所以每个数字只需要与其右侧剩余的数字相乘。

下面是这个算法的实现：

| ​  | ​`function`​ `twoNumberProducts(array) { |
| --- | --- |
| ​  | ​`const`​ `products = []; |
| ​  |  |
| ​  | ​`for`​ (`let`​ `i = 0; i < array.length; i += 1) { |
| ​  | ​`for`​ (`let`​ `j = i + 1; j < array.length; j += 1) { |
| ​  | `products.push(array[i] * array[j]); |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | ​`return`​ `products; |
| ​  | } |

让我们来详细分析一下。`N`是传递给该函数的数组中的项目数量。

我们外循环运行`N`次。（实际上我们运行了`N - 1`次，但我们将忽略这个常数。）然而，内循环则不同。由于`j`总是从`i`右边一个索引开始，内循环的步数在每次外循环启动时都会减少。

让我们看看在这个包含五个元素的示例数组中，内循环运行了多少次：

当`i`为`0`时，内循环在`j`为`1`，`2`，`3`和`4`时运行。当`i`为`1`时，内循环在`j`为`2`，`3`和`4`时运行。当`i`为`2`时，内循环在`j`为`3`和`4`时运行。当`i`为`3`时，内循环在`j`为`4`时运行。最后，内循环运行：

`4 + 3 + 2 + 1` 次。

用`N`来表述的话，我们可以说内循环大约运行：

`N + (N - 1) + (N - 2) + (N - 3) … + 1` 次。

这个公式总是计算出大约`N² / 2`。你可以在[图示](#fig.ch7.cascade)中可视化这一点。为了图示的目的，我们将`N`设为`8`，因此有`8²`，即`64`个正方形。

![images/big_o_in_everyday_code/cascade.png](images/big_o_in_everyday_code/cascade.png)

如果你从顶部开始往下走，你会看到顶部有所有`N`个正方形被涂成灰色。下一行有`N - 1`个灰色正方形，而下一行则有`N - 2`个灰色正方形。这个模式一直持续到最后一行，只有一个灰色正方形。

你也可以一目了然地看到大约一半的正方形是涂色的。这表明`N + (N - 1) + (N - 2) + (N - 3)... + 1`的模式等同于`N² / 2`。

那么，我们发现内部循环运行`N² / 2`步。但是因为大O符号忽略常数，我们将其表示为`O(N²)`。

### 处理多个数据集

现在，如果我们不是计算单个数组中每两个数字的乘积，而是计算一个数组中的每个数字与第二个数组中每个数字的乘积，会发生什么呢？

例如，如果我们有数组`[1, 2, 3]`和数组`[10, 100, 1000]`，我们将按如下方式计算它们的乘积：

| ​  | `[10, 100, 1000, 20, 200, 2000, 30, 300, 3000]` |
| --- | --- |

我们的代码将与之前的代码片段类似，只需做一些小的修改：

| ​  | `function` `twoNumberProducts`(`array1`, `array2`) { |
| --- | --- |
| ​  | `const` `products` = []; |
| ​  |  |
| ​  | `for` (`const` `i` `of` `array1`) { |
| ​  | `for` (`const` `j` `of` `array2`) { |
| ​  | `products.push(i * j);` |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `return` `products`; |
| ​  | } |

让我们分析一下这个函数的时间复杂度。

首先，`N`是什么？这是第一个障碍，因为我们现在有两个数据集，即两个数组。

将一切归结为`N`是两个数组合并后的总项数是很有诱惑力的。但这在以下方面存在问题：

这里有两个场景的故事。在场景1中，有两个大小为`5`的数组。在场景2中，有一个大小为`9`的数组和一个大小为`1`的数组。

在这两种场景中，我们最终都会说`N`是`10`，因为`5 + 5 = 10`和`9 + 1 = 10`。然而，每个场景的效率是非常不同的。

在场景1中，我们的代码需要二十五步（`5 * 5`）。因为`N`是`10`，这相当于（`N / 2`）²步。

在场景2中，我们的代码需要九步（`9 * 1`），这接近大约`N`步。这比场景1快得多！

所以，我们不想将`N`视为两个数组的整数总数，因为这样我们无法在大O符号中准确地确定效率，因为它会根据不同的场景而变化。

我们处于困境中。我们别无选择，只能将时间复杂度表示为`O(N * M)`，其中`N`是一个数组的大小，`M`是另一个数组的大小。

这是一个新概念：每当我们有两个不同的数据集需要通过乘法相互作用时，我们在描述大O效率时必须分别识别这两个来源。

虽然这是用大O符号表达该算法的正确方式，但它在实用性上比其他大O表达式稍差。将`O(N * M)`算法与仅有`N`（而没有`M`）的算法进行比较，就像将苹果与橙子进行比较一样。

然而，我们确实知道`O(N * M)`在一个特定范围内；也就是说，如果`N`和`M`相同，那么它等价于`O(N²)`。如果它们不相同，并且我们任意将较小的数字赋值为`M`，即使`M`低至`1`，我们最终也得到`O(N)`。从某种意义上说，`O(N * M)`可以被理解为在`O(N)`和`O(N²)`之间的一个范围。

这很伟大吗？不，但这是我们所能做的最好选择。
