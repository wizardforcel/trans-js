## 存储单词

现在，我们的前缀树的目的是存储单词。让我们看看下面的前缀树如何存储单词 `"ace"`、`"bad"` 和 `"cat"`，如图所示的 `[图示](#fig.ch17.ace_bad_cat)`。

![images/tries/ace_bad_cat.png](images/tries/ace_bad_cat.png)

这个前缀树通过将每个单词的每个字符转换为自己的前缀树节点来存储这三个单词。例如，如果你从根节点开始并跟随它的 `"a"` 键，它指向一个包含键 `"c"` 的子节点。`"c"` 键又指向一个包含键 `"e"` 的节点。当我们将这三个字符串联在一起时，我们得到单词 `"ace"`。

通过这种模式，你可以看到前缀树如何也存储单词 `"bad"` 和 `"cat"`。

你会注意到这些单词的最后一个字符有自己的子节点。例如，如果你查看单词 `"ace"` 中的 `"e"` 节点，你可以看到 `"e"` 指向一个包含哈希表的子节点，键是 `"*"`，即星号。（值实际上并不重要，所以可以简单地是空值。）这表明我们已到达单词的末尾，因此 `"ace"` 是一个完整的单词。对这个 `"*"` 键的需求将很快变得更加明显。

现在，前缀树变得更加有趣。假设我们还想存储单词 `"act"`。为此，我们保留现有的 `"a"` 和 `"c"` 键，但添加一个新的节点，包含键 `"t"`。请查看下面的图示：

![images/tries/add_act.png](images/tries/add_act.png)

正如你所看到的，粗体节点的哈希表现在包含两个子节点，一个是 `"e"`，一个是 `"t"`。通过这样做，我们表明 `"ace"` 和 `"act"` 都是有效的字典单词。

为了便于将来的可视化，我们将使用更简单的图示来表示我们的前缀树。这里是使用这种新格式的相同前缀树：

![images/tries/no_hash.png](images/tries/no_hash.png)

在这种图示风格中，我们将每个哈希表键放置在指向其子节点的箭头旁边。

### 星号的必要性

假设我们想在前缀树中存储单词 `"bat"` 和 `"batter"`。这是一个有趣的案例，因为单词 `"batter"` 实际上包含单词 `"bat"`。我们是这样处理的：

![images/tries/bat_and_batter.png](images/tries/bat_and_batter.png)

第一个 `"t"` 指向一个有两个键的节点。一个键是 `"*"` 键（有一个空值），而另一个是 `"t"`，其值指向另一个节点。这表明 `"bat"` 本身是一个单词，即使它也是较长单词 `"batter"` 的前缀。

请注意，在这个图示中，我们不再使用经典的哈希表语法，而是使用一种简化的语法来节省空间。我们使用花括号来表示该节点包含一个哈希表。然而，`{"*", "t"}` 不是一个键值对，而仅仅是两个键。`"*"` 键有一个空值，而 `"t"` 键的值是下一个节点。

这就是为什么这些 `"*"` 是至关重要的。我们需要它们来指示一个单词的部分也是单词本身。

让我们用一个更复杂的例子将这一切结合起来。这里有一个包含单词`"ace"`、`"act"`、`"bad"`、`"bake"`、`"bat"`、`"batter"`、`"cab"`、`"cat"`、`"catnap"`和`"catnip"`的字典树：

![`images/tries/foundational_trie.png`](images/tries/foundational_trie.png)

在实际应用中使用的字典树可能包含成千上万的单词。如果它们不包含整个英语语言，至少也包含最常用的单词。

为了构建我们的自动完成功能，让我们首先分析基本的字典树操作。
