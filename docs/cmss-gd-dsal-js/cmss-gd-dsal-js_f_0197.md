## 从这里开始：最佳想象的 Big O

尽管本章中的所有技术都很有用，但你会发现，有些在特定场景中很方便，而其他则在其他场景中有效。

然而，这第一种技术适用于所有算法，应该是你优化过程的第一步。

这就是它的所在。

一旦你确定了当前算法的效率（先决条件），就想出你认为的我所称的“最佳想象的 Big O”。（我见过其他人称之为“最佳可想象运行时间”，应用于速度时。）

本质上，最佳想象的 Big O 是你对手头问题可以梦想的绝对最佳 Big O。这是你知道绝对不可能被超越的 Big O。

例如，如果我们要编写一个打印数组中每个项的函数，我们可能会说这个任务的最佳想象 Big O 是 `O(N)`。因为我们必须打印每个 `N` 项，所以我们别无选择，只能处理每个 `N` 项。这个事实无可避免，因为我们需要“接触”每个项才能打印它。因此，`O(N)` 是我们对这个场景所能想象的最佳想象 Big O。

因此，在优化算法时，我们需要确定两个 Big O。我们需要知道我们算法当前的 Big O（先决条件），并且需要想出该任务可能达到的最佳想象 Big O。

如果这两个 Big O 不相同，意味着我们有优化的空间。假设，我当前的算法运行时间为 `O(N²`)，但最佳想象的 Big O 是 `O(N)`，那么我们就有了努力改进的目标。两个 Big O 之间的差距显示了我们通过优化可以实现的潜在收益。

让我们总结一下这些步骤：

1.  确定你当前算法的 Big O 类别。（这就是先决条件。）

1.  确定你对手头问题能够梦想的最佳想象 Big O。

1.  如果最佳想象的 Big O 比你当前的 Big O 更快，那么你可以尝试优化代码，目标是尽可能将算法接近最佳想象的 Big O。

需要强调的是，达到最佳想象 Big O 并不总是可能的。毕竟，仅仅因为你能梦想某件事情，并不意味着它能变成现实。

事实上，你当前的实现可能无法进一步优化。然而，最佳想象的 Big O 仍然是一个工具，可以为我们的优化提供一个目标。

通常，我发现我能够成功地将算法优化到一个介于我当前的 Big O 和最佳想象的 Big O 之间的速度。

例如，如果我当前的实现是 `O(N²)`，而我能想象的最佳 Big O 是 `O(log N)`，我会努力优化我的算法，使其变为 `O(log N)`。如果最后我的优化使代码“仅仅”达到 `O(N)`，那依然是一个伟大的成功，想象中的最佳 Big O 将发挥有用的作用。

### 伸展想象力

正如你所看到的，提出最佳想象`Big O`的好处在于，它给我们提供了一个优化目标。为了充分利用这一点，值得稍微扩展一下想象力，想出一个惊人的最佳想象`Big O`。事实上，我建议将你能想到的最快的`Big O`设为最佳想象`Big O`，前提是它不是完全不可能的。

这里有另一个我用来激发想象力的心理技巧。我为当前问题选择一个非常快速的`Big O`——我们称之为“惊人的`Big O`”。然后我问自己：“如果有人告诉我他们知道如何实现这个问题的惊人`Big O`，我会相信他们吗？”如果我会相信某人说他们找到了以惊人`Big O`的效率解决这个问题的方法，那么我就将惊人`Big O`设为我能想象的最佳`Big O`。

一旦我们知道当前算法的`Big O`和我们所追求的最佳想象`Big O`，我们就准备好进行优化了。

在本章的剩余部分，我们将探讨其他优化技术和心理策略，以帮助我们提升代码的效率。
