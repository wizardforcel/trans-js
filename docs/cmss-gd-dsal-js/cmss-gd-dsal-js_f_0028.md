## `二分查找 vs. 线性查找`

对于小规模的有序数组，二分查找算法相较于线性查找并没有太大优势。但让我们看看在更大数组中的表现。

对于包含100个值的数组，每种搜索类型的最大步骤数如下：

+   `线性查找：100步`

+   `二分查找：7步`

使用线性查找，如果我们要查找的值在最后一个单元中或大于最后一个单元中的值，我们需要检查每一个元素。对于大小为100的数组，这将需要100步。

然而，当我们使用二分查找时，每次猜测都会消除一半我们需要搜索的可能单元。在我们的第一次猜测中，我们可以消除多达五十个单元。

让我们换个角度看这个问题，会发现一个模式。

对于大小为3的数组，二分查找最多需要两步。

如果我们将数组中的单元数量加倍（并再加一个保持奇数以简化），那么有七个单元。对于这样的数组，使用二分查找查找某个元素的最大步骤数为三。

如果我们再加倍（并加一），使得有序数组包含十五个元素，二分查找的最大步骤数为四。

出现的模式是，每次我们将有序数组的大小加倍，二分查找所需的步骤数增加一。这是合理的，因为每次查找都会消除一半的元素。

这种模式异常高效：每次我们将数据加倍，二分查找算法只需增加一步。

将此与线性查找进行对比。如果你有3个元素，最多需要3步。对于7个元素，最多需要7步。对于100个值，最多需要100步。因此，对于线性查找，步骤数与项目数量相同。因此，每次我们将数组的大小加倍，搜索的步骤数也加倍。而对于二分查找，每次将数组的大小加倍时，只需再加一步。

让我们看看这对更大数组的影响。对于一个包含10,000个元素的数组，线性搜索可能需要多达10,000步，而二分查找最多只需13步。对于大小为一百万的数组，线性搜索将需要多达一百万步，而二分查找最多只需20步。

我们可以通过这个图表可视化线性查找和二分查找之间的性能差异：

![images/binary_search/search_graph.png](images/binary_search/search_graph.png)

我们将分析一些看起来像这样的图表，因此让我们花点时间消化一下正在发生的事情。x轴表示数组中的元素数量。也就是说，当我们从左到右移动时，我们正在处理越来越多的数据。

y轴表示算法所需的步骤数。随着我们在图中向上移动，步骤数会增加。

如果你查看表示`线性搜索`的线条，你会看到，随着数组元素的增加，`线性搜索`所需的步骤数量也在按比例增加。本质上，数组中的每个额外元素，`线性搜索`就多花一步。这形成了一条直线斜率。

另一方面，通过`二分搜索`，你会看到随着数据的增加，算法的步骤仅会略微增加。这与我们所知道的完全一致：你必须将数据量加倍才能在`二分搜索`中增加一步。

请记住，排序数组在某些方面并不是更快的。正如你所见，插入排序数组的速度比标准数组要慢。但这里有一个权衡：使用排序数组，你的插入速度会稍慢，但搜索速度会快得多。再次强调，你必须始终分析你的应用程序，以确定哪种更适合。你的软件会进行很多插入吗？搜索会是你正在构建的应用程序的重要特性吗？

### 测验

我发现以下的测验问题真的迫使人理解`二分搜索`的效率。请遮住答案，看看你是否能答对。

问题是：我们说对于一个包含100个元素的排序数组，`二分搜索`需要七步。对于一个包含200个元素的排序数组，`二分搜索`需要多少步？

答案是：八步。

我常听到的直观答案是十四步，但这是不正确的。`二分搜索`的美在于，每次检查都会消除剩余元素的一半。因此，每当我们将数据量加倍时，只需增加一步。毕竟，这种数据的加倍在第一次检查时就会完全消除！

值得注意的是，既然我们已经将`二分搜索`加入了我们的工具包，排序数组中的插入也可以变得更快。插入之前需要搜索，但我们现在可以将这种搜索从`线性搜索`升级为`二分搜索`。然而，排序数组的插入仍然比常规数组要慢，因为常规数组的插入根本不需要搜索。
