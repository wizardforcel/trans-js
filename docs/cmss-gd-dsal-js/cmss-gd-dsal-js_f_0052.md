## 忽略常数

但有趣的是，在`Big O`符号的世界中，`选择排序`和`冒泡排序`的描述完全相同。

再次强调，`Big O`符号回答了关键问题：如果有`N`个数据元素，算法将需要多少步？因为`选择排序`大约需要`N²`步的一半，合理的描述是将`选择排序`的效率表示为`O(N² / 2)`。也就是说，对于`N`个数据元素，有`N² / 2`步。以下表格证实了这一点：

| `N 元素` | `N² / 2` | `选择排序`中的最大步数 |
| --- | --- | --- |
| 5 | `5² / 2 = 12.5` | 14 |
| 10 | `10² / 2 = 50` | 54 |
| 20 | `20² / 2 = 200` | 209 |
| 40 | `40² / 2 = 800` | 819 |
| 80 | `80² / 2 = 3200` | 3239 |

然而，在实际中，`选择排序`在`Big O`中描述为`O(N²)`，就像`冒泡排序`一样。这是因为我现在第一次介绍的`Big O`的一个主要规则：

`Big O`符号忽略常数。

这仅仅是用数学方式表达`Big O`符号从不包括非指数的常规数字。我们简单地将这些常规数字从表达式中去掉。

因此，在我们的案例中，即使算法需要`N² / 2`步，我们也会丢掉“/ 2”，因为这是一个常规数字，并将效率表示为`O(N²)`。

丢弃常数也是为什么一个算法被写作`O(log[2] N)`的原因，而简化为`O(log N)`。因为在数学上，2为底的对数被视为常数，所以我们将其丢弃。

这里还有几个例子：

对于需要`N / 2`步的算法，我们称之为`O(N)`。

需要`N² + 10`步的算法将被表示为`O(N²)`，因为我们丢掉了10这个常规数字。

对于需要`2N`步的算法（意味着`N * 2`），我们丢掉常规数字并称之为`O(N)`。

即使是`O(100N)`，它比`O(N)`慢100倍，也被称为`O(N)`。

随便想想，这条规则似乎会使`Big O`符号完全无用，因为你可能有两个算法在`Big O`中完全相同地描述，但其中一个可以比另一个快100倍。而这正是我们在`选择排序`和`冒泡排序`中看到的情况。两者在`Big O`中描述为`O(N²)`，但`选择排序`比`冒泡排序`快两倍。

那么，这是怎么回事呢？
