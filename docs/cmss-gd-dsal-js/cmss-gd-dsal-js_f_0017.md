## 读取

我们要看的第一个操作是读取，这会查找数组中某个特定索引所包含的值。

计算机可以在一步之内读取数组中的内容。这是因为计算机能够立即访问数组中的任何特定索引并查看内容。在我们的示例`["apples", "bananas", "cucumbers", "dates", "elderberries"]`中，如果我们查找索引`2`，计算机会直接跳到索引`2`并报告该索引包含值`"cucumbers"`。

计算机是如何在一步之内查找数组的索引的呢？让我们来看一下。

计算机的内存可以被视为一个巨大的单元集合。在下图中，你可以看到一个单元格的网格，其中一些是空的，有些则包含数据位：

![`images/understanding_arrays/array_2.png`](images/understanding_arrays/array_2.png)

虽然这个图示简化了计算机内存的工作原理，但它传达了基本思想。

当程序声明一个数组时，它为程序分配了一组连续的空单元。因此，如果你创建一个用于存储五个元素的数组，计算机会找到一排五个连续的空单元，并将其指定为你的数组：

![`images/understanding_arrays/array_3.png`](images/understanding_arrays/array_3.png)

现在，计算机内存中的每个单元都有一个特定地址。这有点像街道地址（例如，`123 Main St.`），不过它用一个数字来表示。每个单元的内存地址比前一个单元的地址大一。下面是一个展示每个单元内存地址的图示：

![`images/understanding_arrays/array_4.png`](images/understanding_arrays/array_4.png)

在下一个图示中，你可以看到我们的购物清单数组及其索引和内存地址：

![`images/understanding_arrays/array_5.png`](images/understanding_arrays/array_5.png)

当计算机读取数组中特定索引的值时，它能够直接跳到该索引，这是因为计算机关于以下事实的结合：

1.  计算机可以在一步之内访问任何内存地址。例如，如果你要求计算机检查内存地址`1063`中的内容，它可以立即访问而无需执行任何搜索过程。打个比方，如果我让你抬起右手的小指，你不需要搜索所有手指来找到哪个是你的右手小指。你能够立即识别它。

1.  每当计算机分配一个数组时，它也会记录数组开始的内存地址。因此，如果我们让计算机找到数组的第一个元素，它能够立即访问适当的内存地址来找到它。

现在，这些事实解释了计算机如何在一步之内找到数组的第一个值。然而，计算机也可以通过简单的加法找到任何索引处的值。如果我们要求计算机找到索引 `3` 中的值，计算机只需取索引 `0` 的内存地址并加上 `3`。（毕竟，内存地址是连续的。）

让我们将这一点应用于我们的购物清单数组。我们的示例数组起始于内存地址 `1010`。因此，如果我们告诉计算机读取索引 `3` 中的值，计算机将经历以下思维过程：

1.  数组从索引 `0` 开始，该索引位于内存地址 `1010`。

1.  索引 `3` 恰好位于索引 `0` 之后的三个位置。

1.  逻辑推理可以得出，索引 `3` 位于内存地址 `1013`，因为 `1010 + 3` 等于 `1013`。

一旦计算机知道索引 `3` 位于内存地址 `1013`，它就可以直接跳转到那里，并查看该位置包含的值为 `"dates"`。

因此，从数组中读取数据是一种高效的操作，因为计算机可以通过一步跳转到任何内存地址来读取任何索引。尽管我通过将计算机的思维过程分解为三个部分进行了描述，但我们目前关注的是计算机跳转到内存地址的主要步骤。（在后面的章节中，我们将探讨如何判断哪些步骤值得关注。）

自然，一个只需一步的操作是最快的操作类型。除了作为基础数据结构之外，数组还是一种非常强大的数据结构，因为我们可以以如此快速的速度从中读取数据。

现在，如果我们不是询问计算机索引 `3` 中包含的值，而是反过来询问 `"dates"` 可以在什么索引找到呢？这就是搜索操作，我们将接下来探讨这个问题。
