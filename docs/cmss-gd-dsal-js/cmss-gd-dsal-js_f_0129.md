## 练习

以下练习为你提供了一个练习快速排序的机会。这些练习的解决方案在章节 [​`第13章`​](f_0218.xhtml#divide.and.conquer.in.turbo.mode.solutions) 中可以找到。

1.  给定一个正数数组，编写一个函数返回任何三个数字的最大乘积。使用三个嵌套循环的方法会达到 `O(N³)`，这非常慢。使用排序以 `O(N log N)` 的速度实现该函数。（其他一些实现甚至更快，但我们重点关注使用排序作为提高代码速度的技术。）

1.  以下函数从整数数组中找到缺失的数字；也就是说，数组应该包含从 `0` 到数组长度的所有整数，但有一个缺失。例如，数组 `[5, 2, 4, 1, 0]` 缺少数字 `3`，数组 `[9, 3, 2, 5, 6, 7, 1, 0, 4]` 缺少数字 `8`。

    这里有一个 `O(N²)` 的实现（条件 `if (!array.includes(number))` 本身就是 `O(N)`，因为计算机需要搜索整个数组来找到 number）：

    | ​  | ​`function`​ findMissingNumber(array) { |
    | --- | --- |
    | ​  | ​`for`​ (​`let`​ number = `0`; number <= array.length; number += `1`) { |
    | ​  | ​`if`​ (!array.includes(number)) { |
    | ​  | ​`return`​ number; |
    | ​  | `}` |
    | ​  | `}` |
    | ​  |  |
    | ​  | ​`return`​ ​`null`​; |
    | ​  | `}` |

    使用排序编写该函数的新实现，使其仅需 `O(N log N)`。 （其他一些实现甚至更快，但我们重点关注使用排序作为提高代码速度的技术。）

1.  编写三个不同的实现，用于找到数组中的最大数字。写一个 `O(N²)` 的函数，一个 `O(N log N)` 的函数，以及一个 `O(N)` 的函数。

版权所有 © 2024, The Pragmatic Bookshelf.
