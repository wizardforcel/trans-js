## `Quicksort` 的效率

要确定 `Quicksort` 的效率，我们首先要确定单个分区的效率。

当我们分解一个分区的步骤时，会注意到分区涉及两种主要类型的步骤：

+   比较：我们将手头的每个值与 `pivot` 进行比较。

+   交换：在适当的时候，我们交换左指针和右指针指向的值。

每个分区至少有 `N` 次比较——也就是说，我们将数组的每个元素与 `pivot` 进行比较。这是正确的，因为一个分区总是让左右指针通过每个单元格移动，直到左右指针相遇。

交换的次数将取决于数据的排序方式。一个单独的分区最多可以有 `N / 2` 次交换，因为即使我们在每个机会都交换值，每次交换也只处理两个值。如以下图所示，我们仅用三次交换就对六个元素进行了分区：

![`images/divide_and_conquer_code_in_turbo_mode/three_swaps.png`](images/divide_and_conquer_code_in_turbo_mode/three_swaps.png)

现在，在大多数情况下，我们并不是在每一步都进行交换。对于随机排序的数据，我们通常会交换大约一半的值。因此，平均而言，我们大约会进行 `N / 4` 次交换。

所以平均而言，我们进行大约 `N` 次比较和 `N / 4` 次交换。那么，我们可以说对于 `N` 个数据元素，大约有 `1.25N` 步骤。在 `Big O` 符号中，我们忽略常数，因此我们会说一个分区的运行时间为 `O(N)`。

现在，这就是单个分区的效率。但是 `Quicksort` 涉及多个分区，因此我们需要进行进一步分析以确定 `Quicksort` 的效率。

### 从鸟瞰角度看 `Quicksort`

为了更容易地可视化这一点，请查看 [图表](#fig.ch13.partition_numbers)，描绘了从鸟瞰角度看八个元素数组的典型 `Quicksort`。特别地，图表显示了每个分区作用于多少个元素。我们已省略数组中的实际数字，因为确切值并不重要。请注意，在图表中，活动子数组是没有被灰化的单元组。

![`images/divide_and_conquer_code_in_turbo_mode/partition_numbers.png`](images/divide_and_conquer_code_in_turbo_mode/partition_numbers.png)

我们可以看到我们有八个分区，但每个分区是在不同大小的子数组上进行的。我们对原始的八个元素数组进行一次分区，同时还对大小为 `4`、`3` 和 `2` 的子数组进行了分区，以及对四个大小为 `1` 的数组进行了另外四次分区。

由于 `Quicksort` 本质上是由这一系列分区组成的，每个分区对每个子数组的 `N` 个元素大约需要 `N` 步，如果我们将所有子数组的大小加在一起，就可以得到 `Quicksort` 所需的总步骤数：

| ​  | 8 个元素 |
| --- | --- |
| ​  |  |
| ​  | 3 个元素 |
| ​  |  |
| ​  | 1 个元素 |
| ​  |  |
| ​  | 1 个元素 |
| ​  |  |
| ​  | 4 个元素 |
| ​  |  |
| ​  | 2 个元素 |
| ​  |  |
| ​  | 1 个元素 |
| ​  |  |
| ​  | + 1 个元素 |
| ​  | __________ |
| ​  |  |
| ​  | 总计 = 大约21步 |

我们看到原始数组有8个元素时，`快速排序`大约需要21步。这假设是在最佳或平均情况下，枢轴在每次分区后大致位于子数组的中间。

对于16个元素的数组，`快速排序`大约需要64步，而对于32个元素的数组，`快速排序`大约需要160步。看看这个表格：

| `N` | `快速排序步骤（大约）` |
| --- | --- |
| 4 | 8 |
| 8 | 24 |
| 16 | 64 |
| 32 | 160 |

（在之前的例子中，大小为8的数组的`快速排序`步骤数为21，我在这个表格中放了24。确切的步骤数因情况而异，24也是一个合理的近似。我特意将其设为24，以便使接下来的解释更清晰。）

### `快速排序`的大O

我们如何在大O符号中对`快速排序`进行分类？

如果我们查看之前显示的模式，会注意到数组中`N`个元素的`快速排序`步骤数大约是`N`乘以`log N`，如下面的表格所示：

| `N` | `log N` | `N * log N` | `快速排序步骤（大约）` |
| --- | --- | --- | --- |
| 4 | 2 | 8 | 8 |
| 8 | 3 | 24 | 24 |
| 16 | 4 | 64 | 64 |
| 32 | 5 | 160 | 160 |

实际上，这正是表达`快速排序`效率的方法。它是一个`O(N log N)`的算法。我们发现了一个新的大O类别！

[图表](#fig.ch13.big_o_graph)展示了`O(N log N)`与其他大O类别的比较。

![images/divide_and_conquer_code_in_turbo_mode/big_o_graph.png](images/divide_and_conquer_code_in_turbo_mode/big_o_graph.png)

现在，`快速排序`的步骤数正好与`N * log N`对齐并不是偶然。如果我们更广泛地思考`快速排序`，就可以理解为什么会这样。

每次我们对数组进行分区时，都会将其分解为两个子数组。假设枢轴大致位于数组的中间——这正是平均情况下的情况——这两个子数组大致相等。

我们可以将一个数组分成两半多少次，直到完全分解到每个子数组的大小为1？对于大小为`N`的数组，这将需要`log N`次。看看下面的图示：

![images/divide_and_conquer_code_in_turbo_mode/halvings.png](images/divide_and_conquer_code_in_turbo_mode/halvings.png)

正如你所见，对于大小为8的数组，我们需要三次二分，直到将数组缩减为八个单独的元素。这是`log N`，符合我们对`log N`的定义，即将某物二分直到达到1所需的次数。

所以这就是为什么`快速排序`需要`N * log N`步的原因。我们有`log N`次二分，每次二分时，对所有元素总和为`N`的子数组进行分区。（它们的总和为`N`是因为所有子数组只是原始`N`个元素数组的一部分。）

这在前面的图示中有所说明。例如，在图的顶部，我们将原始的八个元素的数组划分为两个大小为`4`的子数组。然后我们再将这两个大小为`4`的子数组进行划分，这意味着我们又一次在划分八个元素。

请记住，`O(N * log N)`只是一个近似值。实际上，我们首先对原始数组执行额外的`O(N)`划分。此外，一个数组并不能干净利落地分成两个相等的部分，因为枢轴并不参与划分。

这里是一个更现实的例子，我们在每次划分后忽略枢轴的情况：

![`images/divide_and_conquer_code_in_turbo_mode/realistic.png`](images/divide_and_conquer_code_in_turbo_mode/realistic.png)
