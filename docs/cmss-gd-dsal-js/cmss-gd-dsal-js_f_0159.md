## 堆删除

关于从堆中删除值的第一件事是我们只删除根节点。这与优先队列的工作方式相符，因为我们只访问和移除优先级最高的项目。

删除堆根节点的算法如下：

1.  将最后一个节点移动到根节点原本的位置，有效地删除原始根节点。

1.  将根节点向下漏水到它的合适位置。我会很快解释向下漏水是如何工作的。

假设我们要从 [`堆`](#fig.ch16.foundational_heap) 中移除根节点。

![`images/heaps/foundational_heap.png`](images/heaps/foundational_heap.png)

在这个例子中，根节点是 `100`。要删除它，我们用最后一个节点覆盖根节点。在这种情况下，最后一个节点是 `3`。所以我们移动 `3` 并将其放在 `100` 原本的位置：

![`images/heaps/move_3_to_root.png`](images/heaps/move_3_to_root.png)

现在，我们不能让堆保持不变，因为堆的条件被破坏了，`3` 目前小于它的一些（实际上是大多数）后代。为了让事情恢复正常，我们需要将 `3` 向下漏水，直到它的堆条件得到恢复。

向下漏水比向上漏水要复杂一些，因为每次我们将节点向下漏水时，有两个可能的方向可以选择；也就是说，我们可以将其与左子节点或右子节点交换。（而向上漏水时，每个节点只有一个父节点可以交换。）

下面是向下漏水的算法。为了清晰起见，我们将要漏水的节点称为“漏水节点”。（听起来很糟糕，我知道。）

1.  我们检查漏水节点的两个子节点，看看哪个更大。

1.  如果漏水节点小于两个子节点中更大的那个，我们将漏水节点与那个更大的子节点交换。

1.  我们重复步骤 1 和 2，直到漏水节点没有比它更大的子节点。

让我们看看这个过程。

步骤 1：`3` 是漏水节点，目前有两个子节点，`88` 和 `25`。`88` 是两者中更大的，鉴于 `3` 小于 `88`，我们将漏水节点与 `88` 交换：

![`images/heaps/swap_3_with_88.png`](images/heaps/swap_3_with_88.png)

步骤 2：当前的漏水节点有两个新子节点，`87` 和 `16`。`87` 是更大的一个，而且它大于漏水节点。因此我们将漏水节点与 `87` 交换：

![`images/heaps/swap_3_with_87.png`](images/heaps/swap_3_with_87.png)

步骤 3：漏水节点的子节点目前是 `86` 和 `50`。`86` 是两者中更大的，它也大于漏水节点，因此我们将 `86` 与漏水节点交换：

![`images/heaps/swap_3_with_86.png`](images/heaps/swap_3_with_86.png)

此时，`漏水节点` 没有任何大于它的子节点。（实际上，它根本没有子节点。）所以我们完成了，因为堆的条件已经恢复。

我们总是将下沉节点与两个子节点中较大的一个交换的原因是，如果我们与较小的一个交换，就会立即违反堆的性质。看看当我们尝试将下沉节点与较小的子节点交换时会发生什么。

让我们重新开始，将`3`作为我们的根节点：

![images/heaps/move_3_to_root.png](images/heaps/move_3_to_root.png)

让我们把`3`与`25`交换，后者是两个子节点中较小的一个：

![images/heaps/swap_3_with_25.png](images/heaps/swap_3_with_25.png)

我们现在将`25`放在一个父节点的位置，而它的子节点是`88`。由于`88`大于它的父节点，堆的性质被破坏了。

像插入一样，从堆中删除的时间复杂度是`O(log N)`，因为我们必须将一个节点从根部逐层下移，经过所有`log(N)`级别的堆。
