## 更改数据结构

另一个有帮助的优化技巧是想象如果我们将给定的数据存储在替代数据结构中会发生什么。

例如，我们可能正在处理一个问题，数据以数组的形式提供给我们。然而，重新构想将相同数据存储为哈希表、树或其他数据结构，有时可以揭示巧妙的优化机会。

我们之前使用哈希表进行神奇查找的例子就是一个具体实例。我们即将看到，改变数据结构在其他场景中也可能是有用的。

### 字母异位词检查器

这里有一个例子。假设我们正在编写一个函数，用于确定给定的两个字符串是否是彼此的字母异位词。我们在`[*字母异位词生成*](f_0109.xhtml#sect.anagram-generation)`中遇到过字母异位词函数，但那里的函数是生成字符串的所有字母异位词。在这里，我们只是并排比较两个字符串。如果它们是字母异位词，则返回`true`，否则返回`false`。

现在，我们可以使用字母异位词生成函数来解决这个问题；也就是说，我们可以生成第一个字符串的所有字母异位词，看看第二个字符串是否与其中任何一个字母异位词匹配。然而，由于对于字符串中的`N`个字符，总会有`N!`个字母异位词，我们的算法将至少需要`O(N!)`的时间。这是灾难性的慢。

你知道流程。在我们继续优化代码之前，需要提出我们能想象到的最佳大O表示法。

现在，我们当然需要至少访问一次两个字符串中的每个字符。由于输入字符串可能大小不同，仅触碰每个字符一次将是`O(N + M)`。因为我无法想象这个任务能更快的速度，所以这就是我们的目标。

理论上，我们可以在函数开头放一些代码，如果两个字符串大小不同，立即返回`false`，因为不同大小的字符串不可能是字母异位词。在这种情况下，我们的目标速度将是`2N`，因为算法只会处理大小相同的字符串。这将简化为`O(N)`。

然而，为了讨论的目的，我们将允许输入两个可能大小不同的字符串，因此我们的目标是`O(N + M)`。

让我们一步步来。

解决我们问题的第二种可能方法是运行嵌套循环来比较两个字符串。具体来说，外部循环遍历第一个字符串的每个字符时，我们将该字符与第二个字符串的每个字符进行比较。每次找到匹配时，我们从第二个字符串中删除一个字符。这里的想法是，如果第一个字符串的每个字符也出现在第二个字符串中，那么在完成外部循环时，我们将删除第二个字符串中的每个字符。

因此，如果在循环结束时，第二个字符串中仍然有字符，那么这意味着这两个字符串不是字母异位词。另外，如果我们还在迭代第一个单词，但已经删除了整个第二个字符串，这也意味着这两个字符串不是字母异位词。但是如果我们顺利到达循环末尾，并且第二个字符串已完全删除，我们可以得出结论：这两个字符串确实是字母异位词。

这是一个 JavaScript 实现：

| ​  | `function` areAnagrams(`firstString`, `secondString`) { |
| --- | --- |
| ​  | `const` `secondStringArray` = [...`secondString`]; |
| ​  |  |
| ​  | `for` (`let` i = 0; i < `firstString`.length; i += 1) { |
| ​  | `if` (`secondStringArray`.length === 0) { |
| ​  | `return` `false`; |
| ​  | } |
| ​  |  |
| ​  | `for` (`let` j = 0; j < `secondStringArray`.length; j += 1) { |
| ​  | `if` (`firstString`[i] === `secondStringArray`[j]) { |
| ​  | `secondStringArray`.splice(j, 1); |
| ​  | `break`; |
| ​  | } |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `return` `secondStringArray`.length === 0; |
| ​  | } |

现在，恰好在循环中删除数组中的项目可能会出错；如果你做错了，就像是在锯掉你坐着的树枝。但即使我们正确处理了这一点，我们的算法仍然运行在 O(`N` * `M`) 的时间复杂度上。这比 O(`N!`) 快得多，但比我们追求的 O(`N` + `M`) 要慢得多。

一种更快的方法是对两个字符串进行排序。如果排序后的两个字符串完全相同，则意味着它们是字母异位词；否则，它们就不是。

这种方法使用快速排序算法（如快速排序）对每个字符串的时间复杂度为 O(`N` log `N`)。由于我们可能有两个不同大小的字符串，这样总的时间复杂度将变为 O(`N` log `N` + `M` log `M`)。这比 O(`N` * `M`) 有了很好的改进，但我们不能就此停下——我们要追求 O(`N` + `M`)，记住了吗？

这时使用替代数据结构就非常有帮助。我们正在处理字符串，但我们可以想象将字符串数据存储在其他类型的数据结构中。

我们可以将字符串存储为单个字符的数组。但这对我们没有帮助。

接下来，让我们想象字符串作为哈希表。这看起来会是什么样子？

一种可能性是创建一个哈希表，其中每个字符都是一个键，值是该字符在单词中出现的次数。例如，字符串 `"balloon"` 的哈希表看起来像这样：

| ​  | {"b": 1, "a": 1, "l": 2, "o": 2, "n": 1} |
| --- | --- |

这个哈希表表明字符串中有一个 `"b"`，一个 `"a"`，两个 `"l"`，两个 `"o"`，和一个 `"n"`。

不过，这并没有告诉我们字符串的所有信息。具体来说，我们无法从哈希表中得知字符在字符串中的顺序。因此在这方面有些数据丢失。

然而，数据丢失正是我们需要的，这有助于我们确定两个字符串是否是异位词：如果两个字符串的每个字符的数量相同，无论顺序如何，它们就会是异位词。

以“rattles”、“startle”和“starlet”这几个单词为例。它们都有两个“t”、一个“a”、一个“l”、一个“e”和一个“s”——这就是使它们成为异位词的原因，并且可以轻松地重新排列成彼此。

我们现在可以编写一个算法，将每个字符串转换为一个哈希表，以统计每种字符的数量。一旦我们将两个字符串转换为两个哈希表，剩下的就是比较这两个哈希表。如果它们相等，这意味着这两个字符串是异位词。

下面是一个实现：

| ​  | `const` objectsEqual = (o1, o2) => Object.keys(o1).length |
| --- | --- |
| ​  | === Object.keys(o2).length && Object.keys(o1).every((p) => o1[p] === o2[p]); |
| ​  |  |
| ​  | `function` areAnagrams(firstString, secondString) { |
| ​  | `const` firstWordHashTable = {}; |
| ​  | `const` secondWordHashTable = {}; |
| ​  |  |
| ​  | `for` (`const` `char` `of` firstString) { |
| ​  | `if` (firstWordHashTable[`char`]) { |
| ​  | firstWordHashTable[`char`] += 1; |
| ​  | } `else` { |
| ​  | firstWordHashTable[`char`] = 1; |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `for` (`const` `char` `of` secondString) { |
| ​  | `if` (secondWordHashTable[`char`]) { |
| ​  | secondWordHashTable[`char`] += 1; |
| ​  | } `else` { |
| ​  | secondWordHashTable[`char`] = 1; |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `return` objectsEqual(firstWordHashTable, secondWordHashTable); |
| ​  | } |

在这个算法中，我们只需遍历两个字符串中的每个字符一次，总共是 `N + M` 步。

请注意，在代码的开头，我们包含了一个方便的 `objectsEqual` 函数，用于比较两个 JavaScript 对象（哈希表），并告诉我们它们在键和值方面是否相同。这最多需要另外 `N + M` 步，因为我们需要遍历哈希表中的每个键值对，以确保这些对在两个哈希表中都存在。然而，这总共只需 `2(N + M)` 步，简化为 `O(N + M)`。这比我们之前的任何方法都快得多。

公平地说，我们在创建这些哈希表时占用了额外的空间。如果我们在原地进行排序，之前建议的对两个字符串进行排序并比较的方法则不会占用额外空间。但如果速度是我们追求的目标，哈希表的方法是无与伦比的，因为我们只需遍历字符串中的每个字符一次。

通过将字符串转换为另一种数据结构（在这种情况下，哈希表），我们能够以一种方式访问原始数据，使我们的算法变得极其快速。

并不总是明显该使用什么新的数据结构，所以想象当前数据如果被转换成各种格式可能会是什么样子，这样可以看看是否能揭示出任何优化。话虽如此，哈希表通常是一个很好的选择，因此这是一个很好的起点。

### 分组排序

这是一个改变数据结构如何优化代码的另一个例子。假设我们有一个包含多种不同值的数组，我们想要重新排序数据，以便相同的值聚在一起。然而，我们并不一定关心这些组的顺序。

例如，假设我们有以下数组：

| ​  | ["a", "c", "d", "b", "b", "c", "a", "d", "c", "b", "a", "d"] |
| --- | --- |

我们的目标是将其分组，如下所示：

| ​  | ["c", "c", "c", "a", "a", "a", "d", "d", "d", "b", "b", "b"] |
| --- | --- |

再次强调，我们不关心组的顺序，因此这些结果也是可以接受的：

| ​  | ["d", "d", "d", "c", "c", "c", "a", "a", "a", "b", "b", "b"] |
| --- | --- |
| ​  | ["b", "b", "b", "c", "c", "c", "a", "a", "a", "d", "d", "d"] |

现在，任何经典的排序算法都能完成我们的任务，因为我们最终会得到：

| ​  | ["a", "a", "a", "b", "b", "b", "c", "c", "c", "d", "d", "d"] |
| --- | --- |

正如你所知，最快的排序算法的时间复杂度为 O(N log N)。但我们能做得更好吗？

让我们开始构思一个最佳的 Big O。由于我们知道通常没有比 O(N log N) 更快的排序算法，所以想象我们如何能在更短的时间内排序可能会很困难。

但由于我们并不是在进行精确排序，如果有人告诉我我们的任务可以在 O(N) 时间内完成，我想我会相信他们。我们当然不能超越 O(N)，因为我们至少需要访问每个值一次。所以我们就朝着 O(N) 的目标努力吧。

让我们运用我们讨论过的技术，并想象我们的数据以另一种数据结构的形式存在。

我们可以从哈希表开始。如果我们的字符串数组是一个哈希表，它会是什么样子？

如果我们采取类似于处理字谜的方式，我们可以用以下方式表示我们的数组：

| ​  | {`"a"`: 3, `"c"`: 3, `"d"`: 3, `"b"`: 3} |
| --- | --- |

与之前的例子一样，这里也有一些数据丢失：我们无法将这个哈希表转换回我们原来的数组，因为我们不知道所有字符串的原始顺序。

不过，出于分组的目的，这种数据丢失并不重要。实际上，哈希表包含了我们需要创建所需分组数组的所有数据。

具体来说，我们可以遍历哈希表中的每一个键值对，并使用这些数据填充一个包含每个字符串正确数量的数组。下面是这段代码：

| ​  | `function` groupSort(array) { |
| --- | --- |
| ​  | `const` hashTable = {}; |
| ​  | `const` newArray = []; |
| ​  |  |
| ​  | `for` ( `const` value `of` array) { |
| ​  | `if` (hashTable[value]) { |
| ​  | hashTable[value] += 1; |
| ​  | } `else` { |
| ​  | `hashTable[value] = 1;` |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `for` (`const` key `of` `Object.keys(hashTable)) {` |
| ​  | `const` count = `hashTable[key];` |
| ​  | `for` (`let` i = 0; i < `count`; i += 1) { |
| ​  | `newArray.push(key);` |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `return` `newArray`; |
| ​  | } |

我们的 `groupSort` 函数接受一个数组，然后开始创建一个空的 `hashTable` 和一个空的 `newArray`。

我们首先收集每个字符串的计数并将其存储在 `hashTable` 中：

| ​  | `for` (`const` value `of` `array`) { |
| --- | --- |
| ​  | `if` (`hashTable[value]`) { |
| ​  | `hashTable[value] += 1;` |
| ​  | } `else` { |
| ​  | `hashTable[value] = 1;` |
| ​  | } |
| ​  | } |

这会创建如下所示的 `hashTable`：

| ​  | `{` `"a"`: 3, `"c"`: 3, `"d"`: 3, `"b"`: 3} |
| --- | --- |

然后我们开始遍历每个键值对，利用这些数据填充 `newArray`：

| ​  | `for` (`const` key `of` `Object.keys(hashTable)) {` |
| --- | --- |
| ​  | `const` count = `hashTable[key];` |
| ​  | `for` (`let` i = 0; i < `count`; i += 1) { |
| ​  | `newArray.push(key);` |
| ​  | } |
| ​  | } |

所以当我们达到对 `"a"`: 3 的统计时，我们将三个 `"a"` 添加到 `newArray` 中。当我们达到 `"c"`: 3 时，我们将三个 `"c"` 添加到 `newArray` 中，依此类推。等到我们完成时，我们的 `newArray` 将包含所有分组的字符串。

该算法仅需 O(N) 的时间，这比排序所需的 O(N log N) 有显著的优化。我们确实使用了 O(N) 的空间来存储额外的 `hashTable` 和 `newArray`，尽管我们可以选择覆盖原始数组以节省额外的内存。也就是说，`hashTable` 占用的空间在最坏情况下仍将是 O(N)，当数组中的每个字符串都不同时。

但如果速度是我们的目标，我们达到了最佳的 Big O，这是一个了不起的胜利。
