## 空间复杂度的大O

有趣的是，计算机科学家使用大O符号来描述空间复杂度，就像他们描述时间复杂度一样。

当我在第三章介绍大O符号时，[*O Yes! 大O符号*](f_0031.xhtml#chp.big_o_notation)，我通过我所称之为“关键问题”来描述大O。对于时间复杂度，关键问题是：如果有`N`个数据元素，算法将需要多少步？

为了使用大O表示空间复杂度，我们只需重新框定关键问题。当涉及到内存消耗时，关键问题变成：如果有`N`个数据元素，算法将消耗多少单位的内存？

这是一个简单的例子。

假设我们正在编写一个接受字符串数组并返回该数组所有字符串为大写的函数。例如，该函数接受数组`["tuvi", "leah", "shaya", "rami", "yechiel"]`，并返回`["TUVI", "LEAH", "SHAYA", "RAMI", "YECHIEL"]`。以下是我们可以编写该函数的一种方式：

| ​  | `function` makeUppercase(array) { |
| --- | --- |
| ​  | `const` newArray = []; |
| ​  |  |
| ​  | `for` (`const` string `of` array) { |
| ​  | `newArray.push(string.toUpperCase());` |
| ​  | `}` |
| ​  |  |
| ​  | `return` newArray; |
| ​  | `}` |

在这个`makeUppercase`函数中，我们接受一个数组。然后我们创建一个全新的数组`newArray`，并用原数组中每个字符串的大写版本填充它。

当这个函数完成时，我们的计算机内存中将有两个数组。我们有原始数组，它包含`["tuvi", "leah", "shaya", "rami", "yechiel"]`，还有`newArray`，它包含`["TUVI", "LEAH", "SHAYA", "RAMI", "YECHIEL"]`。

当我们从空间复杂度的角度分析这个函数时，可以看到这个函数创建了一个包含`N`个元素的全新数组。这是除了原始数组外的额外开销，原始数组也包含`N`个元素。

所以让我们回到我们的关键问题：如果有`N`个数据元素，算法将消耗多少单位的内存？

因为我们的函数生成了额外的`N`个数据元素（以`newArray`的形式），所以我们会说这个函数的空间效率是`O(N)`。

在以下图表中，这种表现方式应该很熟悉：

![images/dealing_with_space_constraints/space_graph.png](images/dealing_with_space_constraints/space_graph.png)

请注意，这个图表与我们在前几章中描绘的`O(N)`图表是相同的，唯一的例外是垂直轴现在表示消耗的内存，而不是时间。

现在，让我们展示一个更节省内存的`makeUppercase`函数：

| ​  | `function` makeUppercase(array) { |
| --- | --- |
| ​  | `for` (`let` index = 0; index < array.length; index += 1) { |
| ​  | `array[index] = array[index].toUpperCase();` |
| ​  | `}` |
| ​  |  |
| ​  | `return` array; |
| ​  | `}` |

在这个第二个版本中，我们不创建任何新的数组。相反，我们直接在原始数组中修改每个值，用该字符串的 uppercase 版本替换每个字符串。然后我们返回修改后的数组。

从内存消耗的角度来看，这是一个显著的改进，因为我们新的函数根本不消耗任何额外内存。

我们如何用 `Big O` 符号来描述这一点呢？

回想一下，在时间复杂度中，`O(1)` 的算法是指无论数据多大，其速度保持不变。同样，在空间复杂度中，`O(1)` 意味着算法消耗的内存在数据大小变化时是恒定的。

我们修订后的 `makeUppercase` 函数在原始数组包含四个元素或一百个元素时，消耗的额外空间是一个恒定的量（零！）。因此，这个函数被认为具有 `O(1)` 的空间效率。

值得强调的是，在使用 `Big O` 描述空间复杂度时，我们只计算算法生成的新数据。即使我们的第二个 `makeUppercase` 函数处理 `N` 个元素的数据，这些数据以传入函数的数组形式存在。然而，我们并没有将这些 `N` 个元素纳入我们的 `Big O` 描述，因为原始数组无论如何都是存在的，我们只关注算法消耗的额外空间。这额外的空间更正式地称为辅助空间。

然而，值得注意的是，有些参考文献在计算空间复杂度时会包括原始输入，这也是可以的。我们没有包括它，每当你看到其他资源中描述空间复杂度时，你需要判断它是否包括原始输入。

现在我们来比较两个 `makeUppercase` 版本在时间和空间复杂度上的表现：

| 版本 | 时间复杂度 | 空间复杂度 |
| --- | --- | --- |
| 版本 #1 | `O(N)` | `O(N)` |
| 版本 #2 | `O(N)` | `O(1)` |

两个版本的时间复杂度都是 `O(N)`，因为它们对 `N` 个数据元素需要 `N` 步。然而，第二个版本在内存使用上更为高效，相较于第一个版本的 `O(N)`，它的空间复杂度是 `O(1)`。

结果是，版本 #2 在空间上比版本 #1 更高效，同时没有牺牲任何速度，这是一个不错的胜利。
