## 魔法查找

我最喜欢的优化技巧之一是问自己：“如果我可以在 `O(1)` 时间内魔法般地找到所需的信息，我能让我的算法更快吗？”如果答案是肯定的，我会使用一种数据结构（通常是哈希表）来实现这种魔法。我称这种技术为“魔法查找”。

让我用一个例子来澄清这种技术。

### 魔法查找作者

假设我们正在编写图书馆软件，关于书籍和其作者的数据分别包含在两个单独的数组中。

特别地，作者数组看起来像这样：

| ​  | `const` authors = [ |
| --- | --- |
| ​  | `{ authorId: 1, name: '弗吉尼亚·伍尔夫' }, |
| ​  | `{ authorId: 2, name: '列夫·托尔斯泰' }, |
| ​  | `{ authorId: 3, name: '苏斯博士' }, |
| ​  | `{ authorId: 4, name: 'J.K.罗琳' }, |
| ​  | `{ authorId: 5, name: '马克·吐温' }, |
| ​  | `]; |

如你所见，这是一个哈希表的数组，每个哈希表包含一个作者的姓名和ID。

我们还有一个单独的数组，包含有关书籍的数据：

| ​  | `const` books = [ |
| --- | --- |
| ​  | `{ authorId: 3, title: 'Hop on Pop' }, |
| ​  | `{ authorId: 1, title: '达洛维夫人' }, |
| ​  | `{ authorId: 4, title: '哈利·波特与魔法石' }, |
| ​  | `{ authorId: 1, title: '到灯塔去' }, |
| ​  | `{ authorId: 2, title: '安娜·卡列尼娜' }, |
| ​  | `{ authorId: 5, title: '汤姆·索亚历险记' }, |
| ​  | `{ authorId: 3, title: '帽子里的猫' }, |
| ​  | `{ authorId: 2, title: '战争与和平' }, |
| ​  | `{ authorId: 3, title: '绿鸡蛋和火腿' }, |
| ​  | `{ authorId: 5, title: '哈克贝里·费恩历险记' }, |
| ​  | `]; |

像作者数组一样，书籍数组包含多个哈希表。每个哈希表包含一本书的标题和 `authorId`，这使我们可以使用作者数组中的数据来确定书籍的作者。例如，“Hop on Pop”的 `authorId` 是3。这意味着“Hop on Pop”的作者是 `苏斯博士`，因为他的ID是3，如作者数组所示。

现在，假设我们想编写代码，将这些信息组合在一起，以创建以下格式的数组：

| ​  | `const` booksWithAuthors = [ |
| --- | --- |
| ​  | `{ author: '苏斯博士', title: 'Hop on Pop' }, |
| ​  | `{ author: '弗吉尼亚·伍尔夫', title: '达洛维夫人' }, |
| ​  | `{ author: 'J.K.罗琳', title: '哈利·波特与魔法石' }, |
| ​  | `{ author: '弗吉尼亚·伍尔夫', title: '到灯塔去' }, |
| ​  | `{ author: '列夫·托尔斯泰', title: '安娜·卡列尼娜' }, |
| ​  | `{ author: '马克·吐温', title: '汤姆·索亚历险记' }, |
| ​  | `{ author: '苏斯博士', title: '帽子里的猫' }, |
| ​  | `{ author: '列夫·托尔斯泰', title: '战争与和平' }, |
| ​  | `{ author: '苏斯博士', title: '绿鸡蛋和火腿' }, |
| ​  | { author: `'马克·吐温'`, title: `'哈克贝里·费恩历险记' }, |
| ​  | ]; |

-   为此，我们可能需要遍历书籍数组，并将每本书连接到其相应的作者。我们具体该如何进行呢？

-   一个解决方案可能是使用嵌套循环。外循环将遍历每本书，对于每本书，我们将运行一个内循环，检查每个作者，直到找到连接 ID 的那个。以下是这种方法的实现：

| ​  | `function` connectBooksWithAuthors(books, authors) { |
| --- | --- |
| ​  | `const` booksWithAuthors = []; |
| ​  |  |
| ​  | `for` (`const` book `of` books) { |
| ​  | `for` (`const` author `of` authors) { |
| ​  | `if` (book.authorId === author.authorId) { |
| ​  | booksWithAuthors.push({ title: book.title, author: author.name }); |
| ​  | } |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `return` booksWithAuthors; |
| ​  | } |

-   在我们能够优化代码之前，我们需要满足我们的前提条件，并确定当前算法的 Big O。

-   这个算法的时间复杂度是 O(N * M)，因为对于每本 N 本书，我们需要遍历 M 个作者以找到书的作者。

-   现在，让我们看看是否能做得更好。

-   首先我们需要做的就是想出最佳的 Big O。在这种情况下，我们绝对需要遍历所有 N 本书，因此似乎不可能超越 O(N)。由于 O(N) 是我能想到的最快速度，而且并不完全不可能，我们可以说 O(N) 是我们设想的最佳 Big O。

-   我们现在准备使用新的神奇查找技巧。为此，我会问自己本节开头提到的问题：“如果我能以 O(1) 的时间神奇地找到所需的信息，我能否让我的算法更快？”

-   让我们将其应用到我们的场景中。我们当前运行一个外循环，遍历所有书籍。目前，对于每本书，我们运行一个内循环，尝试在作者数组中找到该书的 authorId。

-   但如果我们拥有以 O(1) 的时间找到作者的魔法能力会怎样？如果我们每次想查找一个作者时，不必遍历所有作者，而是能够立即找到该作者？那将为我们的算法带来巨大的速度提升，因为我们可能会消除内循环，并将代码的速度提升到令人称道的 O(N)。

-   现在我们已经确定这个神奇的查找能力可以帮助我们，下一步是尝试让这项魔法活起来。

### -   引入额外的数据结构

-   我们可以实现这种神奇查找能力的最简单方法之一是将额外的数据结构引入我们的代码。我们将使用这个数据结构以特定方式存储数据，从而使我们能够快速查找该数据。在许多情况下，哈希表是完美的数据结构，因为它具有 O(1) 的查找速度，正如你在第 8 章中学到的，[*哈希表的快速查找*](f_0076.xhtml#chp.hashes)。

现在，由于作者哈希表存储在数组中，查找任何给定的 `authorId` 始终需要 `O(M)` 步（`M` 为作者的数量）。但如果我们将相同的信息存储在哈希表中，我们就能获得在仅 `O(1)` 时间内找到每位作者的神奇能力。

这是这个哈希表可能的样子：

| ​  | `authorHashTable =` |
| --- | --- |
| ​  | `{1: 'Virginia Woolf', 2: 'Leo Tolstoy', 3: 'Dr. Seuss',` |
| ​  | `4: 'J. K. Rowling', 5: 'Mark Twain'}` |

在这个哈希表中，每个键是作者的 ID，每个键的值是作者的姓名。

所以让我们通过首先将作者数据移入这个哈希表，然后再运行我们的书籍循环来优化算法：

| ​  | `function connectBooksWithAuthors(books, authors) {` |
| --- | --- |
| ​  | `const booksWithAuthors = [];` |
| ​  | `const authorHashTable = {};` |
| ​  |  |
| ​  | `for (const author of authors) {` |
| ​  | `authorHashTable[author.authorId] = author.name;` |
| ​  | `}` |
| ​  |  |
| ​  | `for (const book of books) {` |
| ​  | `booksWithAuthors.push({` |
| ​  | `title: book.title,` |
| ​  | `author: authorHashTable[book.authorId]` |
| ​  | `});` |
| ​  | `}` |
| ​  |  |
| ​  | `return booksWithAuthors;` |
| ​  | `}` |

在这个版本中，我们首先遍历作者数组，并使用这些数据创建 `authorHashTable`。这需要 `M` 步，`M` 是作者的数量。

然后我们遍历书籍列表，并使用 `authorHashTable` “神奇”地在一步中找到每位作者。这个循环需要 `N` 步，`N` 是书籍的数量。

这个优化后的算法总共需要`O(N + M)`步，因为我们对`N`本书进行一次循环，对`M`个作者进行一次循环。这比我们原来的算法快得多，原算法需要`O(N * M)`。

值得注意的是，通过创建额外的哈希表，我们使用了额外的`O(M)`空间，而我们最初的算法根本没有占用任何额外空间。然而，如果我们愿意为了速度牺牲内存，这就是一个很好的优化。

我们通过首先想象神奇的`O(1)`查找能为我们做些什么，然后通过使用哈希表以易于查找的方式存储数据来实现这个魔法。

我们能够在`O(1)`时间查找哈希表数据并不是新鲜事，因为我们在第8章[*使用哈希表的极速查找*](f_0076.xhtml#chp.hashes)中讨论过这个。不过，我在这里分享的具体提示是要不断想象你可以对任何类型的数据执行`O(1)`查找，并注意这是否会加速你的代码。一旦你有了如何利用`O(1)`查找的视野，你就可以尝试使用哈希表或其他数据结构将这个梦想变为现实。

### 两数之和问题

让我们看看另一个我们可以从神奇查找中受益的场景。这是我最喜欢的优化示例之一。

`two sum`问题是一个众所周知的编码练习。任务是编写一个`function`，接受一个数字`array`并返回`true`或`false`，具体取决于`array`中是否有两个数字加起来为`10`（或另一个给定数字）。为简便起见，假设`array`中不会有重复数字。

假设这是我们的`array`：

| ​  | [2, 0, 4, 1, 7, 9] |
| --- | --- |

我们的`function`将返回`true`，因为`1`和`9`加起来为`10`。

但让我们看看以下的`array`：

| ​  | [2, 0, 4, 5, 3, 9] |
| --- | --- |

在这种情况下，我们返回`false`。尽管三个数字`2`、`5`和`3`加起来是`10`，但我们特别需要两个数字加起来为`10`。

我们想到的第一个解决方案是使用嵌套循环将每个数字与其他每个数字进行比较，看看它们是否加起来为`10`。下面是一个JavaScript实现：

| ​  | ​`function`​ `twoSum`(`array`) { |
| --- | --- |
| ​  | ​`for`​ (`let` i = 0; i < `array.length`; i += 1) { |
| ​  | ​`for`​ (`let` j = 0; j < `array.length`; j += 1) { |
| ​  | ​`if`​ (i !== j && `array[i]` + `array[j]` === `10`) { |
| ​  | ​`return`​ ​`true`; |
| ​  | } |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | ​`return`​ ​`false`; |
| ​  | } |

一如既往，在尝试优化之前，我们需要满足我们的前提条件，并弄清楚我们代码的当前`Big O`。

像嵌套循环算法中典型的情况一样，这个`function`的运行时间为`O(N²)`。

接下来，为了看看我们的算法是否值得优化，我们需要看看最理想的`Big O`是否会更好。

在这种情况下，似乎我们必须至少访问一次`array`中的每个数字。所以，我们无法超过`O(N)`。如果有人告诉我这个问题有一个`O(N)`的解决方案，我想我会相信他们。因此，让我们将`O(N)`视为我们能想象的最佳`Big O`。

现在，让我们问自己一个神奇的查找问题：“如果我可以在`O(1)`时间内神奇地找到所需的信息，我能让我的算法更快吗？”

有时，边走边检查我们当前的实现会有所帮助，所以让我们这样做。

让我们心里走过我们的外部循环，使用`array`示例`[2, 0, 4, 1, 7, 9]`。这个循环以第一个数字开始，也就是数字`2`。

现在，我们在查看`2`时可能想要查找什么信息？再一次，我们想知道这个`2`是否可以与`array`中的另一个数字相加得到`10`。

更进一步思考，当查看`2`时，我想知道这个数组中是否有一个`8`。如果我们能够神奇地在`O(1)`时间内查找并知道数组中有一个`8`，我们就可以立即返回`true`。我们将`8`称为`2`的对应数，因为这两个数字相加得到`10`。

同样，当我们移动到`0`时，我们想要进行一次`O(1)`查找，以在数组中找到它的对应数`10`，依此类推。

通过这种方法，我们可以仅遍历一次数组，并在此过程中进行神奇的`O(1)`查找，以查看每个数字的对应数是否存在于数组中。只要我们找到任何数字的对应数，就返回`true`，但如果我们到达数组的末尾而没有找到任何数字对应数，则返回`false`。

现在我们已经确定这些神奇的`O(1)`查找会带来好处，让我们试着通过引入一个额外的数据结构来施展我们的魔法。再次强调，哈希表通常是进行魔法查找的默认选项，因为它的读取时间是`O(1)`。（哈希表加速算法的效果简直让人惊讶。）

由于我们希望能够在`O(1)`时间内查找数组中的任何数字，因此我们将这些数字作为键存储在哈希表中。哈希表可能如下所示：

| ​  | `{2: true, 0: true, 4: true, 1: true, 7: true, 9: true}` |
| --- | --- |

我们可以使用任何任意项作为值；让我们决定使用`true`。

现在我们可以在`O(1)`时间内查找任何数字，我们如何查找数字的对应数？我们注意到，当我们迭代`2`时，我们知道对应数应该是`8`。我们之所以知道这一点，是因为我们直觉上知道`2 + 8 = 10`。

实质上，我们可以通过将某个数字从10中减去来计算它的对应数。因为`10 - 2 = 8`，这意味着`8`是`2`的对应数。

我们现在拥有创建一个非常快速的算法所需的所有元素：

| ​  | ​`function`​ `twoSum(array)` { |
| --- | --- |
| ​  | ​`const`​ `hashTable` = {}; |
| ​  |  |
| ​  | ​`for`​ (`​`​`const`​ `value` ​`of`​ `array`) { |
| ​  | ​`if`​ (`hashTable[10 - value]`) { |
| ​  | ​`return`​ ​`true`; |
| ​  | } ​`else`​ { |
| ​  | `hashTable[value]` = ​`true`; |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | ​`return`​ ​`false`; |
| ​  | } |

该算法仅遍历数组中的每个数字一次。

当我们访问每个数字时，我们检查哈希表中是否包含当前数字的对应数作为键。我们将其计算为`10 - value`。（例如，如果`value`是`3`，对应数将是`7`，因为`10 - 3 = 7`。）

如果我们找到任何数字的对应数，我们立即返回`true`，这意味着我们找到了两个加起来等于10的数字。

此外，当我们遍历每个数字时，我们将数字作为键插入哈希表。这就是我们在遍历数组时填充哈希表的方法。

通过这种方法，我们将算法的速度大幅提高到`O(N)`。我们通过将所有数据元素存储在一个哈希表中来实现这一点，目的是在循环中能够执行`O(1)`查找。

把哈希表视为你的魔法棒，成为你注定要成为的编程巫师。（好吧，够了。）
