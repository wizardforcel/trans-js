## `哈希表查找`

当我们从哈希表中查找项目时，我们使用一个键来查找其关联的值。让我们看看在我们的 `Quickasaurus` 示例哈希表中这是如何工作的。

假设我们想查找与键 `"bad"` 关联的值。在我们的代码中，我们会这样写：

| ​ | `thesaurus["bad"]` |
| --- | --- |

要查找与 `"bad"` 关联的值，计算机执行两个简单步骤：

1.  计算机对我们要查找的键进行哈希：`BAD = 2 * 1 * 4 = 8`。

1.  由于结果是 `8`，计算机查看单元格 `8` 并返回存储在那里值。在这种情况下，就是字符串 `"evil"`。

让我们退一步，从整体上看这个问题。在哈希表中，每个值的位置由其键决定；也就是说，通过对键本身进行哈希，我们计算出键的关联值应该放置的索引号。

因为键决定值的位置，所以我们利用这个原则使查找变得轻而易举。当我们有任何键并想要查找其值时，键本身会告诉我们值将在哪里找到。正如我们对键进行了哈希以将值插入适当的单元格，我们可以再次对键进行哈希，以找到我们之前放置该值的位置。

现在变得清楚为什么在哈希表中查找一个值通常是 O(1)：这是一个需要恒定时间的过程。计算机对键进行哈希，将其转换为一个数字，然后跳到那个数字对应的索引以检索存储在那里值。

现在我们可以理解为什么哈希表在查找餐厅菜单时比数组更快。当我们查找菜单项的价格时，如果使用数组，我们需要逐个检查每个单元格，直到找到它。对于无序数组，这可能需要 O(N) 的时间，对于有序数组，这可能需要 O(log N)。然而，使用哈希表时，我们可以将实际菜单项用作键，从而使查找变为 O(1)。这就是哈希表的魅力所在。

### `单向查找`

重要的是要指出，能够在哈希表中以单步找到任何值的能力仅在我们知道值的键时才有效。如果我们试图在不知道其键的情况下找到特定值，我们仍然必须遍历哈希表中的每一个键值对，这将是 O(N)。

同样，当使用键查找值时，我们才能进行 O(1) 的查找。另一方面，如果我们想使用一个值来查找其关联的键，就无法利用哈希表的快速查找能力。

这是因为哈希表的整个前提是键决定值的位置。但这个前提只在一个方向上有效：我们使用键来查找值。如果我们手中只有一个值，想要找到其对应的键，我们就没有办法快速访问那个键。我们只能遍历整个哈希表来寻找这个键，因为值并没有提供任何关于其键或我们可以在哪里找到它的信息。

想想看，键存储在哪里？在之前的图示中，我们只看到了值如何存储在`hash table`中。

虽然这个细节可能因语言而异，但某些语言会将键存储在值本身旁边。这在发生冲突时非常有用，我将在下一节中讨论这个问题。

无论如何，值得注意的是`hash table`的单向特性。每个键在`hash table`中只能存在一次，但一个值可以有多个实例。

如果我们回想本章开头的菜单示例，我们不能将`hamburger`列出两次（我们也不希望这样，因为它只有一个价格）。然而，我们可以有多个价格为`$2.50`的食物。

在许多语言中，如果我们尝试存储一个已经存在的键值对，它会简单地覆盖旧值，同时保持相同的键。
