## 第 `19` 章

这些是位于[`练习`](f_0194.xhtml#dealing.with.space.constraints.exercises)部分的习题解决方案。

1.  空间复杂度为 `O(N²`。这是因为该函数创建了一个名为 `collection` 的数组，最终将包含 `N²` 个字符串。

1.  该实现占用 `O(N)` 空间，因为我们创建了一个包含 `N` 项的 `newArray`。

1.  以下实现使用此算法：我们原地交换第一个项与最后一个项。然后，我们原地交换第二个项与倒数第二个项。接着，我们继续交换第三个项与倒数第三个项，依此类推。由于一切都在原地进行，且我们没有创建任何新数据，因此其空间复杂度为 `O(1)`。

|  | `function` reverse(array) { |
| --- | --- |
|  | `let` i = `0`; |
|  |  |
|  | `while` (i < `Math.floor(array.length / 2)`) { |
|  | `const` mirrorOfI = `array.length - 1 - i`; |
|  | `[array[i], array[mirrorOfI]] = [array[mirrorOfI], array[i]]; |
|  |  |
|  | i += `1`; |
|  | } |
|  |  |
|  | `return` array; |
|  | } |

（虽然 JavaScript 在底层可能会创建一个临时变量来完成每次交换，但在算法执行期间，我们从未在任何时刻存储超过那一块数据。）

1.  这是完成的表格：

    | 版本 | 时间复杂度 | 空间复杂度 |
    | --- | --- | --- |
    | 版本 `#1` | `O(N)` | `O(N)` |
    | 版本 `#2` | `O(N)` | `O(1)` |
    | 版本 `#3` | `O(N)` | `O(N)` |

    所有三个版本的运行步骤与数组中的数字数量相同，因此它们的时间复杂度都是 `O(N)`。

    版本 `#1` 创建了一个全新的数组来存储双倍的数字。这个数组将与原始数组具有相同的长度，因此占用 `O(N)` 空间。

    版本 `#2` 原地修改原始数组，因此占用零额外空间。这表示为 `O(1)`。

    版本 `#3` 也会原地修改原始数组。然而，由于该函数是递归的，在其高峰时调用栈将有 `N` 次调用，占用 `O(N)` 空间。
