## 计算 `1` 的数量

这是另一个算法，其 Big O 与初看似乎不同。该函数接受一个数组的数组，内部数组包含 `1` 和 `0`。然后，函数返回 `1` 的数量。

所以看看这个示例输入：

| ​  | `[ |
| --- | --- |
| ​  | `[0, 1, 1, 1, 0]`， |
| ​  | `[0, 1, 0, 1, 0, 1]`， |
| ​  | `[1, 0]` |
| ​  | ] |

我们的函数将返回 `7`，因为有七个 `1`。

这是函数：

| ​  | `function` countOnes(outerArray) { |
| --- | --- |
| ​  | `let` count = 0; |
| ​  |  |
| ​  | `for` (`const` innerArray `of` outerArray) { |
| ​  | `for` (`const` number `of` innerArray) { |
| ​  | `if` (number === `1`) { |
| ​  | `count` += 1; |
| ​  | } |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `return` `count`; |
| ​  | } |

这个算法的 Big O 是什么？

再次，我们很容易注意到嵌套循环，并得出结论它是 `O(N²)`。然而，这两个循环是在遍历完全不同的内容。

外层循环遍历内部数组，而内层循环遍历实际的数字。最终，我们的内层循环只会运行与总数字数量相等的次数。

因此，我们可以说 `N` 代表有多少个数字。由于我们的算法仅仅处理每个数字，函数的时间复杂度是 `O(N)`。
