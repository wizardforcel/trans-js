## `Big O`: 与`N`个元素相关的步骤数？

`Big O`通过关注算法所需步骤的数量，但以特定方式实现一致性。让我们开始将`Big O`应用于线性搜索的算法。

在最坏情况下，线性搜索将需要与数组中的元素数量一样多的步骤。正如我们之前所说的：对于数组中的`N`个元素，线性搜索最多可以需要`N`步。用`Big O`符号恰当地表达这一点是：

`O(N)`

有人读作“Big Oh of N”。其他人称其为“Order of N”。不过，我个人更喜欢称其为“哦的N”。

这里的符号表示的意义是它表达了我们称之为关键问题的答案。关键问题是这样的：如果有`N`个数据元素，算法将需要多少步？请再读一遍这句话。然后，把它铭记于心，因为这就是我们在本书中将使用的`Big O`符号的定义。

关键问题的答案在我们`Big O`表达式的括号内。`O(N)`表示关键问题的答案是算法将需要`N`步。

让我们快速回顾一下用`Big O`符号表达时间复杂度的思路，再次使用线性搜索的例子。首先，我们问关键问题：如果数组中有`N`个数据元素，线性搜索将需要多少步？因为这个问题的答案是线性搜索将需要`N`步，我们将其表示为`O(N)`。顺便说一下，`O(N)`的算法也被称为线性时间。

让我们对比一下`Big O`如何表达从标准数组读取的效率。正如你在第1章[*为什么数据结构很重要*](f_0013.xhtml#chp.understanding_data_structures)中学到的，从数组读取只需一步，无论数组多大。为了找出如何用`Big O`术语表达这一点，我们再次问关键问题：如果有`N`个数据元素，从数组中读取需要多少步？答案是读取只需一步。因此我们将其表示为`O(1)`，我读作“哦的一”。

`O(1)`是有趣的，因为尽管我们关键的问题围绕着`N`（“如果有`N`个数据元素，算法会执行多少步？”），答案与`N`无关。这实际上就是重点：无论数组有多少元素，从数组中读取总是只需一步。

这就是为什么`O(1)`被认为是“最快”的算法类型。即使数据增加，`O(1)`算法也不需要额外的步骤。无论`N`是多少，算法始终只需固定的步数。实际上，`O(1)`算法也可以被称为恒定时间。

那么，数学在哪里？

正如我在本书前面提到的，我采用了一种易于理解的方式来讲解`Big O`这个主题。这并不是唯一的方式；如果你参加传统的大学算法课程，你可能会从数学的角度了解`Big O`。`Big O`最初是一个数学概念，因此通常以数学术语描述。例如，描述`Big O`的一种方式是，它描述了函数增长率的上界，或者说如果一个函数`g(x)`的增长速度不超过另一个函数`f(x)`，那么`g`被称为`O(f)`的成员。根据你的数学背景，这要么有意义，要么帮助不大。我写这本书是为了让你在理解这一概念时不需要太多的数学。如果你想更深入了解`Big O`背后的数学，可以参考`Thomas H. Cormen`、`Charles E. Leiserson`、`Ronald L. Rivest`和`Clifford Stein`的《算法导论》（`MIT Press, 2009`）以获取全面的数学解释。`Justin Abrahms`在他的文章中也提供了一个相当不错的定义：[`https://justin.abrah.ms/computer-science/understanding-big-o-formal-definition.html`](https://justin.abrah.ms/computer-science/understanding-big-o-formal-definition.html)。
