## 楼梯问题

你现在已经学会了使用新的思维策略，通过自顶向下的递归来解决某些计算问题。然而，你可能仍然持怀疑态度，问道：“我们为什么需要这种新的思维策略？到目前为止，我一直能用循环很好地解决这些问题。”

事实上，对于更简单的计算，你可能不需要新的思维策略。但在面对更复杂的函数时，你可能会发现递归思维使得代码的编写变得容易得多。对我来说确实是这样的！

这是我最喜欢的例子之一。一个著名的问题——称为楼梯问题——是这样的：

假设我们有一个`N`级楼梯，一个人可以一次爬一步、两步或三步。有人可以采取多少种不同的“路径”到达顶部？写一个函数来计算`N`级楼梯的路径。下图显示了跳跃五级楼梯的三种可能路径。

![images/learning_to_write_in_recursive/staircase.png](images/learning_to_write_in_recursive/staircase.png)

这些只是许多可能路径中的三条。

让我们首先用自底向上的方法来探讨这个问题。也就是说，我们将从最简单的情况逐步上升到更复杂的情况。

显然，如果只有一步，就只有一条可能的路径。

有两步时，有两条路径。人可以两次爬一步，或者人可以一次跳两步。我将这样写：

| ​  | `1, 1` |
| --- | --- |
| ​  | `2` |

对于三步楼梯，有人可以选择四条可能的路径之一：

| ​  | `1, 1, 1` |
| --- | --- |
| ​  | `1, 2` |
| ​  | `2, 1` |
| ​  | `3` |

四步楼梯有七种选择：

| ​  | `1, 1, 1, 1` |
| --- | --- |
| ​  | `1, 1, 2` |
| ​  | `1, 2, 1` |
| ​  | `1, 3` |
| ​  | `2, 1, 1` |
| ​  | `2, 2` |
| ​  | `3, 1` |

试着列出所有可能的五级楼梯组合。可不容易！这才只有五步。想象一下，假设有十一步，会有多少组合。

现在，让我们来谈谈手头的问题：我们该如何编写代码来计算所有路径？

没有递归思维模式，理解这个算法来进行计算可能会很困难。然而，通过自顶向下的思维方式，问题会变得意外简单。

对于一个十一级楼梯，首先想到的子问题是十级楼梯。我们就先这样假设。如果我们知道爬十级楼梯有多少条可能的路径，是否可以将其作为计算十一级楼梯路径的基础？

首先，我们知道，爬一个十一级的楼梯至少需要和爬十级楼梯一样多的步骤。也就是说，我们有到达第`10`级的所有路径，然后可以再爬一步到达顶部。

然而，这不能算是完整的解决方案，因为我们知道，有人也可以从第`9`级和第`8`级直接跳到顶部。

如果我们进一步思考，就会意识到，如果你走的路径包含从楼梯10到楼梯11的移动，那么你就不会走包含从楼梯9到楼梯11的路径。反之亦然，如果你从楼梯9跳到楼梯11，你就不会走包含踩踏楼梯10的路径。

因此我们知道到达顶部的路径数量至少包括到达楼梯10和楼梯9的路径数量。

由于可以从楼梯8跳到楼梯11，因为人可以一次跳三步，我们还需要包括这些路径的数量。

我们已经确定，到达顶部的步骤至少是楼梯10、9和8的所有路径数量之和。

然而，进一步思考后，很明显没有其他可能的路径到达顶部。毕竟，人不能从楼梯7跳到楼梯11。因此，我们可以得出结论，对于N步，路径的数量如下：

| ​  | `numberOfPaths(n - 1) + numberOfPaths(n - 2) + numberOfPaths(n - 3)` |
| --- | --- |

除了基本情况，这将是我们函数的代码！

| ​  | `function` numberOfPaths(n) { |
| --- | --- |
| ​  | `return` (`numberOfPaths(n - 1)` |
| ​  | + `numberOfPaths(n - 2)` |
| ​  | + `numberOfPaths(n - 3)`); |
| ​  | } |

看起来这几乎是我们所需的所有代码，但这是真的。剩下的就是处理基本情况。

### 楼梯问题基本情况

确定这个问题的基本情况有点棘手。这是因为当这个函数达到n为3、2或1时，函数将会在n为0或以下时调用自己。例如，`numberOfPaths(2)`会调用自己`numberOfPaths(1)`、`numberOfPaths(0)`和`numberOfPaths(-1)`。

我们可以通过硬编码所有底部情况来处理这个问题：

| ​  | `function` numberOfPaths(n) { |
| --- | --- |
| ​  | `if` (n <= 0) { |
| ​  | `return` 0; |
| ​  | } `else` `if` (n === 1) { |
| ​  | `return` 1; |
| ​  | } `else` `if` (n === 2) { |
| ​  | `return` 2; |
| ​  | } `else` `if` (n === 3) { |
| ​  | `return` 4; |
| ​  | } |
| ​  |  |
| ​  | `return` (`numberOfPaths(n - 1)` |
| ​  | + `numberOfPaths(n - 2)` |
| ​  | + `numberOfPaths(n - 3)`); |
| ​  | } |

另一种设计基本情况的方法是通过使用奇怪但有效的基本情况巧妙地调整系统，这些情况恰好能够计算出正确的数字。让我来给你展示我所指的。

我们知道我们确实想要`numberOfPaths(1)`的结果为1，因此我们将从以下基本情况开始：

| ​  | `if` (n === 1) { |
| --- | --- |
| ​  | `return` 1; |
| ​  | } |

现在，我们知道我们想要`numberOfPaths(2)`返回2，但我们不需要明确创建那个基本情况。相反，我们可以利用`numberOfPaths(2)`将计算为`numberOfPaths(1) + numberOfPaths(0) + numberOfPaths(-1)`的事实。由于`numberOfPaths(1)`返回1，如果我们让`numberOfPaths(0)`也返回1，而`numberOfPaths(-1)`返回0，那么我们将得到和为2，这正是我们想要的。

所以我们可以添加以下基本情况：

| ​  | `if` (n < 0) { |
| --- | --- |
| ​  | `return` 0; |
| ​  | } `else` `if` (n === 0 | | n === 1) { |
| ​  | `return` 1; |
| ​  | } |

让我们继续讨论`numberOfPaths(3)`，它将返回`numberOfPaths(2) + numberOfPaths(1) + numberOfPaths(0)`的和。我们知道我们想要的结果是4，所以让我们看看这个计算是否正确。我们已经让`numberOfPaths(2)`返回2。`numberOfPaths(1)`将返回1，而`numberOfPaths(0)`也将返回1，所以我们最终得到了4的和，这正是我们所需要的。

我们的完整函数也可以这样写：

| ​  | `function` `numberOfPaths`(n) { |
| --- | --- |
| ​  | `if` (n < 0) { |
| ​  | `return` 0; |
| ​  | } `else` `if` (n === 0 | | n === 1) { |
| ​  | `return` 1; |
| ​  | } |
| ​  |  |
| ​  | `return` (`numberOfPaths(n - 1)` |
| ​  | + `numberOfPaths(n - 2)` |
| ​  | + `numberOfPaths(n - 3));` |
| ​  | } |

虽然这比我们之前的版本不太直观，但我们只用两行代码就覆盖了所有基本情况。

正如你所看到的，自上而下的递归方法使得解决这个问题变得比其他方法简单得多。
