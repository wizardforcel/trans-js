## 抽象数据类型

大多数编程语言并没有将栈作为内置数据类型或类提供。相反，您需要自己实现它。这与大多数语言中可用的数组形成鲜明对比。

因此，要创建一个栈，通常需要使用内置数据结构之一来存储数据。以下是一种使用 JavaScript 实现栈的方法，它在底层使用数组：

| ​  | `class` `Stack` { |
| --- | --- |
| ​  | `constructor`() { |
| ​  | `this.data = [];` |
| ​  | } |
| ​  |  |
| ​  | `push(element)` { |
| ​  | `this.data.push(element);` |
| ​  | } |
| ​  |  |
| ​  | `pop()` { |
| ​  | `if` (`this.data.length > 0) { |
| ​  | `return` `this.data.pop(); |
| ​  | } `else` { |
| ​  | `return` `null`; |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `read()` { |
| ​  | `if` (`this.data.length > 0) { |
| ​  | `return` `this.data[this.data.length - 1]; |
| ​  | } `else` { |
| ​  | `return` `null`; |
| ​  | } |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `export` `default` `Stack`; |

如您所见，我们的栈实现将数据存储在一个名为 `this.data` 的数组中。

每当初始化一个栈时，我们会自动构建一个空数组 `this.data = [];`。我们的栈还包含将新元素 `push` 到 `this.data` 末尾、从 `this.data` 开头 `pop` 元素，以及读取 `this.data` 数组第一个元素的方法。（如果栈为空，`read` 和 `pop` 方法将返回 `null`。）

我们的代码一开始可能看起来有些混乱，因为我们的 `pop` 方法调用 `this.data.pop()`，而我们的 `push` 方法调用 `this.data.push()`。然而，这正是因为 JavaScript 恰好在数组上实现了这些名称的方法，而 `this.data` 就是一个数组。

然而，通过围绕数组构建 `Stack` 类，我们建立了一个接口，迫使用户以有限的方式与数组交互。虽然通常可以从数组的任何索引读取数据，但通过栈接口使用数组时，只能读取最后一个项目。插入和删除数据也是如此。

因此，栈数据结构与数组的类型不同。数组是大多数编程语言内置的，直接与计算机内存交互。而栈则是一组关于我们如何与数组交互的规则和过程，以实现特定结果。

实际上，栈并不关心底层是什么数据结构。它只关心有一组数据元素以后进先出（LIFO）的方式进行操作。我们是否使用数组或其他类型的内置数据结构来实现这一点并不重要。因此，栈是一个被称为抽象数据类型的例子——它是一种围绕某种其他内置数据结构的理论规则集。

我们在第一章遇到的集合`[*为什么数据结构重要*](f_0013.xhtml#chp.understanding_data_structures)`是另一个抽象数据类型的例子。一些集合的实现使用底层数组，而其他实现则使用哈希表。然而，集合本身只是一个理论概念：它是一个不重复的数据元素列表。

在本书剩下的部分，我们将遇到的许多数据结构都是抽象数据类型——它们是建立在其他内置数据结构之上的代码片段。

需要注意的是，即使是内置的数据结构也可以是抽象数据类型。即使一种编程语言确实实现了自己的`Stack`类，这并不改变栈数据结构仍然是一个允许在底层使用各种数据结构的概念这一事实。
