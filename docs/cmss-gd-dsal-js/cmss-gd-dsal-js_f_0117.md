## `通过记忆化的动态编程`

幸运的是，我们确实有选择，那就是通过一种称为`dynamic programming`的方式。`动态编程`是优化具有重叠子问题的递归问题的过程。

（不要过于关注单词`dynamic`。关于这个术语的起源有一些争议，而且我接下来要演示的技术并没有明显的`dynamic`特征。）

用`动态编程`优化算法通常采用两种技术之一。

第一个技术被称为`memoization`。没错，这不是一个错字。发音为`meh-moe-ih-ZAY-shun`，`memoization`是一种简单而巧妙的技术，用于在重叠子问题的情况下减少递归调用。

本质上，`memoization`通过记住先前计算的`functions`来减少递归调用。（在这方面，`memoization`确实像它的发音相似的单词`memorization`。）

在我们的`Fibonacci`示例中，第一次调用`fib(3)`时，`function`进行计算并返回数字`2`。然而，在继续之前，`function`会将此结果存储在哈希表中。哈希表大致如下：

| ​  | {3: 2} |
| --- | --- |

这表明`fib(3)`的结果是数字`2`。

同样，我们的代码会`memoize`它遇到的所有新计算的结果。例如，在遇到`fib(4)`、`fib(5)`和`fib(6)`之后，我们的哈希表将看起来像这样：

| ​  | { |
| --- | --- |
| ​  | 3: 2, |
| ​  | 4: 3, |
| ​  | 5: 5, |
| ​  | 6: 8 |
| ​  | } |

现在我们有了这个哈希表，可以用它来防止未来的递归调用。其工作原理如下：

如果没有`memoization`，`fib(4)`通常会调用`fib(3)`和`fib(2)`，这又会产生各自的递归调用。现在有了这个哈希表，我们可以采取不同的方法。举例来说，`fib(4)`不会再轻率地调用`fib(3)`，而是首先检查哈希表，看看`fib(3)`的结果是否已经计算过。只有当`3`这个键不在哈希表中时，`function`才会继续调用`fib(3)`。

`Memoization`直接切入重叠子问题的核心。重叠子问题的主要问题在于我们不断计算相同的递归调用。但是通过`memoization`，每次进行新的计算时，我们都会将结果存储在哈希表中以供将来使用。这样，只有在之前从未计算过时，我们才会进行计算。

好吧，这一切听起来不错，但有一个明显的问题。每个递归函数如何访问这个哈希表？

答案是：我们将哈希表作为`function`的第二个参数传递。

由于哈希表是内存中的特定对象，我们能够在每个递归调用之间传递它，即使我们在此过程中修改它。这在我们解除调用栈时也同样成立。即使在最初调用时哈希表可能是空的，但在最初调用执行完成时，那个哈希表可以充满数据。

### 实现备忘录化

为了将哈希表传递下去，我们修改我们的函数，使其接受两个参数，哈希表作为第二个参数。我们将这个哈希表称为`memo`，如同备忘录化：

| ​  | ​`function`​ `fib(n, memo={})` { |
| --- | --- |

注意，我们将`memo`设置为默认参数；这样，我们在第一次调用它时就不必传入一个空的哈希表。因此，我们可以简单地使用以下方式调用函数：

| ​  | `fib(6);` |
| --- | --- |

每次`fib`调用自身时，它还会传递哈希表，这样哈希表就会在此过程中填满。

这里是函数的其余部分：

| ​  | ​`function`​ `fib(n, memo={})` { |
| --- | --- |
| ​  | ​`if`​ (`n === 0` | | `n === 1`) { |
| ​  | ​`return`​ `n;` |
| ​  | } |
| ​  |  |
| ​  | ​`if`​ (!`memo[n]`) { |
| ​  | `memo[n] = fib(n - 2, memo) + fib(n - 1, memo);` |
| ​  | } |
| ​  |  |
| ​  | ​`return`​ `memo[n];` |
| ​  | } |

让我们逐行分析。

同样，我们的函数现在接受两个参数，即`n`和备忘录哈希表：

| ​  | ​`function`​ `fib(n, memo={})` { |
| --- | --- |

首先，基本情况 0 和 1 都会自动返回`n`，并且不受备忘录化的影响。

在进行任何递归调用之前，我们的代码首先检查`fib(n)`是否已经为给定的`n`计算过：

| ​  | ​`if`​ (!`memo[n]`) { |
| --- | --- |

（如果`n`的计算已经在哈希表中，我们只需使用`return memo[n]`返回结果。）

只有在对`n`的计算尚未完成时，我们才会继续进行计算：

| ​  | `memo[n] = fib(n - 2, memo) + fib(n - 1, memo);` |
| --- | --- |

在这里，我们将计算的结果存储在备忘录哈希表中，因此我们永远不必再次计算它。

还要注意，我们每次调用`fib`函数时都会将`memo`作为参数传递。这是共享备忘录哈希表的关键。

如您所见，算法的核心部分保持不变。我们仍然在使用递归来解决问题，因为`fib`的计算仍然基本上是`fib(n - 2) + fib(n - 1)`。然而，如果我们计算的数字是新的，我们会将结果存储在哈希表中；如果我们计算的数字之前已经计算过，我们只需从哈希表中获取结果，而不是重新计算。

当我们在备忘录版本中映射递归调用时，我们得到了这个：

![images/dynamic_programming/memoized_fib.png](images/dynamic_programming/memoized_fib.png)

在这个图中，所有被框住的调用是从哈希表中检索结果的调用。

那么我们函数的 Big O 现在是什么？让我们看看对不同类型的`N`我们进行多少次递归调用：

| N 元素 | 调用次数 |
| --- | --- |
| 1 | 1 |
| 2 | 3 |
| 3 | 5 |
| 4 | 7 |
| 5 | 9 |
| 6 | 11 |

我们可以看到，对于`N`，我们进行了`(2N) - 1`次调用。由于在 Big O 中我们省略常数，这个算法是`O(N)`。

这是对`O(2^N)`的一个惊人改进。去备忘录化吧！
