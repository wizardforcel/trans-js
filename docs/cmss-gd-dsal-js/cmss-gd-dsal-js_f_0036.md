## O(log N) 解释

让我们将这一切重新带回大 O 符号。在本书中，每当我们说 `O(log N)` 时，请想象我们在说 `O(log[2] N)`。在 [*忽略常数*](f_0052.xhtml#ignoring.constants) 中，我们将讨论为何在我们的符号中省略底数 2。但现在，当你看到 `O(log N)` 时，请在脑海中将其视为 `O(log[2] N)`。

鉴于这一点，我们现在可以准确解释 `O(log N)` 的含义。

请记住，大 O 符号解决了关键问题：如果有 N 个数据元素，算法将需要多少步骤？

`O(log N)` 意味着对于 N 个数据元素，算法将需要 `log[2] N` 步骤。如果有 8 个元素，算法将需要三步，因为 `log[2] 8 = 3`。

另外说，如果我们不断将 8 个元素对半分，那么我们需要三步才能结束到 1 个元素。

这正是二分查找所发生的情况。当我们搜索特定项时，我们不断将数组的单元格对半分，直到缩小到正确的数字。

简而言之：`O(log N)` 意味着算法所需的步骤数量与每次将数据元素一半的数量相同，直到剩下 1 个元素。

下表展示了 O(N) 和 O(log N) 效率之间显著的差异：

| N 元素 | O(N) | O(log N) |
| --- | --- | --- |
| 8 | 8 | 3 |
| 16 | 16 | 4 |
| 32 | 32 | 5 |
| 64 | 64 | 6 |
| 128 | 128 | 7 |
| 256 | 256 | 8 |
| 512 | 512 | 9 |
| 1024 | 1024 | 10 |

当 O(N) 算法所需的步骤与数据元素的数量相同，而 O(log N) 算法每次数据翻倍时只需额外一步。

在未来的章节中，你将遇到属于大 O 符号其他类别的算法，而不仅仅是你目前所学习的这三种。但是与此同时，让我们将这些概念应用于一些日常代码的例子。
