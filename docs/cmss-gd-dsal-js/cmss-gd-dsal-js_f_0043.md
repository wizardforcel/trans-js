## 冒泡排序的效率

冒泡排序算法包含两种重要的步骤：

+   比较：两个数字相互比较以确定哪个更大。

+   交换：两个数字互相交换以进行排序。

让我们先确定冒泡排序中进行的比较次数。

我们的示例数组有 `五` 个元素。回顾一下，你可以看到在第一次遍历中，我们必须进行 `四` 次关于两组数字的比较。

在我们第二次遍历中，我们只需要进行 `三` 次比较。这是因为我们不需要比较最后两个数字，因为我们知道最后一个数字由于第一次遍历已经在正确的位置。

在我们第三次遍历中，我们进行了 `两` 次比较，而在第四次遍历中，我们只进行了 `一次` 比较。

所以就是

`4 + 3 + 2 + 1 = 10` 次比较。

用一种适用于所有大小数组的方式来说，我们可以说对于 `N` 个元素，我们进行

`(N - 1) + (N - 2) + (N - 3) … + 1` 次比较。

现在我们已经分析了冒泡排序中的比较次数，接下来我们来分析交换。

在最坏的情况下，数组按降序排列（正好与我们想要的相反），实际上每次比较都需要进行一次交换。因此，在这种情况下，我们会有 `10` 次比较和 `10` 次交换，总共是 `20` 步。

让我们看一下整体情况。对于一个包含 `五` 个值的逆序数组，我们进行 `4 + 3 + 2 + 1 = 10` 次比较。再加上 `10` 次交换，总共是 `20` 步。

对于这样一个包含 `10` 个值的数组，我们有 `9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 45` 次比较，以及另外 `45` 次交换。总共是 `90` 步。

对于一个包含 `20` 个值的数组，我们会有：

`19 + 18 + 17 + 16 + 15 + 14 + 13 + 12 + 11 + 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 190` 次比较，约 `190` 次交换，总共是 `380` 步。

注意这里的低效率。随着元素数量的增加，步骤数呈指数增长。（在技术数学术语中，我们可以说它是以二次方增长的。）我们可以在下面的表格中清楚地看到这一点：

| `N 数据元素` | `最大步骤数` |
| --- | --- |
| `---` | `---` |
| `5` | `20` |
| `10` | `90` |
| `20` | `380` |
| `40` | `1560` |
| `80` | `6320` |

如果你观察当 `N` 增加时步骤的增长，你会发现它大约是以 `N²` 的速度增长。看看下面的表格：

| `N 数据元素` | `冒泡排序步骤数` | `N²` |
| --- | --- | --- |
| `---` | `---` | `---` |
| `5` | `20` | `25` |
| `10` | `90` | `100` |
| `20` | `380` | `400` |
| `40` | `1560` | `1600` |
| `80` | `6320` | `6400` |

让我们用大 O 符号表示冒泡排序的时间复杂度。记住，大 O 总是回答关键问题：如果有 `N` 个数据元素，算法将花费多少步骤？因为对于 `N` 个值，冒泡排序需要 `N²` 步骤，所以在大 O 表达中，我们说冒泡排序的效率为 `O(N²)`。

`O(N²)`被认为是一种相对低效的算法，因为随着数据量的增加，步骤会急剧增加。请看下面的图表，它比较了`O(N²)`与更快的`O(N)`：

![`images/speeding_up_your_code_with_big_o/bubble_sort_30.png`](images/speeding_up_your_code_with_big_o/bubble_sort_30.png)

请注意，`O(N²)`在步骤数量方面随着数据的增长而急剧上升。将其与`O(N)`进行比较，后者沿着一条简单的对角线绘制。

最后一点：`O(N²)`也被称为平方时间。
