## 第三类算法

在上一章中，你了解到在有序数组上进行二分搜索比在同一数组上进行线性搜索要快得多。现在让我们看看如何用`Big O`符号来描述二分搜索。

我们不能将二分搜索描述为`O(1)`，因为步骤数量随着数据的增加而增加。它也不属于`O(N)`类别，因为步骤数量远少于`N`个数据元素。正如我们所见，对于包含100个元素的数组，二分搜索只需七步。

因此，二分搜索似乎落在`O(1)`和`O(N)`之间。那么它是什么呢？

在`Big O`的术语中，我们将二分搜索描述为具有以下时间复杂度：

`O(log N)`。

我把这个读作“哦，log N”。这种类型的算法也被称为具有`log time`的时间复杂度。

简而言之，`O(log N)`是描述一种算法的`Big O`方式，该算法在数据每次翻倍时增加一步。正如你在上一章中所学到的，二分搜索正是如此。你将很快看到为什么这被表示为`O(log N)`，但首先让我们总结一下你到目前为止所学的内容。

到目前为止你学习的三种类型的算法可以按效率从高到低排序如下：

`O(1)`

`O(log N)`

`O(N)`

让我们看一下比较这三种类型的图表：

`![images/big_o_notation/graph_three_types_fixed.png](images/big_o_notation/graph_three_types_fixed.png)`

注意`O(log N)`略微向上弯曲，使其效率低于`O(1)`但远高于`O(N)`。

要理解为什么这个算法被称为`O(log N)`，你首先需要了解对数是什么。如果你已经熟悉这个数学概念，可以跳过下一部分。
