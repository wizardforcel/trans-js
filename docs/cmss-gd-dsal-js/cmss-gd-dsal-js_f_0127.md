## 排序作为其他算法的关键

到目前为止，我们所知道的最快的排序算法速度为`O(N log N)`。虽然快速排序是其中最受欢迎的算法之一，但还有许多其他算法。归并排序是另一种著名的`O(N log N)`排序算法，将在本书的第二卷中介绍。

快速排序算法的速度为`O(N log N)`是很重要的，因为这对其他算法也有影响。这是因为有些算法在更大的过程中使用排序作为一个组件。

例如，如果你还记得第4章，[`用大O加速你的代码`](f_0040.xhtml#chp.speeding_up)，我们讨论了检查数组中是否有重复值的问题。

我们查看的第一个解决方案涉及嵌套循环，效率为`O(N²)`。虽然我们找到了一种耗时为`O(N)`的解决方案，但我顺便提到过这种方法的一个缺点与额外的内存消耗有关。（我将在第19章，[`处理空间限制`](f_0189.xhtml#chp.dealing_with_space_constraints)中详细讨论这一点。）所以让我们假设`O(N)`的方法不适用。还有其他方法可以改进二次的`O(N²)`解决方案吗？提示：解决方案与排序有关！

如果我们对数组进行预排序，我们可以构建一个优秀的算法。

假设原始数组是`[5, 9, 3, 2, 4, 5, 6]`。这个数组有两个`5`的实例，因此我们确实有重复的情况。

现在，如果我们先对这个数组进行排序，它将变成`[2, 3, 4, 5, 5, 6, 9]`。

接下来，我们可以使用单个循环遍历每个数字。在检查每个数字时，我们会检查它是否与下一个数字相同。如果是的话，我们就找到了一个重复值。如果在循环结束时没有找到重复值，那么我们就知道没有重复值。

这里的技巧在于，通过预先排序数字，我们最终将重复数字聚在了一起。

在我们的示例中，我们将从第一个数字开始，也就是`2`。我们会检查它是否与下一个数字相同。下一个数字是`3`，所以它们不是重复值。

然后我们会检查`3`是否与下一个数字相同，而下一个数字是`4`，这允许我们继续。我们会将`4`与`5`进行比较，然后再次继续。

此时，我们会检查第一个`5`，并将其与下一个数字进行比较，也就是第二个`5`。哈！我们找到了一个重复数字对，可以返回`true`。

这里是这个算法的JavaScript实现：

| ​  | `function hasDuplicateValue(array) {` |
| --- | --- |
| ​  | `array.sort((a, b) => a - b);` |
| ​  |  |
| ​  | `for (let index = 0; index < array.length - 1; index += 1) {` |
| ​  | `if (array[index] === array[index + 1]) {` |
| ​  | `return true`; |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `return false`; |
| ​  | } |

在这里，我们使用 JavaScript 的内置排序函数。参数`(a, b) => a - b`是必要的，以确保 JavaScript 正确排序整数，而不是像处理字符串那样排序它们。

现在，这是一个将排序作为其组成部分的算法。那么，这个算法的 Big O 是多少呢？

我们首先对数组进行排序。我们可以假设 JavaScript 的排序函数在内部使用类似于`快速排序`的算法，并且其效率为`O(N log N)`。接下来，我们最多需要`N`步来遍历数组。因此，我们的算法需要`(N log N) + N`步。

你已经了解到，当我们将多个阶数相加时，大 O 符号只保留最高阶的`N`，因为低阶与高阶相比是微不足道的。在这里，`N`在`N log N`面前也是微不足道的，因此我们将表达式简化为`O(N log N)`。

就这样！我们使用排序开发了一个复杂度为`O(N log N)`的算法，这比原来的`O(N²)`算法有了显著的改进。

很多算法在更大的过程中使用排序。我们现在知道，每当我们这样做时，算法的复杂度至少是`O(N log N)`。当然，如果算法有其他操作，它的速度可能会比这慢，但我们知道`O(N log N)`始终是基准。
