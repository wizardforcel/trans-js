## 自上而下的递归：一种新的思维方式

这将我们带到本章的核心要点：在实现自上而下的方法时，递归表现出色，因为自上而下提供了一种全新的思维策略来解决问题。也就是说，递归的自上而下方法允许我们以完全不同的方式思考问题。

具体来说，当我们采取自上而下的方式时，我们可以在心理上“将问题推迟”。我们可以将思维从通常在自下而上过程中需要考虑的一些琐碎细节中解放出来。

为了说明我的意思，让我们再看一眼自上而下`factorial`实现中的关键行：

| ​  | ​`return number * factorial(number - 1);` |
| --- | --- |

这行代码的计算基于`factorial(number - 1)`。当我们写这行代码时，我们必须理解它调用的`factorial`函数是如何工作的吗？从技术上讲，我们并不需要。每当我们编写调用另一个函数的代码时，我们假设该函数会返回正确的值，而不必理解其内部是如何工作的。

同样，在我们基于调用`factorial`函数计算答案时，我们并不需要理解`factorial`函数是如何工作的；我们只需期待它返回正确的结果。当然，奇怪的是，我们就是编写`factorial`函数的人！这行代码存在于`factorial`函数内部。但这正是自上而下思维的伟大之处：在某种意义上，我们可以在不知道如何解决问题的情况下解决问题。

当我们以递归方式实施自上而下策略时，我们可以稍微放松大脑。我们甚至可以选择忽略计算实际如何工作的细节。我们可以说，“让我们依赖子问题来处理细节。”

### 自上而下的思维过程

如果你之前没有做过很多自上而下的递归，学习以这种方式思考需要时间和练习。我发现，当面对一个自上而下的问题时，思考以下三点是有帮助的：

1.  想象你正在编写的函数已经由其他人编写。

1.  确定问题的子问题。

1.  看看当你在子问题上调用函数时会发生什么，并从那里开始。

虽然这些步骤目前听起来很模糊，但通过以下示例，它们会变得更清晰。

### 数组求和

假设我们必须编写一个名为`sum`的函数，用于对给定数组中的所有数字求和。例如，如果我们将数组`[1, 2, 3, 4, 5]`传递给这个函数，它将返回`15`，即这些数字的总和。

我们要做的第一件事是想象`sum`函数已经被实现。诚然，这需要一定程度的悬置怀疑，因为我们知道我们正处于编写这个函数的过程中！但是让我们尝试放手，假装`sum`函数已经可以正常工作。

接下来，让我们确定子问题。这更像是一种艺术而非科学，但练习会帮助你提高。在我们的例子中，我们可以说子问题是数组 `[2, 3, 4, 5]`——也就是说，数组中除第一个元素外的所有数字。

最后，让我们看看当我们将 `sum` 函数应用于我们的子问题时会发生什么。如果 `sum` 函数“已经有效”，而子问题是 `[2, 3, 4, 5]`，当我们调用 `sum([2, 3, 4, 5])` 时会发生什么？好吧，我们得到 `2 + 3 + 4 + 5` 的和，即 `14`。

为了找到 `[1, 2, 3, 4, 5]` 的和，我们只需将第一个数字 `1` 加到 `sum([2, 3, 4, 5])` 的结果中。

在伪代码中，我们会写成这样：

| ​  | `return` `array[0] + sum(数组其余部分)` |
| --- | --- |

在 JavaScript 中，我们可以这样写：

| ​  | `return`​ `array[0] + sum(array.slice(1));` |
| --- | --- |

（在 JavaScript 中，语法 `.slice(1)` 返回一个新数组，其内容是从索引 1 开始到末尾的原数组元素。）

现在，信不信由你，我们完成了！除了我们稍后要处理的基本情况外，我们的 `sum` 函数可以写成这样：

| ​  | `function`​ `sum(array) {` |
| --- | --- |
| ​  | `return`​ `array[0] + sum(array.slice(1));` |
| ​  | } |

注意我们并没有考虑如何将所有数字相加。我们只是假想别人为我们写了 `sum` 函数，然后将其应用于子问题。我们将问题抛给了未来，但在这样做的过程中，我们解决了整个问题。

我们需要做的最后一件事是处理基本情况。也就是说，如果每个子问题递归地调用它自己的子问题，我们最终会达到 `sum([5])` 的子问题。这个函数最终会尝试将 `5` 加到数组的其余部分，但数组中没有其他元素。

为了解决这个问题，我们可以添加基本情况：

| ​  | `function`​ `sum(array) {` |
| --- | --- |
| ​  | `// 基本情况：数组中只有一个元素：`​ |
| ​  | `if`​ `(array.length === 1) { `​ `return`​ `array[0]; }` |
| ​  |  |
| ​  | `return`​ `array[0] + sum(array.slice(1));` |
| ​  | } |

现在我们完成了。

从技术上讲，还有一种情况我们尚未处理，那就是输入数组完全为空。目前，我们的代码会对这种输入抛出错误。

在这本书中，我们的代码不一定会尝试处理每一个边缘情况。（例如，如果输入数组包含字符串而不是数字会怎样？）然而，我们有时会通过抛出一个额外的条件来防止空数组，如下所示：

| ​  | `function`​ `sum(array) {` |
| --- | --- |
| ​  | `// 如果数组为空：`​ |
| ​  | `if`​ `(array.length === 0) { `​ `return`​ `0; }` |
| ​  |  |
| ​  | `// 主要基本情况：`​ |
| ​  | `if`​ `(array.length === 1) { `​ `return`​ `array[0]; }` |
| ​  |  |
| ​  | `return`​ `array[0] + sum(array.slice(1));` |
| ​  | } |

我们现在在技术上有两个基本情况。数组为空的可能性本身就是一个基本情况，但只有在原始输入为空时才会触发。另一方面，长度为 1 的数组是主要的基本情况，因为该情况将始终被递归本身触发。

然而，一个巧妙的小技巧可以让我们再次将代码减少到只有一个基本情况，同时仍然处理空数组的可能性。

它依赖于这样一个事实：在JavaScript中，当我们对一个仅包含一个值的数组调用`.slice(1)`时，我们会得到一个空数组。考虑到这一点，我们只需要空数组的基本情况，因为递归最终会触发这样的情况。我们可以完全消除长度为1的数组的基本情况，因为对这样的数组递归调用`sum`方法将产生一个空数组的情况。因此，以下代码可以完美工作：

| ​  | ​`function`​ `sum(array) {` |
| --- | --- |
| ​  | ​*// 基本情况：一个空数组*​ |
| ​  | ​`if`​ (array.length === 0) { ​`return`​ 0; } |
| ​  |  |
| ​  | ​`return`​ `array[0] + sum(array.slice(1));` |
| ​  | } |

而现在我们真的完成了。

### 字符串反转

让我们尝试另一个例子。我们将编写一个反转字符串的`reverse`函数。如果该函数接受参数"abcde"，它将返回"edcba"。

首先，让我们识别子问题。再次，这需要实践，但通常首先尝试的是当前问题的次小版本。因此，对于字符串"abcde"，我们假设子问题是"bcde"。这个子问题是原始字符串去掉第一个字符后的结果。

接下来，让我们想象一下，有人为我们实现了`reverse`函数。真是太好了！

现在，如果`reverse`函数可用，并且我们的子问题是"bcde"，这意味着我们可以调用`reverse("bcde")`，它将返回"edcb"。

一旦我们可以这样做，处理"a"就简单多了。我们只需将其添加到字符串的末尾。

所以，我们可以写：

| ​  | ​`function`​ `reverse(string) {` |
| --- | --- |
| ​  | ​`return`​ `reverse(string.slice(1)) + string[0];` |
| ​  | } |

我们的计算仅仅是调用`reverse`在子问题上的结果，然后将第一个字符添加到末尾。

一次又一次，除了基本情况，我们就完成了。我知道，这真是神奇。

基本情况发生在字符串只有一个字符时，因此我们可以添加以下代码行来处理它：

| ​  | ​`if`​ (string.length === 1) { ​`return`​ string[0]; } |
| --- | --- |

然而，和之前的例子一样，我们可以将基本情况设为一个空字符串，从而处理这样的输入。这再次有效，因为对一个单字符字符串调用`string.slice(1)`会产生一个空字符串：

| ​  | ​`function`​ `reverse(string) {` |
| --- | --- |
| ​  | ​`if`​ (string.length === 0) { ​`return`​ ​*''*​; } |
| ​  |  |
| ​  | ​`return`​ `reverse(string.slice(1)) + string[0];` |
| ​  | } |

然后我们就完成了。

### 计数X

我们正在顺利进行，所以让我们尝试另一个例子。让我们编写一个名为countX的函数，它返回给定字符串中“x”的数量。如果我们的函数接受字符串"axbxcxd"，它将返回3，因为字符“x”出现了三次。

首先，让我们识别子问题。就像之前的例子一样，我们可以说子问题是原始字符串去掉第一个字符。因此，对于"axbxcxd"，子问题是"xbxcxd"。

接下来，让我们想象countX已经实现。如果我们在子问题上调用countX，通过调用countX("xbxcxd")，我们得到3。在此基础上，如果我们的第一个字符也是“x”，我们只需加1。（如果我们的第一个字符不是“x”，我们就不需要向子问题的结果中添加任何东西。）

所以，我们可以写：

| ​  | `function` countX(string) { |
| --- | --- |
| ​  | `if` (string[0] === 'x') { |
| ​  | `return` 1 + countX(string.slice(1)); |
| ​  | } `else` { |
| ​  | `return` countX(string.slice(1)); |
| ​  | } |
| ​  | } |

这个条件语句很简单。如果第一个字符是“x”，我们就将1加到子问题的结果上。否则，我们就直接返回子问题的结果。

在这里，我们基本上也完成了。我们需要做的就是处理基本情况。

我们可以说，这里的基本情况是当字符串只有一个字符时。但是这会导致一些尴尬的代码，因为我们实际上有两个基本情况，因为这个单个字符可能是“x”，也可能不是“x”：

| ​  | `function` countX(string) { |
| --- | --- |
| ​  | `// 两个基本情况:` |
| ​  | `if` (string.length === 1) { |
| ​  | `if` (string[0] === 'x') { |
| ​  | `return` 1; |
| ​  | } `else` { |
| ​  | `return` 0; |
| ​  | } |
| ​  | } |
| ​  |  |
| ​  | `if` (string[0] === 'x') { |
| ​  | `return` 1 + countX(string.slice(1)); |
| ​  | } `else` { |
| ​  | `return` countX(string.slice(1)); |
| ​  | } |
| ​  | } |

不过，如果我们将基本情况设为空字符串，我们可以简化代码，只需一个基本情况：

| ​  | `function` countX(string) { |
| --- | --- |
| ​  | `// 基本情况：空字符串` |
| ​  | `if` (string.length === 0) { `return` 0; } |
| ​  |  |
| ​  | `if` (string[0] === 'x') { |
| ​  | `return` 1 + countX(string.slice(1)); |
| ​  | } `else` { |
| ​  | `return` countX(string.slice(1)); |
| ​  | } |
| ​  | } |

根据定义，空字符串将始终包含零个“x”，所以我们确实只有一个基本情况。
