## `通过自底向上实现动态规划`

我之前提到动态规划可以通过两种技术之一来实现。我们看过一种技术，即记忆化，它相当巧妙。

第二种技术，被称为自底向上，实际上要简单得多，甚至可能看起来根本不是一种技术。自底向上的意思就是放弃递归，使用其他方法（比如循环）来解决同样的问题。

从下往上的方法被认为是动态规划的一部分，原因在于动态规划意味着将一个可以递归解决的问题转化为不对重叠子问题进行重复调用。使用迭代（即循环）而不是递归，从技术上讲，是实现这一点的一种方式。

当一个问题更自然地通过递归来解决时，自底向上变得更像是一种“技术”。生成斐波那契数列就是一个递归优雅解决方案的例子。用迭代方式解决同样的问题可能需要更多的脑力，因为迭代方法可能不那么直观。（想象一下用循环解决上一章的楼梯问题。呃。）

让我们看看如何为我们的斐波那契函数实现一种自底向上的方法。

### `自底向上的斐波那契`

在下面的自底向上的方法中，我们从前两个斐波那契数字`0`和`1`开始。然后，我们利用老办法迭代来构建序列：

| ​  | ​`function`​ `fib(n) {` |
| --- | --- |
| ​  | ​`if`​ (`n === 0) { ​`return`​ `0`; } |
| ​  |  |
| ​  | ​`let`​ `a = 0;` |
| ​  | ​`let`​ `b = 1;` |
| ​  |  |
| ​  | ​`for`​ (`let`​ `i = 1; i < n; i += 1) {` |
| ​  | `[a, b] = [b, a + b];` |
| ​  | } |
| ​  |  |
| ​  | ​`return`​ `b`; |
| ​  | } |

我们首先做的就是如果输入`n`为`0`时返回`0`。正式来说，`fib(0)`应该返回`0`，所以我们通过一个简单的条件语句轻松处理了这个情况。

现在，我们进入代码的核心部分。我们将变量`a`和`b`分别初始化为`0`和`1`，因为这就是斐波那契数列的前两个数字。

然后我们开始一个循环，以便在达到`n`之前计算序列中的每个数字：

| ​  | ​`for`​ (`let`​ `i = 1; i < n; i += 1) {` |
| --- | --- |

要计算序列中的下一个数字，我们需要将前两个数字相加，即`a + b`。我们将更新`b`为这个新数字，因为`b`始终指向序列中的最后一个数字。我们还将`a`更新为`b`之前的值，以便`a`继续指向倒数第二个数字。我们通过一次方便的交换来完成这一切：

| ​  | `[a, b] = [b, a + b];` |
| --- | --- |

因为我们的代码是从`1`到`N`的简单循环，所以我们的代码需要`N`步。与记忆化方法类似，它的时间复杂度是`O(N)`。

### `记忆化与自底向上`

现在你已经看到了动态规划的两种主要技术：记忆化和自底向上。哪种技术更好呢？

通常，这取决于问题以及你为什么要使用`recursion`。如果`recursion`为特定问题提供了优雅而直观的解决方案，你可能会想继续使用它，并利用`memoization`来处理任何重叠的子问题。然而，如果`iterative`方法同样直观，你可能会选择使用它。

重要的是要指出，即使有`memoization`，`recursion`与`iteration`相比仍然会带来一些额外的开销。具体而言，使用任何`recursion`时，计算机需要在`call stack`中跟踪所有的调用，这会消耗内存。`memoization`本身也需要使用`hash table`，这会在你的计算机上占用额外的空间。（关于这一点，更多内容请参见第19章， [*处理空间限制*](f_0189.xhtml#chp.dealing_with_space_constraints)。）

一般来说，选择`bottom-up`方法通常是更好的选择，除非`recursive`解决方案更加直观。在`recursion`更直观的情况下，你可以保留`recursion`并通过使用`memoization`来保持其高效。
