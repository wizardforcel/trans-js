| 配方 46 | 使用反向引用引用匹配的字符串 |
| --- | --- |

### 任务

假设你的任务是检查文档中的重复单词，比如“the the book”，这是编辑繁重的文本中常见的排版错误。这个任务涉及到寻找重复单词，尽管它们的大小写不同，例如“this this”。它还需要找到在单词之间有不同数量的空白字符的情况，包括制表符和换行符。

你需要想出一个解决方案，能够找到所有重复的单词并自动修复它们。

### 解决方案

捕获带有捕获组的单词，并使用反向引用来匹配捕获组匹配的相同文本：

[part_2/backreference/backreference_ex1.js](http://media.pragprog.com/titles/fkjavascript/code/part_2/backreference/backreference_ex1.js)

|   | **function** dupWordRemover(str) { |
| --- | --- |
|   | **const** re = */**\b([**-'**\w]**+**)\s**+**\1\b**/ig*; |
|   | **return** str.replace(re, *"$1"*); |
|   | } |
|   |  |
|   | **const** str = *"没有没有人有足够好的记忆力能成为一个成功的骗子。"*; |
|   |  |
|   | dupWordRemover(str) |
|   | *// → "没有人有足够好的记忆力能成为一个成功的骗子。"* |

问题解决了！你的文本现在已经去除了大部分重复的单词。

| 在消除重复单词之前评估它们的重要性 |
| --- |
| ![images/aside-icons/important.png](images/aside-icons/important.png) | 请记住，重复词语的使用并不总是错误的，在没有评估的情况下消除它们可能是有风险的。例如，“had had”是“have”的过去完成时形式，有时候像“ha ha”这样的词语和其他结构也会产生故意重复的词。因此，在去除重复词之前，最好检查每个匹配项。另外请注意，这个方法只检测由ASCII单词字符组成的重复词。如果你想包括带重音符号的字母以及来自不同书写系统的字母，应该使用Unicode字母类别（见第53条，[*使用Unicode属性转义匹配Unicode单词边界*](f_0064.xhtml#rcp.unicode_property_escapes_p3)）。 |

### 讨论

当模式中有捕获组时，括号内的内容会被标记。回溯引用提供了一种便捷的方法，允许我们以\1、\2等形式重复使用这些内容，其中\1指代第一个捕获组，\2指代第二个捕获组，以此类推。

这种方法与仅仅用量词重复一个标记或组不同。为了说明这一点，让我们对比两个简单的正则表达式：\d{2} 和 (\d)\1。第一个使用量词来匹配任意两个数字，而第二个则使用捕获组和回溯引用来匹配相同的数字两次。

现在，让我们一步步地来看正则表达式：

|   | /\b([-'\w]+)\s+\1\b/ig |
| --- | --- |
|   |  |
|   | ● \b 确定单词边界的位置 |
|   | ● ([-'\w]+) 第一个捕获组 |
|   | ○ [-'\w] 匹配列表中的单个字符 |
|   | ○ - 字面匹配一个 - 字符 |
|   | ○ ' 字面匹配一个 ' 字符 |
|   | ○ \w 匹配任何单词字符 |
|   | ○ + 匹配前一个标记一次或多次 |
|   | ● \s 匹配任何空白字符 |
|   | ○ + 匹配前一个标记一次或多次 |
|   | ● \1 匹配由第一个捕获组匹配的相同文本 |
|   | ● \b 表示单词边界的位置 |
|   | ● 标志 |
|   | ○ i: 启用不区分大小写的匹配 |
|   | ○ g: 启用全局匹配，返回所有匹配项 |

本食谱中的正则表达式首先通过匹配单词边界 (\b) 来确保我们只匹配整个单词。接着，我们使用捕获组 ([-’\w]+) 来匹配一个或多个字母、数字、下划线、连字符和撇号的组合。匹配连字符和撇号很重要，因为我们希望能够检测到重复的单词，例如 “check-in check-in” 和 “can’t can’t”。

捕获到第一个单词后，我们使用 \s+ 来匹配第一个和第二个捕获组之间的一个或多个空白字符（如空格和制表符）。接下来，我们使用反向引用 \1 来确保第二个出现的单词与第一个相同。正则表达式以另一个单词边界 (\b) 结尾。

为了执行正则表达式，我们使用 replace() 方法。replace() 将正则表达式作为第一个参数，尝试在给定的字符串中找到匹配项，并用第二个参数替换它。在这个例子中，替换值是 $1，这是一个特殊的替换模式，用于引用第一个捕获组。结果是匹配的子字符串 “No no” 被替换为 “No”。有关特殊替换模式的更多信息，请参见食谱 34，[*使用特殊替换模式*](f_0045.xhtml#rcp.replacement_patterns)。

我们也可以使用命名捕获组的反向引用——可以使用常规的编号反向引用或 \k<name> 语法。让我们来看一个例子：

[part_2/backreference/backreference_ex2.js](http://media.pragprog.com/titles/fkjavascript/code/part_2/backreference/backreference_ex2.js)

|   | **函数** dupWordRemover(str) { |
| --- | --- |
|   | **常量** re = */**\b(?<**dup>**[**-'**\w]**+**)\s**+**\k**<dup>**\b**/ig*; |
|   | **返回** str.replace(re, *"$1"*); |
|   | } |
|   |  |
|   | **const** str = *"没有没有人拥有足够好的记忆力，能够成为一个成功的骗子。"*; |
|   |  |
|   | dupWordRemover(str) |
|   | *// → "没有人拥有足够好的记忆力，能够成为一个成功的骗子。"* |

这段代码实现的结果与本食谱中的解决方案相同，唯一的不同是它使用了命名捕获组 (?<dup>[-’\w]+)，并通过 \k<dup> 引用该捕获组。有关命名捕获组的更多内容，请参见食谱 33，[*使用命名捕获组轻松读取分组*](f_0044.xhtml#rcp.named_capturing_group)。

JavaScript 的正则表达式和其他语言的正则表达式有一个区别，那就是它处理回溯引用（backreference）的方式。与大多数其他语言不同，JavaScript 不区分回溯引用匹配到空字符串的捕获组和没有参与匹配的捕获组。

让我通过一个简单的例子来澄清：正则表达式 /(-?)cat\1/ 可以匹配字符串“cat”、“-cat”或“-cat-”。在 JavaScript 中，这个模式等同于 /(-)?cat\1/。但这与大多数其他正则表达式的实现不同。

当 JavaScript 正则引擎处理 /(-?)cat\1/ 并应用于字符串“cat”时，它的处理过程是这样的：首先，正则引擎尝试字面匹配一个连字符 (-)，并且成功匹配到空字符串（回想一下，? 是一个元字符，表示匹配前一个字符零次或一次）。

字符串中的下一个字符是字母 c，正则引擎成功地匹配了它。引擎还匹配了接下来的两个字符：a 和 t。最后，\1 成功匹配了捕获组中出现零次的 -。

现在我们来看第二个模式： /(-)?cat\1/。在这里，引擎无法匹配 -，但由于捕获组后面有一个问号，它变成了可选项，因此引擎继续匹配字面字符。正则表达式 \1 指向未能匹配任何内容的捕获组，导致回溯引用也无法匹配。

由于反向引用后没有问号使其变为可选，因此在大多数变种中，整体匹配会失败。但 JavaScript 是不同的。在 JavaScript 中，反向引用指向一个未参与匹配的捕获组时，反向引用会成功匹配到空字符串，从而使整体匹配成功。

一方面，这可以带来好处，因为你不需要担心某个特定的捕获组是否参与了匹配。另一方面，这种缺乏区分的做法可能导致你的模式在其他正则表达式变种中失败。

| 复用反向引用 |
| --- |
| ![images/aside-icons/info.png](images/aside-icons/info.png) | 反向引用可以被多次重用。例如，(ha)\1\1 匹配 hahaha。 |
| 前向引用 |
| --- |
| ![images/aside-icons/warning.png](images/aside-icons/warning.png) | JavaScript 不支持前向引用。前向引用允许你引用正则表达式中稍后出现的组。 |

利用反向引用来引用捕获组匹配的精确文本。当使用普通捕获组时，你可以以 \1、\2 等形式重用内容。如果使用命名捕获组，你也可以使用 \k<name> 语法。
