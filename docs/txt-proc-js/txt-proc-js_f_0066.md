| Recipe 54 | 验证电子邮件地址 |
| --- | --- |

### 任务

假设你的网页或应用程序上有一个表单，要求用户提供一个电子邮件地址。无论是用于发送新闻通讯、常规沟通、密码恢复还是其他目的，在继续操作之前确保你获得了正确的电子邮件地址至关重要——这样可以尽量减少退回的无法送达的邮件数量。

你需要的是一个机制来检查输入的文本是否符合有效的电子邮件地址格式。

### 解决方案

如果你的表单在一个网站上，你可以从设置内建的 HTML5 表单功能开始。首先，确保你的输入元素具有一个类型属性，值为“email”：

[part_3/validating_email/email_ex1.xhtml](http://media.pragprog.com/titles/fkjavascript/code/part_3/validating_email/email_ex1.xhtml)

|   | <form> |
| --- | --- |
|   | <label for=*"Email"*>邮箱：</label> |
|   | <input type=*"email"* id=*"Email"*> |
|   | <input type=*"submit"*> |
|   | </form> |

电子邮件输入通常能捕捉到用户在输入电子邮件时最明显的错误。为了强制要求输入，最简单的验证工具是“required”属性。为了实现这一点，可以在闭合的输入标签前加入该属性：

[part_3/validating_email/email_ex2.xhtml](http://media.pragprog.com/titles/fkjavascript/code/part_3/validating_email/email_ex2.xhtml)

|   | <form> |
| --- | --- |
|   | <label for=*"Email"*>邮箱：</label> |
|   | <input type=*"email"* id=*"Email"* required> |
|   | <input type=*"submit"*> |
|   | </form> |

在服务器端，验证输入的电子邮件地址是否包含“@”符号，并且符号前后都是非空白字符：

[part_3/validating_email/email_ex2.js](http://media.pragprog.com/titles/fkjavascript/code/part_3/validating_email/email_ex2.js)

|   | **function** isValidEmail(str) { |
| --- | --- |
|   | **const** re = */^**\S**+@**\S**+$/*; |
|   | **return** re.test(str); |
|   | } |
|   |  |
|   | isValidEmail(*"faraz@"*); *// → false* |
|   | isValidEmail(*"@abcd"*); *// → false* |
|   | isValidEmail(*"faraz@somewhere.com"*); *// → true* |

这个模式执行的检查类似于 HTML 机制中验证电子邮件的过程。

### 讨论

设计网页表单一直是程序员面临的挑战。虽然表单本身的编码相对简单，但验证每个输入值是否符合逻辑和可接受的要求则更具难度，而且将任何问题传达给用户也可能是一个头痛问题。客户端表单验证有助于用户更快地识别和修正表单提交中的错误。

但是，重要的是要理解，仅依赖客户端验证可能无法提供全面的安全性。为了确保最大限度的安全性，你的应用程序必须在服务器端和客户端都对表单数据执行安全检查。而正则表达式通常是程序员用来执行此任务的首选工具。

在大多数情况下，你在互联网上遇到的正则表达式模式对于电子邮件地址验证来说过于限制。一些开发者建议检查输入是否符合 RFC 5322 标准。RFC 5322 定义了电子邮件消息的结构和语法，其中包括电子邮件地址。^([[32]](f_0087.xhtml#FOOTNOTE-32))

为了实现这一点，你需要一个像这样的正则表达式：

|   | const re = /(?:[a-z0-9!#$%&'*+/=?^_`{&#124;}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{&#124;}~-]+ |
| --- | --- |
|   | )*&#124;"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]&#124;\\[\x01-\x09\x0b\x |
|   | 0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9 |
|   | -]*[a-z0-9])?&#124;\[(?:(?:(2(5[0-5]&#124;[0-4][0-9])&#124;1[0-9][0-9]&#124;[1-9]?[0-9]))\.){3}( |
|   | ?:(2(5[0-5]&#124;[0-4][0-9])&#124;1[0-9][0-9]&#124;[1-9]?[0-9])&#124;[a-z0-9-]*[a-z0-9]:(?:[\x01 |
|   | -\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]&#124;\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\ |
|   | ])/; |

这个正则表达式对于那些不熟悉正则表达式的开发人员来说同样令人生畏，对于那些熟练掌握正则表达式的人也不例外！但是，即使按照 RFC 标准验证电子邮件地址，也无法提供关于该地址在给定域名上是否存在或该地址的真实所有权的信息。

根据 RFC 5322，qwerty@qwerty.qwerty 是一个有效的电子邮件地址。然而，如果有效电子邮件地址的定义要求它必须能够接收邮件，那么它就不被视为有效。这是因为并没有名为 qwerty 的顶级域名。^([[33]](f_0087.xhtml#FOOTNOTE-33))

以前，限制顶级域名为两字母组合的国家代码，并对通用顶级域名（如 com|net|org|mil|edu）进行完全列举是合乎逻辑的。但是，随着新的顶级域名的频繁增加，曾经有效的这些模式很快就会过时。

基本上，除非你发送邮件并查看是否能够发送成功，否则无法确定 david@somewhere.com 是否能够接收到邮件。即使在这种情况下，是否没有回复也不能确定是因为 somewhere.com 域名悄悄地将发送到不存在邮件地址的邮件丢弃，还是 David 本人删除了邮件，或者是他的垃圾邮件过滤器拦截了邮件。

一个可靠的电子邮件验证工具不仅仅是检查电子邮件地址的语法或向邮件服务器发送 Ping 请求。这个过程涉及向输入的电子邮件地址发送一条包含确认令牌的消息。确认令牌是验证输入的电子邮件地址是否正确的唯一方式。

这就是为什么大多数邮件列表依赖这个机制来验证注册信息的原因。因为任何人都可以输入 ceo@microsoft.com，这在技术上可能是有效的，但接收方不太可能是实际的 CEO。

因为你需要发送确认邮件来验证一个地址是否存在，你可以选择一个不那么严格的正则表达式。让一些无效地址通过，可能比阻止有效地址更好，这样就不会给人们带来不便。即使这个方案允许像 %#$ 这样的字符——这些字符通常在电子邮件地址中是不会出现的——它依然高效且简洁。此外，它也不会阻止一个合法的电子邮件地址被接受。

如果你想为正则表达式增加复杂度，我建议你通知用户电子邮件地址可能存在问题，而不是直接将其视为禁用。
