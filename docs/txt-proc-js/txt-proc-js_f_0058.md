| 食谱47 | 使用正向前瞻测试模式 |
| --- | --- |

### 任务

假设你的任务是修正多个文档中的错误，这些文档错误地列出了公司的收入为美元，而不是欧元。你需要找到所有“$90.3百万”的实例，并将“$”替换为“€”。

所以，你需要的是一个正则表达式模式，用来在类似这样的句子中找到“$90.3百万”：

|   | "公司发布了九月季度创纪录的收入为$90.3百万， |
| --- | --- |
|   | 上涨8%的年同比增长。" |

但你只想匹配和替换货币符号，而不是整个字符串。你需要一种方法来排除“90.3百万”不在匹配结果中。

### 解决方案

使用正向前瞻 (?= ... ) 来匹配你不想包括在结果中的字符串部分：

[part_2/positive_lookahead/positive_lookahead_ex1.js](http://media.pragprog.com/titles/fkjavascript/code/part_2/positive_lookahead/positive_lookahead_ex1.js)

|   | **const** str = *`公司发布了九月季度创纪录的收入* |
| --- | --- |
|   | *为$90.3百万，上涨8%的年同比增长。`*; |
|   |  |
|   | **const** re = */**\$(?=**90**\.**3**\s**million**)**/ig*; |
|   |  |
|   | *// 只替换$为€* |
|   | str.replace(re, *"€"*); |
|   | *// → "公司发布了九月季度创纪录的收入\n* |
|   | *// 的€90.3百万，上涨8%的年同比增长。"* |

使用 (?= ... ) 语法，你需要一个模式出现在正则表达式匹配之后，但不包括它在匹配中。

### 讨论

前瞻断言是非捕获组，它允许我们基于模式后面的子字符串来匹配模式。为了使正向前瞻匹配成功，它必须匹配一个模式，后跟子表达式中的模式。

请注意以下代码中match()的输出结果，它仅为“$”。

[part_2/positive_lookahead/positive_lookahead_ex2.js](http://media.pragprog.com/titles/fkjavascript/code/part_2/positive_lookahead/positive_lookahead_ex2.js)

|   | **const** str = *"$90.3 million"*; |
| --- | --- |
|   | **const** re = */**\$(?=**90**\.**3**\s**million**)**/*; |
|   |  |
|   | str.match(re)[0]; *// → "$"* |

使用前瞻时，子表达式不会包含在结果中，也不能通过反向引用来引用。

不过，也有解决方法。如果你将捕获括号放在前瞻表达式中，如(?=(regex))，你也可以在lookarounds中捕获匹配。将整个前瞻表达式用括号包裹是行不通的，因为当捕获组试图存储匹配时，前瞻已经丢弃了它。

不要混淆捕获和匹配。正向前瞻断言 (?= ... ) 和非捕获组 (?: ... ) 各自有不同的作用。虽然两者都不会捕获它们匹配的子字符串，但非捕获组会将该子字符串包括在整体匹配中，而正向前瞻断言则不会。

举个例子，如果我们重写本食谱中的解决方案，将非捕获组替换为前瞻断言，整个匹配将被替换：

[part_2/positive_lookahead/positive_lookahead_ex3.js](http://media.pragprog.com/titles/fkjavascript/code/part_2/positive_lookahead/positive_lookahead_ex3.js)

|   | **const** str = *`公司公布了九月季度创纪录的收入* |
| --- | --- |
|   | *的$90.3百万，同比增长8%。`*; |
|   |  |
|   | **const** re = */**\$(?:**90**\.**3**\s**million**)**/ig*; |
|   |  |
|   | str.replace(re, *"€"*); |
|   | *// → "公司公布了九月季度创纪录的收入 \n* |
|   | *// of €, year over year增长8%."* |

要了解更多关于非捕获组的内容，请参见第31条，[*使用捕获组提取匹配值*](f_0042.xhtml#rcp.capturing_group_p2)。

现在，让我们深入了解正则表达式模式：

|   | /\$(?=90\.3\smillion)/ig |
| --- | --- |
|   |  |
|   | ● \$ 匹配字符 "$" |
|   | ● (?=90.3\smillion) 正向前瞻 |
|   | ○ 90 匹配字符 "90" |
|   | ○ \. 匹配字符 "." |
|   | ○ 3 字面匹配字符 "3" |
|   | ○ \s 匹配任何空白字符 |
|   | ○ million 字面匹配字符 "million" |
|   | Flags |
|   | ● i 不区分大小写匹配 |
|   | ● g 全局匹配 |

使用预查来检查是否可以匹配一个特定的字符串，而不实际进行匹配。你可以使用两种类型的预查：正向预查和负向预查。正向预查用`(?= ... )`语法表示，它确保一个模式后面跟着另一个模式。另一方面，负向预查（我们将在下一个示例中重点介绍）用`(?! ... )`表示，它保证一个模式后面不跟着另一个模式。
