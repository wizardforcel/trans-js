| 配方 30 | 使用捕获组将多个字符视为一个单元 |
| --- | --- |

### 任务

假设你想要搜索一个文档档案并检索出其中提到8月日期的文档。你唯一的线索是这些日期有四种不同的样式。例如：“August 16”，“August 16th”，“Aug 16”或者“Aug 16th”。

要使用正则表达式匹配这样的日期，你需要一种方法，使得“August”中的“ust”和“16th”中的“th”变为可选。

### 解决方案

为了使某些字母变为可选，你需要将它们分组，放在括号中，并在组后面加上问号：

[part_2/capturing_group_p1/capturing_group_p1_ex1.js](http://media.pragprog.com/titles/fkjavascript/code/part_2/capturing_group_p1/capturing_group_p1_ex1.js)

|   | **const** re = */**\b**Aug**(**ust**)?\s\d{1,2}(**st&#124;nd&#124;rd&#124;th**)?\b**/*; |
| --- | --- |
|   |  |
|   | *// 分组允许匹配多个备选项* |
|   | re.test(*"Aug 16"*); *// → true* |
|   | re.test(*"August 16"*); *// → true* |
|   | re.test(*"Aug 16th"*); *// → true* |
|   | re.test(*"August 16th"*); *// → true* |

这个正则表达式匹配日期格式为“Aug 1st”，“August 15th”，“Aug 22nd”，“August 31st”等等。请注意，如果日期包含排版错误，比如“August 16nd”或者“Aug 1rd”，这个模式仍然会匹配。

### 讨论

让我们一步步来分析这个模式：

|   | /\bAug(ust)?\s\d{1,2}(st&#124;nd&#124;rd&#124;th)?\b/ |
| --- | --- |
|   |  |
|   | ● \b 断言单词边界 |
|   | ● Aug 匹配字面上的字符 Aug |
|   | ● (ust)? 第一个捕获组 |
|   | ○ ust 匹配字面上的字符 ust |
|   | ○ ? 匹配前面的标记零次或一次 |
|   | ● \s 匹配任何空白字符 |
|   | ● \d 匹配一个数字 |
|   | ○ {1,2} 匹配前面的标记1次或2次 |
|   | ● (st&#124;nd&#124;rd&#124;th)? |
|   | ○ 第一种备选项 st: 匹配字面上的字符 st |
|   | ○ 第二种备选项 nd: 匹配字面上的字符 nd |
|   | ○ 第三个备选项 rd：字面匹配字符 rd |
|   | ○ 第四个备选项 th：字面匹配字符 th |
|   | ○ ? 匹配前一个符号零次或一次 |
|   | ● \b 断言一个单词边界 |

正则表达式以单词边界（\b）开始，这使我们能够匹配单词的开头。接着我们使用Aug(ust)?来匹配“Aug”字符串，后面跟一个可选的“ust”，这告诉正则表达式同时匹配“Aug”和“August”两种格式的月份。之后，我们使用\s来匹配月份后的空白字符（空格、制表符等）。

对于日期中的天数，我们使用\d{1,2}来匹配一位或两位数字。范围{1,2}确保只匹配一位或两位数字。接着，我们使用(st|nd|rd|th)?来匹配日期的后缀，包括“st”、“nd”、“rd”或“th”。在所有元字符中，竖线的优先级最低：它匹配竖线左边或右边的任何内容。在这种情况下，我们需要通过将字符括起来来限制选择的范围。

然后我们使用问号使后缀变为可选。最后，我们在正则表达式的结尾加上单词边界（\b），以匹配单词的结尾。

| 不要在字符类中使用捕获组 |
| --- |
| ![images/aside-icons/warning.png](images/aside-icons/warning.png) | 在字符类中无法使用捕获组，因为字符类中的括号会被视为字面字符。例如，[x(y)] 会匹配字符x、(、y和)中的任意一个。 |

有时，分组正则表达式中的一部分并将其视为一个单独的单元是很有用的。你可以通过将字符封装在括号中来实现。分组使你能够对整个分组使用量词，限制交替只作用于模式的某部分，或者提取匹配的值以进行进一步处理（这也是我们下一个主题的内容）。
