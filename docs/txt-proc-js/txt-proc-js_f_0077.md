| 配方 65 | 提取被单引号括起来的文本 |
| --- | --- |

### 任务

假设你的迷你游戏小部件的数据源列出了昵称时使用的是单引号，而不是双引号。提取单引号中的文本比提取双引号中的文本更具挑战性，因为昵称本身可能包含撇号。

例如：

|   | 迈克尔·尤金·阿彻，亦称为 'D'Angelo' |
| --- | --- |

你需要一个能够准确识别一对单引号，并将其与撇号区分开的解决方案。

### 解决方案

利用正向与反向查找：

[part_3/extracting_text_in_single_quotes/single_quoted_text_ex1.js](http://media.pragprog.com/titles/fkjavascript/code/part_3/extracting_text_in_single_quotes/single_quoted_text_ex1.js)

|   | **const** str = |
| --- | --- |
|   | *`1\. 迈克尔·尤金·阿彻，亦称为 'D'Angelo'* |
|   | *2\. スカーレット・ヨハンソン，亦称为 'Scarjo'* |
|   | *3\. 布拉德利·库珀，亦称为 'Coop'* |
|   | *4\. 詹妮弗·劳伦斯，亦称为 'Nitro'* |
|   | *5\. 休·杰克曼，亦称为 'Sticks'* |
|   | *6\. 汤姆·哈迪，亦称为 'Weasel'`*; |
|   |  |
|   | **function** extractQuotes(str) { |
|   | **const** re = */**(?<**!**\w)**'**(**.+**?)**'**(?!\w)**/g*; |
|   | **const** quotes = [...str.matchAll(re)].map(value => value[1]); |
|   |  |
|   | **return** quotes; |
|   | } |
|   |  |
|   | extractQuotes(str); |
|   | *// → ["D'Angelo", "Scarjo", "Coop", "Nitro", "Sticks", "Weasel"]* |

该解决方案可以捕获那些不属于更大单词或被其他单词字符包围的单引号字符串。

### 讨论

让我们一步步地分析这个正则表达式：

|   | /(?<!\w)'(.+?)'(?!\w)/ |
| --- | --- |
|   |  |
|   | ● (?<!\w) 负向查找：确保正则表达式内部不匹配 |
|   | ○ \w 匹配任何单词字符 |
|   | ● ' 字符字面上匹配 ' |
|   | ● (.+?) 第一个捕获组 |
|   | ○ . 匹配任何字符（除了行终止符） |
|   | ○ +? 匹配前面的标记一次或多次，尽可能少 |
|   | 次数尽可能少（懒惰） |
|   | ● ' 字面匹配字符 ' |
|   | ● (?!\w) 负向前瞻：断言括号内的正则表达式不匹配 |
|   | ○ \w 匹配任何单词字符 |

这个正则表达式以负向后顾开始，匹配一个没有被字母、数字或下划线等单词字符所预先跟随的单引号。因此，它不会匹配像“What's”这样的词。接下来，(.+?) 匹配一个或多个字符。问号使得匹配变得非贪婪，这意味着量词尽可能少地匹配前面的内容（见第38条，[*通过问号创建懒量词*](f_0049.xhtml#rcp.lazy)）。如果没有问号，模式将匹配字符串中的最后一个闭合引号。

最后，’(?!\w) 匹配一个单引号，且后面不能跟随字母、数字或下划线——这是由于负向前瞻的作用。
