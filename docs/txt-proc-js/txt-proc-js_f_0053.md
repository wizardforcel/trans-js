| 配方 42 | 强制 . 匹配换行符的 s 标志 |
| --- | --- |

### 任务

假设你想编写一个脚本，用于从 JavaScript 文件中删除所有注释，以减小文件的大小。删除单行注释很容易：只需找到以双斜杠开头的行并删除整行。

但是，删除可能跨越多行的 /* */ 语法块注释要复杂一些。你可能会认为像 /\/\*.*\*\// 这样的模式可以工作，因为它会找到 /* 后面跟着任何字符直到 */。

但是，这个模式中的点号符号不会匹配换行符，因此正则表达式可能会失败：

[part_2/flag_dotall/dotall_ex1.js](http://media.pragprog.com/titles/fkjavascript/code/part_2/flag_dotall/dotall_ex1.js)

|   | **const** re = */**\/\***.***?\*\/**/*; |
| --- | --- |
|   |  |
|   | **const** comment = *`/* 这个* |
|   | *是多行* |
|   | *注释 */`*; |
|   |  |
|   | re.test(comment); *// → false* |

一个旧的解决方法是使用两个相反的简写字符类，例如 [\w\W]。由于所有字符要么是单词字符，要么是非单词字符，因此该字符类将匹配任何字符，包括 \r 和 \n：

幸运的是，ES2018 引入了 dotAll 模式，更优雅地解决了这个问题。

### 解决方案

将 s 标志附加到模式的末尾，像这样：

[part_2/flag_dotall/dotall_ex2.js](http://media.pragprog.com/titles/fkjavascript/code/part_2/flag_dotall/dotall_ex2.js)

|   | **const** re = */**\/\***.***?\*\/**/*s; |
| --- | --- |
|   |  |
|   | **const** comment = *`/* 这个* |
|   | *是多行* |
|   | *注释 */`*; |
|   |  |
|   | re.test(comment); *// → true* |

现在，你的正则表达式可以匹配跨越多行的块注释。现在，让我们利用这个功能构建一个函数，该函数接受一个字符串并删除其中所有的 JavaScript 注释：

[part_2/flag_dotall/dotall_ex3.js](http://media.pragprog.com/titles/fkjavascript/code/part_2/flag_dotall/dotall_ex3.js)

|   | *// 删除 js 注释* |
| --- | --- |
|   | **function** removeComments(str) { |
|   |  |
|   | *// 匹配块注释（/*...*/）* |
|   | **const** re1 = */**\/\***.***?\*\/**/*sg; |
|   |  |
|   | *// 匹配单行注释（//...）* |
|   | **const** re2 = */**\/\/\s**.+/g*; |
|   |  |
|   | *// 移除注释* |
|   | **let** code = str.replace(re1, *""*); |
|   | code = code.replace(re2, *""*); |
|   |  |
|   | **return** code; |
|   | } |
|   |  |
|   | **const** jsCode = |
|   | *`// 一个变量* |
|   | *let abc = 123;* |
|   | */* 另一个* |
|   | *变量 */* |
|   | *let def = 456;`*; |
|   |  |
|   | console.log(removeComments(jsCode)); |
|   | *//* |
|   | *// let abc = 123;* |
|   | *//* |
|   | *// let def = 456;* |

请注意，在某些情况下，这种解决方案可能无法准确地移除 JavaScript 注释。例如，字符串中的双斜杠（//）不再是注释，但正则表达式并不会这样识别并会将其移除。或者，块注释中的*/不会在 JavaScript 解释器看来结束注释，但在正则表达式中却是结束符。为了更准确地去除 JavaScript 注释，您可以利用抽象语法树（AST）解析器，例如 acorn。^([[26]](f_0064.xhtml#FOOTNOTE-26))

### 讨论

使用标志来改变句点的工作方式的好处在于，它允许我们在每个正则表达式的基础上激活该模式。这样，依赖于旧有句点行为的现有正则表达式模式就不会受到影响。

在这个方案中，我们创建了一个函数，用于从给定字符串中移除单行和块注释。为了避免正则表达式过于复杂，我们使用了两种不同的模式分别匹配每种类型的注释。找到所有匹配项后，我们将其替换为空字符串，并返回修改后的字符串。

第一个模式匹配以 `/*` 开头并以 `*/` 结尾的多行注释。由于正斜杠也用于在 JavaScript 中界定正则表达式，我们需要使用反斜杠对它进行转义，以匹配字面意义上的正斜杠。类似地，我们需要对星号进行转义，以匹配字面意义上的星号：

|   | /\/\*.*?\*\//sg |
| --- | --- |
|   |  |
|   | ● \/ 匹配字符 / 字面意思 |
|   | ● \* 匹配字符 * 字面意思 |
|   | ● . 匹配任何字符 |
|   | ○ *? 匹配前一个标记出现零次到无限次，尽可能少 |
|   | 尽可能多次（懒惰模式） |
|   | ● \* 匹配字符 * 字面意思 |
|   | ● \/ 匹配字符 / 字面意思 |
|   | ● 标志 |
|   | ○ s: 启用匹配换行符 |
|   | ○ g: 启用查找所有匹配项 |

我们使用 `.*?` 来匹配任何字符序列，包括换行符，但尽可能少。`?` 使得 `*` 变成懒惰模式。这一点很重要，因为我们只想匹配注释的内容，而不匹配任何后续的注释。

接下来，我们使用 `*\/` 来匹配一个字面意思的星号后跟一个正斜杠。模式末尾的 `s` 标志启用“dot all”模式。如果没有这个标志，`.` 就无法匹配换行符，正则表达式也无法匹配多行注释。

第二个正则表达式匹配以两个正斜杠（“//”）开头，后跟一个空白字符，然后是一个或多个非换行字符的任何字符序列。我们需要通过在每个正斜杠前加上反斜杠来转义它：

|   | /\/\/\s.+/g |
| --- | --- |
|   |  |
|   | ● \/ 匹配字符 / 字面意思 |
|   | ● \/ 匹配字符 / 字面意思 |
|   | ● \s 匹配任何空白字符 |
|   | ● . 匹配任何字符 |
|   | ○ + 匹配前一个标记出现一次到无限次，尽可能多 |
|   | 尽可能多次（贪婪模式） |
|   | ● 标志 |
|   | ○ g: 启用查找所有匹配项 |

我们使用 “.+” 来匹配直到行尾的所有内容。没有必要添加额外的表达式来使匹配停止在行尾。只需确保此正则表达式没有设置 `s` 标志。

句号可能是正则表达式中最常用的元字符。默认情况下，它匹配除换行符以外的任何单个字符。但大多数情况下，我们也希望匹配换行符。dotAll 模式提供了一个简单的解决方法，可以通过 `s` 标志来激活。
