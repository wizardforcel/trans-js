| 方案 64 | 提取双引号括起来的文本 |
| --- | --- |

### 任务

假设你有一个电影评论网站，并且你想在页面上嵌入一个迷你游戏小部件。这个游戏会提示读者根据给定的昵称猜测名人的名字。

数据源是一个包含名人姓名及其对应昵称的字符串，所有内容都被双引号括起来，像这样：

|   | 1\. 德维恩·约翰逊，也被称为"巨石" |
| --- | --- |
|   | 2\. 薇诺娜·约翰逊，也被称为"Scarjo" |
|   | 3\. 布莱德利·库珀，也被称为"库普" |
|   | 4\. 詹妮弗·劳伦斯，也被称为"炸药" |
|   | 5\. 雨果·杰克曼，也被称为"棍子" |
|   | 6\. 汤姆·哈迪，也被称为"黄鼠狼" |

你的初始任务是从字符串中提取引用文本，以便构建一个包含昵称的数组：

|   | ["巨石", "Scarjo", "库普", "炸药", "棍子", "黄鼠狼"] |
| --- | --- |

你需要做的是检测一对引号并提取其中的文本。

### 解决方案

向正则表达式模式的开始和结尾添加双引号，并使用否定字符类匹配非双引号字符：

[part_3/extracting_text_in_double_quotes/double_quoted_text_ex1.js](http://media.pragprog.com/titles/fkjavascript/code/part_3/extracting_text_in_double_quotes/double_quoted_text_ex1.js)

|   | **const** str = |
| --- | --- |
|   | *`1\. 德维恩·约翰逊，也被称为"巨石"* |
|   | *2\. 薇诺娜·约翰逊，也被称为"Scarjo"* |
|   | *3\. 布莱德利·库珀，也被称为"库普"* |
|   | *4\. 詹妮弗·劳伦斯，也被称为"炸药"* |
|   | *5\. 雨果·杰克曼，也被称为"棍子"* |
|   | *6\. 汤姆·哈迪，也被称为"黄鼠狼"`*; |
|   | **function** extractQuotes(str) { |
|   | **const** re = */"**([^**"**]*****)**"/g*; |
|   | **const** quotes = [...str.matchAll(re)].map(value => value[1]); |
|   |  |
|   | **return** quotes; |
|   | } |
|   |  |
|   | extractQuotes(str); |
|   | *// → ["The Rock", "Scarjo", "Coop", "Nitro", "Sticks", "Weasel"]* |

该函数返回一个包含引用文本的数组，但结果中不包括引号。

### 讨论

双引号在正则表达式中没有特殊含义，因此我们只是将其添加到模式中。接下来，我们使用`[^"]`来匹配任何不是双引号的字符，并追加一个`*`来使该类重复零次或多次。该模式以一个双引号结束，用于匹配结束的双引号。

为了获取所有匹配的捕获组，我们使用`matchAll()`方法。由于`matchAll()`返回一个迭代器，我们可以使用扩展语法（…）来解包对象，并从结果中生成一个数组。这样我们就可以在其上使用数组方法。

由于我们的正则表达式模式中有一个捕获组，每个匹配结果都包含一个有两个元素的数组：整个匹配的子字符串和引号中的内容。通过使用`value[1]`，我们访问数组的第二个元素，这对应于引号中的内容。然后，我们将这些内容存储在`quotes`数组中。

匹配单引号括起来的字符串可能稍微有些挑战，因为引号中的文本可能包含撇号，例如在‘I can’t.’中。下一个示例提供了解决方案，用于提取被单引号括起来的文本。
