| 配方49 | 使用正向回顾测试模式 |
| --- | --- |

### 任务

假设你的任务是从标准化考试中提取问题并将其存储到数据库中。你需要提取的问题文本总是紧跟在类似“Question #5:”的编号系统后面，但你希望提取问题文本时不包含编号。

由于编号系统中字符的长度在不同问题之间会有所变化，粘滞标志在这种情况下并不有效。例如，一个问题可能以“Question #9”开始，而另一个问题则可能以“Question #10”开始（关于粘滞标志的更多内容，参见配方44，[*使用y标志从特定索引开始搜索*](f_0055.xhtml#rcp.flag_y)）。

你需要一种解决方案，允许你匹配由“Question #n”前缀的问题，但不将编号包括在结果中。

### 解决方案

将模式包含在一个正向回顾断言中，表示为(?<= ... )：

[part_2/positive_lookbehind/positive_lookbehind_ex1.js](http://media.pragprog.com/titles/fkjavascript/code/part_2/positive_lookbehind/positive_lookbehind_ex1.js)

|   | **const** re = */**(?<**=Question**\s**#**\d{1,3}**:**\s)**.+**?\.**/ig*s; |
| --- | --- |
|   | **const** str = *`* |
|   | *Question #9: 伯罗奔尼撒战争是发生在__________之间的。* |
|   | *Question #10: 一个金字塔形神庙是__________。* |
|   | *`*; |
|   |  |
|   | **const** questions = str.match(re); |
|   |  |
|   | console.log(questions); |
|   | *// → [* |
|   | *// "伯罗奔尼撒战争是发生在__________之间的。"* |
|   | *// "一个金字塔形神庙是__________。"* |
|   | *// ]* |

成功！匹配的项目不包括编号系统。

| 浏览器兼容性 |
| --- |
| ![images/aside-icons/warning.png](images/aside-icons/warning.png) | 尽管现代浏览器的最新版本支持后顾查找断言，^([[29]](f_0064.xhtml#FOOTNOTE-29)) 但并非所有用户都已更新他们的浏览器。为了确保最大兼容性，您可以在服务器端使用后顾查找断言，自 Node 10.3 版本起，它们就已经得到了支持。 |

### 讨论

在 ES2018 之前，JavaScript 仅支持正向查找断言（lookahead assertions）。但随着 ES2018 的引入，后顾查找断言（lookbehinds）被添加，以增强 JavaScript 的功能。类似于正向查找，后顾查找也有两个版本：正向后顾查找和负向后顾查找。

在这个例子中，.+\. 匹配一个或多个字符，直到遇到句号。但在此之前，有一个正向后顾查找断言，确保该模式前面有单词“Question”，后跟一个空白字符、一个#、1到3个数字、一个冒号和另一个空白字符。

让我们一步步分析正则表达式模式：

|   | /(?<=Question\s#\d{1,3}:\s).+\./igs |
| --- | --- |
|   |  |
|   | ● (?<=Question\s#\d:\s) 正向查找断言 |
|   | ○ Question 匹配字符"Question"字面意义 |
|   | ○ \s 匹配任何空白字符 |
|   | ○ # 匹配字符"#"字面意义 |
|   | ○ \d 匹配一个数字 |
|   | ○ {1,3} 匹配前一个元素 1 到 3 次 |
|   | ○ : 匹配字符":"字面意义 |
|   | ○ \s 匹配任何空白字符 |
|   | ● . 匹配任何字符 |
|   | ○ +? 匹配前一个元素一次或多次（懒惰匹配） |
|   | ● \. 匹配字符"."字面意义 |
|   | ● 标志 |
|   | ○ i 执行不区分大小写的匹配 |
|   | ○ g 查找所有匹配项 |
|   | ○ s 点号匹配换行符 |
| 什么是查找断言？ |
| --- |
| ![images/aside-icons/info.png](images/aside-icons/info.png) | 查找前瞻和查找后顾断言统称为查找断言（lookarounds）。 |
| 多重查找断言 |
| --- |
| ![images/aside-icons/tip.png](images/aside-icons/tip.png) | 任意类型的前后查找（负向或正向）可以连续出现，以创建更复杂的模式。 |

关于前后查找（lookarounds），需要记住的一点是，尽管它们检查是否可能匹配，但实际上并不会消耗字符串中的字符。后向查找（lookbehinds）与前向查找（lookaheads）相似，区别在于它们是向后查找。它们指示正则表达式暂时向后移动，以查看其子表达式是否能够匹配。
