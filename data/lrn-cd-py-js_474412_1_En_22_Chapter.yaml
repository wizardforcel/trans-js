- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024 J. L. Zuckarelli Learn coding with Python and JavaScript
    [`https://doi.org/10.1007/978-3-658-42912-6_22`](https://doi.org/10.1007/978-3-658-42912-6_22)
  id: totrans-0
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: © 作者，Springer Fachmedien Wiesbaden GmbH 独家许可，Springer Nature 2024 J. L. Zuckarelli
    《使用 Python 和 JavaScript 学习编程》[`https://doi.org/10.1007/978-3-658-42912-6_22`](https://doi.org/10.1007/978-3-658-42912-6_22)
- en: '`22. User Interfaces: How Do I Input and Output Data?`'
  id: totrans-1
  prefs:
  - PREF_H1
  stylish: true
  type: TYPE_NORMAL
  zh: '`22. 用户界面：如何输入和输出数据？`'
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1)München, Germany Overview
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: Joachim L. Zuckarelli^([1](#Aff2) )(1)慕尼黑，德国 概览
- en: We have dealt extensively with the organization of data in the program, namely
    the variables and objects used. Now is the time to talk about how data can be
    received from and output back to the user. To this end, in this chapter we will
    first deal with the simplest way of input and output, namely via the `console`.
    After that, we’ll give our programs a much more appealing look with `graphical
    user interfaces` (GUIs). Not only will we take a closer look at working with GUIs
    using a complete application example, but you will also have the opportunity to
    program your own first GUI application as part of an exercise. Finally, we turn
    to working with `files`, which is of course extremely important in practice.
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们已经广泛讨论了程序中数据的组织方式，即使用的变量和对象。现在是时候讨论如何从用户那里接收数据并将其输出回去了。为此，在本章中我们将首先讨论最简单的输入和输出方式，即通过
    `控制台`。之后，我们将通过 `图形用户界面`（GUI）使我们的程序看起来更加吸引人。我们不仅将通过一个完整的应用程序示例更深入地了解如何使用 GUI，还将有机会在练习中编写你自己的第一个
    GUI 应用程序。最后，我们将讨论如何与 `文件` 打交道，这在实际操作中非常重要。
- en: 'In this chapter you will learn:'
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在本章中你将学习：
- en: How to output information to the console and how to query the user in the console
  id: totrans-5
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何将信息输出到控制台以及如何在控制台中查询用户
- en: how to use the Python library `tkinter` to provide your program with a graphical
    user interface
  id: totrans-6
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何使用 Python 库 `tkinter` 为你的程序提供图形用户界面
- en: what controls are available to you, how they can be configured, placed and arranged
    on the interface
  id: totrans-7
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 可用的控件有哪些，它们如何配置、放置以及在界面上排列
- en: how you can react in your program code to events that the user triggers via
    the interface (for example, when clicking on a button)
  id: totrans-8
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何在程序代码中响应用户通过界面触发的事件（例如，点击按钮时）
- en: how to read data from and write data to files.
  id: totrans-9
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何从文件中读取数据以及如何向文件写入数据。
- en: '`22.1 Input and Output in the Console`'
  id: totrans-10
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`22.1 控制台中的输入和输出`'
- en: Already in the previous chapters we have seen the two most important functions
    that are used to input and output data in the Python console, `input()` and `print()`.
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经看到两个最重要的函数，它们用于在 Python 控制台中输入和输出数据，`input()` 和 `print()`。
- en: '`Input`'
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`输入`'
- en: '`input(prompt)` displays a prompt and lets the user enter input from the keyboard,
    completing the input by pressing the `<RETURN>` or `<ENTER>` key. `input()` then
    returns the input as a return value, and always as a string. This is important,
    particularly if you expect the input to be numbers that you can use in calculations
    later. In this case, you must first explicitly convert the return value of `input()`
    to a number, as we did in ► Sect. `21.5`.'
  id: totrans-13
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`input(prompt)` 显示一个提示并允许用户从键盘输入，通过按下 `<RETURN>` 或 `<ENTER>` 键来完成输入。然后，`input()`
    会将输入作为返回值返回，并始终以字符串形式返回。这一点很重要，特别是当你期望输入的内容是数字，之后用于计算时。在这种情况下，你必须首先显式地将 `input()`
    的返回值转换为数字，正如我们在 ► 第 `21.5` 节 中所做的那样。'
- en: '`Output`'
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`输出`'
- en: 'The most important tool for outputting information is the`print()` function.
    It can be used to print one or more objects. If more than one object is to be
    printed, the optional string argument`sep` determines how the individual objects
    are separated from each other in the output; by default, this is done with a space
    character. The optional`end` argument controls what is printed at the end of the
    output; unless otherwise specified with`end`，a line break is placed at the end
    of the output. The line break is represented by an escape sequence`''\n''` (for
    *new line*), which we already learned about in ► Sect. [11.​2.​2](474412_1_En_11_Chapter.xhtml#Sec4)
    in connection with strings. Of course, we can also use these escape sequences
    directly in strings that we want to output: Consider the following small program
    as an example:'
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 输出信息的最重要工具是`print()`函数。它可以用于打印一个或多个对象。如果要打印多个对象，可选的字符串参数`sep`决定了输出中各个对象之间如何分隔；默认情况下，这些对象通过空格字符分隔。可选的`end`参数控制输出的结束部分；除非另行指定`end`，否则会在输出的末尾添加换行符。换行符由转义序列`'\n'`表示（用于*新行*），我们已经在►
    Sect. [11.​2.​2](474412_1_En_11_Chapter.xhtml#Sec4)中与字符串一起学习过这个内容。当然，我们也可以在想要输出的字符串中直接使用这些转义序列：考虑以下小程序作为例子：
- en: '`user = input(''Username: '') pwd = input(''Password: '') print(''Welcome,
    '', user, ''!\nYour password is: '', pwd)` Here we read a username and password
    from the user and then output a total of four objects:'
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`user = input(''用户名：'') pwd = input(''密码：'') print(''欢迎，'', user, ''!\n你的密码是：'',
    pwd)` 在这里，我们从用户那里读取用户名和密码，然后输出总共四个对象：'
- en: The string`'Welcome, '`
  id: totrans-17
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 字符串`'欢迎，'`
- en: The string variable`user`
  id: totrans-18
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 字符串变量`user`
- en: 'The string`''!\n Your password is:''` (Attention: This string contains a line
    break after the exclamation mark!)'
  id: totrans-19
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 字符串`'!\n 你的密码是：'`（注意：这个字符串在感叹号后面包含了换行符！）
- en: The string variable`pwd`.
  id: totrans-20
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 字符串变量`pwd`。
- en: 'If you call the program now and enter`peter` and`889X!z5` as username and password,
    you get the following output: Welcome, `peter` !Your password is: `889X!z5`'
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你现在调用程序并输入`peter`和`889X!z5`作为用户名和密码，你将看到以下输出：欢迎，`peter`！你的密码是：`889X!z5`
- en: 'The space between the username`peter` and the exclamation mark is a bit unattractive.
    It is due to the default value of the separator argument`sep`，which is a space.
    Because of this, the two objects to be output, the variable`user` and the string
    beginning with the exclamation mark, are separated by a space. To avoid such problems,
    it is recommended to control the output of whitespace itself and set the argument`sep`
    to “empty string”, so that no separator is output by the`print()` function itself.
    The call to`print()`could then be like this:'
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 用户名`peter`和感叹号之间的空格看起来有点不太美观。这是由于`sep`参数的默认值为空格。正因为如此，要输出的两个对象，即变量`user`和以感叹号开头的字符串，被空格隔开了。为了避免此类问题，建议控制空白字符的输出，并将`sep`参数设置为空字符串，这样`print()`函数就不会自动输出分隔符。此时，`print()`的调用方式可以是这样的：
- en: '`print(''Welcome, '', user, ''!\nYour password is: '', pwd, sep = '''')`'
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`print(''欢迎，'', user, ''!\n你的密码是：'', pwd, sep = '''')`'
- en: If you compare this with the call above, you will see that we have inserted
    a space wherever a space is to be output and have provided an empty string as`sep`
    argument. Please note that the`sep` argument must always be called with its name,
    otherwise the`print()` function does not know whether the last string still belongs
    to the objects to be output or whether it has a special meaning, i.e. it already
    represents the *next argument of* the function, as in our case. So, we call`sep`
    as a *keyword argument*. More on this in ► Sect. [23.​1.​2](474412_1_En_23_Chapter.xhtml#Sec3).
  id: totrans-24
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你将此与上面的调用进行对比，你会发现我们在每个需要输出空格的地方插入了一个空格，并且为`sep`参数提供了一个空字符串。请注意，`sep`参数必须始终使用其名称调用，否则`print()`函数无法判断最后一个字符串是否仍然属于要输出的对象，或者它是否具有特殊含义，即它已经代表了*函数的下一个参数*，就像在我们这个例子中一样。因此，我们将`sep`作为*关键字参数*来调用。更多内容请参见►
    Sect. [23.​1.​2](474412_1_En_23_Chapter.xhtml#Sec3)。
- en: 'Of course, the objects that are printed with `print()` do not have to be strings
    only. In fact, you can use `print()` to print practically any object, and even
    include objects of different types, i.e., different classes, in one and the same
    `print()` call. This applies to classes that you have defined yourself. But how
    can this work? How does `print()` know how to display an object of type `Product`
    from ► Sect. [21.​7](474412_1_En_21_Chapter.xhtml#Sec23), for example? The answer
    is simple: Classes in Python can have a special function `__str__()`. It returns
    a string representation of the object and is called by `print()` when an object
    of that class is to be output. As the developer of the class, you can specify
    how objects of your class should be represented. All you have to do is define
    a `__str__()` method. We will look at an example of this in ► Sect. [23.​2](474412_1_En_23_Chapter.xhtml#Sec6).'
  id: totrans-25
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当然，通过`print()`打印的对象不一定只有字符串。实际上，您可以使用`print()`打印几乎任何对象，甚至可以在同一个`print()`调用中包含不同类型的对象，即不同类的对象。这也适用于您自己定义的类。那么这怎么实现呢？比如，`print()`是如何知道如何显示一个`Product`类型的对象的呢？答案很简单：Python中的类可以有一个特殊的`__str__()`函数。当该类的对象需要输出时，`print()`会调用这个函数。作为类的开发者，您可以指定对象应该如何表示。您只需要定义一个`__str__()`方法即可。我们将在►节[23.2](474412_1_En_23_Chapter.xhtml#Sec6)中看一个例子。
- en: 22.1`[5 min]`
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 22.1`[5分钟]`
- en: Specify three different ways to output the three string expressions `'First
    line'`, `'Second line'` and `'Third line'` in three consecutive lines.
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 指定三种不同的方式，将三条字符串表达式`'First line'`、`'Second line'`和`'Third line'`输出到连续的三行中。
- en: 22.2`Graphical User Interfaces with Tkinter`
  id: totrans-28
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 22.2`使用Tkinter创建图形用户界面`
- en: 22.2.1`Overview`
  id: totrans-29
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 22.2.1`概述`
- en: Programs on the command line or in the Python console are not everyone’s cup
    of tea. Especially if you develop software for non-tech-savvy end users, you simply
    can’t get around graphical user interfaces. Therefore, in this section we will
    look at how to design graphical user interfaces in Python with manageable effort,
    and how to back them up with program functionality. There are a number of ways
    to design graphical user interfaces in Python. With the `Streamlit` library, for
    example, you can use Python to create dynamic web pages that can also be hosted
    on web servers. In this chapter, we will concentrate on applications that run
    locally on a client, e.g. your computer.
  id: totrans-30
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 命令行程序或Python控制台程序并不是每个人的“茶”。尤其是如果您为非技术用户开发软件时，您根本无法绕过图形用户界面。因此，在本节中，我们将讨论如何用可管理的工作量在Python中设计图形用户界面，并如何为其添加程序功能。Python中有多种设计图形用户界面的方法。例如，使用`Streamlit`库，您可以使用Python创建动态网页，并且这些网页也可以托管在Web服务器上。本章我们将重点讨论在本地客户端（例如您的计算机）上运行的应用程序。
- en: Using the example of a graphical calculator, you will see that with only a few
    lines of code you can write a useful, fully functional program with an attractive
    interface that does not force the user to sit in front of a black console and
    stubbornly follow the given program flow. The chapter concludes with an exercise
    in which you will develop your own simple text editor that allows you to open,
    edit, and save text files.
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以图形计算器为例，您将看到，通过仅仅几行代码，您就可以编写一个有用的、功能完备的程序，拥有一个不强迫用户坐在黑色控制台前并固执地跟随给定程序流程的吸引人界面。本章最后将有一个练习，您将在其中开发自己的简单文本编辑器，允许您打开、编辑和保存文本文件。
- en: 有许多不同的库和框架用于开发图形界面。它们中的许多都是跨平台的，这意味着您用它们开发的程序可以在不同的计算机（有时是移动）操作系统上运行。我们将使用的一个常用库是`tkinter`。方便的是，它是Python的标准库，因此我们不需要安装额外的东西。`tkinter`是基于`Tk`的，这是一种用于图形用户界面的跨平台库，最初是在1990年代初期用一种名为`Tcl`的编程语言开发的。`Tcl`主要因`Tk`库而流行。这是因为它不仅适用于Tcl本身，而且适用于大量其他编程语言，包括Python。
  id: totrans-32
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 有许多不同的库和框架用于开发图形界面。它们中的许多都是跨平台的，这意味着您用它们开发的程序可以在不同的计算机（有时是移动）操作系统上运行。我们将使用的一个常用库是`tkinter`。方便的是，它是Python的标准库，因此我们不需要安装额外的东西。`tkinter`是基于`Tk`的，这是一种用于图形用户界面的跨平台库，最初是在1990年代初期用一种名为`Tcl`的编程语言开发的。`Tcl`主要因`Tk`库而流行。这是因为它不仅适用于Tcl本身，而且适用于大量其他编程语言，包括Python。
- en: Python提供了一个名为`tkinter`的包，它最终是一种与`Tk`的“连接”。要使用`Tk`库，Python调用一个Tcl解释器，该解释器也是标准Python安装的一部分。因此，实际上，您间接地使用了另一种编程语言，但您不需要理解Tcl语法或自己调用Tcl解释器。相反，您可以在Python中工作，并使用常规的Python语法。在必要时，Python会将您的语句“翻译”成Tcl代码并调用Tcl解释器。关于`Tk`的实用之处在于，一旦您理解了这个库的工作原理，您可以快速在支持`Tk`的其他编程语言中开发自己的图形用户界面——而这些语言有不少——而不会遇到任何重大转换困难。
  id: totrans-33
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: Python提供了一个名为`tkinter`的包，它最终是一种与`Tk`的“连接”。要使用`Tk`库，Python调用一个Tcl解释器，该解释器也是标准Python安装的一部分。因此，实际上，您间接地使用了另一种编程语言，但您不需要理解Tcl语法或自己调用Tcl解释器。相反，您可以在Python中工作，并使用常规的Python语法。在必要时，Python会将您的语句“翻译”成Tcl代码并调用Tcl解释器。关于`Tk`的实用之处在于，一旦您理解了这个库的工作原理，您可以快速在支持`Tk`的其他编程语言中开发自己的图形用户界面——而这些语言有不少——而不会遇到任何重大转换困难。
- en: 在下一部分中，我们将编写一个简单的`Hello World`程序，该程序将在屏幕上打开一个窗口。之后，我们将仔细查看用户界面的各种图形控件，即`widgets`，如按钮、输入框和复选框。之后，我们只需再缺少两个组件。我们需要将这些元素按我们希望的方式排列在界面上，以便获得所需的界面外观。最后，我们必须将控件与背后的程序代码连接起来，以便它们能对用户的操作做出适当反应。这使我们拥有编写具有适当图形界面的Python程序所需的一切，比如我们将在`tkinter`介绍结束时开发的计算器。但让我们先从小事开始！
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将编写一个简单的`Hello World`程序，该程序将在屏幕上打开一个窗口。之后，我们将仔细查看用户界面的各种图形控件，即`widgets`，如按钮、输入框和复选框。之后，我们只需再缺少两个组件。我们需要将这些元素按我们希望的方式排列在界面上，以便获得所需的界面外观。最后，我们必须将控件与背后的程序代码连接起来，以便它们能对用户的操作做出适当反应。这使我们拥有编写具有适当图形界面的Python程序所需的一切，比如我们将在`tkinter`介绍结束时开发的计算器。但让我们先从小事开始！
- en: 22.2.2 Hello Tkinter!
  id: totrans-35
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 22.2.2 你好，Tkinter！
- en: 创建一个新的Python文件，包含以下程序代码并运行该程序：
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件，包含以下程序代码并运行该程序：
- en: '`from tkinter import win = Tk() win.title(''Hello World Program'') win.geometry(''900x500'')
    win.mainloop()` 一扇窗口打开，外观类似于◘ 图 [22.1](#Fig1)。![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig1_HTML.jpg)'
  id: totrans-37
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`from tkinter import win = Tk() win.title(''Hello World Program'') win.geometry(''900x500'')
    win.mainloop()` 打开一个窗口，外观类似于◘ 图 [22.1](#Fig1)。![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig1_HTML.jpg)'
- en: 窗口中显示的文本为“Hello world program”的截图。
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 窗口中显示的文本为“Hello world program”的截图。
- en: 图 22.1
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 22.1
- en: 一个`Hello World`程序与`tkinter`
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个`Hello World`程序与`tkinter`
- en: 窗口仍然非常空，但在接下来的部分中这一点将很快改变。
  id: totrans-41
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 窗口仍然非常空，但在接下来的部分中这一点将很快改变。
- en: If you take a closer look at the code, you will notice that it starts with an
    `import` statement。这是必要的以使模块 `tkinter` 可用。You should not worry about the exact
    structure of the `import` statement at this point, because we will deal with the
    import from modules in more detail in ► Sect. [23.​3](474412_1_En_23_Chapter.xhtml#Sec7)。At
    this point, it is sufficient to know that the `import` statement makes the classes
    of the module `tkinter`，in particular the class `Tk`，usable for our program。
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果仔细查看代码，你会发现它以`import`语句开始。这是必要的，以使模块 `tkinter` 可用。你不必担心此时`import`语句的具体结构，因为我们将在►
    第23.3节（[链接](474412_1_En_23_Chapter.xhtml#Sec7)）中更详细地讲解模块的导入。此时，了解`import`语句使得`tkinter`模块的类，特别是`Tk`类，能在我们的程序中使用就足够了。
- en: We create an instance of this class `Tk` in our program, namely the object `win`，the
    main window of our application。With the methods `title('titletext')` and `geometry('dimensions')`
    we set two important properties，the title of the window and its size in pixels。Then,
    using the `mainloop()` method, we display the window on the screen and start event
    processing；our program can now react to user actions。Our first `tkinter` program
    is complete！Simple, isn’t it？However, the user can still do little with our graphical
    interface。So, we need control elements that allow the user to make inputs and
    trigger actions。These controls are called `*widgets*` in `Tk/tkinter`。We will
    deal with them in the next section。
  id: totrans-43
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们在程序中创建了`Tk`类的一个实例，即对象`win`，它是我们应用程序的主窗口。通过方法`title('titletext')`和`geometry('dimensions')`，我们设置了两个重要的属性：窗口的标题和窗口的尺寸（像素）。然后，使用`mainloop()`方法，我们将窗口显示在屏幕上，并开始事件处理；我们的程序现在可以响应用户的操作了。我们的第一个`tkinter`程序完成了！很简单，对吧？不过，用户仍然无法做太多事情。所以，我们需要控件，允许用户进行输入并触发操作。这些控件在`Tk/tkinter`中被称为`*widgets*`。我们将在下一部分讨论它们。
- en: 22.2.3 Graphical Controls (Widgets)
  id: totrans-44
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 22.2.3 图形控件（Widgets）
- en: In this section we will look at a number of important widgets。Using the first
    widget, the button, as an example, you will see how widgets are created and how
    their properties are adjusted when they are created (or even later)。
  id: totrans-45
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一些重要的控件。以第一个控件——按钮为例，你将看到控件是如何创建的，以及它们在创建时（或稍后）如何调整其属性。
- en: 22.2.3.1 Buttons (Class `Button`)
  id: totrans-46
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 22.2.3.1 按钮（类 `Button`）
- en: Buttons are built into `tkinter` as the class `Button`。They are used to let
    the user of the program trigger actions。Like all widgets, they can be easily created
    using their constructor method。The program from the previous section extended
    by this constructor call then looks like this：
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 按钮作为`tkinter`中的`Button`类内建。它们用于让程序的用户触发操作。像所有控件一样，它们可以通过其构造方法轻松创建。将上一个部分的程序扩展以包含此构造调用，代码将如下所示：
- en: '`from tkinter import win = Tk() win.title(''Hello World Program'') win.geometry(''900x500'')
    mybutton = Button(win, text = ''Press me'') mybutton.pack() win.mainloop()`'
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`from tkinter import win = Tk() win.title(''Hello World Program'') win.geometry(''900x500'')
    mybutton = Button(win, text = ''Press me'') mybutton.pack() win.mainloop()`'
- en: The `Button()` constructor method receives as function arguments the window
    in which we want to place the button, in our case `win`。Options for the design
    of the button can be specified; in our example, we label the button “Press me”
    with the help of the option `text`。Of course, we can still change the button’s
    properties `*after*` we have created the button。However, the properties are not
    simply editable class attributes of the `Button` class, but are changed with a
    special method called `config()`。Like the constructor, the `config()` method expects
    key-value pairs, consisting of the name of the option to be modified as a key
    and the value to be assigned to it。So, for example, if we wanted to change the
    width of our button, we would have to adjust the `width` option as follows：
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Button()` 构造方法接收一个窗口作为函数参数，该窗口是我们希望放置按钮的地方，在我们的例子中是 `win`。可以指定按钮的设计选项；在我们的示例中，我们通过
    `text` 选项给按钮命名为“Press me”。当然，我们在创建按钮后仍然可以修改按钮的属性，*但是*这些属性并不是 `Button` 类的普通可编辑属性，而是通过一个名为
    `config()` 的特殊方法来修改的。与构造函数类似，`config()` 方法接受键值对，其中键是要修改的选项名称，值是要分配给它的值。例如，如果我们想要修改按钮的宽度，我们可以按如下方式调整
    `width` 选项：'
- en: '`mybutton.config(width = 50)`'
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`mybutton.config(width = 50)`'
- en: The same can be done with the option`text`，i.e., the label of the button。
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 也可以对 `text` 选项进行相同的操作，即按钮的标签。
- en: 'A second way to modify options is to access them like a dictionary, whose keys
    are the option names:'
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 修改选项的第二种方法是像访问字典一样访问它们，字典的键就是选项名称：
- en: '`mybutton[''width''] = 50`'
  id: totrans-53
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`mybutton[''width''] = 50`'
- en: 'The question now is what setting options are available? To find out, you should
    take a look at the help of the class `tkinter`. To do this, you must first import
    the `Button` class (or just all classes, as we do below) from the `tkinter` module
    into the console (remember: your Python programs and the console do not use the
    same namespace; the fact that you already have a Python program that imports the
    module does not mean that you can also use the module in the console. So, before
    calling the help function, you still have to execute an `import` statement in
    the console):'
  id: totrans-54
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 那么，问题是有哪些设置选项可用呢？要找出这些，你应该查看 `tkinter` 类的帮助文档。为此，首先需要从 `tkinter` 模块中导入 `Button`
    类（或者像下面所做的那样导入所有类）到控制台中（记住：你的 Python 程序和控制台使用的是不同的命名空间；即使你已经在 Python 程序中导入了该模块，也不意味着你可以在控制台中直接使用它。因此，在调用
    help 函数之前，你仍然需要在控制台中执行一次 `import` 语句）：
- en: '`>>>` from `tkinter` import `>>>` help(`Button`)'
  id: totrans-55
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` 从 `tkinter` 导入 `>>>` help(`Button`)'
- en: 'Right at the top of the help text that appears is the following information:'
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 帮助文本最上方显示了以下信息：
- en: '| STANDARD OPTIONS || activebackground, activeforeground, anchor, | background,
    bitmap, borderwidth, cursor, | disabledforeground, font, foreground | highlightbackground,
    highlightcolor, | highlightthickness, image, justify, | padx, pady, relief, repeatdelay,
    | repeatinterval, takefocus, text, | textvariable, underline, wraplength || WIDGET-SPECIFIC
    OPTIONS || command, compound, default, height, | overrelief, state, width'
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '| 标准选项 || activebackground, activeforeground, anchor, | background, bitmap,
    borderwidth, cursor, | disabledforeground, font, foreground | highlightbackground,
    highlightcolor, | highlightthickness, image, justify, | padx, pady, relief, repeatdelay,
    | repeatinterval, takefocus, text, | textvariable, underline, wraplength || 小部件特定选项
    || command, compound, default, height, | overrelief, state, width'
- en: So, as you can see, on the one hand there are `standard options` common to most
    widgets, on the other hand there are special options available only for buttons.
    Unfortunately, the help lacks a description of what setting each option controls,
    and how these options are used. Also, the “official” documentation of the `tkinter`
    package (► [https://​docs.​python.​org/​3/​library/​tk.​html](https://docs.python.org/3/library/tk.html))
    is of rather limited use, especially for beginners. However, there are numerous
    pages on the Internet where the features are explained in an understandable way,
    currently for example ► [https://​www.​tutorialspoint.​com/​python/​tk_​button.​htm](https://www.tutorialspoint.com/python/tk_button.htm).
  id: totrans-58
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如你所见，一方面有许多 `标准选项` 是大多数小部件通用的，另一方面则有一些仅适用于按钮的特殊选项。不幸的是，帮助文档没有描述每个选项控制的内容以及这些选项如何使用。此外，`tkinter`
    包的“官方”文档（► [https://​docs.​python.​org/​3/​library/​tk.​html](https://docs.python.org/3/library/tk.html)）的帮助有限，尤其是对于初学者而言。然而，互联网上有许多页面以通俗易懂的方式解释了这些功能，目前例如
    ► [https://​www.​tutorialspoint.​com/​python/​tk_​button.​htm](https://www.tutorialspoint.com/python/tk_button.htm)。
- en: ◘ Table [22.1](#Tab1) shows an overview of some of the options that most, if
    not all, widgets have. This table also explains procedures for encoding colors
    and working with font formatting that can be used in many places in `tkinter`.
    Table 22.1
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: ◘ 表格 [22.1](#Tab1) 显示了大多数控件（如果不是所有控件）的一些选项的概览。该表格还解释了编码颜色和使用字体格式的过程，这些可以在 `tkinter`
    中许多地方使用。表格 22.1
- en: Standard properties of `tkinter` widgets
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`tkinter` 控件的标准属性'
- en: '| Option | Type | Meaning |'
  id: totrans-61
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| Option | Type | Meaning |'
- en: '| --- | --- | --- |'
  id: totrans-62
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `activebackground/activeforeground` | `Str` | Color of the control (background)
    or the text on it (foreground) when the control is activated (for in our case,
    by clicking on the button) Like all colors in `tkinter`, you can either specify
    one of the many predefined color constants (for example `''green''` or `''purple''`;
    you can quickly find lists of these color constants on the internet), or a red-green-blue
    (RGB) coded value of the form `''#RRGGBB''`, where `RR`, `GG`, and `BB` represent
    the hexadecimal (!) coded red, green, and blue parts of the color, respectively.
    It is best to use one of the many converters on the internet to convert the decimal
    values to the hexadecimal system. The value for red (R = 255, G = 0, B = 0) would
    thus become `''#FF0000''`, because `FF` represents the number 255 in the hexadecimal
    number system |'
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `activebackground/activeforeground` | `Str` | 控件激活时（例如点击按钮时）控件的颜色（背景）或其上的文本颜色（前景）。像
    `tkinter` 中所有的颜色一样，你可以指定多个预定义的颜色常量之一（例如 `''green''` 或 `''purple''`；你可以快速在互联网上找到这些颜色常量的列表），或者使用红绿蓝（RGB）编码值，格式为
    `''#RRGGBB''`，其中 `RR`、`GG` 和 `BB` 分别表示颜色的红色、绿色和蓝色部分的十六进制编码值。最好的做法是使用互联网上的转换器将十进制值转换为十六进制系统。红色的值（R
    = 255，G = 0，B = 0）将变为 `''#FF0000''`，因为 `FF` 在十六进制系统中表示数字 255。 |'
- en: '| `background/foreground` | `Str` | Default color of the control (background)
    or the text on it (foreground) |'
  id: totrans-64
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `background/foreground` | `Str` | 控件的默认颜色（背景）或其上的文本颜色（前景）。 |'
- en: '| `border` | `Int` | Thickness of the border of the control in pixels (`border=0`
    means no border) |'
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `border` | `Int` | 控件边框的厚度，单位为像素（`border=0` 表示没有边框）。 |'
- en: '| `cursor` | `Str` | The shape of the mouse cursor when the mouse pointer is
    over the control; examples are `''hand2''` (hand), `''watch''` (hourglass), `''cross''`
    (cross), `''left_ptr''` (“normal” mouse pointer with top left tip). There are
    also lists on the internet that specify the possible pointer characteristics |'
  id: totrans-66
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `cursor` | `Str` | 当鼠标指针悬停在控件上时，鼠标光标的形状；例如 `''hand2''`（手形）、`''watch''`（沙漏）、`''cross''`（十字）、`''left_ptr''`（“正常”鼠标指针，左上角为箭头）。互联网上也有一些列出了可用的指针样式。
    |'
- en: '| `font` | `Font` | The font formatting of the control; if you want to deviate
    from the default font, you must add an additional `import` statement and then
    create a new `Font` object using the `Font()` constructor: `from tkinter.font
    import font = Font(family = ''Times'', size = 36, weight = ''bold'', underline
    = 1)` After that, the new `Font` object `font` can be assigned to the `font` option
    of the control: `mybutton[''font''] = font` The `family` is a font identifier
    (e.g. `Helvetica`, `Courier`). The `weight` distinguishes between `''bold''` and
    `''normal''`. In addition, you can use the `slant` option, which is not used in
    the above example, to set the text to italic or not italic (`''normal''`). `overstrike`,
    which can take the values 1 and 0 (or `True` and `False`) just like `underline`,
    is used to strike through the text You can make changes to your `Font` object
    using the `config()` method, just as you can with controls: `font.config(weight
    = ''normal'')` Changes you make in this way automatically affect *all* controls
    to whose `font` option you originally assigned the now changed `Font` object |'
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `font` | `Font` | 控件的字体格式；如果你想偏离默认字体，必须添加一个额外的 `import` 语句，然后使用 `Font()`
    构造函数创建一个新的 `Font` 对象：`from tkinter.font import font = Font(family = ''Times'',
    size = 36, weight = ''bold'', underline = 1)` 之后，新的 `Font` 对象 `font` 可以被赋值给控件的
    `font` 选项：`mybutton[''font''] = font` `family` 是字体标识符（例如 `Helvetica`，`Courier`）。`weight`
    区分 `''bold''` 和 `''normal''`。此外，你还可以使用 `slant` 选项（在上面的示例中未使用），用来设置文本为斜体或非斜体（`''normal''`）。`overstrike`，它可以像
    `underline` 一样取值为 1 和 0（或 `True` 和 `False`），用于删除文本。你可以通过 `config()` 方法修改你的 `Font`
    对象，就像修改控件一样：`font.config(weight = ''normal'')` 这种方式做的更改会自动影响*所有*最初将现已更改的 `Font`
    对象分配给其 `font` 选项的控件。 |'
- en: '| `padx`, `pady` | `int` | Indentation of the text (or an image) on the control
    left/right (`padx`) or top/bottom (`pady`) |'
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `padx`, `pady` | `int` | 控件中文本（或图像）的缩进，左/右（`padx`）或上下（`pady`）。 |'
- en: '| `relief` | `str` | 3D representation of the control. Possible values here
    are: `''raised''` (protruding, the default value), `''sunken''` (deepened), `''flat''`,
    `''groove''` (deepened border) and `''ridge''` (simple border, otherwise flat)
    |'
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `relief` | `str` | 控件的 3D 表现形式。这里可能的值有：`''raised''`（凸起，默认值）、`''sunken''`（凹陷）、`''flat''`、`''groove''`（凹边）和`''ridge''`（简单边框，否则为平的）
    |'
- en: '| `text` | `str` | Labeling of the control |'
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `text` | `str` | 控件的标签文本 |'
- en: ◘ Table [22.2](#Tab2) then lists some of the `special` button options. In the
    following sections on the other widgets, you will find such a table with the most
    important specific properties for exactly this widget. Table 22.2
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: ◘ 表 22.2（#Tab2）列出了 `special` 按钮选项的一些内容。在接下来的章节中，关于其他小部件，你会找到类似的表格，列出该小部件的最重要特定属性。表
    22.2
- en: Special properties of the button widget
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 按钮小部件的特殊属性
- en: '| Option | Type | Meaning |'
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| 选项 | 类型 | 含义 |'
- en: '| --- | --- | --- |'
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `command` | `function` | Function that is executed when the user clicks on
    the button. We will take a closer look at this event handling in ► Sect. [22.2.5](#Sec19)
    |'
  id: totrans-75
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `command` | `function` | 用户点击按钮时执行的函数。我们将在 ► 第 22.2.5 节 中详细介绍事件处理 |'
- en: '| `default` | `int` | If `default = 1`, then the button is the default button
    (triggered when the user presses the `<ENTER>` key) |'
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `default` | `int` | 如果 `default = 1`，则按钮是默认按钮（当用户按 `<ENTER>` 键时触发） |'
- en: '| `height/width` | `int` | Height/width of the button. Specified in letter
    heights if text is displayed on the button, in pixels if an image is displayed.
    If not specified at all, width and height are calculated automatically |'
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `height/width` | `int` | 按钮的高度/宽度。如果按钮上显示文本，则以字母高度为单位；如果显示图片，则以像素为单位。如果未指定，则宽度和高度会自动计算
    |'
- en: '| `state` | `str` | Button can be set to either ''`normal`'' (clickable) or
    ''`disabled`'' (grayed out). If the button is currently clicked, `state` takes
    the value ''`active`'' |'
  id: totrans-78
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `state` | `str` | 按钮可以设置为 `''normal''`（可点击）或 `''disabled''`（灰显）。如果按钮当前被点击，`state`
    的值将是 `''active''` |'
- en: 'We have just seen options that partly behave like a dictionary. Therefore,
    you can also use the `keys()` method to read the keys and thus the names of the
    options. If, after creating the widget instance, you include in your program code
    the statement `print(mybuttons.keys())` you will see the names of the available
    options in the (run) console when you run the program. If you call the `config()`
    method with no arguments, you will get back the entire dictionary with all name-value
    pairs. You can also have this output: `options = switch.config()` `print(options)`'
  id: totrans-79
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们刚才已经看到一些选项，它们部分像字典一样工作。因此，你也可以使用 `keys()` 方法来读取键，从而得到选项的名称。如果在创建小部件实例后，你在程序代码中加入
    `print(mybuttons.keys())` 语句，当你运行程序时，控制台会显示所有可用选项的名称。如果你调用没有参数的 `config()` 方法，你会得到包含所有名称-值对的完整字典。你也可以这样输出：`options
    = switch.config()` `print(options)`
- en: 'Often, the lowercase string option values such as ''`sunken`'' for the `relief`
    option can also be controlled with the help of a predefined, then capitalized
    constant, in our example `SUNKEN`. In the following, however, we will regularly
    work with the strings instead of the constants. If you want to work with the constants,
    look for the file `constants.py` in the `tkinter` directory of your hard disk.
    The constants are defined there. To use them, add the following import statement
    to your program:'
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 通常，像 `relief` 选项中的小写字符串值（例如 `'sunken'`）也可以通过预定义的常量来控制，这些常量通常是大写的，例如我们示例中的 `SUNKEN`。但在接下来的内容中，我们将常常使用字符串而不是常量。如果你想使用常量，可以在硬盘的
    `tkinter` 目录中查找 `constants.py` 文件，其中定义了这些常量。要使用它们，请在程序中添加以下导入语句：
- en: '`from tkinter.constants import *`'
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`from tkinter.constants import *`'
- en: So far, we haven’t even talked about the call to the `pack()` method that we
    snuck into our program. This statement makes the button visible on the screen
    in the first place (comment out the line and see what happens when you run the
    program again!). Making it visible is closely related to the arrangement of the
    widgets on the graphical interface. We will look at this in more detail in ► Sect.
    [22.2.4](#Sec15). At this point, all we need to do is call `pack()` to display
    our control on the interface.
  id: totrans-82
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 到目前为止，我们甚至没有提到 `pack()` 方法的调用，这是我们偷偷加入程序中的一行代码。这个语句首先使按钮在屏幕上可见（注释掉这一行，再次运行程序看看会发生什么！）。使它可见与小部件在图形界面上的布局密切相关。我们将在
    ► 第 22.2.4 节 中更详细地讨论这个问题。此时，我们需要做的只是调用 `pack()`，使控件在界面上显示出来。
- en: 22.2.3.2 Menus (Class `Menu`)
  id: totrans-83
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 22.2.3.2 菜单（`Menu` 类）
- en: 'Menus can be designed very easily with `tkinter`。To do this, we first create
    a new menu bar for our window, i.e., the `Tk` object `win` in the example above.
    The menu bar is represented in `tkinter` by the class `Menu`。The window to which
    the menu bar is to belong is already passed as an argument to the call of the
    constructor of this class. Conversely, we explicitly assign the new menu bar to
    the window with the help of the menu option of the `Tk` object, so that it is
    visible later:'
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 菜单可以通过`tkinter`非常容易地设计。为了实现这一点，我们首先为窗口创建一个新的菜单栏，即上例中的`Tk`对象`win`。在`tkinter`中，菜单栏由`Menu`类表示。要将菜单栏附加到的窗口已作为参数传递给该类构造函数的调用。相反，我们通过`Tk`对象的`menu`选项显式地将新的菜单栏分配给窗口，这样它就能在之后显示出来：
- en: '`menubar_top = Menu(win)` `win.config(menu = menubar_top)`'
  id: totrans-85
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`menubar_top = Menu(win)` `win.config(menu = menubar_top)`'
- en: 'As you already know, instead of calling the `Tk` object’s `config()` method
    in the last statement, we could have taken advantage of the practical fact that
    `tkinter` widgets work partly like dictionaries, and their options can therefore
    be accessed as well, like the key-value pairs of a dictionary. Accordingly, we
    could have written:'
  id: totrans-86
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如你所知，除了在最后的语句中调用`Tk`对象的`config()`方法外，我们还可以利用一个实际的事实，即`tkinter`的控件部分像字典一样工作，它们的选项因此也可以像字典的键值对一样访问。因此，我们本可以写成：
- en: '`win[''menu''] = menubar_top`'
  id: totrans-87
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`win[''menu''] = menubar_top`'
- en: 'Now, your application has a menu bar, but it is not yet displayed when you
    start the program in this state. First, we have to add the individual pull-down
    menus, which will then be expandable and collapsible for the user. These pull-down
    menus are also objects of the `Menu` class, which we can create by calling the
    class constructor. This time, however, we don’t attach the new (pull-down) menus
    directly to the window `win`，but to our existing menu bar `menubar_top`:'
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在，你的应用程序有了菜单栏，但在这种状态下启动程序时，菜单栏还不会显示出来。首先，我们需要添加单独的下拉菜单，这些菜单将为用户提供展开和折叠的功能。这些下拉菜单也是`Menu`类的对象，我们可以通过调用类的构造函数来创建。不过，这一次，我们不会直接将新的（下拉）菜单附加到窗口`win`，而是将其附加到我们已有的菜单栏`menubar_top`上：
- en: '`file_menu = Menu(menubar_top, tearoff = 0)`'
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`file_menu = Menu(menubar_top, tearoff = 0)`'
- en: The option `tearoff=0` causes the menu to be “bolted” to the window. If you
    omit this option or set it to `tearoff=1`，the first entry in your menu will be
    a dashed line. If you click on this entry, the menu detaches itself from its anchoring
    and is displayed in its own window, which can be moved around the screen at will
    (try it out!); a behavior that you would normally want to disable.
  id: totrans-90
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 选项`tearoff=0`会使菜单“固定”在窗口上。如果你省略此选项或将其设置为`tearoff=1`，菜单的第一项将显示为虚线。如果点击此项，菜单将从其固定位置分离，并在自己的窗口中显示出来，可以随意在屏幕上移动（试试看！）；这种行为通常是你希望禁用的。
- en: 'Now we can start adding new command items to the menu with `add_command(label
    = label)`:'
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在我们可以开始通过`add_command(label = label)`向菜单中添加新的命令项：
- en: '`file_menu.add_command(label = ''Open...'')file_menu.add_command(label = ''Save'')file_menu.add_separator()file_menu.add_command(label
    = ''Close'')`'
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`file_menu.add_command(label = ''打开...'')file_menu.add_command(label = ''保存'')file_menu.add_separator()file_menu.add_command(label
    = ''关闭'')`'
- en: Using the `add_separator()` function of the `Menu` object we create a horizontal
    separator in the menu to structure our menu items more clearly. In addition to
    `add_command()` and `add_separator()`，there are two other types of menu items,
    `add_checkbutton()` and `add_radiobutton()`。Both allow the user to make a setting,
    as in the following example. The current setting (whether the menu option is currently
    selected or not) can be read at any time from the variable passed as the option
    `variable` to the `add_checkbutton()` function.
  id: totrans-93
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 通过使用`Menu`对象的`add_separator()`函数，我们在菜单中创建一个水平分隔线，以便更清晰地组织我们的菜单项。除了`add_command()`和`add_separator()`，还有两种其他类型的菜单项，`add_checkbutton()`和`add_radiobutton()`。这两种菜单项允许用户进行设置，如以下示例所示。当前的设置（即菜单选项是否被选中）可以随时从传递给`add_checkbutton()`函数的`variable`选项所绑定的变量中读取。
- en: '`file_menu.add_checkbutton(label = ''Auto save'', variable = auto_save)`'
  id: totrans-94
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`file_menu.add_checkbutton(label = ''自动保存'', variable = auto_save)`'
- en: 'So far, our menu—unlike the individual menu items—has no display name at all.
    We change this by calling the function `add_cascade()` of the menu bar object,
    which also ensures that the menu is actually displayed as a pull-down menu on
    our menu bar:'
  id: totrans-95
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 到目前为止，我们的菜单——与单独的菜单项不同——根本没有显示名称。我们通过调用菜单栏对象的`add_cascade()`函数来更改这一点，它还确保菜单实际上作为下拉菜单显示在我们的菜单栏上：
- en: '`menubar_top.add_cascade(label = ''File'', menu = file_menu)`'
  id: totrans-96
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`menubar_top.add_cascade(label = ''文件'', menu = file_menu)`'
- en: If you now start the program like this, a program window will open that has
    a menu bar with a “File” menu. Analogously, we could of course now place more
    pull-down menus on the menu bar.
  id: totrans-97
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你现在按这样启动程序，一个程序窗口将会打开，窗口中有一个带有“文件”菜单的菜单栏。当然，我们也可以继续在菜单栏上放置更多的下拉菜单。
- en: 'The `add_...()` functions like `add_command()` can be called with numerous
    options, many of which can be found in ◘ Table [22.1](#Tab1). For example:'
  id: totrans-98
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`add_...()`函数，例如`add_command()`，可以通过多种选项调用，许多选项可以在◘表[22.1](#Tab1)中找到。例如：'
- en: '`file_menu.add_command(label = ''Save'', background=''#FF0000'')` adds a menu
    item “Save” with a red background, the statement `file_menu.add_command(label
    = ''Save'', state=''disabled'')` shows a deactivated (grayed out) menu item. Of
    course, you can still modify your menu `after` you have created it. With `delete(index_from,
    index_to)` you can delete menu items by their numeric indices. With `entryconfig(index,
    option=value)` you change an `option` (for example `state` to enable/disable)
    for the menu item defined by `index`. You can query the options with `entrycget(index,
    option)`。Thus, to display the label (option `label`) of the second menu item,
    you can use the statement `print(file_menu.entrycget(1, ''label''))` (the indexes
    start, as always in Python, at 0!).'
  id: totrans-99
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`file_menu.add_command(label = ''Save'', background=''#FF0000'')`将添加一个带有红色背景的菜单项“保存”，语句`file_menu.add_command(label
    = ''Save'', state=''disabled'')`则会显示一个禁用（灰显）的菜单项。当然，你仍然可以在创建菜单后修改它。使用`delete(index_from,
    index_to)`可以根据数字索引删除菜单项。使用`entryconfig(index, option=value)`可以更改由`index`定义的菜单项的`option`（例如`state`用于启用/禁用）。你可以使用`entrycget(index,
    option)`查询选项。因此，要显示第二个菜单项的标签（`label`选项），你可以使用语句`print(file_menu.entrycget(1, ''label''))`（索引从0开始，就像在Python中一样！）。'
- en: If you want to insert a menu entry later, use the functions `insert_...(index,
    option)`, where `...` stands for the respective element (e.g. `command`, `separator`,
    `checkbox`), just as with `add_...()`。The entry is then inserted `after` the entry
    specified by `index`。
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你想稍后插入一个菜单项，可以使用函数`insert_...(index, option)`，其中`...`代表相应的元素（例如`command`、`separator`、`checkbox`），就像使用`add_...()`一样。该菜单项将插入到由`index`指定的菜单项之后。
- en: 'Our menu is now quite pretty to look at, but it has no functionality: clicking
    on a menu command does not trigger any action. This is because in our calls to
    `add_command()` of the pull-down menu object `file_menu`, we omitted the important
    `command` option, which allows us to specify a function to be called whenever
    the user clicks on the menu item. In this function we would then place the part
    of the program code that should be behind the menu item. We will deal with these
    event handlers in more detail in ► Sect. [22.2.5](#Sec19). At this point here
    we will concentrate entirely on creating a visually appealing interface.'
  id: totrans-101
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们的菜单现在看起来相当漂亮，但它没有任何功能：点击菜单命令不会触发任何操作。这是因为在我们调用下拉菜单对象`file_menu`的`add_command()`时，我们遗漏了一个重要的`command`选项，正是这个选项让我们能够指定一个函数，在用户点击菜单项时被调用。在这个函数中，我们将放置与菜单项相关的程序代码。我们将在►第[22.2.5](#Sec19)节中详细处理这些事件处理程序。在此处，我们将完全专注于创建一个具有视觉吸引力的界面。
- en: 'Dealing with a menu in `tkinter` is, as you can see, not complicated at all,
    but it requires several different steps. Therefore, here again is the overview
    what you have to do to provide your program with a menu:'
  id: totrans-102
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如你所见，在`tkinter`中处理菜单并不复杂，但需要多个不同的步骤。因此，这里再次概述了你需要做的事情，以便为你的程序提供一个菜单：
- en: '1.'
  id: totrans-103
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '1.'
- en: Create the menu bar using the constructor `menubar = Menu(window)`。
  id: totrans-104
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 使用构造函数`menubar = Menu(window)`创建菜单栏。
- en: '2.'
  id: totrans-105
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '2.'
- en: 'Add the menu bar to the window: `window[''menu''] = menubar`。'
  id: totrans-106
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 将菜单栏添加到窗口中：`window['menu'] = menubar`。
- en: '3.'
  id: totrans-107
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '3.'
- en: 'Create a new pull-down menu that you want to place on the menu bar: `pd_menu
    = Menu(menubar)`。'
  id: totrans-108
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 创建一个新的下拉菜单，你希望将其放置在菜单栏上：`pd_menu = Menu(menubar)`。
- en: '4.'
  id: totrans-109
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '4.'
- en: 'Add menu items, i.e. commands (with `add_command()`), preference options (with
    `add_checkbox()` or `add_radiobutton()`) or separators (`add_separator()`) to
    the new pull-down menu, for example: `pd_menu.add_command(label = ''Title of command'')`.
    Note that later, to add functionality to the menu item, we will include the `command
    = event_function` option at this point.'
  id: totrans-110
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 向新的下拉菜单中添加菜单项，即命令（使用`add_command()`）、偏好选项（使用`add_checkbox()`或`add_radiobutton()`）或分隔符（`add_separator()`），例如：`pd_menu.add_command(label
    = 'Title of command')`。请注意，稍后为了给菜单项添加功能，我们会在此处加入`command = event_function`选项。
- en: '5.'
  id: totrans-111
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '5.'
- en: 'Attach your new pull-down menu to the menu bar and assign a title that will
    be visible in the menu bar: `menubar.add_cascade(label = ''Title of menu'', menu
    = pd_menu)`.'
  id: totrans-112
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 将新的下拉菜单附加到菜单栏，并为其指定一个在菜单栏中可见的标题：`menubar.add_cascade(label = 'Title of menu',
    menu = pd_menu)`。
- en: In this section, we’ve looked at creating an application menu as the main menu
    in your program. However, the `Menu` object can also be used to open pop-up/context
    menus anywhere in your window thanks to the `post(x, y)` function, but this is
    beyond the brief introduction to `tkinter` in this section.
  id: totrans-113
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在本节中，我们已经介绍了如何创建应用程序菜单作为程序中的主菜单。然而，`Menu` 对象也可以用来在窗口的任何位置打开弹出/上下文菜单，这得益于 `post(x,
    y)` 函数，但这超出了本节对 `tkinter` 的简要介绍。
- en: 22.2.3.3 Input Fields (Classes `Entry` and `ScrolledText`)
  id: totrans-114
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 22.2.3.3 输入字段（类 `Entry` 和 `ScrolledText`）
- en: 'Single-Line Entry: `Entry`'
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 单行输入框：`Entry`
- en: Input fields are used to accept text input from the user. In `tkinter`, a distinction
    is made between single-line (widget class `Entry`) and multi-line text input (widget
    class `ScrolledText`). We will take a closer look at both in this section.
  id: totrans-116
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 输入字段用于接收用户的文本输入。在 `tkinter` 中，单行（小部件类 `Entry`）和多行文本输入（小部件类 `ScrolledText`）之间有区分。我们将在本节中更详细地了解这两者。
- en: The widget of type `Entry` can be created very easily with the constructor and
    assigned to the window, in our example still to the `Tk` object `win`.
  id: totrans-117
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Entry` 类型的小部件可以通过构造函数非常容易地创建并分配给窗口，在我们的例子中，仍然分配给 `Tk` 对象 `win`。'
- en: '`myentry = Entry(win)` `myentry.pack()`'
  id: totrans-118
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`myentry = Entry(win)` `myentry.pack()`'
- en: As with the button before, we call the `pack()` method to display the control
    in our window. In ► Sect. [22.2.4](#Sec15) we will look at how we can influence
    the arrangement of the controls in the window in more detail.
  id: totrans-119
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 和之前的按钮一样，我们调用 `pack()` 方法将控件显示在窗口中。在► 第 [22.2.4](#Sec15) 节中，我们将更详细地探讨如何影响控件在窗口中的排列。
- en: In ◘ Table [22.3](#Tab3) you will find an overview of the most important properties
    of the widget, which you can access in the usual way either by dictionary indexing
    `input['option']` or (but then only by writing) by `input.configure(option=value)`.Table
    22.3
  id: totrans-120
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在◘ 表格 [22.3](#Tab3) 中，你将找到小部件最重要属性的概述，你可以通过字典索引 `input['option']` 或（但仅限于写入）通过
    `input.configure(option=value)` 以通常的方式访问这些属性。表格 22.3
- en: Special properties of the `Entry` widget
  id: totrans-121
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Entry` 小部件的特殊属性'
- en: '| Option | Type | Meaning |'
  id: totrans-122
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| 选项 | 类型 | 说明 |'
- en: '| --- | --- | --- |'
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `justify` | `str` | Alignment of the text in the entry field, `''left''`
    (left-aligned, the default), `''center''` (centered) or `''right''` (right-aligned)
    |'
  id: totrans-124
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `justify` | `str` | 输入框中文本的对齐方式，`''left''`（左对齐，默认值），`''center''`（居中）或`''right''`（右对齐）
    |'
- en: '| `selectbackground` | `str` | Background color of text selections |'
  id: totrans-125
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `selectbackground` | `str` | 文本选择的背景颜色 |'
- en: '| `selectforeground` | `str` | Font color of text selections |'
  id: totrans-126
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `selectforeground` | `str` | 文本选择的字体颜色 |'
- en: '| `show` | `str` | Character that is displayed (instead of the entered character);
    can be used for password entries, for example |'
  id: totrans-127
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `show` | `str` | 显示的字符（替代输入的字符）；例如可以用于密码输入 |'
- en: '| `width` | `int` | Width of the entry field (in characters, not pixels) |'
  id: totrans-128
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `width` | `int` | 输入字段的宽度（以字符为单位，而非像素） |'
- en: 'You can use the `get()` method at any time to retrieve the text that is currently
    in the `Entry` field, for example:'
  id: totrans-129
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以随时使用 `get()` 方法获取当前在 `Entry` 字段中的文本，例如：
- en: '`my_text = input.get()`'
  id: totrans-130
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`my_text = input.get()`'
- en: Of course, you can also edit the text. This is done with the help of the `insert(index,
    string)` method. `index` specifies the text position (starting at 0) where you
    want to insert, `string` specifies the text to be inserted. So, at the beginning
    you can start with
  id: totrans-131
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当然，你也可以编辑文本。这可以通过 `insert(index, string)` 方法实现。`index` 指定要插入的位置（从0开始计数），`string`
    指定要插入的文本。因此，一开始你可以从
- en: '`input.insert(0, ''A first text in the input field.'')`可以预设输入字段的文本。你可以简单地在`insert()`方法中指定`''end''`、`''insert''`或`''anchor''`，而不是使用真实的位置索引。这样文本会插入到末尾（`''end''`）、当前位置（`''insert''`）或当前选择的开头（如果当前有选择，则插入在开头，否则直接在文本开头）。例如，你可以使用语句`input.insert(''end'',
    ''End of text.'')`来将文本追加到末尾。同样，你可以使用`delete(*****from_index*****,** ***to_index*****)`方法删除文本。如果你省略可选参数`to_index`，只会删除索引为`from_index`的字符。'
  id: totrans-132
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`input.insert(0, ''A first text in the input field.'')` 可以预设输入字段的文本。你可以简单地在
    `insert()` 方法中指定 `''end''`、`''insert''` 或 `''anchor''`，而不是使用真实的位置索引。这样文本会插入到末尾（`''end''`）、当前位置（`''insert''`）或当前选择的开头（如果当前有选择，则插入在开头，否则直接在文本开头）。例如，你可以使用语句
    `input.insert(''end'', ''End of text.'')` 来将文本追加到末尾。同样，你可以使用 `delete(*****from_index*****,
    ** ***to_index*****)` 方法删除文本。如果你省略可选参数 `to_index`，只会删除索引为 `from_index` 的字符。'
- en: 使用`icursor(*****index*****)`可以将光标放置在文本中的特定位置，更确切地说，是在指定的`index`字符之后。然而，请注意，在`tkinter`中字符计数是从1开始的，这与Python的习惯不同。如果你将数字0指定为`index`，则光标会放在第一个字符之前。这种计数方法适用于所有使用字符索引的地方。
  id: totrans-133
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用 `icursor(*****index*****)` 可以将光标放置在文本中的特定位置，更确切地说，是在指定的 `index` 字符之后。然而，请注意，在
    `tkinter` 中字符计数是从 1 开始的，这与 Python 的习惯不同。如果你将数字 0 指定为 `index`，则光标会放在第一个字符之前。这种计数方法适用于所有使用字符索引的地方。
- en: 为了使光标在文本中实际可见，你必须给予控件焦点，即使它成为你窗口中当前活动的控件。你可以像对待所有其他小部件一样，使用`focus()`方法做到这一点。
  id: totrans-134
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为了使光标在文本中实际可见，你必须给予控件焦点，即使它成为你窗口中当前活动的控件。你可以像对待所有其他小部件一样，使用 `focus()` 方法做到这一点。
- en: 最后，方法`selection_range(*****from_index*****,** ***to_index*****)`允许你选择文本。同样，你可以使用`insert()`中已知的特殊常量`'end'`、`'insert'`和`'anchor'`。你可以使用`selection_get()`查询当前选中的文本，方法`selection_present()`在文本被选中时返回`True`。
  id: totrans-135
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 最后，方法`selection_range(*****from_index*****,** ***to_index*****)`允许你选择文本。同样，你可以使用`insert()`中已知的特殊常量`'end'`、`'insert'`和`'anchor'`。你可以使用`selection_get()`查询当前选中的文本，方法`selection_present()`在文本被选中时返回`True`。
- en: '`Entry`还允许你使用剪贴板。你可以使用方法`clipboard_append(*****text*****)`将文本添加到剪贴板；使用`clipboard_get()`检索剪贴板的内容，使用`clipoard_clear()`清空剪贴板。'
  id: totrans-136
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Entry`还允许你使用剪贴板。你可以使用方法`clipboard_append(*****text*****)`将文本添加到剪贴板；使用`clipboard_get()`检索剪贴板的内容，使用`clipoard_clear()`清空剪贴板。'
- en: 多行输入：`ScrolledText`
  id: totrans-137
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 多行输入：`ScrolledText`
- en: 如果要编辑更长的文本，小部件`ScrolledText`是一个不错的选择。要使用它，必须首先从`tkinter`包的`scrolledtext`模块中导入类`ScrolledText`：
  id: totrans-138
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果要编辑更长的文本，小部件`ScrolledText`是一个不错的选择。要使用它，必须首先从`tkinter`包的`scrolledtext`模块中导入类`ScrolledText`：
- en: '`from` tkinter.scrolledtext `import` ScrolledText'
  id: totrans-139
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`from` tkinter.scrolledtext `import` ScrolledText'
- en: 在许多方面，`ScrolledText`小部件的行为与`Entry`小部件完全相同。你所学到的关于`Entry`的内容大部分可以直接应用于`ScrolledText`（区别在于`justify`和`show`选项、`icursor()`方法和插入位置`'anchor'`不可用）。
  id: totrans-140
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在许多方面，`ScrolledText`小部件的行为与`Entry`小部件完全相同。你所学到的关于`Entry`的内容大部分可以直接应用于`ScrolledText`（区别在于`justify`和`show`选项、`icursor()`方法和插入位置`'anchor'`不可用）。
- en: 由于`ScrolledText`允许多行输入，因此文本位置也可以按照行/列方案进行定位是合乎逻辑的。例如，如果我们想删除从第二行第五个字符开始的所有文本，可以使用下面的方法调用。如果之前使用构造方法`ScrolledText()`创建的小部件命名为`st`：
  id: totrans-141
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 由于`ScrolledText`允许多行输入，因此文本位置也可以按照行/列方案进行定位是合乎逻辑的。例如，如果我们想删除从第二行第五个字符开始的所有文本，可以使用下面的方法调用。如果之前使用构造方法`ScrolledText()`创建的小部件命名为`st`：
- en: '`st.delete(2.4,''end'')`'
  id: totrans-142
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`st.delete(2.4,''end'')`'
- en: 请注意，在`Entry`中有一个单一索引的位置，现在出现了一个分数：`2.4`。然而，这个数字是一个编码的行/列规范。它表示：第二行，第五个字符。因此，尽管在行内字符从0开始计数（`4`因此指的是第五个字符），我们在`tkinter`中已经习惯的行计数从1开始！`2.4`因此指的是`第二`行，但指的是`第五`个字符。
  id: totrans-143
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 请注意，在`Entry`中有一个单一索引的位置，现在出现了一个分数：`2.4`。然而，这个数字是一个编码的行/列规范。它表示：第二行，第五个字符。因此，尽管在行内字符从0开始计数（`4`因此指的是第五个字符），我们在`tkinter`中已经习惯的行计数从1开始！`2.4`因此指的是`第二`行，但指的是`第五`个字符。
- en: '`ScrolledText`小部件比`Entry`小部件强大得多。例如，它本身允许使用`edit_undo()`和`edit_redo()`方法来撤销或重做编辑操作（该小部件的`undo`选项必须事先设置为`True`）。`ScrolledText`还允许您为文本区域分配名称（称为`tags`），然后使用`tags`访问和编辑文本区域。这样，您可以例如以不同的颜色突出显示不同的文本区域。因此，如果您想开发一个具有语法高亮功能的文本编辑器，`ScrolledText`小部件不是一个坏的起点。'
  id: totrans-144
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`ScrolledText`小部件比`Entry`小部件强大得多。例如，它本身允许使用`edit_undo()`和`edit_redo()`方法来撤销或重做编辑操作（该小部件的`undo`选项必须事先设置为`True`）。`ScrolledText`还允许您为文本区域分配名称（称为`tags`），然后使用`tags`访问和编辑文本区域。这样，您可以例如以不同的颜色突出显示不同的文本区域。因此，如果您想开发一个具有语法高亮功能的文本编辑器，`ScrolledText`小部件不是一个坏的起点。'
- en: 22.2.3.4 文本输出（标签）
  id: totrans-145
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 22.2.3.4 文本输出（标签）
- en: 标签是显示在应用程序窗口中的静态文本。它们通常不提供用户任何交互选项，而是用于显示信息或描述控件的功能（如果这些控件没有自己的标签，例如按钮）。
  id: totrans-146
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 标签是显示在应用程序窗口中的静态文本。它们通常不提供用户任何交互选项，而是用于显示信息或描述控件的功能（如果这些控件没有自己的标签，例如按钮）。
- en: 您可以如下创建并显示标签小部件：
  id: totrans-147
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 您可以如下创建并显示标签小部件：
- en: '`label = Label(win, text = ''Here is a fixed text'')` `label.pack()` ◘ 表 [22.4](#Tab4)
    显示了一些标签的重要属性。此外，当然还有大多数小部件提供的标准属性，这些属性列在◘ 表 [22.1](#Tab1)中，而标签最显著的特性无疑是`text`选项，即在标签上显示的文本。在示例中，我们在调用构造函数时直接设置了文本，但当然，像所有其他属性一样，它也可以通过`label.configure(text
    =` `new_text` `)`或`label[''text''] =` `new_text`轻松更改。'
  id: totrans-148
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`label = Label(win, text = ''Here is a fixed text'')` `label.pack()` ◘ 表 [22.4](#Tab4)
    显示了一些标签的重要属性。此外，当然还有大多数小部件提供的标准属性，这些属性列在◘ 表 [22.1](#Tab1)中，而标签最显著的特性无疑是`text`选项，即在标签上显示的文本。在示例中，我们在调用构造函数时直接设置了文本，但当然，像所有其他属性一样，它也可以通过`label.configure(text
    =` `new_text` `)`或`label[''text''] =` `new_text`轻松更改。'
- en: '`Label`小部件的特殊属性'
  id: totrans-149
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Label`小部件的特殊属性'
- en: '| 选项 | 类型 | 说明 |'
  id: totrans-150
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| 选项 | 类型 | 说明 |'
- en: '| --- | --- | --- |'
  id: totrans-151
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **anchor** | **str** | 文本的位置和方向。使用方位词的英文缩写进行描述，例如`''ne''`表示*东北*，即右上角；可能的规格包括：`''n''`（顶部中心）、`''ne''`（右上角）、`''e''`（右中心）、`''se''`（右下角）、`''s''`（底部）、`''sw''`（左下角）、`''w''`（左中心）、`''nw''`（左上角）以及另外的`''center''`（水平和垂直居中）
    |'
  id: totrans-152
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| **anchor** | **str** | 文本的位置和方向。使用方位词的英文缩写进行描述，例如`''ne''`表示*东北*，即右上角；可能的规格包括：`''n''`（顶部中心）、`''ne''`（右上角）、`''e''`（右中心）、`''se''`（右下角）、`''s''`（底部）、`''sw''`（左下角）、`''w''`（左中心）、`''nw''`（左上角）以及另外的`''center''`（水平和垂直居中）
    |'
- en: '| **width** | **int** | 标签的宽度（以字符为单位）。如果未指定，标签的宽度将足够容纳要添加的文本 |'
  id: totrans-153
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| **width** | **int** | 标签的宽度（以字符为单位）。如果未指定，标签的宽度将足够容纳要添加的文本 |'
- en: '| **wraplength** | **int** | 标签中文本被换行的字符数。如果未指定，则不会换行 |'
  id: totrans-154
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| **wraplength** | **int** | 标签中文本被换行的字符数。如果未指定，则不会换行 |'
- en: 22.2.3.5 `Check Buttons`和`Radio Buttons`
  id: totrans-155
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 22.2.3.5 `Check Buttons`和`Radio Buttons`
- en: '`Check`按钮（或`checkbox`）和`radio`按钮用于给用户提供多种设置/选项的选择。`checkbox`允许用户选择多个不同的设置/选项，而`radio`按钮仅允许用户一次选择一个设置/选项。'
  id: totrans-156
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Check`按钮（或`checkbox`）和`radio`按钮用于给用户提供多种设置/选项的选择。`checkbox`允许用户选择多个不同的设置/选项，而`radio`按钮仅允许用户一次选择一个设置/选项。'
- en: '`Check`按钮和`radio`按钮在`tkinter`中由同名类表示。让我们首先创建两个`radio`按钮：'
  id: totrans-157
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Check`按钮和`radio`按钮在`tkinter`中由同名类表示。让我们首先创建两个`radio`按钮：'
- en: '`selection_var = IntVar()` `selection_opt1 = Radiobutton(win, text = ''Option
    One'', variable = selection_var, value = 1)` `selection_opt2 = Radiobutton(win,
    text = ''Option Two'', variable = selection_var, value = 2)` `selection_opt1.pack()`
    `selection_opt2.pack()`'
  id: totrans-158
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`selection_var = IntVar()` `selection_opt1 = Radiobutton(win, text = ''Option
    One'', variable = selection_var, value = 1)` `selection_opt2 = Radiobutton(win,
    text = ''Option Two'', variable = selection_var, value = 2)` `selection_opt1.pack()`
    `selection_opt2.pack()`'
- en: 首先，考虑`radio`按钮本身的构造函数调用：在这里，像往常一样，我们首先将我们的窗口对象`win`（类型为`Tk`）传递给`radio`按钮，并显示作为选择选项的文本。除此之外，还有两个参数，`variable`和`value`。
  id: totrans-159
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 首先，考虑`radio`按钮本身的构造函数调用：在这里，像往常一样，我们首先将我们的窗口对象`win`（类型为`Tk`）传递给`radio`按钮，并显示作为选择选项的文本。除此之外，还有两个参数，`variable`和`value`。
- en: 对于`variable`参数，我们将一个变量`selection_var`赋值给它，`selection_var`是在代码段开始时创建的，作为`IntVar`类的实例。`IntVar`是`tkinter`附带的几个特殊变量类之一。它不仅仅是一个普通的`int`变量。这个变量的特别之处在于，当我们将它赋值给`radio`按钮构造函数的`variable`参数时，它始终反映我们的`radio`按钮集的当前状态，即指示当前选择了哪个`radio`按钮选项。我们通过`Radionbutton()`的`value`参数定义`selection_var`在选择特定`radio`按钮时所取的值。因此，如果用户点击“Option
    Two”`radio`按钮，`selection_var`的值为2。如果用户点击“Option One”，`selection_var`的值为1。`IntVar
    selection_var`会在`radio`按钮的选择状态变化时自动更新。
  id: totrans-160
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 对于`variable`参数，我们将一个变量`selection_var`赋值给它，`selection_var`是在代码段开始时创建的，作为`IntVar`类的实例。`IntVar`是`tkinter`附带的几个特殊变量类之一。它不仅仅是一个普通的`int`变量。这个变量的特别之处在于，当我们将它赋值给`radio`按钮构造函数的`variable`参数时，它始终反映我们的`radio`按钮集的当前状态，即指示当前选择了哪个`radio`按钮选项。我们通过`Radionbutton()`的`value`参数定义`selection_var`在选择特定`radio`按钮时所取的值。因此，如果用户点击“Option
    Two”`radio`按钮，`selection_var`的值为2。如果用户点击“Option One”，`selection_var`的值为1。`IntVar
    selection_var`会在`radio`按钮的选择状态变化时自动更新。
- en: 这非常方便；但是，在查询值时需要记住一个特殊之处：如果你执行`print(selection_var)`，则会在运行控制台输出以下内容：`PY_VAR0`
  id: totrans-161
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这非常方便；但是，在查询值时需要记住一个特殊之处：如果你执行`print(selection_var)`，则会在运行控制台输出以下内容：`PY_VAR0`
- en: 但这不是变量的值。这是因为`selection_var`不是一个普通的`int`变量。我们必须使用它的`get()`方法查询它的值，尽管这需要一些适应。以下语句将成功：
  id: totrans-162
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 但这不是变量的值。这是因为`selection_var`不是一个普通的`int`变量。我们必须使用它的`get()`方法查询它的值，尽管这需要一些适应。以下语句将成功：
- en: '`print(selection_var.get())`'
  id: totrans-163
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`print(selection_var.get())`'
- en: 类似地，有一个方法`set()`，可以改变`IntVar`变量的值。由于我们通过构造函数`Radiobutton()`的`variable`参数将变量`selection_var`链接到单选按钮，这也改变了单选按钮之间的选择。
  id: totrans-164
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 类似地，有一个方法`set()`，可以改变`IntVar`变量的值。由于我们通过构造函数`Radiobutton()`的`variable`参数将变量`selection_var`链接到单选按钮，这也改变了单选按钮之间的选择。
- en: '`selection_var.set(2)`我们会自动选择分配值为2的单选按钮，即“左侧”单选按钮。相同的效果可以通过调用相应单选按钮实例的`select()`方法来实现：`select_left.select()`'
  id: totrans-165
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`selection_var.set(2)`我们会自动选择分配值为2的单选按钮，即“左侧”单选按钮。相同的效果可以通过调用相应单选按钮实例的`select()`方法来实现：`select_left.select()`'
- en: 因为我们将`IntVar`变量`selection_var`作为`variable`选项`to both radio buttons`，`tkinter`知道这两个单选按钮属于同一组，因此只能`one
    of them`被选中。所以请务必将相同的变量作为`variable`选项分配给属于同一“选择组”的单选按钮！
  id: totrans-166
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 因为我们将`IntVar`变量`selection_var`作为`variable`选项`to both radio buttons`，`tkinter`知道这两个单选按钮属于同一组，因此只能`one
    of them`被选中。所以请务必将相同的变量作为`variable`选项分配给属于同一“选择组”的单选按钮！
- en: '`Check buttons`的功能与单选按钮非常相似，当然不同的是，这里可以同时选择多个复选框，因为这两个复选框可以彼此独立选择。而对于单选按钮，如果按钮1被选中，按钮2就不能被选中，两个复选按钮则不再只有两种状态，而是四种不同的状态（两者都选中、都不选中、只选中第一个按钮、只选中第二个按钮）；一个的状态因此不再依赖于另一个按钮的状态。因此，你还需要两个不同的`IntVar`变量作为构造函数`Checkbutton()`的`variable`参数：'
  id: totrans-167
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Check buttons`的功能与单选按钮非常相似，当然不同的是，这里可以同时选择多个复选框，因为这两个复选框可以彼此独立选择。而对于单选按钮，如果按钮1被选中，按钮2就不能被选中，两个复选按钮则不再只有两种状态，而是四种不同的状态（两者都选中、都不选中、只选中第一个按钮、只选中第二个按钮）；一个的状态因此不再依赖于另一个按钮的状态。因此，你还需要两个不同的`IntVar`变量作为构造函数`Checkbutton()`的`variable`参数：'
- en: '`selection_var1 = IntVar()` `selection_var2 = IntVar()` `selection_opt1 = Checkbutton(win,
    text = ''Option One'', variable = selection_var1)` `selection_opt2 = Checkbutton(win,
    text = ''Option Two'', variable = selection_var2)` `selection_opt1.pack()` `selection_opt2.pack()`'
  id: totrans-168
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`selection_var1 = IntVar()` `selection_var2 = IntVar()` `selection_opt1 = Checkbutton(win,
    text = ''Option One'', variable = selection_var1)` `selection_opt2 = Checkbutton(win,
    text = ''Option Two'', variable = selection_var2)` `selection_opt1.pack()` `selection_opt2.pack()`'
- en: 你可能已经注意到，在`Checkbutton()`构造函数中，我们不再有`value`参数。默认情况下，状态变量`variable`在复选框被选中时取值`True`，未被选中时取值`False`。不过，使用可选参数或控件选项`onvalue`和`offvalue`，如果需要，可以更改此值。
  id: totrans-169
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在`Checkbutton()`构造函数中，我们不再有`value`参数。默认情况下，状态变量`variable`在复选框被选中时取值`True`，未被选中时取值`False`。不过，使用可选参数或控件选项`onvalue`和`offvalue`，如果需要，可以更改此值。
- en: ◘ 表[22.5](#Tab5)给出了`Radiobutton`和`Checkbutton`类型的控件最重要的特殊属性的概述，超出了◘ 表[22.1](#Tab1)中列出的标准选项。
  id: totrans-170
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: ◘ 表[22.5](#Tab5)给出了`Radiobutton`和`Checkbutton`类型的控件最重要的特殊属性的概述，超出了◘ 表[22.1](#Tab1)中列出的标准选项。
- en: '`Checkbutton`和`Radiobutton`控件的特殊属性'
  id: totrans-171
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Checkbutton`和`Radiobutton`控件的特殊属性'
- en: '| 选项 | 类型 | 意义 |'
  id: totrans-172
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| 选项 | 类型 | 意义 |'
- en: '| --- | --- | --- |'
  id: totrans-173
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `indicatoron` | `Bool` | If `False`，then instead of the circular (for radio
    buttons) or square (for check buttons) selection element, a real button is displayed
    that looks pressed down when the radio button/check button is selected |'
  id: totrans-174
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `indicatoron` | `Bool` | 如果为`False`，则显示一个真正的按钮，而不是圆形（单选按钮）或方形（复选按钮）选择元素，选中单选按钮/复选按钮时，按钮会看起来被按下
    |'
- en: '| `selectcolor` | `str` | Background color of the circular (for radio buttons)
    or square (for check buttons) selection element |'
  id: totrans-175
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `selectcolor` | `str` | 圆形（单选按钮）或方形（复选按钮）选择元素的背景颜色 |'
- en: 22.2.3.6 Selection Lists (`Listbox`)
  id: totrans-176
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 22.2.3.6 选择列表 (`Listbox`)
- en: 'Selection lists, represented by the `tkinter` class `Listbox`，allow a (single
    or multiple) selection from an enumeration of text entries. After creating a list
    box using the `Listbox()` class constructor and displaying the list box in the
    window using the `pack()` method:'
  id: totrans-177
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 选择列表，表示为`tkinter`类`Listbox`，允许从一组文本条目中进行（单项或多项）选择。在使用`Listbox()`类构造函数创建列表框并使用`pack()`方法将其显示在窗口中后：
- en: '`mylistbox = Listbox(win)` `mylistbox.pack()` we can start adding items to
    the list box. To do this, we use the `insert(index, entry, ...)` method: `mylistbox.insert(''end'',
    ''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'')`'
  id: totrans-178
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`mylistbox = Listbox(win)` `mylistbox.pack()` 我们可以开始向列表框中添加项目。为此，我们使用`insert(index,
    entry, ...)`方法：`mylistbox.insert(''end'', ''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'',
    ''Cathy'')`'
- en: '`insert()` has some similarities to the `Entry` widget method of the same name:
    `index` first specifies the numeric index of the element to be inserted *after*;
    as with `Entry`’s `insert()` method, the value `''end''` can also be specified,
    which ensures that the entries are added to the end of the list. The list can
    also be extended by several entries at the same time. Please note that the indexing
    of the list entries starts at 0, as is typical for Python (unlike the indexing
    of the characters for the `Entry` widgets, but just like the “column indexing”
    for the multiline `ScrolledText` widgets).'
  id: totrans-179
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`insert()`方法与`Entry`控件的同名方法有一些相似之处：`index`首先指定要插入元素的数字索引，它是插入位置的“后面”；与`Entry`的`insert()`方法一样，值`''end''`也可以指定，确保将条目添加到列表的末尾。也可以通过同时添加多个条目来扩展列表。请注意，列表条目的索引从0开始，这与Python的典型做法一致（不同于`Entry`控件中字符的索引，但与多行`ScrolledText`控件的“列索引”一致）。'
- en: Also analogous to `Entry`，you can delete list entries from the list box with
    the method `delete(index_from, index_to)`。In the case of the `Entry` widget, this
    method had removed individual characters from the contents of the `Entry` field,
    i.e., a string and thus a “character list”.
  id: totrans-180
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 同样，类似于`Entry`，您可以使用`delete(index_from, index_to)`方法从列表框中删除列表条目。在`Entry`控件中，此方法会删除`Entry`字段中的单个字符，也就是字符串，因此是一个“字符列表”。
- en: By calling the method `selection_set(index_from, index_to)`，you select entries
    in the list box as if the user had selected them.
  id: totrans-181
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 通过调用`selection_set(index_from, index_to)`方法，您可以像用户选择条目一样选择列表框中的条目。
- en: In both `delete()` and `selection_set()`，`index_to` is an optional argument,
    i.e. an argument that can be omitted when calling the method.
  id: totrans-182
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在`delete()`和`selection_set()`中，`index_to`是一个可选参数，也就是说，在调用方法时可以省略该参数。
- en: Just as you can use `selection_set()` to select one (or more) entries, you can
    apply `selection_includes(index)` to check whether the element of the list denoted
    by `index` is currently selected.
  id: totrans-183
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 就像您可以使用`selection_set()`选择一个（或多个）条目一样，您可以应用`selection_includes(index)`来检查由`index`表示的列表元素是否当前已被选中。
- en: Finally, with `selection_clear()` you can clear the current selection in the
    list box.
  id: totrans-184
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 最后，使用`selection_clear()`可以清除列表框中的当前选择。
- en: You determine the number of list entries using the `length()` method, while
    `get(index_from, index_to)` allows you to read the text entry of one or more entries.
    If you use the optional argument `index_to` and thus specify a range, you get
    a `tuple` with the text entries of the specified list entries as return values.
  id: totrans-185
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 您可以使用`length()`方法来确定列表条目的数量，而`get(index_from, index_to)`允许您读取一个或多个条目的文本。如果您使用可选参数`index_to`并指定一个范围，您将获得一个`tuple`，其中包含指定列表条目的文本条目作为返回值。
- en: ◘ Table [22.6](#Tab6) lists some important options that you can customize in
    the now familiar ways for the `Listbox` widget. Table 22.6
  id: totrans-186
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: ◘ 表格[22.6](#Tab6)列出了您可以按照现在熟悉的方式自定义的`Listbox`控件的一些重要选项。表格22.6
- en: Special properties of the `Listbox` widget
  id: totrans-187
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Listbox`控件的特殊属性'
- en: '| Option | Type | Meaning |'
  id: totrans-188
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| 选项 | 类型 | 说明 |'
- en: '| --- | --- | --- |'
  id: totrans-189
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `activestyle` | `str` | Specifies how the active entry, that is, the selected
    entry that currently has the focus, should be visually highlighted; possible values
    are `underline` (text underlined), `dotbox` (outline with dotted line), and `none`
    (no highlighting), where `underline` is the default value |'
  id: totrans-190
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `activestyle` | `str` | 指定活动条目（即当前具有焦点的已选条目）应该如何在视觉上突出显示；可能的值有`underline`（文本下划线）、`dotbox`（带点线的轮廓框）和`none`（不突出显示），其中`underline`为默认值
    |'
- en: '| `height` | `int` | The height of the list box but measured in entries rather
    than pixels; the default value is 10\. If you have more than the number of entries
    set in `height` and want to ensure that the entry at the `index` position is displayed,
    you can call the `see(index)` method; it scrolls the list box so that the `index`
    entry is visible in any case |'
  id: totrans-191
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `height` | `int` | 列表框的高度，但以条目数来度量，而不是像素；默认值为10。如果您有超过`height`中设置的条目数并希望确保`index`位置的条目被显示，您可以调用`see(index)`方法；该方法会滚动列表框，以确保`index`条目无论如何都能显示出来
    |'
- en: '| `selectmode` | `str` | Specifies how many entries can be selected at the
    same time and how they must be related; possible specifications are: `single`
    (one entry can be selected by clicking on the entry), `browse` (one entry can
    be selected by clicking or moving the mouse with the mouse button pressed), `multiple`
    (several entries can be selected, clicking on an entry sets the selection if it
    wasn’t selected before or removes it if it was already selected) and `extended`
    (several entries can be selected by clicking while holding down the <CTRL> or
    <SHIFT> key); the default value is `multiple`, which is somewhat unusual for Windows
    users |'
  id: totrans-192
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `selectmode` | `str` | 指定一次可以选择多少条目以及它们必须如何相关；可能的选项有：`single`（可以通过点击条目选择一个条目），`browse`（可以通过点击或按住鼠标按钮并移动鼠标来选择一个条目），`multiple`（可以选择多个条目，点击条目会选择它，如果之前没有选中它，则选中它，如果已经选中则移除它）和`extended`（可以通过按住<CTRL>或<SHIFT>键同时点击来选择多个条目）；默认值是`multiple`，这对于Windows用户来说有些不常见
    |'
- en: 'In addition, you can of course work with the standard options that we looked
    at in ◘ Table [22.1](#Tab1). Many of these properties can also be applied to `individual
    items` in the list box. To do this, use the `itemconfig(index, option=value)`
    method. For example, to give the third item a greenish background, you can execute
    the following statement: `mylistbox.itemconfig(2, background=''#ED5036'')`'
  id: totrans-193
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 此外，你当然也可以使用我们在◘表格[22.1](#Tab1)中看到的标准选项。这些属性中的许多也可以应用于`listbox`中的`individual
    items`。为此，请使用`itemconfig(index, option=value)`方法。例如，要给第三个项设置一个绿色背景，你可以执行以下语句：`mylistbox.itemconfig(2,
    background='#ED5036')`
- en: 'In ◘ Table [22.6](#Tab6) you will once again find cases of options which can
    take one of several values, for example `activestyle`. In view of the rather difficult
    documentation situation with `tkinter`, the question naturally arises which expressions
    are permissible at all. You still don’t know what the individual values do, but
    you can quickly find out by trial and error. So, the important thing in the first
    step would be to understand what options you have in the first place. There is
    a simple trick for this: You provoke an error. To do this, consider the following
    code:'
  id: totrans-194
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在◘表格[22.6](#Tab6)中，你将再次看到可以取多个值的选项的情况，例如`activestyle`。鉴于`tkinter`的文档情况相当复杂，问题自然出现了，哪些表达式是被允许的。你仍然不知道各个值的作用，但可以通过反复试验很快找出。所以，第一步要做的关键是理解你到底有哪些选项。这里有一个简单的技巧：你可以故意引发一个错误。为此，请考虑以下代码：
- en: '`mylistbox[''activestyle''] = ''xxx''`'
  id: totrans-195
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`mylistbox[''activestyle''] = ''xxx''`'
- en: 'Here we are trying to assign the value `xxx` to the `activestyle` option, which
    likely is not a valid expression for this option. If we run a program with this
    statement, we get an error message, but that is exactly what we are trying to
    achieve in this case. In our example we get:'
  id: totrans-196
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这里，我们尝试将值`xxx`赋给`activestyle`选项，这很可能不是该选项的有效表达式。如果我们运行含有此语句的程序，我们会得到一条错误消息，而这正是我们在此案例中试图实现的目标。在我们的例子中，得到的错误是：
- en: '`Traceback (most recent call last):` `File "C:/Users/MyUser/Desktop/Documents/tkinter_hello_world.py",
    line 138, in <module>` `names[''activestyle'']=''xxx''` `File "C:\Users\MyUser\AppData\Local\Programs\Python\Python37-32\lib\tkinter\__init__.py",
    line 1489, in __setitem__` `self.configure({key: value})` `File "C:\Users\MyUser\AppData\Local\Programs\Python\Python37-32\lib\tkinter\__init__.py",
    line 1482, in configure` `return self._configure(''configure'', cnf, kw)` `File
    "C:\Users\MyUser\AppData\Local\Programs\Python\Python37-32\lib\tkinter\__init__.py",
    line 1473, in _configure` `self.tk.call(_flatten((self._w, cmd)) + self._options(cnf))`
    `_tkinter.TclError: bad activestyle "xxx": must be dotbox, none, or underline`'
  id: totrans-197
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Traceback (most recent call last):` `File "C:/Users/MyUser/Desktop/Documents/tkinter_hello_world.py",
    line 138, in <module>` `names[''activestyle'']=''xxx''` `File "C:\Users\MyUser\AppData\Local\Programs\Python\Python37-32\lib\tkinter\__init__.py",
    line 1489, in __setitem__` `self.configure({key: value})` `File "C:\Users\MyUser\AppData\Local\Programs\Python\Python37-32\lib\tkinter\__init__.py",
    line 1482, in configure` `return self._configure(''configure'', cnf, kw)` `File
    "C:\Users\MyUser\AppData\Local\Programs\Python\Python37-32\lib\tkinter\__init__.py",
    line 1473, in _configure` `self.tk.call(_flatten((self._w, cmd)) + self._options(cnf))`
    `_tkinter.TclError: bad activestyle "xxx": must be dotbox, none, or underline`'
- en: The crucial part here is in the last line. There, the error message lists the
    possible values, which can now be easily tried out.
  id: totrans-198
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里的关键部分在于最后一行。在那里，错误消息列出了可能的值，现在你可以轻松地一一尝试。
- en: '`22.2.3.7 Message/Decision Dialogs (Class messagebox)`'
  id: totrans-199
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`22.2.3.7 消息/决策对话框（类messagebox）`'
- en: 有时你想以某种方式提醒用户，让他们注意到你的消息。或者你可能想强迫用户做出立即决策，比如在保存文件时是否覆盖它。在所有这些情况下，`message box`是一个不错的选择。
  id: totrans-200
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 有时你可能希望以某种方式提醒用户，让他们注意到你的消息。或者你可能希望强迫用户立即做出决定，例如在保存文件时是否覆盖它。在所有这些情况下，`message
    box`是一个不错的选择。
- en: You create a message box with the help of the `tkinter` module `messagebox`。因为`messagebox`与我们迄今为止遇到的大多数控件不同，它“打包”在自己的模块中（与`ScrolledText`一样），我们必须首先导入它包含的类。我们在这里简单使用星号通配符来导入`messagebox`模块中包含的所有类：
  id: totrans-201
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以借助`tkinter`模块的`messagebox`创建一个消息框。因为`messagebox`与我们迄今为止遇到的大多数控件不同，它“打包”在自己的模块中（与`ScrolledText`一样），我们必须首先导入它包含的类。我们在这里简单使用星号通配符来导入`messagebox`模块中包含的所有类：
- en: '`from tkinter.messagebox import *`'
  id: totrans-202
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`from tkinter.messagebox import *`'
- en: Then, using the `showinfo(title, message)`，`showwarning(title, message)` 和 `showerror(title,
    message)`函数，我们可以显示一个消息框，根据消息类型（信息、警告或错误）每个都有不同的图标。这里是一个警告消息的示例：
  id: totrans-203
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然后，使用`showinfo(title, message)`，`showwarning(title, message)`和`showerror(title,
    message)`函数，我们可以显示一个消息框，根据消息类型（信息、警告或错误）每个都有不同的图标。这里是一个警告消息的示例：
- en: '`showwarning(''Attention'',''The entered age must be greater than 0.'')`'
  id: totrans-204
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`showwarning(''注意'',''输入的年龄必须大于0。'')`'
- en: You can also customize the design of the message boxes by specifying additional
    options when calling the respective function. Possible options are `icon`（应该显示哪个图标？），`type`（应该显示哪些按钮？）和
    `default`（哪个按钮应该预选，以便在用户按下<ENTER>键时触发）。
  id: totrans-205
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你还可以通过在调用相应函数时指定额外的选项来定制消息框的设计。可选的选项有`icon`（应该显示哪个图标？），`type`（应该显示哪些按钮？）和`default`（哪个按钮应该预选，以便在用户按下<ENTER>键时触发）。
- en: 'The `icon` option can take the values `''info''`, `''warning''`, `''error''`
    and `''question''`. The first three are the icons also used by the functions `showinfo()`,
    `showwarning()` and `showerror()`, while `''question''` displays a question mark
    icon. Like the icons, the combination of buttons available to the user can be
    specified using constants, in this case `''ok''` (*okay* button), `''okcancel''`
    (*okay* and *cancel*), `''yesno''` (*yes* and *no*), `''yesnocancel''` (*yes*,
    *no* and *cancel*), `''retrycancel''` (*retry* and *cancel*) and `''abortretryignore''`
    (*cancel*, *retry* and *ignore*). So, for example, if we wanted to display a small
    dialog asking the user if he wants to overwrite a file and offering him *Yes*,
    *No* and *Cancel* buttons, we could create a suitable message box like this:'
  id: totrans-206
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`icon`选项可以取值为`''info''`、`''warning''`、`''error''`和`''question''`。前三个是`showinfo()`、`showwarning()`和`showerror()`函数也使用的图标，而`''question''`则显示一个问号图标。像图标一样，用户可用的按钮组合也可以通过常量来指定，在这种情况下，`''ok''`（*确定*按钮）、`''okcancel''`（*确定*和*取消*）、`''yesno''`（*是*和*否*）、`''yesnocancel''`（*是*、*否*和*取消*）、`''retrycancel''`（*重试*和*取消*）以及`''abortretryignore''`（*取消*、*重试*和*忽略*）。例如，如果我们想显示一个小对话框，询问用户是否要覆盖文件，并提供*是*、*否*和*取消*按钮，我们可以创建一个合适的消息框，代码如下：'
- en: '`feedback = showwarning(''Confirmation'', ''Do you really want to overwrite
    the file?'', icon=''question'', type=''yesnocancel'', default=''yes'')print(feedback)`'
  id: totrans-207
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`feedback = showwarning(''确认'', ''你真的要覆盖文件吗？'', icon=''question'', type=''yesnocancel'',
    default=''yes'')print(feedback)`'
- en: You can see from this example that although we are using the `showwarning()`
    function, which by default displays an exclamation mark as an icon, we can override
    the default behavior by specifying the `icon` option.
  id: totrans-208
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 从这个例子中可以看出，尽管我们使用的是`showwarning()`函数，默认显示感叹号图标，但通过指定`icon`选项，我们可以覆盖默认行为。
- en: The function returns the value as a lowercase string containing the label of
    the button that was clicked, in our example `'yes'`, `'no'` or `'cancel'`. This
    function value is important in order to be able to react to the user’s input accordingly.
  id: totrans-209
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 该函数返回一个小写字母字符串，包含被点击按钮的标签，在我们的示例中是`'yes'`、`'no'`或`'cancel'`。这个函数的返回值对于能够根据用户的输入做出相应反应非常重要。
- en: Unlike the controls we looked at in the previous sections, the message box is
    not a class that we need to create an instance of. Rather, it is simply a function
    that is contained in the `messagebox` module. It’s much the same with the file
    dialogs, which we’ll look at in the next section.
  id: totrans-210
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与我们在前几节中查看的控件不同，消息框不是我们需要创建实例的类。相反，它只是`messagebox`模块中的一个函数。文件对话框也是如此，我们将在下一节中讨论。
- en: 22.2.3.8 File Open/File Save Dialogs
  id: totrans-211
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 22.2.3.8 文件打开/保存对话框
- en: If you want to let the user select a file to open or to save something to, the
    `tkinter` module `filedialog` allows you to easily use the well known standard
    dialogs “Open file” and “Save file as” in your own programs.
  id: totrans-212
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你希望让用户选择打开文件或保存文件，`tkinter`模块中的`filedialog`可以让你轻松地在程序中使用“打开文件”和“另存为”这两个标准对话框。
- en: 'First, we need to import the module. For the sake of simplicity, we import
    all classes and functions contained in the module, just as we did with the `messagebox`
    module in the previous section:'
  id: totrans-213
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 首先，我们需要导入该模块。为了简化，我们导入模块中包含的所有类和函数，就像在前一节中导入`messagebox`模块一样：
- en: '`from tkinter.filedialog import *`'
  id: totrans-214
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`from tkinter.filedialog import *`'
- en: 'After that, the `askopenfilename()` or `asksaveasfilename()` functions can
    be used to call the dialogs for opening or saving files. In the following example
    we select a file to open and print the result in the (run-)console:'
  id: totrans-215
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 之后，可以使用`askopenfilename()`或`asksaveasfilename()`函数调用打开或保存文件的对话框。在以下示例中，我们选择一个文件进行打开，并在（运行）控制台中打印结果：
- en: '`filename = askopenfilename(defaultextension=''txt'', filetypes=[(''Text files'',
    ''*.txt''), (''All files'', ''*.*'')], title=''Open file...'', initialdir=''C:\\Windows'')print(filename)`'
  id: totrans-216
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`filename = askopenfilename(defaultextension=''txt'', filetypes=[(''文本文件'',
    ''*.txt''), (''所有文件'', ''*.*'')], title=''打开文件...'', initialdir=''C:\\Windows'')print(filename)`'
- en: The functions return the name (including the path) of the selected file. If
    the user cancels the dialog without selecting a file or entering a file name,
    an empty string is returned. As you can see from the example above, you can control
    the behavior of the dialog with some options. `filetypes` is a list (note the
    enclosing square brackets!) of tuples, each consisting of a description and a
    file extension; the user can then preselect the file types thus defined. The `title`
    option controls the dialog title; `initialdir` is the directory whose contents
    should be displayed by default when the dialog opens; the backslash (`\`) as part
    of the pathname must be written twice, a single backslash would be interpreted
    by Python as an attempt to escape the character behind it; if you are not familiar
    with escaping, go back to ► Sect. [11.​2.​2](474412_1_En_11_Chapter.xhtml#Sec4).
  id: totrans-217
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这些函数返回所选文件的名称（包括路径）。如果用户在对话框中取消选择而没有选择文件或输入文件名，则返回一个空字符串。如上例所示，您可以通过一些选项来控制对话框的行为。`filetypes`是一个列表（注意方括号！），其中每个元素是一个元组，包含描述和文件扩展名；用户可以预先选择定义的文件类型。`title`选项控制对话框标题；`initialdir`是对话框打开时默认显示的目录；路径中的反斜杠（`\`）必须写两次，单个反斜杠会被Python解释为转义字符；如果您不熟悉转义字符，请返回►
    Sect. [11.​2.​2](474412_1_En_11_Chapter.xhtml#Sec4)。
- en: 'By the way: You may have wondered in the last section, with the `messagebox`
    module, why we don’t actually work with classes here, as with the other widgets,
    but instead call functions like `showwarning()` or `askopenfilename()`. The answer
    is: Because it’s easiest for us that way! These functions create the necessary
    class instances in the background. Since we’re only interested in the results,
    in this case the filenames, and don’t really want to work with the dialog (class)
    instances themselves, it’s sufficient that an appropriate function provides us
    with the filename and saves us the trouble of creating instances of the necessary
    classes ourselves and working with them. The situation is different, of course,
    with the other widgets, which are permanently present in our application window
    and with which we also want to work later.'
  id: totrans-218
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 顺便提一下：你可能在上一节中对`messagebox`模块产生过疑问，为什么在这里我们没有像其他小部件那样使用类，而是调用像`showwarning()`或`askopenfilename()`这样的函数。答案是：因为这种方式对我们来说最简单！这些函数会在后台创建必要的类实例。由于我们只关心结果，这里指的是文件名，并且不想真正处理对话框（类）实例，因此只要一个合适的函数提供我们文件名并省去了自己创建类实例的麻烦，就足够了。当然，其他小部件的情况是不同的，它们会一直存在于我们的应用程序窗口中，且我们稍后还会与它们一起工作。
- en: '`22.2.3.9 Other Widgets`'
  id: totrans-219
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`22.2.3.9 其他小部件`'
- en: In addition to the widgets we have looked at in the previous sections, there
    are a number of other controls that you can use when designing your program interface,
    for example `Canvas` (drawing area), `Spinbox` (input field with up-down arrows
    to adjust the value), `Treeview` (hierarchical display of elements; import from
    module `tkinter.ttk` module), `Notebook` (display of controls on tabs/tabs; also
    in `tkinter.ttk` module), `Progressbar` (in `tkinter.ttk` module), just to name
    a few. For working with images, which can be added to many controls (e.g., menu
    items, buttons) or used as background (e.g., of the main application window),
    there is also the class `PhotoImage`.
  id: totrans-220
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 除了我们在前几节中看到的小部件外，设计程序界面时还有许多其他控件可以使用，例如`Canvas`（绘图区域）、`Spinbox`（带有上下箭头的输入框用于调整值）、`Treeview`（元素的层次显示；从`tkinter.ttk`模块导入）、`Notebook`（选项卡上的控件显示；也在`tkinter.ttk`模块中）、`Progressbar`（在`tkinter.ttk`模块中），仅举几例。对于可以添加到许多控件（如菜单项、按钮）中或用作背景（例如主应用窗口背景）的图像，还有`PhotoImage`类。
- en: 正如您所看到的，`tkinter`还有很多东西值得探索！唯一的缺点是相对较差的文档，至少对于上述提到的`tkinter.ttk`模块的小部件而言。有较多或少足够的“官方”文档（目前可用地址为►
    [https://​docs.​python.​org/​3/​library/​tkinter.​ttk.​html](https://docs.python.org/3/library/tkinter.ttk.html)）。不过，通常进行自己的互联网搜索往往是最佳选择。幸运的是，您通常可以快速找到所需的内容，因为许多程序员在您之前已经有过类似的问题！
  id: totrans-221
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 正如您所看到的，`tkinter`还有很多东西值得探索！唯一的缺点是相对较差的文档，至少对于上述提到的`tkinter.ttk`模块的小部件而言。有较多或少足够的“官方”文档（目前可用地址为►
    [https://​docs.​python.​org/​3/​library/​tkinter.​ttk.​html](https://docs.python.org/3/library/tkinter.ttk.html)）。不过，通常进行自己的互联网搜索往往是最佳选择。幸运的是，您通常可以快速找到所需的内容，因为许多程序员在您之前已经有过类似的问题！
- en: 22.2.4 控件的排列（几何管理器）
  id: totrans-222
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 22.2.4 控件的排列（几何管理器）
- en: 在前面的部分中，我们认识了一些控制元素，允许用户通过界面控制程序。为了构建一个视觉上吸引人且易于使用的界面，各种控制元素必须放置在它们应该在界面上的位置。
  id: totrans-223
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们认识了一些控制元素，允许用户通过界面控制程序。为了构建一个视觉上吸引人且易于使用的界面，各种控制元素必须放置在它们应该在界面上的位置。
- en: 为了在表面上安排控件，`tkinter`提供了三种*几何管理器*，我们将在接下来的部分中更详细地处理它们。这三者都遵循不同的基本原则来定义控件在表面上的位置。根据您应用程序最适合的定位方式，您可以选择相关的几何管理器。
  id: totrans-224
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为了在表面上安排控件，`tkinter`提供了三种*几何管理器*，我们将在接下来的部分中更详细地处理它们。这三者都遵循不同的基本原则来定义控件在表面上的位置。根据您应用程序最适合的定位方式，您可以选择相关的几何管理器。
- en: 三个几何管理器是：
  id: totrans-225
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 三个几何管理器是：
- en: '`Pack`：`Pack`简单地将控件一个接一个地放置，或者一个在另一个下面。在前面的部分中，我们已经通过调用小部件的`pack()`方法来使用这个几何管理器。这使得小部件一个在另一个下面被放置，并将它们居中于可用空间。'
  id: totrans-226
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`Pack`：`Pack`简单地将控件一个接一个地放置，或者一个在另一个下面。在前面的部分中，我们已经通过调用小部件的`pack()`方法来使用这个几何管理器。这使得小部件一个在另一个下面被放置，并将它们居中于可用空间。'
- en: '`Grid`：`Grid`心理上将表面上的可用空间划分为行和列的网格，并允许控件放置在该网格的每个“单元格”中。`Grid`非常适合构建复杂的表面，并且应该足以满足大多数目的。'
  id: totrans-227
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`Grid`：`Grid`心理上将表面上的可用空间划分为行和列的网格，并允许控件放置在该网格的每个“单元格”中。`Grid`非常适合构建复杂的界面，并且应该足以满足大多数目的。'
- en: '`Place`：`Place`根据其*绝对*“坐标”位置来定位元素，这些坐标以像素为单位，或*相对*（以窗口宽度/高度的比例来测量）于窗口的左上角。'
  id: totrans-228
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`Place`：`Place`根据其*绝对*“坐标”位置来定位元素，这些坐标以像素为单位，或*相对*（以窗口宽度/高度的比例来测量）于窗口的左上角。'
- en: 22.2.4.1 `Pack`
  id: totrans-229
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 22.2.4.1 `Pack`
- en: 当我们仔细查看各种小部件时，我们使用了`pack()`方法以确保这些小部件实际显示在我们的程序界面上。然而，这些小部件不仅被显示出来，而且当然也在窗口中同时定位，一个在另一个下面。这正是几何管理器`Pack`所做的：顾名思义，它“打包”各种控件，可以是垂直的“堆叠”（这是默认方向），也可以是水平的“行”。元素在表面上出现的位置主要取决于其前驱在堆叠（在垂直对齐的情况下）或行（在水平对齐的情况下）中的大小。
  id: totrans-230
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当我们仔细查看各种小部件时，我们使用了`pack()`方法以确保这些小部件实际显示在我们的程序界面上。然而，这些小部件不仅被显示出来，而且当然也在窗口中同时定位，一个在另一个下面。这正是几何管理器`Pack`所做的：顾名思义，它“打包”各种控件，可以是垂直的“堆叠”（这是默认方向），也可以是水平的“行”。元素在表面上出现的位置主要取决于其前驱在堆叠（在垂直对齐的情况下）或行（在水平对齐的情况下）中的大小。
- en: 举个例子，假设我们有一个用于输入密码的程序界面：
  id: totrans-231
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 举个例子，假设我们有一个用于输入密码的程序界面：
- en: '`from` `tkinter` `import` `win = Tk()win.title(''Demonstration of the Geometry
    Managers'')win.geometry(''500x100'')prompt = Label(win, text = ''Please enter
    your password:'')pwd = Entry(win)login = Button(win, text = ''Login'')pwd[''show'']
    = ''*''pwd[''width''] = 20pwd.focus()`'
  id: totrans-232
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`from` `tkinter` `import` `win = Tk()win.title(''Demonstration of the Geometry
    Managers'')win.geometry(''500x100'')prompt = Label(win, text = ''Please enter
    your password:'')pwd = Entry(win)login = Button(win, text = ''Login'')pwd[''show'']
    = ''*''pwd[''width''] = 20pwd.focus()`'
- en: 'We create three widgets: a `label` called `prompt` to display a prompt, an
    entry field `pwd` to hold the password, and a login button to confirm the password
    entry. We then configure the entry field `pwd` to hide the password input and
    display only asterisks for the characters entered. We also set its width to 20
    characters and assign it focus so that the user can start typing directly. Next,
    as before, we call the `pack()` method to let the `pack` Geometry Manager place
    the widgets on the surface. To make sure that the controls are displayed next
    to each other and not—as would happen by default—below each other, we call `pack()`
    with the option `side`，which accepts the constants `''left''`，`''right''` and
    `''bottom''` as values for the direction of the widget positioning in addition
    to the default value `''top''`：'
  id: totrans-233
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们创建了三个小部件：一个名为`prompt`的`label`用来显示提示信息，一个输入框`pwd`用来保存密码，以及一个登录按钮用来确认密码输入。然后，我们配置输入框`pwd`隐藏密码输入，只显示输入字符的星号。我们还将其宽度设置为20个字符，并赋予它焦点，这样用户可以直接开始输入。接下来，像之前一样，我们调用`pack()`方法，让`pack`几何管理器将小部件放置在界面上。为了确保控件彼此并排显示，而不是像默认情况那样堆叠在彼此下面，我们使用`side`选项调用`pack()`，该选项接受常量`'left'`、`'right'`和`'bottom'`作为控件定位方向的值，默认值为`'top'`：
- en: '`prompt.pack(side = ''left'')pwd.pack(side = ''left'')login.pack(side = ''left'')win.mainloop()You
    can see the result in ◘ Fig. [22.2](#Fig2). The widgets are now right next to
    each other. With the option `padx` (and vertically `pady`) we can add some spacing
    (`padding`) to the left and right of each widget, for example with:![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig2_HTML.jpg)'
  id: totrans-234
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`prompt.pack(side = ''left'')pwd.pack(side = ''left'')login.pack(side = ''left'')win.mainloop()你可以在◘
    图 [22.2](#Fig2)中看到结果。小部件现在紧挨着彼此。通过使用`padx`（以及垂直方向的`pady`），我们可以为每个小部件的左右添加一些间距（`padding`），例如：![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig2_HTML.jpg)'
- en: A screenshot of a window titled, demonstration of the Geometry Managers. A password
    field is given below with a login button placed right next to it.
  id: totrans-235
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 显示一个标题为“几何管理器演示”的窗口截图，下面是一个密码框，旁边放置了一个登录按钮。
- en: Fig. 22.2
  id: totrans-236
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 22.2
- en: Arrangement of the widgets with `pack(side = LEFT)`
  id: totrans-237
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用`pack(side = LEFT)`排列小部件
- en: '`pwd.pack(side = ''left'', padx = 5)`'
  id: totrans-238
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`pwd.pack(side = ''left'', padx = 5)`'
- en: 'Two other important options can be used to control the behavior of `pack()`
    in even more detail: `expand`，which can take the values `1` and `0` or `True`
    and `False`，determines whether the `pack` Geometry Manager should use the full
    width it has available. In our example，this is the entire window width. If we
    were to change the default setting for all three widgets and tell `pack()` to
    use the full width with `expand=1`，i.e.'
  id: totrans-239
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 另外两个重要的选项可以用来更详细地控制`pack()`的行为：`expand`，它可以取值`1`和`0`，或者`True`和`False`，决定`pack`几何管理器是否应使用它所能使用的全部宽度。在我们的示例中，这就是整个窗口的宽度。如果我们改变所有三个小部件的默认设置，并告诉`pack()`使用全部宽度（`expand=1`），即：
- en: '`prompt.pack(side = ''left'', expand = 1)pwd.pack(side = ''left'', expand =
    1)login.pack(side = ''left'', expand = 1)the result looks as in ◘ Fig. [22.3](#Fig3).![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig3_HTML.jpg)'
  id: totrans-240
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`prompt.pack(side = ''left'', expand = 1)pwd.pack(side = ''left'', expand =
    1)login.pack(side = ''left'', expand = 1)`，结果如◘ 图 [22.3](#Fig3)所示。![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig3_HTML.jpg)'
- en: A screenshot of a window titled, demonstration of the Geometry Managers. A password
    field is given below with a login button placed at a distance from it.
  id: totrans-241
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个名为“几何管理器演示”的窗口截图。下面是一个密码输入框，登录按钮与其保持一定距离。
- en: Fig. 22.3
  id: totrans-242
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 22.3
- en: Arrangement of widgets with `expand` option
  id: totrans-243
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 带有 `expand` 选项的小部件布局
- en: This still “packs” the widgets, but each widget has more space. Within the space
    available to each widget, the control is centered by default, but this can easily
    be adjusted with the specifications`'n'`,`'ne'`,`'e'`,`'se'`,`'s'`,`'sw'`,`'w'`,`'nw'`,
    and`'center'` (default) of the additional `anchor` option. These options are the
    same as for the `Label` widget (see ◘ Table [22.4](#Tab4)).
  id: totrans-244
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这仍然是“打包”小部件，但每个小部件有更多的空间。在每个小部件可用的空间内，控件默认居中，但可以通过额外的 `anchor` 选项轻松调整，具体规格为`'n'`、`'ne'`、`'e'`、`'se'`、`'s'`、`'sw'`、`'w'`、`'nw'`和`'center'`（默认）。这些选项与
    `Label` 小部件相同（参见 ◘ 表 [22.4](#Tab4)）。
- en: Also, we can tell`pack()` to maximally expand the widgets in the space available
    to them, which is useful for some purposes, but often looks rather strange. To
    do this, we set the `fill` option to one of the constants`'x'` (expand horizontally),`'y'`
    (expand vertically), or`'both'` (expand both horizontally and vertically). This
    is exactly what happens in the following example with the input field, which we
    let expand in the horizontal direction, and the button, which we let expand in
    both directions to take up the available space, resulting in the interface seen
    in ◘ Fig. [22.4](#Fig4):![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig4_HTML.jpg)
  id: totrans-245
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 此外，我们还可以告诉 `pack()` 最大程度地扩展小部件在可用空间中的占据，这对于某些用途非常有用，但有时看起来会比较奇怪。为此，我们将 `fill`
    选项设置为常量之一：`'x'`（水平扩展）、`'y'`（垂直扩展）或 `'both'`（水平和垂直都扩展）。以下示例正是这样做的，我们让输入框在水平方向上扩展，登录按钮则在两个方向上都扩展以占据可用空间，最终呈现出
    ◘ 图 [22.4](#Fig4) 中看到的界面：![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig4_HTML.jpg)
- en: A screenshot of a window titled, demonstration of the Geometry Managers. An
    elongated password field is given below with a login button placed at a distance
    from it.
  id: totrans-246
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个名为“几何管理器演示”的窗口截图。下方是一个延伸的密码输入框，登录按钮与其保持一定距离。
- en: Fig. 22.4
  id: totrans-247
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 22.4
- en: Arrangement of the widgets with different options
  id: totrans-248
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 带有不同选项的小部件布局
- en: '`prompt.pack(side = ''left'', fill = ''x'', anchor = ''w'')` `pwd.pack(side
    = ''left'', expand = 1, fill = ''x'', padx = 5, anchor = ''w'')` `login.pack(side
    = ''left'', expand = 1, fill = ''both'', anchor = ''w'')`'
  id: totrans-249
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`prompt.pack(side = ''left'', fill = ''x'', anchor = ''w'')` `pwd.pack(side
    = ''left'', expand = 1, fill = ''x'', padx = 5, anchor = ''w'')` `login.pack(side
    = ''left'', expand = 1, fill = ''both'', anchor = ''w'')`'
- en: As this example shows, you will usually have to play around with the `pack`
    options `side`,`fill`,`expand`,`anchor` and `padx/pady` until you have found a
    good layout. With a little experience, you can implement a surface structure that
    you have sketched on paper or digitally.
  id: totrans-250
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如本示例所示，通常需要不断调整 `pack` 选项如 `side`、`fill`、`expand`、`anchor` 和 `padx/pady`，直到找到合适的布局。稍微有些经验后，你可以实现你在纸上或数字上画出的界面结构。
- en: 22.2.4.2 Grid
  id: totrans-251
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 22.2.4.2 网格布局
- en: While `Pack` tries to “pack” the controls side by side, the `grid` Geometry
    Manager sees the application window as a `grid` of `rows` and `columns`. Controls
    can be freely positioned within the grid. The individual “cells” in the grid are
    addressed using the Python-typical indices starting at 0.
  id: totrans-252
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Pack` 尝试将控件并排“打包”，而 `grid` 几何管理器则将应用程序窗口视为一个由 `行` 和 `列` 组成的 `网格`。控件可以在网格内自由定位。网格中的每个“单元格”使用从
    0 开始的 Python 风格的索引来定位。'
- en: 'Consider the password input example used in the last section:'
  id: totrans-253
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 请参考上一节中使用的密码输入示例：
- en: '`from tkinter import` `win = Tk()` `win.title(''Demonstration of the Geometry
    Managers'')` `win.geometry(''500x100'')` `prompt = Label(win, text = ''Please
    enter your password:'')` `pwd = Entry(win)` `login = Button(win, text = ''Login'')`
    `pwd[''show''] = ''*''` `pwd[''width''] = 20` `pwd.focus()`'
  id: totrans-254
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`from tkinter import` `win = Tk()` `win.title(''几何管理器演示'')` `win.geometry(''500x100'')`
    `prompt = Label(win, text = ''请输入您的密码：'')` `pwd = Entry(win)` `login = Button(win,
    text = ''登录'')` `pwd[''show''] = ''*''` `pwd[''width''] = 20` `pwd.focus()`'
- en: 'In the next step, we use the `grid(row =` `row`, `column =` `column)` method
    to position the prompt and the input field next to each other, with the login
    button below the input field:'
  id: totrans-255
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在下一步中，我们使用 `grid(row =` `row`, `column =` `column)` 方法将提示和输入框并排放置，登录按钮位于输入框下方：
- en: '`prompt.grid(row = 0, column = 0)` `pwd.grid(row = 0, column = 1)` `login.grid(row
    = 1, column = 1)` `win.mainloop()` The result is shown in ◘ Fig. [22.5](#Fig5).![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig5_HTML.jpg)'
  id: totrans-256
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`prompt.grid(row = 0, column = 0)` `pwd.grid(row = 0, column = 1)` `login.grid(row
    = 1, column = 1)` `win.mainloop()` 结果如◘图 [22.5](#Fig5)所示。![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig5_HTML.jpg)'
- en: A screenshot of a window titled, demonstration of the Geometry Managers. A password
    field is given with a login button placed below it.
  id: totrans-257
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个窗口截图，标题为“几何管理器的演示”。其中有一个密码输入框，下面放置了一个登录按钮。
- en: Fig. `22.5`
  id: totrans-258
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 `22.5`
- en: Arrangement of the widgets with `grid()`.
  id: totrans-259
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用 `grid()` 安排小部件。
- en: As you can see, the input field and the button are displayed in the same column,
    namely column 1 (i.e., the second column). The Geometry Manager sizes the cells
    so that the widgets just fit into them. Within the cells, the controls are centered
    by default (vertically, and—as you can see in the example of the button—horizontally).
  id: totrans-260
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如你所见，输入框和按钮显示在同一列中，即第 1 列（即第二列）。几何管理器调整单元格的大小，使小部件正好适合其中。在单元格中，控件默认是居中的（垂直居中——以及如按钮示例所示的水平居中）。
- en: However, the alignment of widgets within their cells can be easily influenced
    using the `sticky` option. As seen several times before, `sticky` is a compass
    direction specification. `sticky = 'w'` therefore means that the widget should
    be aligned “in the west”, i.e., on the left edge of the cell. At the same time,
    the cardinal directions can also be used to adjust the width of the widget so
    that, if it were smaller than the cell, it would still fill it completely. For
    example, `sticky = 'we'` causes the widget in its cell, whose width is determined
    by the wider input field in the row above it, to extend “from west to east”, i.e.,
    over the entire width of the cell.
  id: totrans-261
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，小部件在单元格中的对齐方式可以通过使用 `sticky` 选项轻松影响。如之前多次所见，`sticky` 是一种方向指定方式。`sticky =
    'w'` 意味着小部件应当对齐到“西边”，即单元格的左边缘。同时，也可以使用四个方向来调整小部件的宽度，使其即使比单元格小，仍能完全填充单元格。例如，`sticky
    = 'we'` 使得小部件在其单元格中，单元格宽度由上面行中较宽的输入框决定，从“西到东”延伸，即跨越整个单元格的宽度。
- en: You can see the result in ◘ Fig. [`22.6`](#Fig6).![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig6_HTML.jpg)
  id: totrans-262
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在◘图 [`22.6`](#Fig6) 中看到结果。![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig6_HTML.jpg)
- en: A screenshot of a window titled, demonstration of the Geometry Managers. A password
    field is given with a login button placed right below it.
  id: totrans-263
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个窗口截图，标题为“几何管理器的演示”。其中有一个密码输入框，下面正下方放置了一个登录按钮。
- en: Fig. `22.6`
  id: totrans-264
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 `22.6`
- en: Arrangement of the widgets with `grid()` and the option `sticky = 'we'` for
    the button.
  id: totrans-265
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用 `grid()` 和按钮的 `sticky = 'we'` 选项来安排小部件。
- en: Sometimes, however, this is not enough, and you want a widget to span multiple
    columns or multiple rows. In this case, the `rowspan` and `columnspan` options
    help, specifying the number of rows or columns spanned respectively. With
  id: totrans-266
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，有时这并不足够，你可能希望某个小部件跨越多个列或多个行。在这种情况下，`rowspan` 和 `columnspan` 选项可以派上用场，它们分别指定跨越的行数或列数。
- en: '`login.grid(row = 1, column = 0, sticky = ''we'', columnspan = 3)` our button
    would extend from the left edge of the prompt to the right edge of the input field.
    The `padx` and `pady` options, already known from `pack()` , allow you to specify
    a left/right and top/bottom spacing, respectively, which generally equalizes the
    display somewhat, as can be seen in the example in ◘ Fig. [`22.7`](#Fig7), where
    `padx` and `pady` values of 5 were used.![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig7_HTML.jpg)'
  id: totrans-267
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`login.grid(row = 1, column = 0, sticky = ''we'', columnspan = 3)` 这样，我们的按钮就会从提示框的左边缘延伸到输入框的右边缘。`padx`
    和 `pady` 选项（从 `pack()` 中已经知道）允许你分别指定左右和上下的间距，这样通常会使显示效果更加均衡，如◘图 [`22.7`](#Fig7)所示，在该例中使用了
    `padx` 和 `pady` 值为 5。![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig7_HTML.jpg)'
- en: A screenshot of a window titled, demonstration of the Geometry Managers. A password
    field is given with a login button placed below it at a distance.
  id: totrans-268
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个窗口截图，标题为“几何管理器的演示”。其中有一个密码输入框，下面放置了一个距离较远的登录按钮。
- en: Fig. `22.7`
  id: totrans-269
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 `22.7`
- en: Arrangement of the widgets with `grid()` and the options `padx` and `pady`.
  id: totrans-270
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用 `grid()` 和 `padx`、`pady` 选项安排小部件。
- en: The total size of the grid in your application window depends on where you have
    placed the widgets positioned furthest out. In our example, the grid has two columns
    and two rows; if we were to place a widget to the right of the input field using
    `widget.grid(row = 0, column = 2)` , a third column would be added. Grid is a
    very popular Geometry Manager because it allows you to design effective surfaces
    with little effort, while providing intuitive positioning. The example in ► Sect.
    [`22.2.6`](#Sec20), where we develop a full `tkinter` application, will also use
    `Grid`.
  id: totrans-271
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 应用窗口中网格的总大小取决于你放置的最远位置的小部件。在我们的例子中，网格有两列和两行；如果我们使用`widget.grid(row = 0, column
    = 2)`将小部件放置到输入框的右侧，那么就会添加第三列。Grid是一个非常流行的几何管理器，因为它能够让你以最小的努力设计出有效的界面，同时提供直观的定位方式。在►第[`22.2.6`](#Sec20)节中，我们将开发一个完整的`tkinter`应用程序，那里也会使用`Grid`。
- en: '`22.2.4.3 Place`'
  id: totrans-272
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`22.2.4.3 Place`'
- en: The third, last and probably least frequently used Geometry Manager in practice
    is `Place`. `Place` is used to place widgets either at an absolute position specified
    by `x` and `y` coordinates using the `x` and `y` arguments, or at a relative position.
    Relative means that the position relative to the upper left corner of the window
    is measured as a percentage of the window width or height. The statement
  id: totrans-273
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第三种、最后一种可能也是最少使用的几何管理器是`Place`。`Place`用于将小部件放置在一个绝对位置，该位置由`x`和`y`坐标指定，或者放置在一个相对位置。相对位置意味着，位置是相对于窗口的左上角，按照窗口宽度或高度的百分比来测量的。语句
- en: '`login.place(relx = 0.5, rely = 0.5)` positions the `login` button exactly
    in the middle of the window, namely after 50% of the window width (`relx`) and
    50% of the window height (`rely`) from the upper left corner of the window. More
    precisely: The `upper left corner` of the button is placed there. With the `anchor`
    option, already known from `pack()`，another corner can also be specified as the
    “anchor” of the positioning. Again, the corner is specified by geographical directions,
    for example `''se''` for the southeastern, i.e., the lower right corner. The size
    of the widgets can also be specified, either absolutely with the help of the `width`
    and `height` options, or by a relative size specification. In this case, `relwidth`
    and `relheight` can be used to specify a width or height as a percentage of the
    window width or height.'
  id: totrans-274
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`login.place(relx = 0.5, rely = 0.5)`将`login`按钮精确地放置在窗口的正中央，也就是距离窗口左上角50%窗口宽度（`relx`）和50%窗口高度（`rely`）。更准确地说：按钮的`左上角`被放置在那里。通过`anchor`选项（从`pack()`已知），还可以指定另一个角作为定位的“锚点”。同样，角落是通过地理方向指定的，例如`''se''`表示东南角，也就是右下角。小部件的大小也可以指定，可以通过`width`和`height`选项进行绝对指定，或者通过相对大小指定。在这种情况下，可以使用`relwidth`和`relheight`将宽度或高度指定为窗口宽度或高度的百分比。'
- en: The advantage of specifying relative positioning and sizes is that the position
    and size of the widgets adapt when the window size changes, an effect that can
    also be achieved with the Geometry Managers `pack` and `grid` (although a bit
    more tedious with the latter), but this is not the case when using `place` with
    absolute position specifications.
  id: totrans-275
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 指定相对位置和大小的优点在于，当窗口大小发生变化时，小部件的位置和大小会自动适应，这一效果也可以通过几何管理器`pack`和`grid`实现（尽管使用后者时稍显繁琐），但当使用`place`进行绝对位置指定时，就无法实现这一点。
- en: 22.2.5 Events
  id: totrans-276
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 22.2.5 事件
- en: The Command Option of the `tkinter` Widgets
  id: totrans-277
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`tkinter`小部件的命令选项'
- en: So far, we have put together responsive interfaces, but they are largely without
    function. Nothing happens when you click on one of our buttons or menu items.
    That will change now.
  id: totrans-278
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经组合了响应式界面，但它们基本上没有任何功能。当你点击我们的按钮或菜单项时，什么也不会发生。现在，情况将发生变化。
- en: 'Some widgets, such as `Button` or `Menu`，bring with them the ability to specify
    a function that will be called whenever the control is “triggered” by the user.
    Consider the following simple example of the now well-known conversion between
    Kelvin and degrees Celsius. A small converter with a graphical interface might
    look like this:'
  id: totrans-279
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一些小部件，如`Button`或`Menu`，本身带有一个功能，可以在控件被用户“触发”时调用该功能。考虑一下现在广为人知的开尔文与摄氏度之间的转换。一个带有图形界面的简单转换器可能像这样：
- en: '`from` `tkinter` `import` `def convert():lb_result[''text''] = ''Conversion
    result: '' + str(round(float(en_kelvin.get()) - 273.15, 2)) + '' °C.''`def closeapp():quit()win
    = Tk()win.title(''Kelvin-Celsius Conversion'')win.geometry(''400x150'')menu_top
    = Menu(win)win.config(menu = menu_top)actionmenu = Menu(menu_top, tearoff = 0)actionmenu.add_command(label
    = ''Convert'', command = convert)actionmenu.add_separator()actionmenu.add_command(label
    = ''Close'', command = closeapp)menu_top.add_cascade(label = ''Action'', menu
    = actionmenu)lb_input = Label(text = ''Temperature in Kelvin:'')en_kelvin = Entry()bt_convert
    = Button(win, text = ''Convert'', command = convert)lb_result = Label(width =
    30)lb_result.pack()en_kelvin.pack()bt_convert.pack(pady = 10)lb_result.pack(pady
    = 10)win.mainloop()`用户界面的程序如图`◘ Fig. [22.8](#Fig8)`所示。![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig8_HTML.jpg)'
  id: totrans-280
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`from` `tkinter` `import` `def convert():lb_result[''text''] = ''Conversion
    result: '' + str(round(float(en_kelvin.get()) - 273.15, 2)) + '' °C.''`def closeapp():quit()win
    = Tk()win.title(''Kelvin-Celsius Conversion'')win.geometry(''400x150'')menu_top
    = Menu(win)win.config(menu = menu_top)actionmenu = Menu(menu_top, tearoff = 0)actionmenu.add_command(label
    = ''Convert'', command = convert)actionmenu.add_separator()actionmenu.add_command(label
    = ''Close'', command = closeapp)menu_top.add_cascade(label = ''Action'', menu
    = actionmenu)lb_input = Label(text = ''Temperature in Kelvin:'')en_kelvin = Entry()bt_convert
    = Button(win, text = ''Convert'', command = convert)lb_result = Label(width =
    30)lb_result.pack()en_kelvin.pack()bt_convert.pack(pady = 10)lb_result.pack(pady
    = 10)win.mainloop()`用户界面的程序如图`◘ 图 22.8`所示。![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig8_HTML.jpg)'
- en: 窗口截图标题为“Kelvin-Celsius conversion”。输入字段下方有一个转换按钮。
  id: totrans-281
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 窗口截图标题为“Kelvin-Celsius 转换”。输入字段下方有一个转换按钮。
- en: '`Fig. 22.8`'
  id: totrans-282
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`图 22.8`'
- en: '`Kelvin to Celsius converter`'
  id: totrans-283
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Kelvin to Celsius converter`'
- en: 与前面的部分相比，这一次我们在调用按钮构造方法`Button()`时使用了`command`选项来添加菜单项`add_command()`。`command`选项被赋值为一个函数，称为`event
    handler`或`callback function`，每当用户触发该控件时，该函数会被自动调用。例如，如果我们的“Convert”按钮被点击，`convert()`函数会被自动调用。我们在程序中较早之前定义了`convert()`函数（函数定义必须在赋值给`command`选项之前）；它简单地执行转换并在`lb_result`标签上打印结果。注意，在将事件处理函数分配给`command`选项时，函数名后面没有指定圆括号。这是因为`command`选项仅仅传递函数`object`；你会记得在Python中，函数也是对象——只有在定义函数（如你将看到的）或调用函数时，我们才需要包括圆括号，而不是当我们指的是函数对象本身时。
  id: totrans-284
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与前面的部分相比，这一次我们在调用按钮构造方法`Button()`时使用了`command`选项来添加菜单项`add_command()`。`command`选项被赋值为一个函数，称为`事件处理程序`或`回调函数`，每当用户触发该控件时，该函数会被自动调用。例如，如果我们的“转换”按钮被点击，`convert()`函数会被自动调用。我们在程序中较早之前定义了`convert()`函数（函数定义必须在赋值给`command`选项之前）；它简单地执行转换并在`lb_result`标签上打印结果。注意，在将事件处理函数分配给`command`选项时，函数名后面没有指定圆括号。这是因为`command`选项仅仅传递函数`对象`；你会记得在Python中，函数也是对象——只有在定义函数（如你将看到的）或调用函数时，我们才需要包括圆括号，而不是当我们指的是函数对象本身时。
- en: 'Binding Event Handlers `tkinter` knows another, much more powerful way to react
    to events. This is done with the help of the widget method `bind()`. With the
    statement `bt_convert.bind(''<button-1>'', convert)` we could have achieved the
    same effect as with the `command` option in the `Button()` constructor above.
    The `bind(event, eventhandler_function)` method binds an event handler function
    to an event. Henceforth, our event processing `mainloop()` watches to see if the
    event is triggered and calls the event handler function if it is. The string `''<Button-1>''`
    represents the event that the left/primary mouse button (“Button 1”) is pressed
    (the right mouse button, by the way, would be `''<Button-3>''`, `''<Button-2>''`
    the middle mouse button). Besides these button events, there are a variety of
    such events to which we can bind event handlers; here are some examples:'
  id: totrans-285
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 绑定事件处理程序 `tkinter` 知道另一种更强大的方式来响应事件。这是通过使用小部件方法 `bind()` 来实现的。通过语句 `bt_convert.bind('<button-1>',
    convert)`，我们本可以实现与上面`Button()`构造器中的 `command` 选项相同的效果。`bind(event, eventhandler_function)`方法将事件处理函数绑定到一个事件。因此，从此之后，我们的事件处理`mainloop()`会监视是否触发事件，并在事件发生时调用事件处理函数。字符串`'<Button-1>'`表示按下了左键/主要鼠标按钮（顺便提一下，右键鼠标按钮是`'<Button-3>'`，中间按钮是`'<Button-2>'`）。除了这些按钮事件外，还有多种事件可以绑定事件处理程序；以下是一些示例：
- en: '`<DoubleButton-1>`: Double click with the left mouse button.'
  id: totrans-286
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`<DoubleButton-1>`：左键双击。'
- en: '`<Enter>` and `<Leave>`: The user has entered the area of the control with
    the mouse pointer or the mouse pointer has left the area of the control.'
  id: totrans-287
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`<Enter>` 和 `<Leave>`：用户将鼠标指针移入或移出控件区域。'
- en: '`a`, `b`, `c`, ...: The respective letter was pressed.'
  id: totrans-288
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`a`，`b`，`c`，...：按下了相应的字母键。'
- en: '`<Key>`: `Any` letter was pressed.'
  id: totrans-289
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`<Key>`：按下了任意字母键。'
- en: '`<F1>`, ...: The respective function key was triggered.'
  id: totrans-290
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`<F1>`，...：触发了相应的功能键。'
- en: '`<Escape>`, `<BackSpace>` (remove), `<Delete>`, `<Tab>` (tabulator), `<Return>`
    (Return or Enter), `<Shift_L>` (Shift), `<Control_L>` (Ctrl), `<Alt_L>` (Alt),
    `<End>`, `<Home>`, `<Left>` (left arrow), `<Up>` (Up arrow), `<Right>` (Right
    arrow), `<Down>` (Down arrow), `<Print>`, `<Insert>`: The respective special key
    was pressed.'
  id: totrans-291
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`<Escape>`，`<BackSpace>`（删除），`<Delete>`，`<Tab>`（制表符），`<Return>`（回车或回车键），`<Shift_L>`（Shift），`<Control_L>`（Ctrl），`<Alt_L>`（Alt），`<End>`，`<Home>`，`<Left>`（左箭头），`<Up>`（上箭头），`<Right>`（右箭头），`<Down>`（下箭头），`<Print>`，`<Insert>`：按下了相应的特殊键。'
- en: 'Key combinations can also be represented with this method: If, for example,
    you want to bind a function to the event that `<CTRL>` and `S` were pressed simultaneously,
    you can simply specify `''<Control_L>S''` as the event.'
  id: totrans-292
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 键盘组合也可以通过这种方式表示：例如，如果你想绑定一个函数到同时按下`<CTRL>`和`S`的事件，你只需要指定`'<Control_L>S'`作为事件。
- en: 'Let’s take a closer look at the event handlers that we bind to an event with
    `bind()`. These functions are automatically passed an argument of type `Event`.
    Accordingly, we have to adapt our previous event handlers, which we assigned to
    the `command` option of our button, for example, because these event handlers
    do not require any argument. The change is marginal, but avoids a runtime error:'
  id: totrans-293
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们使用`bind()`绑定到事件的事件处理程序。这些函数会自动传递一个`Event`类型的参数。因此，我们需要调整之前为按钮的`command`选项分配的事件处理程序，例如，因为这些事件处理程序不需要任何参数。这个变化很小，但可以避免运行时错误：
- en: '`def` convert(ev = `None`):`lb_result[''text'']` = ''Conversion result: ''
    `+` str(round(float(`en_kelvin.get()`) - 273.15, 2)) `+` '' °C.'''
  id: totrans-294
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`def` convert(ev = `None`):`lb_result[''text'']` = ''转换结果: '' `+` str(round(float(`en_kelvin.get()`)
    - 273.15, 2)) `+` '' °C.'''
- en: We don’t need to do anything with the `Event` object `ev` but the event handler
    function must provide the argument. By giving the argument a default value (namely
    `None`), we also make the function callable for the `command` option of our menu
    item “Convert”, because it calls the event handler `without` an argument. So,
    the event handler has to cope with being called with an argument as well as with
    the argument being omitted.
  id: totrans-295
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们不需要对`Event`对象`ev`做任何处理，但事件处理程序函数必须提供这个参数。通过为参数提供默认值（即`None`），我们还使得该函数可以用于菜单项“转换”的`command`选项，因为它在调用时不会传递参数。所以，事件处理程序必须能够处理在有参数和没有参数两种情况下被调用的情况。
- en: 'But what is the content of this event object? The event object provides some
    information about the event, especially:'
  id: totrans-296
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 那么，这个事件对象的内容是什么呢？事件对象提供了一些关于事件的信息，特别是：
- en: '`x`, `y`：鼠标位置（相对于窗口左上角）触发事件的位置（对于点击事件特别重要）。'
  id: totrans-297
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`x`, `y`：鼠标位置（相对于窗口左上角）触发事件的位置（对于点击事件特别重要）。'
- en: '`widget`：触发事件的小部件。'
  id: totrans-298
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`widget`：触发事件的小部件。'
- en: '`char`：被按下的字符键（对于`<Key>`事件尤其重要）。'
  id: totrans-299
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`char`：被按下的字符键（对于`<Key>`事件尤其重要）。'
- en: 顺便提一下：您还可以直接将事件绑定到应用程序窗口，在我们的案例中是`Tk`对象`win`。如果某个小部件触发了事件，系统会首先自动检查该小部件是否绑定了事件处理程序。如果没有，则会检查“下一个更高”的对象，在我们的案例中是应用程序窗口，是否有此事件的事件处理程序。从这个意义上说，事件处理程序的存在是从“具体到一般”进行检查的；事件处理程序形成了一种层级结构。
  id: totrans-300
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 顺便提一下：您还可以直接将事件绑定到应用程序窗口，在我们的案例中是`Tk`对象`win`。如果某个小部件触发了事件，系统会首先自动检查该小部件是否绑定了事件处理程序。如果没有，则会检查“下一个更高”的对象，在我们的案例中是应用程序窗口，是否有此事件的事件处理程序。从这个意义上说，事件处理程序的存在是从“具体到一般”进行检查的；事件处理程序形成了一种层级结构。
- en: 22.2.6 示例：计算器应用程序
  id: totrans-301
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 22.2.6 示例：计算器应用程序
- en: 在本节中，我们将使用`tkinter`开发一个简单的计算器。计算器应能处理四种基本算术运算，并允许将计算结果复制到剪贴板。您可以在◘图`[22.9](#Fig9)`中查看结果。![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig9_HTML.jpg)
  id: totrans-302
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`tkinter`开发一个简单的计算器。计算器应能处理四种基本算术运算，并允许将计算结果复制到剪贴板。您可以在◘图`[22.9](#Fig9)`中查看结果。![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig9_HTML.jpg)
- en: 一个计算器应用程序窗口的截图。下面是一个输入框，数字为`96.54`，并有一个数字键盘和数学运算符。
  id: totrans-303
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个计算器应用程序窗口的截图。下面是一个输入框，数字为`96.54`，并有一个数字键盘和数学运算符。
- en: 图`22.9`
  id: totrans-304
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图`22.9`
- en: 计算器应用程序的界面
  id: totrans-305
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 计算器应用程序的界面
- en: 现在让我们逐步查看代码：
  id: totrans-306
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在让我们逐步查看代码：
- en: '1`from`tkinter`import`2`from`tkinter.font`import`3`from`functools`import`456`#
    Define eventhandler functions for buttons`7`def`digit_operator_press(digit_operator):`8`display[''text'']
    = display[''text''] + digit_operator`91011`def`delete_press():`12`display[''text'']
    = ''''`131415`def`copy_press():`16`win.clipboard_clear()`17`win.clipboard_append(display[''text''])`181920`def`plusminus_press():`21`display[''text'']
    = ''-'' + display[''text'']`222324`def`equal_press():`25`display[''text''] = str(eval(display[''text'']))`262728`#
    Define eventhandler for <ENTER> key`29`def`enter_press(ev):`30`equal_press()`313233`#
    Create application window`34`win = Tk()`35`win[''background''] = ''#000000''`36`win.title(''Calculator'')`37`win.geometry(''268x470'')`38`win.resizable(height=False,
    width=False)`3940`# Define fonts for button and display`41`digit_font = Font(family
    = ''Arial'', size = 18)`42`display_font = Font(family = ''Arial'', size = 24,`43`weight
    = ''bold'')`4445`# Create the display`46`display = Label(text = '''',`47`background
    = ''#000000'',`48`foreground = ''#00FF00'')`49`display[''width''] = 1350`display[''font'']
    = display_font`51`display[''height''] = 252`display[''anchor''] = ''e''`5354`#
    Define buttons`55`delete_op = Button(win,`56`text = ''Delete'',`57`width = 9,`58`height
    = 1,`59`font = digit_font,`60`foreground = ''#FFFFFF'',`61`background = ''#4C4E4F'',`62`command
    = delete_press)`63`plusminus_op = Button(win,`64`text = ''+/-'',`65`width = 4,`66`height
    = 1,`67`font = digit_font,`68`foreground = ''#FFFFFF'',`69`background = ''#4C4E4F'',`70`command
    = plusminus_press)`71`copy_op = Button(win,`72`text = ''Copy'',`73`width = 4,`74`height
    = 1,`75`font = digit_font,`76`foreground = ''#FFFFFF'',`77`background = ''#4C4E4F'',`78`command
    = copy_press)`79`digit1 = Button(win,`80`text = ''1'',`81`width = 4,`82`height
    = 2,`83`font = digit_font,`84`command = partial(digit_operator_press,''1''))`85`digit2
    = Button(win,`86`text = ''2'',`87`width = 4,`88`height = 2,`89`font = digit_font,`90`command
    = partial(digit_operator_press, ''2''))`91`digit3 = Button(win,`92`text = ''3'',`93`width
    = 4,`94`height = 2,`95`font = digit_font,`96`command = partial(digit_operator_press,
    ''3''))`97`digit4 = Button(win,`98`text = ''4'',`99`width = 4,`100`height = 2,`101`font
    = digit_font,`102`command = partial(digit_operator_press, ''4''))`103`digit5 =
    Button(win,`104`text = ''5'',`105`width = 4,`106`height = 2,`107`font = digit_font,`108`command
    = partial(digit_operator_press, ''5''))`109`digit6 = Button(win,`110`text = ''6'',`111`width
    = 4,`112`height = 2,`113`font = digit_font,`114`command = partial(digit_operator_press,
    ''6''))`115`digit7 = Button(win,`116`text = ''7'',`117`width = 4,`118`height =
    2,`119`font = digit_font,`120`command = partial(digit_operator_press, ''7''))`121`digit8
    = Button(win,`122`text = ''8'',`123`width = 4,`124`height = 2,`125`font = digit_font,`126`command
    = partial(digit_operator_press, ''8''))`127`digit9 = Button(win,`128`text = ''9'',`129`width
    = 4,`130`height = 2,`131`font = digit_font,`132`command = partial(digit_operator_press,
    ''9''))`133`digit0 = Button(win,`134`text = ''0'',`135`width = 9,`136`height =
    2,`137`font = digit_font,`138`command = partial(digit_operator_press, ''0''))`139`divide_op
    = Button(win,`140`text = ''/'',`141`width = 4,`142`height = 2,`143`font = digit_font,`144`foreground
    = ''#FFFFFF'',`145`background = ''#10a605'',`146`command = partial(digit_operator_press,
    '' / ''))`147`multiply_op = Button(win,`148`text = ''*'',`149`width = 4,`150`height
    = 2,`151`font = digit_font,`152`foreground = ''#FFFFFF'',`153`background = ''#10a605'',`154`command
    = partial(digit_operator_press, '' * ''))`155`minus_op = Button(win,`156`text
    = ''-'',`157`width = 4,`158`height = 2,`159`font = digit_font,`160`foreground
    = ''#FFFFFF'',`161`background = ''#10a605'',`162`command = partial(digit_operator_press,
    '' - ''))`163`plus_op = Button(win,`164`text = ''+'',`165`width = 4,`166`height
    = 2,`167`font = digit_font,`168`foreground = ''#FFFFFF'',`169`background = ''#10a605'',`170`command
    = partial(digit_operator_press,'' + ''))`171`point_op = Button(win,`172`text =
    '','',`173`width = 4,`174`height = 2,`175`font = digit_font,`176`command = partial(digit_operator_press,
    ''.''))`177`equal_op = Button(win,`178`text = ''='',`179`width = 10,`180`height
    = 1,`181`font = digit_font,`182`foreground = ''#FFFFFF'',`183`background = ''#0570A6'',`184`command
    = equal_press)`185186`# Define eventhandler for Enter key`187`win.bind(''<Return>'',
    enter_press)`188189`# Place buttons on interface`190`display.grid(row = 0, column
    = 0, columnspan = 5,`191`sticky = ''news'')`192`delete_op.grid(row = 1, column
    = 0, columnspan = 2,`193`sticky = ''news'')`194`plusminus_op.grid(row = 1, column
    = 2, sticky = ''news'')`195`copy_op.grid(row = 1, column = 4, sticky = ''news'')`196`digit1.grid(row
    = 2, column = 0, sticky = ''news'')`197`digit2.grid(row = 2, column = 1, sticky
    = ''news'')`198`digit3.grid(row = 2, column = 2, sticky = ''news'')`199`digit4.grid(row
    = 3, column = 0, sticky = ''news'')`200`digit5.grid(row = 3, column = 1, sticky
    = ''news'')`201`digit6.grid(row = 3, column = 2, sticky = ''news'')`202`digit7.grid(row
    = 4, column = 0, sticky = ''news'')`203`digit8.grid(row = 4, column = 1, sticky
    = ''news'')`204`digit9.grid(row = 4, column = 2, sticky = ''news'')`205`digit0.grid(row
    = 5, column = 0, columnspan = 2,`206`sticky = ''news'')`207`point_op.grid(row
    = 5, column = 2, sticky = ''news'')`208`divide_op.grid(row = 2, column = 4, sticky
    = ''news'')`209`multiply_op.grid(row = 3, column = 4, sticky = ''news'')`210`minus_op.grid(row
    = 4, column = 4, sticky = ''news'')`211`plus_op.grid(row = 5, column = 4, sticky
    = ''news'')`212`equal_op.grid(row = 6, column = 0, columnspan = 5,`213`sticky
    = ''news'')`214215`# Event loop`216`win.mainloop()`Lines 1–3: Import'
  id: totrans-307
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 1`from`tkinter`import`2`from`tkinter.font`import`3`from`functools`import`456`#
    定义按钮的事件处理函数`7`def`digit_operator_press(digit_operator):`8`display['text'] = display['text']
    + digit_operator`91011`def`delete_press():`12`display['text'] = ''`131415`def`copy_press():`16`win.clipboard_clear()`17`win.clipboard_append(display['text'])`181920`def`plusminus_press():`21`display['text']
    = '-' + display['text']`222324`def`equal_press():`25`display['text'] = str(eval(display['text']))`262728`#
    定义<ENTER>键的事件处理函数`29`def`enter_press(ev):`30`equal_press()`313233`# 创建应用窗口`34`win
    = Tk()`35`win['background'] = '#000000'`36`win.title('计算器')`37`win.geometry('268x470')`38`win.resizable(height=False,
    width=False)`3940`# 定义按钮和显示器的字体`41`digit_font = Font(family = 'Arial', size =
    18)`42`display_font = Font(family = 'Arial', size = 24,`43`weight = 'bold')`4445`#
    创建显示器`46`display = Label(text = '',`47`background = '#000000',`48`foreground =
    '#00FF00')`49`display['width'] = 1350`display['font'] = display_font`51`display['height']
    = 252`display['anchor'] = 'e'`5354`# 定义按钮`55`delete_op = Button(win,`56`text =
    '删除',`57`width = 9,`58`height = 1,`59`font = digit_font,`60`foreground = '#FFFFFF',`61`background
    = '#4C4E4F',`62`command = delete_press)`63`plusminus_op = Button(win,`64`text
    = '+/-',`65`width = 4,`66`height = 1,`67`font = digit_font,`68`foreground = '#FFFFFF',`69`background
    = '#4C4E4F',`70`command = plusminus_press)`71`copy_op = Button(win,`72`text =
    '复制',`73`width = 4,`74`height = 1,`75`font = digit_font,`76`foreground = '#FFFFFF',`77`background
    = '#4C4E4F',`78`command = copy_press)`79`digit1 = Button(win,`80`text = '1',`81`width
    = 4,`82`height = 2,`83`font = digit_font,`84`command = partial(digit_operator_press,'1'))`85`digit2
    = Button(win,`86`text = '2',`87`width = 4,`88`height = 2,`89`font = digit_font,`90`command
    = partial(digit_operator_press, '2'))`91`digit3 = Button(win,`92`text = '3',`93`width
    = 4,`94`height = 2,`95`font = digit_font,`96`command = partial(digit_operator_press,
    '3'))`97`digit4 = Button(win,`98`text = '4',`99`width = 4,`100`height = 2,`101`font
    = digit_font,`102`command = partial(digit_operator_press, '4'))`103`digit5 = Button(win,`104`text
    = '5',`105`width = 4,`106`height = 2,`107`font = digit_font,`108`command = partial(digit_operator_press,
    '5'))`109`digit6 = Button(win,`110`text = '6',`111`width = 4,`112`height = 2,`113`font
    = digit_font,`114`command = partial(digit_operator_press, '6'))`115`digit7 = Button(win,`116`text
    = '7',`117`width = 4,`118`height = 2,`119`font = digit_font,`120`command = partial(digit_operator_press,
    '7'))`121`digit8 = Button(win,`122`text = '8',`123`width = 4,`124`height = 2,`125`font
    = digit_font,`126`command = partial(digit_operator_press, '8'))`127`digit9 = Button(win,`128`text
    = '9',`129`width = 4,`130`height = 2,`131`font = digit_font,`132`command = partial(digit_operator_press,
    '9'))`133`digit0 = Button(win,`134`text = '0',`135`width = 9,`136`height = 2,`137`font
    = digit_font,`138`command = partial(digit_operator_press, '0'))`139`divide_op
    = Button(win,`140`text = '/',`141`width = 4,`142`height = 2,`143`font = digit_font,`144`foreground
    = '#FFFFFF',`145`background = '#10a605',`146`command = partial(digit_operator_press,
    ' / '))`147`multiply_op = Button(win,`148`text = '*',`149`width = 4,`150`height
    = 2,`151`font = digit_font,`152`foreground = '#FFFFFF',`153`background = '#10a605',`154`command
    = partial(digit_operator_press, ' * '))`155`minus_op = Button(win,`156`text =
    '-',`157`width = 4,`158`height = 2,`159`font = digit_font,`160`foreground = '#FFFFFF',`161`background
    = '#10a605',`162`command = partial(digit_operator_press, ' - '))`163`plus_op =
    Button(win,`164`text = '+',`165`width = 4,`166`height = 2,`167`font = digit_font,`168`foreground
    = '#FFFFFF',`169`background = '#10a605',`170`command = partial(digit_operator_press,'
    + '))`171`point_op = Button(win,`172`text = ',',`173`width = 4,`174`height = 2,`175`font
    = digit_font,`176`command = partial(digit_operator_press, '.'))`177`equal_op =
    Button(win,`178`text = '=',`179`width = 10,`180`height = 1,`181`font = digit_font,`182`foreground
    = '#FFFFFF',`183`background = '#0570A6',`184`command = equal_press)`185186`# 定义回车键的事件处理函数`187`win.bind('<Return>',
    enter_press)`188189`# 将按钮放置到界面`190`display.grid(row = 0, column = 0, columnspan
    = 5,`191`sticky = 'news')`192`delete_op.grid(row = 1, column = 0, columnspan =
    2,`193`sticky = 'news')`194`plusminus_op.grid(row = 1, column = 2, sticky = 'news')`195`copy_op.grid(row
    = 1, column = 4, sticky = 'news')`196`digit1.grid(row = 2, column = 0, sticky
    = 'news')`197`digit2.grid(row = 2, column = 1, sticky = 'news')`198`digit3.grid(row
    = 2, column = 2, sticky = 'news')`199`digit4.grid(row = 3, column = 0, sticky
    = 'news')`200`digit5.grid(row = 3, column = 1, sticky = 'news')`201`digit6.grid(row
    = 3, column = 2, sticky = 'news')`202`digit7.grid(row = 4, column = 0, sticky
    = 'news')`203`digit8.grid(row = 4, column = 1, sticky = 'news')`204`digit9.grid(row
    = 4, column = 2, sticky = 'news')`205`digit0.grid(row = 5, column = 0, columnspan
    = 2,`206`sticky = 'news')`207`point_op.grid(row = 5, column = 2, sticky = 'news')`208`divide_op.grid(row
    = 2, column = 4, sticky = 'news')`209`multiply_op.grid(row = 3, column = 4, sticky
    = 'news')`210`minus_op.grid(row = 4, column = 4, sticky = 'news')`211`plus_op.grid(row
    = 5, column = 4, sticky = 'news')`212`equal_op.grid(row = 6, column = 0, columnspan
    = 5,`213`sticky = 'news')`214215`
- en: We first import all classes from the `tkinter` module. Furthermore, the “display”
    of our calculator will use a special font, so we also import everything from the
    `font` module. We need the last import statement to make the event functions that
    are supposed to react to the user’s digit input a bit simpler. More about this
    shortly.
  id: totrans-308
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们首先从`tkinter`模块导入所有类。此外，我们的计算器的“显示”部分将使用特殊字体，因此我们还从`font`模块导入所有内容。我们需要最后一个导入语句，以简化事件函数，这些函数将响应用户的数字输入。稍后会详细讲解。
- en: 'Lines 6–30: Event Handler Functions for Buttons'
  id: totrans-309
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第6至30行：按钮的事件处理函数
- en: These are the event functions that react to the different user actions. We’ll
    go into these functions in a little more detail at the end, but first we want
    to look at the interface. With knowledge of the interface, it is also easier to
    understand how the event handlers work.
  id: totrans-310
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这些是响应不同用户操作的事件函数。我们将在最后详细介绍这些函数，但首先我们想先看一下界面。了解界面后，也更容易理解事件处理函数是如何工作的。
- en: 'Lines 33–38: Window of the Application'
  id: totrans-311
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第33至38行：应用程序的窗口
- en: Our calculator should have a black background and a fixed window size that cannot
    be changed by the user.
  id: totrans-312
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们的计算器应该有一个黑色背景，并且窗口大小是固定的，用户不能更改。
- en: 'Lines 40–52: Fonts and Display'
  id: totrans-313
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第40至52行：字体和显示
- en: Next, we define two fonts, `digits_font` for the digits on the calculator keys,
    and `display_font` for the display on the calculator. The display itself has a
    green foreground and a black background color. With `display['anchor'] = 'e'`
    we align its content “east”，i.e., right aligned.
  id: totrans-314
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，我们定义了两种字体，`digits_font`用于计算器键上的数字，`display_font`用于计算器的显示部分。显示本身具有绿色前景和黑色背景色。通过`display['anchor']
    = 'e'`，我们将其内容对齐到“东边”，即右对齐。
- en: 'Lines 54–184: Create the Buttons'
  id: totrans-315
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第54至184行：创建按钮
- en: Next, we create the buttons for our window `win`，which are characterized by
    a number of properties, namely their label (`text`), their `width` and `height`
    in text characters, the `font`，the `foreground` and `background` color, and the
    event handler (`command`) that is called when the user clicks on the button.
  id: totrans-316
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，我们为窗口`win`创建按钮，这些按钮具有多个属性，具体包括它们的标签（`text`）、宽度和高度（以文本字符为单位）、字体（`font`）、前景色（`foreground`）和背景色（`background`），以及用户点击按钮时调用的事件处理函数（`command`）。
- en: For the event handlers, we use a little trick to avoid having to write a separate
    event handler for each of the 10 digits and each arithmetic operator. We have
    defined only one event handler named `digit_operator_press()`，which we call with
    one argument, namely the respective digit or the respective operator. But the
    option `command` of the `tkinter button` object must be passed a function object,
    not a call to a function with arguments. Therefore, we use the `partial` function
    from the `functools` module to create a function object in which the argument
    is already “baked in”. Since the return value of `partial()` is an object not
    unlike the `function` object, but which already contains the argument value, we
    can use this return value as the value for the `command` option of our buttons.
  id: totrans-317
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 对于事件处理函数，我们使用一个小技巧，避免为每个数字和每个运算符编写单独的事件处理函数。我们只定义了一个事件处理函数，命名为`digit_operator_press()`，并传入一个参数，即相应的数字或运算符。但`tkinter
    button`对象的`command`选项必须传入一个函数对象，而不能传入带参数的函数调用。因此，我们使用`functools`模块中的`partial`函数来创建一个函数对象，其中参数已经“预先嵌入”。由于`partial()`的返回值是一个类似于`function`对象的对象，但它已经包含了参数值，因此我们可以将这个返回值作为按钮的`command`选项的值。
- en: 'Lines 186–187: Event Handler for the `<ENTER>` Key'
  id: totrans-318
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第186至187行：`<ENTER>`键的事件处理函数
- en: To make it possible to trigger the computation not only by clicking the equals
    sign button on the interface, but also by pressing `<ENTER>` on the keyboard,
    we bind an event handler (lines 29–30) to the event of pressing `<ENTER>`，which
    does nothing but call the event handler that is triggered when the equals sign
    button is pressed (lines 24–25). We still need to separate the two event handlers,
    because the event handler that processes the button press is passed an event object
    as an argument by default, which we must accept even if we don’t process it at
    all.
  id: totrans-319
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为了使得不仅通过点击界面上的等号按钮触发计算，还能通过按键盘上的`<ENTER>`键触发计算，我们将一个事件处理函数（第29至30行）绑定到按下`<ENTER>`键的事件上，函数的作用仅仅是调用当点击等号按钮时触发的事件处理函数（第24至25行）。我们仍然需要分开这两个事件处理函数，因为处理按钮点击的事件处理函数默认会接收一个事件对象作为参数，即使我们不处理它，也必须接受这个参数。
- en: 'With that in mind, let’s take a quick look at the other event handlers:'
  id: totrans-320
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 考虑到这些，让我们快速看看其他的事件处理函数：
- en: '`digit_operator_press()`（第6–8行）：事件处理程序将被点击的数字或算术运算符作为参数传递。按下的按钮的值简单地附加到显示区域中现有的内容上。'
  id: totrans-321
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`digit_operator_press()`（第6–8行）：事件处理程序将被点击的数字或算术运算符作为参数传递。按下的按钮的值简单地附加到显示区域中现有的内容上。'
- en: '`delete_press()`（第11–12行）：清空显示区域的内容。'
  id: totrans-322
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`delete_press()`（第11–12行）：清空显示区域的内容。'
- en: '`copy_press()`（第15–17行）：首先清空剪贴板，然后将显示区域的当前内容追加到剪贴板中。`clipboard_clear()`和`clipboard_append()`这两个函数用于此目的，它们都由`Tk`类方便地提供，因此也可以用于我们的窗口对象`win`。'
  id: totrans-323
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`copy_press()`（第15–17行）：首先清空剪贴板，然后将显示区域的当前内容追加到剪贴板中。`clipboard_clear()`和`clipboard_append()`这两个函数用于此目的，它们都由`Tk`类方便地提供，因此也可以用于我们的窗口对象`win`。'
- en: '`plusminus_press()`（第20–21行）：当按下加减按钮时，我们简单地在当前显示内容前面添加一个减号。严格来说，我们应该检查是否已经存在一个减号，然后将其移除。但就像处理其他输入一样（例如，我们不检查用户是否连续输入两个运算符），我们在这一点上让自己轻松一些，并依赖用户的常识。'
  id: totrans-324
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`plusminus_press()`（第20–21行）：当按下加减按钮时，我们简单地在当前显示内容前面添加一个减号。严格来说，我们应该检查是否已经存在一个减号，然后将其移除。但就像处理其他输入一样（例如，我们不检查用户是否连续输入两个运算符），我们在这一点上让自己轻松一些，并依赖用户的常识。'
- en: '`equal_press()`（第24–25行）：这是之前提到的事件处理程序，当用户请求计算结果时被调用。在这里，我们使用`eval()`函数，它会评估一个Python表达式并返回其结果。在我们的案例中，Python表达式就是用户输入并显示在计算器显示区域的数字和运算符的序列。然而，`eval()`也可以用于执行作为字符串参数传递的完全任意的Python代码。'
  id: totrans-325
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`equal_press()`（第24–25行）：这是之前提到的事件处理程序，当用户请求计算结果时被调用。在这里，我们使用`eval()`函数，它会评估一个Python表达式并返回其结果。在我们的案例中，Python表达式就是用户输入并显示在计算器显示区域的数字和运算符的序列。然而，`eval()`也可以用于执行作为字符串参数传递的完全任意的Python代码。'
- en: 第189–213行：将按钮放置在界面上。
  id: totrans-326
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第189–213行：将按钮放置在界面上。
- en: 现在我们只需要将显示区域和按钮放置在界面上。为此，我们需要`grid`几何管理器，因此我们使用`grid()`方法来为各个控件指定它们在网格中的位置，具体通过指定它们的`row`和`column`号。通过`columnspan`选项，我们可以使某些元素横向扩展跨越多个网格单元，例如显示区域。通过`sticky`选项的值`news`（`north
    + east + west + south`），我们指定各自网格单元中的元素应完全扩展，即填充整个单元。
  id: totrans-327
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在我们只需要将显示区域和按钮放置在界面上。为此，我们需要`grid`几何管理器，因此我们使用`grid()`方法来为各个控件指定它们在网格中的位置，具体通过指定它们的`row`和`column`号。通过`columnspan`选项，我们可以使某些元素横向扩展跨越多个网格单元，例如显示区域。通过`sticky`选项的值`news`（`north
    + east + west + south`），我们指定各自网格单元中的元素应完全扩展，即填充整个单元。
- en: 第215–216行：事件循环。
  id: totrans-328
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第215–216行：事件循环。
- en: 使用`mainloop()`我们开始处理计算器的事件。从现在起，用户界面会通过调用相应的事件处理程序来响应用户的输入。
  id: totrans-329
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用`mainloop()`我们开始处理计算器的事件。从现在起，用户界面会通过调用相应的事件处理程序来响应用户的输入。
- en: 22.3 处理文件
  id: totrans-330
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 22.3 处理文件
- en: 在Python中处理文件非常简单。这个过程分为三个步骤，和大多数其他编程语言类似：
  id: totrans-331
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在Python中处理文件非常简单。这个过程分为三个步骤，和大多数其他编程语言类似：
- en: '1.'
  id: totrans-332
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '1.'
- en: 文件被打开（可能在第一时间被创建）。
  id: totrans-333
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 文件被打开（可能在第一时间被创建）。
- en: '2.'
  id: totrans-334
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '2.'
- en: 文件被处理（它被读取、写入或追加）。
  id: totrans-335
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 文件被处理（它被读取、写入或追加）。
- en: '3.'
  id: totrans-336
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '3.'
- en: 文件在所有工作完成后关闭。
  id: totrans-337
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 文件在所有工作完成后关闭。
- en: 'Opening FilesA file is represented by a `file object`。We create such a file
    object with the help of the standard Python function `open(filepath, mode)`。The
    argument `mode` describes the editing mode in which the file is to be opened。Possible
    values of the mode are:'
  id: totrans-338
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 打开文件：文件由`文件对象`表示。我们使用标准的Python函数`open(filepath, mode)`来创建文件对象。参数`mode`描述了文件要以何种编辑模式打开。模式的可能值包括：
- en: '`"w"`: The file is opened for `writing`。The file pointer is set to the beginning
    of the file。Any existing contents of the file are completely replaced。If the file
    does not yet exist, it will be newly created。Reading from the file in this mode
    is not possible。'
  id: totrans-339
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`"w"`: 文件以`写入`模式打开。文件指针被设置到文件的开始位置。文件的现有内容将被完全替换。如果文件不存在，它将被新建。此模式下无法从文件读取内容。'
- en: '`"a"`: The file is opened for `appending`。The file pointer is placed at the
    end of the file。Contents that are written to the file are appended to it。Reading
    from the file is not possible in this mode。'
  id: totrans-340
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`"a"`: 文件以`追加`模式打开。文件指针被放置在文件的末尾。写入到文件的内容将被附加到文件末尾。此模式下无法从文件读取内容。'
- en: '`"r"`: The file is opened for `reading`。The file pointer is set to the beginning
    of the file。Writing to the file is not possible in this mode。'
  id: totrans-341
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`"r"`: 文件以`读取`模式打开。文件指针被设置到文件的开始位置。此模式下无法向文件写入内容。'
- en: '`"r+"`: The file is opened for reading `and` writing。'
  id: totrans-342
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`"r+"`: 文件以`读取`和`写入`模式打开。'
- en: 'Note that if you are working on a Windows system, you must `escape` the backslashes
    that separate the path components in the path specification with another backslash,
    otherwise Python will regard them as an attempt to escape the `following character`
    and thus assign a special control function to it (if you are no longer familiar
    with escaping, go back and review ► Sect. [11.​2.​2](474412_1_En_11_Chapter.xhtml#Sec4))。For
    example, if we wanted to open the file `test.txt` in the directory `C:\Programming`
    for writing, we would first have the function `open()` create a corresponding
    file object (which we call `file` here for simplicity): `file = open("C:\\Programming\\test.txt",
    "w")`'
  id: totrans-343
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 注意，如果你在Windows系统上工作，你必须用另一个反斜杠来`转义`路径中分隔符的反斜杠，否则Python会将它们视为对`后续字符`的转义尝试，并为其分配特殊的控制功能（如果你不再熟悉转义，回去复习►第[11.2.2节](474412_1_En_11_Chapter.xhtml#Sec4)）。例如，如果我们想在`C:\Programming`目录中以写入模式打开`test.txt`文件，我们首先让`open()`函数创建一个相应的文件对象（为了简化起见，我们称之为`file`）：`file
    = open("C:\\Programming\\test.txt", "w")`
- en: 'This object has a number of properties that allow us to better understand its
    character: `file.name` gives us the file name as a full path specification, `file.mode`
    the mode in which we opened the file。Furthermore, whether the file is readable
    and/or writable can be determined with the methods `file.readable()` and `file.writable()`，which
    return a `bool` value each。'
  id: totrans-344
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 该对象具有许多属性，帮助我们更好地理解它的特征：`file.name` 返回文件的完整路径，`file.mode` 返回文件的打开模式。此外，可以使用
    `file.readable()` 和 `file.writable()` 方法来确定文件是否可读和/或可写，每个方法返回一个 `bool` 值。
- en: Editing the File
  id: totrans-345
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 编辑文件
- en: To `write` to the file, the file object provides the methods `write(text)` and
    `writelines(lines)`。
  id: totrans-346
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 要`写入`文件，文件对象提供了 `write(text)` 和 `writelines(lines)` 方法。
- en: '`write()` simply writes `a` string to the file, without a trailing newline
    unless `text` contains the escape sequence `\n` at the end (for example, `"This
    is a newline\n text"`)。'
  id: totrans-347
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`write()` 只是将`一个`字符串写入文件，除非 `text` 末尾包含换行符转义序列 `\n`（例如 `"This is a newline\n
    text"`），否则不会自动添加换行符。'
- en: '`writelines()`, in contrast, writes `several` strings that are passed as an
    array; the name of the function is somewhat misleading, because `writelines()`
    also does not write a newline at the end of each string。So, if you want a line
    break after each string, you have to add it yourself：'
  id: totrans-348
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 相比之下，`writelines()` 会写入`多个`作为数组传递的字符串；该函数名有些误导，因为 `writelines()` 也不会在每个字符串末尾写入换行符。因此，如果你希望每个字符串后面有换行符，你需要手动添加：
- en: '`lines = ["line 1\n", "line 2\n"]file.writelines(lines)`'
  id: totrans-349
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`lines = ["line 1\n", "line 2\n"] file.writelines(lines)`'
- en: The write methods each return the number of characters written as a function
    value。
  id: totrans-350
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 每个写入方法都会返回写入的字符数作为返回值。
- en: 'To *read* from a file the functions `read()`， `readline()` and `readlines()`
    are available. `read()` reads the *entire* file contents and returns it as a string.
    With an optional argument, a *certain number of characters* (measured from the
    current position of the file pointer) can be read. The file pointer starts at
    the beginning of the file and moves accordingly with each read operation. Consider
    the following example file:'
  id: totrans-351
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 要从文件中*读取*，可以使用 `read()`、`readline()` 和 `readlines()` 函数。`read()` 读取*整个*文件内容并将其作为字符串返回。通过一个可选参数，可以读取*一定数量的字符*（从文件指针当前位置开始计算）。文件指针从文件开头开始，并随着每次读取操作相应移动。请参见以下示例文件：
- en: Line number oneOne more lineLast line
  id: totrans-352
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第一行一行 还有一行 最后一行
- en: With `read(3)`， after opening the file (the file pointer is then at the beginning
    of the file)， we would first read the string `"Lin"`。 After that, the file pointer
    is on the `"e"` of `"line"`。 Another `read(19)` would then return the next 19
    characters, i.e. `"e number one\nOne mo"`。 Note that the line break also counts
    as a character, and as *exactly one* character (although it is represented as
    an escape sequence in the form `\n` with two characters). After this reread, the
    file pointer is now on `"r"` of `"more"`。
  id: totrans-353
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用 `read(3)`，在打开文件后（此时文件指针位于文件开头），我们首先会读取字符串 `"Lin"`。之后，文件指针位于 `"line"` 的 `"e"`
    上。接着，`read(19)` 将返回接下来的 19 个字符，即 `"e number one\nOne mo"`。请注意，换行符也算作一个字符，且是*正好一个*字符（尽管它在转义序列中表示为
    `\n`，由两个字符组成）。此时，重新读取后，文件指针位于 `"more"` 的 `"r"` 上。
- en: The `readline()` and `readlines()` functions proceed differently than `read()`;
    they read in one or more *lines* respectively. `readline()` always reads in exactly
    the next line, while `readlines()` reads in all lines or the number of lines passed
    as an optional argument, returning an *array of strings.* The `readline()` and
    `readlines(1)` method calls thus differ in that the result of the `readline()`
    call results in a `str` value, while `readlines()` returns an array, which in
    this case contains only a single string as an element.
  id: totrans-354
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`readline()` 和 `readlines()` 函数与 `read()` 的处理方式不同；它们分别读取一行或多行*内容*。`readline()`
    总是读取精确的下一行，而 `readlines()` 则读取所有行或传递的行数（作为可选参数），并返回一个*字符串数组*。因此，`readline()` 和
    `readlines(1)` 的方法调用有所不同，`readline()` 调用的结果是一个 `str` 值，而 `readlines()` 返回一个数组，在此案例中仅包含一个字符串元素。'
- en: If the file pointer is not at the beginning of a line, but in the middle of
    a line, as after the call to `read(3)` above, then `readline()` and `readlines()`
    read from the character on which the file pointer is currently located. The beginning
    of the line (in our example, the first three characters already read with `read()`)
    is then no longer read.
  id: totrans-355
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果文件指针不在行的开头，而是在行的中间（例如在上面调用 `read(3)` 后），那么 `readline()` 和 `readlines()` 将从文件指针当前位置的字符开始读取。此时，行的开头（在本例中是已经用
    `read()` 读取的前三个字符）将不再被读取。
- en: When reading, you can use `seek(*****characterindex*****)` to set the file pointer
    to the character specified by `characterindex`， counting from the beginning of
    the file. The current position of the file pointer is returned by the `tell()`
    method of the file object.
  id: totrans-356
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在读取时，你可以使用`seek(*****characterindex*****)`将文件指针设置到由`characterindex`指定的字符位置，计数从文件的开始处。文件对象的`tell()`方法返回文件指针的当前位置。
- en: 'By the way: If you open the file in `"r+"` mode (read *and* write), you can
    actually use the same file object for both operations. However, writing is always
    done at the end of the file, reading at the current position of the file pointer,
    which behaves the same way as when opening the file in `"r"` mode.'
  id: totrans-357
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 顺便提一句：如果你以`"r+"`模式（读 *和* 写）打开文件，实际上可以使用同一个文件对象进行这两项操作。然而，写入始终是在文件的末尾进行，读取则是在文件指针的当前位置进行，其行为与以`"r"`模式打开文件时相同。
- en: Close the File
  id: totrans-358
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 关闭文件
- en: 'After editing the file, close it with the `***file*****.close()` method. The
    file object will continue to exist, but its property `***file*****.closed` will
    now take the value `True`， indicating that the object is not available for reading
    or writing any more. However, since the file object still carries the path to
    the file as its `name` property, you can simply “reactivate” it:'
  id: totrans-359
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 编辑完文件后，用`***file*****.close()`方法关闭它。文件对象将继续存在，但其属性`***file*****.closed`将变为`True`，表示该对象不再可用于读写。然而，由于文件对象仍然携带文件路径作为其`name`属性，你可以简单地“重新激活”它：
- en: '`file = open(file.name, "r")` 22.2 [15 min]'
  id: totrans-360
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`file = open(file.name, "r")` 22.2 [15 min]'
- en: Write a program that queries the user for the name of a file (with its complete
    path). A certain percentage (specified by the user) of the file content is then
    to be displayed as a preview. Line breaks shall be removed from the preview display
    so that the display is as compact as possible.
  id: totrans-361
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 编写一个程序，要求用户输入文件的名称（包括完整路径）。然后，按用户指定的百分比显示文件内容的预览。预览显示中应删除换行符，使显示尽可能紧凑。
- en: '22.4 Exercise: Development of a Simple Text Editor'
  id: totrans-362
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 22.4 练习：开发一个简单的文本编辑器
- en: The following exercise combines many of the things you have learned in this
    chapter to develop a useful little application.
  id: totrans-363
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下练习结合了你在本章中学到的许多内容，用来开发一个有用的小应用。
- en: The task is to program a simple text editor with `tkinter`. This should allow
    you to create new files or open existing files, and then edit and save the files
    again, either under the current name or a new name. Also, the user should be able
    to copy text to the clipboard and paste it from the clipboard. The commands of
    the editor shall be selectable via a menu as well as via a button bar.
  id: totrans-364
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 任务是用`tkinter`编程开发一个简单的文本编辑器。该编辑器应允许你创建新文件或打开现有文件，然后编辑并保存文件，无论是以当前名称还是新名称保存。同时，用户应该能够将文本复制到剪贴板并从剪贴板粘贴。编辑器的命令应通过菜单或按钮栏选择。
- en: You will want to use the `ScrolledText` widget from the `tkinter` module `scrolledtext`.
    Therefore, make sure you include the line `from tkinter.scrolledtext import ScrolledText`
    in your imports even if you import the rest of the `tkinter` widgets with `from
    tkinter import *`.
  id: totrans-365
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你需要使用来自`tkinter`模块`scrolledtext`的小部件`ScrolledText`。因此，即使你使用`from tkinter import
    *`导入了`tkinter`模块的其他小部件，也请确保在导入中包含`from tkinter.scrolledtext import ScrolledText`这一行。
- en: Test your program extensively!
  id: totrans-366
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 充分测试你的程序！
- en: The estimated time to complete this task is 120 min. You should have a quiet
    space to focus on this piece of development work. If the task still seems too
    challenging, do not spend hours trying to develop the editor yourself, but read
    the code in the sample solution and try to understand it, at first without referring
    to the explanatory notes in the solution.
  id: totrans-367
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 完成此任务的预估时间为120分钟。你应该在一个安静的地方集中精力进行这项开发工作。如果任务仍然显得太具挑战性，不要花费几个小时尝试自己开发编辑器，而是阅读样本解决方案中的代码，先试着理解它，而不要参考解决方案中的解释性备注。
- en: 22.5 Summary
  id: totrans-368
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 22.5 总结
- en: In this chapter, we looked at how to input and output data via the console.
    We also looked at how graphical user interfaces can be implemented in Python to
    allow the user to interact with your program conveniently.
  id: totrans-369
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过控制台输入和输出数据。我们还研究了如何在Python中实现图形用户界面，以便用户能够方便地与程序进行交互。
- en: 'Be sure to take the following points from this chapter:'
  id: totrans-370
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 确保从本章中记住以下几点：
- en: In the Python console, you can always print objects using the built-in Python
    function `print(object)`.
  id: totrans-371
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 在Python控制台中，你可以使用内置的Python函数`print(object)`来打印对象。
- en: Information can be requested from the user using the `input(prompt)` method,
    which always returns the user input as a string (so the user input must be converted
    if necessary).
  id: totrans-372
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 可以使用`input(prompt)`方法向用户请求信息，该方法总是返回用户输入的字符串（因此如果需要，必须将用户输入转换为其他类型）。
- en: Graphical user interfaces (GUIs) can be easily implemented with the `tkinter`
    library, which is part of the standard Python package.
  id: totrans-373
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 图形用户界面（GUI）可以通过`tkinter`库轻松实现，`tkinter`是 Python 标准库的一部分。
- en: A `tkinter` program always consists of creating a `Tk` object using the constructor
    function of the same name, creating and configuring the controls (widgets), defining
    the arrangement of the controls (using a Geometry Manager) and starting event
    processing (method `mainloop()` of the `Tk` object).
  id: totrans-374
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 一个`tkinter`程序通常包含以下几个部分：使用同名构造函数创建一个`Tk`对象，创建和配置控件（小部件），定义控件的布局（使用几何管理器），并启动事件处理（`Tk`对象的`mainloop()`方法）。
- en: The most important controls (widgets) for graphical user interfaces in `tkinter`
    are `Button`, `Menu`, `Entry` (text input), `Label` (text display), `Checkbutton`
    (multiple selection of options), `Radiobutton` (single selection of options) and
    `Listbox` (list-like display of text entries with single or multiple selection).
  id: totrans-375
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`tkinter`图形用户界面中的最重要控件（小部件）包括`Button`（按钮）、`Menu`（菜单）、`Entry`（文本输入框）、`Label`（文本显示框）、`Checkbutton`（多选框）、`Radiobutton`（单选框）和`Listbox`（列表框，支持单选或多选文本条目）。'
- en: 'Important standard dialogs that can be used from within `tkinter` (more specifically,
    the `tkinter` module `filedialog`) are: `messagebox` (with several variants that
    differ in the displayed icons and buttons) for displaying text messages; and `askopenfilename()`
    and `asksaveasfilename()` for querying file paths when opening or saving files.'
  id: totrans-376
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`tkinter`（更具体地说，是`tkinter`模块的`filedialog`）提供了一些常用的标准对话框：`messagebox`（有多个变体，显示不同的图标和按钮）用于显示文本消息；`askopenfilename()`和`asksaveasfilename()`用于在打开或保存文件时查询文件路径。'
- en: The widgets are configured via options; some options (but not their values!)
    are common to almost all widgets (for example, the `background` color and the
    `font`), others are specific to the particular control.
  id: totrans-377
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 控件通过选项进行配置；一些选项（但不是它们的值！）几乎所有控件都有（例如，`background`颜色和`font`），而其他选项则是特定于某个控件的。
- en: All widgets have the `config(*****option*** **=** ***value*****, ...)` method,
    which can be used to set the values of the options. In addition, the options can
    be accessed in the form `widget['option']` as if they were a dictionary.
  id: totrans-378
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 所有控件都有`config(*****option*** **=** ***value*****, ...)`方法，可以用来设置选项的值。此外，这些选项也可以通过`widget['option']`的方式访问，就像访问字典一样。
- en: Widgets are arranged on the program surface with the help of a Geometry Manager;
    `tkinter` has three such arrangement tools with `pack` (arrange directly next
    to/below each other), `grid` (arrange along an imaginary grid) and `place` (arrange
    by specifying coordinates relative to a reference point), that can be called with
    the standard methods `pack()`, `grid()` and `place()` of each widget.
  id: totrans-379
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 控件通过几何管理器在程序界面上进行排列；`tkinter`有三个几何管理器：`pack`（将控件直接排列在彼此旁边或下方）、`grid`（沿着一个虚拟网格排列）和`place`（通过指定相对于参考点的坐标来排列），它们分别通过每个控件的`pack()`、`grid()`和`place()`方法调用。
- en: To read and write data from or to files, the file in question is first opened
    with the built-in Python function `open(*****filename*****, **mode**)`; this returns
    a `File` object.
  id: totrans-380
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 要从文件读取或写入数据，首先需要使用内置的 Python 函数`open(*****filename*****, **mode**)`打开文件；该函数返回一个`File`对象。
- en: Modes for editing files are `r` (read), `w` (write), `a` (append), and `r+`
    (read and write).
  id: totrans-381
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 编辑文件的模式有`r`（读取）、`w`（写入）、`a`（追加）和`r+`（读写）。
- en: The methods `read()` and `readlines()` as well as `write()` and `writelines()`
    of the `File` object can be used to read from or write to the file.
  id: totrans-382
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`File`对象的`read()`和`readlines()`方法以及`write()`和`writelines()`方法可以用来从文件中读取或写入数据。'
- en: The `close()` method of the `File` object closes the file again after processing
    is complete.
  id: totrans-383
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`File`对象的`close()`方法在处理完成后关闭文件。'
- en: 22.6 Solutions to the Exercises
  id: totrans-384
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 22.6 练习题解答
- en: 'Exercise 22.1 `# First option: Three print()-commands (each automatically #
    ending with \n) print(''First line'') print(''Second line'') print(''Third line'')
    # Second option: One string, lines separated by the \n escape # sequence. print(''First
    line\nSecond line\nThird line'') # Third option: Output of three string objects,
    using the \n # escape sequence as separator. print(''First line'', ''Second line'',
    ''Third line'', sep = ''\n'')` Exercise 22.2'
  id: totrans-385
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '练习 22.1 `# 第一个选项：三条 print() 命令（每条命令自动以 \n 结尾） print(''第一行'') print(''第二行'')
    print(''第三行'') # 第二个选项：一个字符串，行之间由 \n 转义符分隔 print(''第一行\n第二行\n第三行'') # 第三个选项：输出三个字符串对象，使用
    \n 转义符作为分隔符 print(''第一行'', ''第二行'', ''第三行'', sep = ''\n'')` 练习 22.2'
- en: 'The program could look like this:'
  id: totrans-386
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 程序可能如下所示：
- en: '`filename = input("Please enter a filename (incl. path): ") percent = input("Percent
    of content to be previewed " + "(whole number, e.g. 10 for 10%): ") previewfile
    = open(filename, "r") contents = previewfile.read() previewfile.close() content
    = contents.replace("\n", "") length_total = len(content) length_preview = int(length_total
    * int(percent) / 100) print("### Preview: ", length_preview, " characters of ",
    length_total, "characters ###") print(content[0:length_preview], "\n####\n")`'
  id: totrans-387
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`filename = input("请输入文件名（包括路径）：") percent = input("要预览的内容百分比" + "（整数，例如 10
    表示 10%）：") previewfile = open(filename, "r") contents = previewfile.read() previewfile.close()
    content = contents.replace("\n", "") length_total = len(content) length_preview
    = int(length_total * int(percent) / 100) print("### 预览：", length_preview, "个字符，共",
    length_total, "个字符 ###") print(content[0:length_preview], "\n####\n")`'
- en: The file is first opened in read mode (`"r"`) and its entire contents are read
    with `read()`. After that, the file can be closed again, because the string variable
    `content` now contains the entire file content, and we will only continue to work
    with this content. After we have cleaned line breaks from the content by removing
    the escape sequence `\n` with the string method `replace()`, we select the desired
    number of characters in the last statement, which we have previously calculated
    from the preview percentage specified by the user, and display them on the screen.
    When selecting characters from the string, it is important to ensure that the
    selection limits are integers. We achieve this by using `int()` to store the result
    as an integer variable when calculating the preview length.
  id: totrans-388
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 文件首先以读取模式（`"r"`）打开，并通过`read()`读取其全部内容。然后，文件可以关闭，因为字符串变量`content`现在包含了整个文件的内容，我们将继续处理这些内容。在通过使用字符串方法`replace()`移除换行符转义序列`\n`清理内容后，我们在最后一条语句中选择所需的字符数，这个字符数是根据用户指定的预览百分比计算出来的，并将其显示在屏幕上。选择字符串中的字符时，必须确保选择的范围是整数。我们通过使用`int()`将结果作为整数变量存储来实现这一点，以计算预览长度。
- en: Programming Task `Text Editor` Many variants are of course possible in the development
    of the text editor. The user interface of the solution presented here can be seen
    in ◘ `Fig. [22.10](#Fig10).` ![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig10_HTML.jpg)
  id: totrans-389
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 编程任务`文本编辑器`在文本编辑器的开发过程中，当然有许多不同的变体。这里呈现的解决方案的用户界面可以在◘ `图 22.10` 中看到。 ![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig10_HTML.jpg)
- en: A screenshot of a window titled, `My personal text editor`. It has buttons on
    top of the window such as `new`, `open`, and `save`. Three lines are given in
    the field below with the text, `line number one`, `one more line`, and `last line`,
    respectively.
  id: totrans-390
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个截图，窗口标题为`我的个人文本编辑器`。窗口顶部有一些按钮，如`新建`、`打开`和`保存`。在下面的字段中给出了三行文本，分别为`第一行`、`另一行`和`最后一行`。
- en: '`Fig. 22.10`'
  id: totrans-391
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`图 22.10`'
- en: '`User interface` of our text editor'
  id: totrans-392
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们文本编辑器的`用户界面`
- en: 'The code looks like this:'
  id: totrans-393
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 代码如下所示：
- en: '1 **from** tkinter **import** *2 **from** tkinter.filedialog **import** *3
    **from** tkinter.scrolledtext **import** ScrolledText45 *# Define event handler
    functions for buttons and menus*67 **def** new_press():8 **global** filename9
    text.delete(1.0, ''end'')10 filename = ''''11 status[''text''] = ''Unsaved new
    file''121314 **def** open_press():15 **global** filename16 fname = askopenfilename(defaultextension
    = ''txt'',17 filetypes = [(''Text Files'', ''*.txt''),18 (''All Files'', ''*.*''),],19
    title = ''Open....'',20 initialdir = ''C:\\Windows'')21 textfile = open(fname,
    ''r'')22 text.delete(1.0, ''end'')23 text.insert(1.0, textfile.read())24 textfile.close()2526
    status[''text''] = ''File "'' + fname + ''" opened.''27 filename = fname282930
    **def** saveas_press():31 **global** filename32 fname = asksaveasfilename(defaultextension
    = ''txt'',33 filetypes = [(''Text Files'', ''*.txt''),34 (''All Files'', ''*.*''),],35
    title = ''Save File As...'',36 initialdir = ''C:\\Windows'')37 textfile = open(fname,
    ''w'')38 textfile.write(text.get(1.0, ''end''))39 textfile.close()4041 status[''text'']
    = ''File "'' + fname + ''" saved.''42 filename = fname434445 **def** save_press():46
    **global** filename47 textfile = open(filename, ''w'')48 textfile.write(text.get(1.0,
    ''end''))49 textfile.close()5051 status[''text''] = ''File "'' + filename + ''"
    saved.''525354 **def** copy_press():55 selection = text.selection_get()56 text.clipboard_clear()57
    text.clipboard_append(selection)585960 **def** paste_press():61 text.insert(text.index(''insert''),
    text.clipboard_get())626364 **def** copy_press_key(event):65 copy_press()666768
    **def** paste_press_key(event):69 paste_press()707172 **def** quit_press():73
    win.quit()747576 *# Create application window*77 win = Tk()78 win.title(''My Personal
    Text Editor'')79 win.geometry(''760x490'')80 win.resizable(height = True, width
    = True)818283 # Set up the menu84 menubar = Menu(win)85 win.config(menu = menubar)8687
    file_menu = Menu(menubar, tearoff=0)88 edit_menu = Menu(menubar, tearoff=0)8990
    menubar.add_cascade(label = ''File'', menu = file_menu)91 menubar.add_cascade(label
    = ''Edit'', menu = edit_menu)9293 file_menu.add_command(label = ''New'',94 command
    = new_press)95 file_menu.add_command(label = ''Open...'',96 command = open_press)97
    file_menu.add_command(label = ''Save'',98 command = save_press)99 file_menu.add_command(label
    = ''Save As...'',100 command = saveas_press)101 file_menu.add_separator()102 file_menu.add_command(label
    = ''Quit'',103 command = quit_press)104105 edit_menu.add_command(label =''Copy'',106
    command = copy_press)107 edit_menu.add_command(label =''Paste'',108 command =
    paste_press)109110111 # Create the control elements112 new_button = Button(win,113
    text = ''New'',114 height = 3,115 width = 16,116 command = new_press)117 open_button
    = Button(win,118 text = ''Open...'',119 height = 3,120 width = 16,121 command
    = open_press)122 save_button = Button(win,123 text = ''Save'',124 height =3,125
    width = 16,126 command = save_press)127 saveas_button = Button(win,128 text =
    ''Save As...'',129 height = 3,130 width = 16,131 command = saveas_press)132 seplabel
    = Label(win,133 text='''',134 height =3,135 width= 3)136 copy_button = Button(win,137
    text = ''Copy'',138 height = 3,139 width = 16,140 command = copy_press)141 paste_button
    = Button(win,142 text = ''Paste'',143 height = 3,144 width = 16,145 command =
    paste_press)146147 text = ScrolledText(win)148 text.bind(''<Control-c>'', copy_press_key)149
    text.bind(''<Control-v>'', paste_press_key)150151152 *# Set up the status bar*153
    status = Label(win,154 text = ''No file openend.'',155 anchor = ''w'',156 background
    = ''#FFEFC4'')157 filename = ''''158159160 *# Place buttons on surface*161 new_button.grid(row
    = 0, column = 0, sticky = ''news'')162 open_button.grid(row = 0, column = 1, sticky
    = ''news'')163 save_button.grid(row = 0, column = 2, sticky = ''news'')164 saveas_button.grid(row
    = 0, column = 3, sticky = ''news'')165166 seplabel.grid(row = 0, column= 4, sticky
    = ''news'')167 copy_button.grid(row = 0, column = 5, sticky = ''news'')168 paste_button.grid(row
    = 0, column = 6, sticky = ''news'')169170 text.grid(row = 1, column = 0, columnspan
    = 7, pady = 10,171 sticky = ''news'')172173 status.grid(row = 2, column = 0, columnspan
    = 7,174 sticky = ''news'')175176177 *# Event loop*178 win.mainloop()Lines 5–73:
    Eventhandler Functions for Buttons and Menus'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '1 **从** tkinter **导入** *2 **从** tkinter.filedialog **导入** *3 **从** tkinter.scrolledtext
    **导入** ScrolledText45 *# 定义按钮和菜单的事件处理函数*67 **定义** new_press():8 **全局** filename9
    text.delete(1.0, ''end'')10 filename = ''''11 status[''text''] = ''未保存的新文件''121314
    **定义** open_press():15 **全局** filename16 fname = askopenfilename(defaultextension
    = ''txt'',17 filetypes = [(''文本文件'', ''*.txt''),18 (''所有文件'', ''*.*''),],19 title
    = ''打开....'',20 initialdir = ''C:\\Windows'')21 textfile = open(fname, ''r'')22
    text.delete(1.0, ''end'')23 text.insert(1.0, textfile.read())24 textfile.close()2526
    status[''text''] = ''文件 "'' + fname + ''" 已打开。''27 filename = fname282930 **定义**
    saveas_press():31 **全局** filename32 fname = asksaveasfilename(defaultextension
    = ''txt'',33 filetypes = [(''文本文件'', ''*.txt''),34 (''所有文件'', ''*.*''),],35 title
    = ''另存为...'',36 initialdir = ''C:\\Windows'')37 textfile = open(fname, ''w'')38
    textfile.write(text.get(1.0, ''end''))39 textfile.close()4041 status[''text'']
    = ''文件 "'' + fname + ''" 已保存。''42 filename = fname434445 **定义** save_press():46
    **全局** filename47 textfile = open(filename, ''w'')48 textfile.write(text.get(1.0,
    ''end''))49 textfile.close()5051 status[''text''] = ''文件 "'' + filename + ''"
    已保存。''525354 **定义** copy_press():55 selection = text.selection_get()56 text.clipboard_clear()57
    text.clipboard_append(selection)585960 **定义** paste_press():61 text.insert(text.index(''insert''),
    text.clipboard_get())626364 **定义** copy_press_key(event):65 copy_press()666768
    **定义** paste_press_key(event):69 paste_press()707172 **定义** quit_press():73 win.quit()747576
    *# 创建应用窗口*77 win = Tk()78 win.title(''我的个人文本编辑器'')79 win.geometry(''760x490'')80
    win.resizable(height = True, width = True)818283 # 设置菜单栏84 menubar = Menu(win)85
    win.config(menu = menubar)8687 file_menu = Menu(menubar, tearoff=0)88 edit_menu
    = Menu(menubar, tearoff=0)8990 menubar.add_cascade(label = ''文件'', menu = file_menu)91
    menubar.add_cascade(label = ''编辑'', menu = edit_menu)9293 file_menu.add_command(label
    = ''新建'',94 command = new_press)95 file_menu.add_command(label = ''打开...'',96
    command = open_press)97 file_menu.add_command(label = ''保存'',98 command = save_press)99
    file_menu.add_command(label = ''另存为...'',100 command = saveas_press)101 file_menu.add_separator()102
    file_menu.add_command(label = ''退出'',103 command = quit_press)104105 edit_menu.add_command(label
    =''复制'',106 command = copy_press)107 edit_menu.add_command(label =''粘贴'',108 command
    = paste_press)109110111 # 创建控件元素112 new_button = Button(win,113 text = ''新建'',114
    height = 3,115 width = 16,116 command = new_press)117 open_button = Button(win,118
    text = ''打开...'',119 height = 3,120 width = 16,121 command = open_press)122 save_button
    = Button(win,123 text = ''保存'',124 height =3,125 width = 16,126 command = save_press)127
    saveas_button = Button(win,128 text = ''另存为...'',129 height = 3,130 width = 16,131
    command = saveas_press)132 seplabel = Label(win,133 text='''',134 height =3,135
    width= 3)136 copy_button = Button(win,137 text = ''复制'',138 height = 3,139 width
    = 16,140 command = copy_press)141 paste_button = Button(win,142 text = ''粘贴'',143
    height = 3,144 width = 16,145 command = paste_press)146147 text = ScrolledText(win)148
    text.bind(''<Control-c>'', copy_press_key)149 text.bind(''<Control-v>'', paste_press_key)150151152
    *# 设置状态栏*153 status = Label(win,154 text = ''没有文件打开。'',155 anchor = ''w'',156
    background = ''#FFEFC4'')157 filename = ''''158159160 *# 将按钮放置到界面*161 new_button.grid(row
    = 0, column = 0, sticky = ''news'')162 open_button.grid(row = 0, column = 1, sticky
    = ''news'')163 save_button.grid(row = 0, column = 2, sticky = ''news'')164 saveas_button.grid(row
    = 0, column = 3, sticky = ''news'')165166 seplabel.grid(row = 0, column= 4, sticky
    = ''news'')167 copy_button.grid(row = 0, column = 5, sticky = ''news'')168 paste_button.grid(row
    = 0, column = 6, sticky = ''news'')169170 text.grid(row = 1, column = 0, columnspan
    = 7, pady = 10,171 sticky = ''news'')172173 status.grid(row = 2, column = 0, columnspan
    = 7,174 sticky = ''news'')175176177 *# 事件循环*178 win.mainloop()'
- en: We’ll take a closer look at how event handlers work below once it’s clear which
    components will make up the interface.
  id: totrans-395
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一旦清楚了界面由哪些组件构成，我们将详细了解事件处理程序是如何工作的。
- en: 'Lines 76–80: `Application Window`'
  id: totrans-396
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第76到80行：`应用程序窗口`
- en: The window `win` is created and scaled as a `Tk` object. It should be resizable
    for the user.
  id: totrans-397
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`win`窗口被创建并作为`Tk`对象进行缩放。它应该可以被用户调整大小。'
- en: 'Lines 83–108: `Menu Setup`'
  id: totrans-398
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第83到108行：`菜单设置`
- en: A new menu bar is created for the `win` window and two drop-down menus, `file_menu`
    and `edit_menu` are placed on the bar. The menu items are then gradually added
    to the menus.
  id: totrans-399
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为`win`窗口创建了一个新的菜单栏，并在菜单栏上放置了两个下拉菜单，`file_menu`和`edit_menu`。菜单项随后逐渐添加到菜单中。
- en: 'Lines 111–149: `Creating the Remaining Controls`'
  id: totrans-400
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第111到149行：`创建剩余控件`
- en: This is where the buttons and the text input field are created. In addition,
    event handlers are bound to two events of the text input field to process the
    pressing of the key combinations `<CTRL>+<C>` (copy) and `<CTRL>+<V>` (paste).
  id: totrans-401
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里创建了按钮和文本输入框。此外，事件处理程序被绑定到文本输入框的两个事件上，用来处理按下键组合`<CTRL>+<C>`（复制）和`<CTRL>+<V>`（粘贴）。
- en: 'Lines 152–157: `Preparing the Status Bar`'
  id: totrans-402
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第152到157行：`准备状态栏`
- en: We create a label as a yellowish colored status bar, on which the name of the
    currently opened file is displayed.
  id: totrans-403
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们创建了一个标签作为黄色的状态栏，当前打开的文件名称会显示在上面。
- en: 'Lines 160–174: `Placing the Controls on the Interface`'
  id: totrans-404
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第160到174行：`将控件放置到界面上`
- en: The controls are arranged on the user interface using the `grid` Geometry Manager,
    in such a way that they fully fill their respective “grid cells” (`sticky = 'news'`，i.e.,
    `north east west south`).
  id: totrans-405
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 控件通过使用`grid`几何管理器在用户界面上排列，以便它们完全填充各自的“网格单元格”（`sticky = 'news'`，即`north east
    west south`）。
- en: 'Lines 177–178: `Event Loop`'
  id: totrans-406
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第177到178行：`事件循环`
- en: '`mainloop()` starts event processing for our editor. This makes the user interface
    react to the user’s input.'
  id: totrans-407
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`mainloop()`开始了我们编辑器的事件处理。这使得用户界面能够对用户的输入作出反应。'
- en: '`Event Handlers` (Lines 5–73)'
  id: totrans-408
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`事件处理器`（第5到73行）'
- en: '`new_press()`: Creates a file by first deleting the contents of the `ScrolledText`
    field; deletes from line 1 (line numbering starts at 1 for text widgets in `tkinter`)，column
    0 (column numbering starts at 0) to the end. Instead of the string `''end''` the
    constant `END` could have been used.'
  id: totrans-409
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`new_press()`: 通过首先删除`ScrolledText`字段的内容来创建一个文件；从第1行（文本小部件中的行号从1开始）第0列（列号从0开始）删除到末尾。可以使用常量`END`来代替字符串`''end''`。'
- en: The global variable `filename`，to which we secure access with the statement
    `global filename` (otherwise a `local` variable with the same name would be created
    within `new_press()`) is reinitialized with an empty string and the text of the
    status bar is updated.
  id: totrans-410
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 全局变量`filename`通过`global filename`语句确保访问权限（否则在`new_press()`中会创建一个同名的`local`变量），并重新初始化为空字符串，状态栏的文本也随之更新。
- en: '`open_press()`: Here we use the `askopenfilename()` function to retrieve the
    path to the file we want to open. After that, the file is opened in read mode
    with `open()` and the content read from it with `read()` is put into our text
    field before the file is closed again with `close()`.'
  id: totrans-411
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`open_press()`: 在这里，我们使用`askopenfilename()`函数来获取我们要打开的文件路径。然后，文件以读取模式通过`open()`打开，使用`read()`读取的内容被放入我们的文本框中，之后文件再次通过`close()`关闭。'
- en: '`save_as_press()` and `save_press()`: For save, we basically do the same as
    for open; however, the file is opened in write mode so that the `write()` method
    can write the text on the editor that we get using the `get()` method of the `ScrolledText`
    widget. In `save_as_press()`，we ask for the filename using `tkinter`’s `asksaveasfilename()`
    function, and for `save_press()`，we save the file using the name we’re already
    using. So, this can only work if a file has been opened or the content of the
    `ScrolledText` widget has already been saved to a file.'
  id: totrans-412
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`save_as_press()`和`save_press()`：对于保存，我们基本上和打开一样；不过文件是以写入模式打开的，以便`write()`方法可以将我们通过`ScrolledText`小部件的`get()`方法获取的文本写入编辑器。在`save_as_press()`中，我们通过`tkinter`的`asksaveasfilename()`函数来询问文件名，而在`save_press()`中，我们使用已经在使用的文件名来保存文件。因此，只有在文件已经打开或`ScrolledText`小部件的内容已经保存到文件时，这才有效。'
- en: '`copy_press()`和`paste_press()`，`copy_press_key()`和`paste_press_key()`：在复制文本时，我们首先使用`ScrolledText`小部件的`selection_get()`方法确定文本选择的内容，然后使用`clipboard_clear()`清空剪贴板，最后使用`clipboard_append()`方法将要复制的文本插入剪贴板。'
  id: totrans-413
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`copy_press()`和`paste_press()`，`copy_press_key()`和`paste_press_key()`：在复制文本时，我们首先使用`ScrolledText`小部件的`selection_get()`方法获取所选文本，然后用`clipboard_clear()`清空剪贴板，最后用`clipboard_append()`方法将要复制的文本插入到剪贴板。'
- en: 在插入文本时，我们首先确定当前插入位置，即在我们的`ScrolledText`小部件中的光标位置，使用`index('insert')`，然后获取剪贴板内容，使用`clipboard_get()`将其插入到该位置。
  id: totrans-414
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 在插入文本时，我们首先确定当前插入位置，即在我们的`ScrolledText`小部件中的光标位置，使用`index('insert')`，然后获取剪贴板内容，使用`clipboard_get()`将其插入到该位置。
- en: The `copy_press_key()`和`paste_press_key()`函数是我们绑定到按键事件的（第148/149行），它们调用我们之前讨论的事件处理程序，但它们是必要的，因为通过`bind()`绑定到事件的事件处理程序作为参数传递了一个事件对象。因此，这些事件处理程序必须提供一个参数，而我们通过`command`选项绑定到按钮和菜单项的事件处理程序则不需要任何参数。
  id: totrans-415
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: '`copy_press_key()`和`paste_press_key()`函数是我们绑定到按键事件的（第148/149行），它们调用我们之前讨论的事件处理程序，但它们是必要的，因为通过`bind()`绑定到事件的事件处理程序作为参数传递了一个事件对象。因此，这些事件处理程序必须提供一个参数，而我们通过`command`选项绑定到按钮和菜单项的事件处理程序则不需要任何参数。'
