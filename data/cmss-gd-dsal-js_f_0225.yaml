- en: Chapter 20
  id: totrans-0
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 第20章
- en: These are the solutions to the exercises found in the section [`Exercises`](f_0204.xhtml#tips.for.code.optimization.exercises).
  id: totrans-1
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这些是[`练习`](f_0204.xhtml#tips.for.code.optimization.exercises)部分的练习解决方案。
- en: We can optimize this algorithm if we ask ourselves, “If I could magically find
    a desired piece of information in `O(1)` time, can I make my algorithm faster?”
  id: totrans-2
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果我们问自己：“如果我能在`O(1)`的时间内神奇地找到所需的信息，我能否让我的算法更快？”那么我们就可以优化这个算法。
- en: Specifically, as we iterate over one array, we’d want to “magically” look up
    that athlete from the other array in `O(1)` time. To accomplish this, we can first
    transform one of the arrays into a hash table. We’ll use the full name (that is,
    the first and last name) as the key, and `true` (or any arbitrary item) as the
    value.
  id: totrans-3
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 具体来说，当我们遍历一个数组时，我们希望能“神奇地”在另一个数组中以`O(1)`的时间查找那个运动员。为此，我们可以先将其中一个数组转换为哈希表。我们将全名（即名和姓）作为键，`true`（或任何任意项）作为值。
- en: Once we’ve turned one array into this hash table, we then iterate over the other
    array. As we encounter each athlete, we do an `O(1)` lookup in the hash table
    to see if that athlete already plays the other sport. If they do, we add that
    athlete to our multisportAthletes array, which we return at the end of the function.
  id: totrans-4
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 一旦我们将一个数组转换为这个哈希表，我们就遍历另一个数组。当我们遇到每个运动员时，我们在哈希表中进行一次`O(1)`的查找，以查看该运动员是否已经在另一个运动中比赛。如果是，我们就将该运动员添加到我们的`multisportAthletes`数组中，最后在函数结束时返回它。
- en: 'Here’s the code for this approach:'
  id: totrans-5
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是这个方法的代码：
- en: '| ​  | `function` findMultisportAthletes(array1, array2) { |'
  id: totrans-6
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `function` findMultisportAthletes(array1, array2) { |'
- en: '| ​  | `const` hashTable = {}; |'
  id: totrans-7
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `const` hashTable = {}; |'
- en: '| ​  | `const` multisportAthletes = []; |'
  id: totrans-8
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `const` multisportAthletes = []; |'
- en: '| ​  |  |'
  id: totrans-9
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `for` ( `const` athlete `of` array1) { |'
  id: totrans-10
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `for` ( `const` athlete `of` array1) { |'
- en: '| ​  | `hashTable[`*`*​${athlete.firstName}​​${athlete.lastName}​*`*​] = `true`;
    |'
  id: totrans-11
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `hashTable[`*`*​${athlete.firstName}​​${athlete.lastName}​*`*​] = `true`;
    |'
- en: '| ​  | } |'
  id: totrans-12
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  |  |'
  id: totrans-13
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `for` ( `const` athlete `of` array2) { |'
  id: totrans-14
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `for` ( `const` athlete `of` array2) { |'
- en: '| ​  | `if` (hashTable[`*`*​${athlete.firstName}​​${athlete.lastName}​*`*​])
    { |'
  id: totrans-15
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `if` (hashTable[`*`*​${athlete.firstName}​​${athlete.lastName}​*`*​])
    { |'
- en: '| ​  | multisportAthletes.push(​*`*​${athlete.firstName}​​${athlete.lastName}​*`*​);
    |'
  id: totrans-16
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | multisportAthletes.push(​*`*​${athlete.firstName}​​${athlete.lastName}​*`*​);
    |'
- en: '| ​  | } |'
  id: totrans-17
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  | } |'
  id: totrans-18
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  |  |'
  id: totrans-19
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `return` multisportAthletes; |'
  id: totrans-20
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `return` multisportAthletes; |'
- en: '| ​  | } |'
  id: totrans-21
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: This algorithm is `O(N + M)` since we iterate through each set of players just
    once.
  id: totrans-22
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 这个算法是`O(N + M)`，因为我们只需遍历每组运动员一次。
- en: For this algorithm, generating examples to find a pattern will be immensely
    helpful.
  id: totrans-23
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 对于这个算法，生成例子以寻找模式将非常有帮助。
- en: 'Let’s take an array that has six integers and see what would happen if we removed
    a different integer each time:'
  id: totrans-24
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们取一个包含六个整数的数组，看看每次移除一个不同的整数会发生什么：
- en: '| ​  | [1, 2, 3, 4, 5, 6] : missing `0`: `sum = 21` |'
  id: totrans-25
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | [1, 2, 3, 4, 5, 6] : 缺失`0`：`sum = 21` |'
- en: '| ​  | [0, 2, 3, 4, 5, 6] : missing 1: `sum = 20` |'
  id: totrans-26
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | [0, 2, 3, 4, 5, 6] : 缺失`1`：`sum = 20` |'
- en: '| ​  | [0, 1, 3, 4, 5, 6] : missing `2`: `sum = 19` |'
  id: totrans-27
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | [0, 1, 3, 4, 5, 6] : 缺失`2`：`sum = 19` |'
- en: '| ​  | [0, 1, 2, 4, 5, 6] : missing `3`: `sum = 18` |'
  id: totrans-28
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | [0, 1, 2, 4, 5, 6] : 缺失`3`：`sum = 18` |'
- en: '| ​  | [0, 1, 2, 3, 5, 6] : missing `4`: `sum = 17` |'
  id: totrans-29
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | [0, 1, 2, 3, 5, 6] : 缺失`4`：`sum = 17` |'
- en: '| ​  | [0, 1, 2, 3, 4, 6] : missing `5`: `sum = 16` |'
  id: totrans-30
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | [0, 1, 2, 3, 4, 6] : 缺失`5`：`sum = 16` |'
- en: Hmm. When we remove the `0`, the sum is `21`。When we remove the `1`, the sum
    is `20`。And when we remove the `2`, the sum is `19`，and so on. This definitely
    seems like a pattern!
  id: totrans-31
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 嗯。当我们移除`0`时，总和是`21`。当我们移除`1`时，总和是`20`。而当我们移除`2`时，总和是`19`，依此类推。这显然是一个模式！
- en: Before we go further, let’s call the `21` in this case the “full sum.” This
    is the sum of the array when it’s just missing the `0`.
  id: totrans-32
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 在我们深入之前，让我们把这个例子中的`21`称为“完整总和”。这是数组在只缺少`0`时的总和。
- en: If we analyze these cases carefully, we’ll see that the sum of any array is
    less than the full sum by the amount of the missing number. For example, when
    we’re missing the `4`, the sum is `17`，which is four less than `21`。And when we’re
    missing the `1`, the sum is `20`，which is one less than `21`。
  id: totrans-33
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 如果我们仔细分析这些情况，就会发现任何数组的总和比完整的总和少了缺失数字的值。例如，当我们缺失`4`时，总和是`17`，比`21`少四。而当我们缺失`1`时，总和是`20`，比`21`少一。
- en: So we can begin our algorithm by calculating what the full sum is. We can then
    subtract the actual sum from the full sum, and that will be our missing number.
  id: totrans-34
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 所以我们可以通过计算完整总和来开始我们的算法。然后我们可以从完整总和中减去实际总和，这将是我们的缺失数字。
- en: 'Here’s the code for this:'
  id: totrans-35
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是这个代码：
- en: '| ​  | `function` `findMissingNumber`(`array`) { |'
  id: totrans-36
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `function` `findMissingNumber`(`array`) { |'
- en: '| ​  | `let` `fullSum` = `0`; |'
  id: totrans-37
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` `fullSum` = `0`; |'
- en: '| ​  |  |'
  id: totrans-38
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `for`(`let` `num` = `1`; `num` <= `array.length`; `num` += `1`) { |'
  id: totrans-39
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `for`(`let` `num` = `1`; `num` <= `array.length`; `num` += `1`) { |'
- en: '| ​  | `fullSum` += `num`; |'
  id: totrans-40
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `fullSum` += `num`; |'
- en: '| ​  | } |'
  id: totrans-41
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  |  |'
  id: totrans-42
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `let` `currentSum` = `0`; |'
  id: totrans-43
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` `currentSum` = `0`; |'
- en: '| ​  |  |'
  id: totrans-44
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `for`(`const` `num` `of` `array`) { |'
  id: totrans-45
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `for`(`const` `num` `of` `array`) { |'
- en: '| ​  | `currentSum` += `num`; |'
  id: totrans-46
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `currentSum` += `num`; |'
- en: '| ​  | } |'
  id: totrans-47
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  |  |'
  id: totrans-48
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `return` `fullSum` - `currentSum`; |'
  id: totrans-49
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `return` `fullSum` - `currentSum`; |'
- en: '| ​  | `}` |'
  id: totrans-50
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `}` |'
- en: '-   这个算法是 O(N)。计算总和需要 N 步，然后再计算实际总和需要 N 步。总共是 2N 步，简化为 O(N)。'
  id: totrans-51
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: '-   这个算法是 O(N)。计算总和需要 N 步，然后再计算实际总和需要 N 步。总共是 2N 步，简化为 O(N)。'
- en: '-   如果我们使用贪心算法，这个函数可以变得更快。（也许这并不令人惊讶，因为我们的代码试图在股票上获得尽可能大的利润。）'
  id: totrans-52
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '-   如果我们使用贪心算法，这个函数可以变得更快。（也许这并不令人惊讶，因为我们的代码试图在股票上获得尽可能大的利润。）'
- en: '-   为了获得最大的利润，我们希望尽可能低价买入，尽可能高价卖出。我们的贪心算法首先将第一个价格赋值为 `buyPrice`。然后我们遍历所有价格，一旦找到更低的价格，就将其作为新的
    `buyPrice`。'
  id: totrans-53
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: '-   为了获得最大的利润，我们希望尽可能低价买入，尽可能高价卖出。我们的贪心算法首先将第一个价格赋值为 `buyPrice`。然后我们遍历所有价格，一旦找到更低的价格，就将其作为新的
    `buyPrice`。'
- en: '-   同样地，在遍历价格时，我们检查如果以当前价格出售能赚多少利润。利润通过从当前价格减去 `buyPrice` 计算得出。以贪心的方式，我们将这个利润保存在一个名为
    `greatestProfit` 的变量中。当我们遍历所有价格时，每当发现更大的利润时，就更新 `greatestProfit`。'
  id: totrans-54
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: '-   同样地，在遍历价格时，我们检查如果以当前价格出售能赚多少利润。利润通过从当前价格减去 `buyPrice` 计算得出。以贪心的方式，我们将这个利润保存在一个名为
    `greatestProfit` 的变量中。当我们遍历所有价格时，每当发现更大的利润时，就更新 `greatestProfit`。'
- en: '-   当我们完成遍历价格时，`greatestProfit` 将保存我们通过一次买入和卖出所能获得的最大利润。'
  id: totrans-55
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: '-   当我们完成遍历价格时，`greatestProfit` 将保存我们通过一次买入和卖出所能获得的最大利润。'
- en: '-   这是我们算法的代码：'
  id: totrans-56
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: '-   这是我们算法的代码：'
- en: '| ​  | `function` `findGreatestProfit`(`array`) { |'
  id: totrans-57
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `function` `findGreatestProfit`(`array`) { |'
- en: '| ​  | `let` `buyPrice` = `array[0]`; |'
  id: totrans-58
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` `buyPrice` = `array[0]`; |'
- en: '| ​  | `let` `greatestProfit` = `0`; |'
  id: totrans-59
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` `greatestProfit` = `0`; |'
- en: '| ​  |  |'
  id: totrans-60
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `for`(`const` price `of` array) { |'
  id: totrans-61
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `for`(`const` price `of` array) { |'
- en: '| ​  | `const` `potentialProfit` = `price` - `buyPrice`; |'
  id: totrans-62
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `const` `potentialProfit` = `price` - `buyPrice`; |'
- en: '| ​  |  |'
  id: totrans-63
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `if` (`price` < `buyPrice`) { |'
  id: totrans-64
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `if` (`price` < `buyPrice`) { |'
- en: '| ​  | `buyPrice` = `price`; |'
  id: totrans-65
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `buyPrice` = `price`; |'
- en: '| ​  | `} else if` (`potentialProfit` > `greatestProfit`) { |'
  id: totrans-66
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `} else if` (`potentialProfit` > `greatestProfit`) { |'
- en: '| ​  | `greatestProfit` = `potentialProfit`; |'
  id: totrans-67
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `greatestProfit` = `potentialProfit`; |'
- en: '| ​  | } |'
  id: totrans-68
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  | } |'
  id: totrans-69
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  |  |'
  id: totrans-70
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `return` `greatestProfit`; |'
  id: totrans-71
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `return` `greatestProfit`; |'
- en: '| ​  | } |'
  id: totrans-72
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '-   因为我们仅遍历 N 个价格一次，所以我们的函数运行时间为 O(N)。我们不仅赚了很多钱，而且速度也很快。'
  id: totrans-73
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: '-   因为我们仅遍历 N 个价格一次，所以我们的函数运行时间为 O(N)。我们不仅赚了很多钱，而且速度也很快。'
- en: '-   这是另一个通过生成示例来寻找模式以优化的算法。'
  id: totrans-74
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '-   这是另一个通过生成示例来寻找模式以优化的算法。'
- en: '-   根据练习的说明，最大乘积可能是负数的结果。让我们看一下各种数组及其由两个数字形成的最大乘积的例子：'
  id: totrans-75
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: '-   根据练习的说明，最大乘积可能是负数的结果。让我们看一下各种数组及其由两个数字形成的最大乘积的例子：'
- en: '| ​  | `[-5, -4, -3, 0, 3, 4]` -> 最大乘积: `20` (`-5 * -4`) |'
  id: totrans-76
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `[-5, -4, -3, 0, 3, 4]` -> 最大乘积: `20` (`-5 * -4`) |'
- en: '| ​  | `[-9, -2, -1, 2, 3, 7]` -> 最大乘积: `21` (`3 * 7`) |'
  id: totrans-77
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `[-9, -2, -1, 2, 3, 7]` -> 最大乘积: `21` (`3 * 7`) |'
- en: '| ​  | `[-7, -4, -3, 0, 4, 6]` -> 最大乘积: `28` (`-7 * -4`) |'
  id: totrans-78
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `[-7, -4, -3, 0, 4, 6]` -> 最大乘积: `28` (`-7 * -4`) |'
- en: '| ​  | `[-6, -5, -1, 2, 3, 9]` -> 最大乘积: `30` (`-6 * -5`) |'
  id: totrans-79
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `[-6, -5, -1, 2, 3, 9]` -> 最大乘积: `30` (`-6 * -5`) |'
- en: '| ​  | `[-9, -4, -3, 0, 6, 7]` -> 最大乘积: `42` (`6 * 7`) |'
  id: totrans-80
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `[-9, -4, -3, 0, 6, 7]` -> 最大乘积: `42` (`6 * 7`) |'
- en: Seeing all these cases may help us realize that the greatest product can only
    be formed by either the greatest two numbers or the lowest two (negative) numbers.
  id: totrans-81
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 看到这些情况可能会帮助我们意识到，最大的乘积只能由最大的两个数字或最低的两个（负）数字组成。
- en: 'With this in mind, we should design our algorithm to keep track of these four
    numbers:'
  id: totrans-82
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们应该设计我们的算法来跟踪这四个数字：
- en: The greatest number
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 最大的数字
- en: The second-to-greatest number
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 第二大数字
- en: The lowest number
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 最低的数字
- en: The second-to-lowest number
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 第二低的数字
- en: We can then compare the product of the two greatest numbers versus the product
    of the two lowest numbers. And whichever product is greater is the greatest product
    in the array.
  id: totrans-87
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 然后我们可以比较两个最大数字的乘积与两个最小数字的乘积。较大的乘积就是数组中的最大乘积。
- en: Now, how do we find the greatest two numbers and the lowest two numbers? If
    we sorted the array, that would be easy. But that’s still O(N log N), and the
    instructions say that we can achieve O(N).
  id: totrans-88
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 现在，我们如何找到最大的两个数字和最低的两个数字？如果我们对数组进行排序，那将很简单。但这仍然是 O(N log N)，而说明中说我们可以实现 O(N)。
- en: In fact, we can find all four numbers in a single pass through the array. It’s
    time to get greedy again.
  id: totrans-89
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 事实上，我们可以在一次遍历数组中找到所有四个数字。是时候再次采取贪心策略了。
- en: 'Here’s the code, followed by its explanation:'
  id: totrans-90
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是代码及其解释：
- en: '| ​  | `function` greatestProduct(array) { |'
  id: totrans-91
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `function` greatestProduct(array) { |'
- en: '| ​  | `let` greatestNumber = -`Infinity`; |'
  id: totrans-92
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` greatestNumber = -`Infinity`; |'
- en: '| ​  | `let` secondToGreatestNumber = -`Infinity`; |'
  id: totrans-93
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` secondToGreatestNumber = -`Infinity`; |'
- en: '| ​  |  |'
  id: totrans-94
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `let` lowestNumber = `Infinity`; |'
  id: totrans-95
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` lowestNumber = `Infinity`; |'
- en: '| ​  | `let` secondToLowestNumber = `Infinity`; |'
  id: totrans-96
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` secondToLowestNumber = `Infinity`; |'
- en: '| ​  |  |'
  id: totrans-97
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `for` (`const` number `of` array) { |'
  id: totrans-98
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `for` (`const` number `of` array) { |'
- en: '| ​  | `if` (number >= greatestNumber) { |'
  id: totrans-99
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `if` (number >= greatestNumber) { |'
- en: '| ​  | secondToGreatestNumber = greatestNumber; |'
  id: totrans-100
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | secondToGreatestNumber = greatestNumber; |'
- en: '| ​  | greatestNumber = number; |'
  id: totrans-101
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | greatestNumber = number; |'
- en: '| ​  | } `else` `if` (number > secondToGreatestNumber) { |'
  id: totrans-102
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } `else` `if` (number > secondToGreatestNumber) { |'
- en: '| ​  | secondToGreatestNumber = number; |'
  id: totrans-103
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | secondToGreatestNumber = number; |'
- en: '| ​  | } |'
  id: totrans-104
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  |  |'
  id: totrans-105
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `if` (number <= lowestNumber) { |'
  id: totrans-106
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `if` (number <= lowestNumber) { |'
- en: '| ​  | secondToLowestNumber = lowestNumber; |'
  id: totrans-107
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | secondToLowestNumber = lowestNumber; |'
- en: '| ​  | lowestNumber = number; |'
  id: totrans-108
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | lowestNumber = number; |'
- en: '| ​  | } `else` `if` (number < secondToLowestNumber) { |'
  id: totrans-109
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } `else` `if` (number < secondToLowestNumber) { |'
- en: '| ​  | secondToLowestNumber = number; |'
  id: totrans-110
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | secondToLowestNumber = number; |'
- en: '| ​  | } |'
  id: totrans-111
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  | } |'
  id: totrans-112
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  |  |'
  id: totrans-113
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `const` greatestProductFromTwoHighest = |'
  id: totrans-114
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `const` greatestProductFromTwoHighest = |'
- en: '| ​  | (greatestNumber * secondToGreatestNumber); |'
  id: totrans-115
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | (greatestNumber * secondToGreatestNumber); |'
- en: '| ​  |  |'
  id: totrans-116
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `const` greatestProductFromTwoLowest = (lowestNumber * secondToLowestNumber);
    |'
  id: totrans-117
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `const` greatestProductFromTwoLowest = (lowestNumber * secondToLowestNumber);
    |'
- en: '| ​  |  |'
  id: totrans-118
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `if` (greatestProductFromTwoHighest > greatestProductFromTwoLowest)
    { |'
  id: totrans-119
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `if` (greatestProductFromTwoHighest > greatestProductFromTwoLowest)
    { |'
- en: '| ​  | `return` greatestProductFromTwoHighest; |'
  id: totrans-120
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `return` greatestProductFromTwoHighest; |'
- en: '| ​  | } `else` { |'
  id: totrans-121
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } `else` { |'
- en: '| ​  | `return` greatestProductFromTwoLowest; |'
  id: totrans-122
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `return` greatestProductFromTwoLowest; |'
- en: '| ​  | } |'
  id: totrans-123
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  | } |'
  id: totrans-124
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: Before we begin our loop, we set the greatestNumber and secondToGreatestNumber
    to be negative infinity. This ensures they start out lower than any number currently
    in the array.
  id: totrans-125
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 在我们开始循环之前，我们将 greatestNumber 和 secondToGreatestNumber 设置为负无穷。这确保它们的初始值低于数组中的任何数字。
- en: We then iterate over each number. If the current number is greater than the
    greatestNumber, we greedily turn the current number into the new greatestNumber.
    If we’ve already found a secondToGreatestNumber, we reassign the secondToGreatestNumber
    to be whatever the greatestNumber was before we reached the current number. This
    ensures the secondToGreatestNumber will indeed be the second-to-greatest number.
  id: totrans-126
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 然后我们遍历每个数字。如果当前数字大于 greatestNumber，我们就贪婪地将当前数字设为新的 greatestNumber。如果我们已经找到 secondToGreatestNumber，我们将其重新分配为在到达当前数字之前的
    greatestNumber。这样可以确保 secondToGreatestNumber 确实是第二大的数字。
- en: If the current number we’re iterating over is less than the greatestNumber but
    greater than the secondToGreatestNumber, we update the secondToGreatestNumber
    to be the current number.
  id: totrans-127
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 如果当前迭代的数字小于 greatestNumber 但大于 secondToGreatestNumber，我们将 secondToGreatestNumber
    更新为当前数字。
- en: 我们按照相同的过程找到`lowestNumber`和`secondToLowestNumber`。
  id: totrans-128
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 我们按照相同的过程找到`lowestNumber`和`secondToLowestNumber`。
- en: 一旦找到所有四个数字，我们计算两个最高数字的乘积和两个最低数字的乘积，并返回较大的乘积。
  id: totrans-129
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 一旦找到所有四个数字，我们计算两个最高数字的乘积和两个最低数字的乘积，并返回较大的乘积。
- en: 优化该算法的关键在于我们正在对有限数量的值进行排序。具体来说，这个数组中只有十一种温度读数，即：
  id: totrans-130
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 优化该算法的关键在于我们正在对有限数量的值进行排序。具体来说，这个数组中只有十一种温度读数，即：
- en: '| ​  | 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105 |'
  id: totrans-131
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105 |'
- en: 假设我们的输入数组是：
  id: totrans-132
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 假设我们的输入数组是：
- en: '| ​  | [98, 99, 95, 105, 104, 99, 101, 99, 101, 97] |'
  id: totrans-133
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | [98, 99, 95, 105, 104, 99, 101, 99, 101, 97] |'
- en: 如果我们将温度数组想象成一个哈希表，我们可以将每个温度存储为键，将出现次数存储为值。它的形式大致如下：
  id: totrans-134
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 如果我们将温度数组想象成一个哈希表，我们可以将每个温度存储为键，将出现次数存储为值。它的形式大致如下：
- en: '| ​  | {98: 1, 99: 3, 95: 1, 105: 1, 104: 1, 101: 2, 97:1} |'
  id: totrans-135
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | {98: 1, 99: 3, 95: 1, 105: 1, 104: 1, 101: 2, 97:1} |'
- en: 考虑到这一点，我们可以运行一个从 95 到 105 的循环，并检查哈希表中该温度的出现次数。每次查找的时间复杂度都是 O(1)。
  id: totrans-136
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以运行一个从 95 到 105 的循环，并检查哈希表中该温度的出现次数。每次查找的时间复杂度都是 O(1)。
- en: 然后我们使用该出现次数来填充一个新数组。因为我们的循环设置为从 95 到 105，所以我们的数组最终将呈现完美的升序。
  id: totrans-137
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 然后我们使用该出现次数来填充一个新数组。因为我们的循环设置为从 95 到 105，所以我们的数组最终将呈现完美的升序。
- en: 这里是该代码：
  id: totrans-138
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是该代码：
- en: '| ​  | `function` sortTemperatures(array) { |'
  id: totrans-139
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `function` sortTemperatures(array) { |'
- en: '| ​  | `const` hashTable = {}; |'
  id: totrans-140
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `const` hashTable = {}; |'
- en: '| ​  |  |'
  id: totrans-141
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `for` (`const` temperature `of` array) { |'
  id: totrans-142
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `for` (`const` temperature `of` array) { |'
- en: '| ​  | `if` (hashTable[temperature]) { |'
  id: totrans-143
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `if` (hashTable[temperature]) { |'
- en: '| ​  | hashTable[temperature] += 1; |'
  id: totrans-144
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | hashTable[temperature] += 1; |'
- en: '| ​  | } `else` { |'
  id: totrans-145
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } `else` { |'
- en: '| ​  | hashTable[temperature] = 1; |'
  id: totrans-146
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | hashTable[temperature] = 1; |'
- en: '| ​  | } |'
  id: totrans-147
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  | } |'
  id: totrans-148
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  |  |'
  id: totrans-149
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `const` sortedTemperatures = []; |'
  id: totrans-150
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `const` sortedTemperatures = []; |'
- en: '| ​  | `let` temperature = 95; |'
  id: totrans-151
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` temperature = 95; |'
- en: '| ​  |  |'
  id: totrans-152
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `while` (temperature <= 105) { |'
  id: totrans-153
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `while` (temperature <= 105) { |'
- en: '| ​  | `if` (hashTable[temperature]) { |'
  id: totrans-154
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `if` (hashTable[temperature]) { |'
- en: '| ​  | `for` (`let` i = 0; i < hashTable[temperature]; i += 1) { |'
  id: totrans-155
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `for` (`let` i = 0; i < hashTable[temperature]; i += 1) { |'
- en: '| ​  | sortedTemperatures.push(temperature); |'
  id: totrans-156
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | sortedTemperatures.push(temperature); |'
- en: '| ​  | } |'
  id: totrans-157
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  | } |'
  id: totrans-158
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  |  |'
  id: totrans-159
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | temperature += 1; |'
  id: totrans-160
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | temperature += 1; |'
- en: '| ​  | } |'
  id: totrans-161
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  |  |'
  id: totrans-162
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `return` sortedTemperatures; |'
  id: totrans-163
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `return` sortedTemperatures; |'
- en: '| ​  | } |'
  id: totrans-164
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: 现在让我们分析该算法的效率。我们需要 N 步骤来创建哈希表。然后我们循环执行十一次，遍历所有可能的温度，从 95 到 105。
  id: totrans-165
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 现在让我们分析该算法的效率。我们需要 N 步骤来创建哈希表。然后我们循环执行十一次，遍历所有可能的温度，从 95 到 105。
- en: 在每轮循环中，我们运行一个嵌套循环来填充`sortedTemperatures`与温度。然而，这个内层循环不会运行超过输入数组中的 N 个温度。这是因为内层循环仅针对原始数组中的每个温度运行一次。
  id: totrans-166
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 在每轮循环中，我们运行一个嵌套循环来填充`sortedTemperatures`与温度。然而，这个内层循环不会运行超过输入数组中的 N 个温度。这是因为内层循环仅针对原始数组中的每个温度运行一次。
- en: 因此，我们有 N 步骤来创建哈希表，外层循环需要十一步，内层循环也需要 N 步骤。这是 2N + 11，简化为 O(N)。
  id: totrans-167
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 因此，我们有 N 步骤来创建哈希表，外层循环需要十一步，内层循环也需要 N 步骤。这是 2N + 11，简化为 O(N)。
- en: 该算法是经典的排序算法，称为计数排序。它在处理相对小范围的可能输入值时非常有用，例如我们这一例中只有十一种可能的值。
  id: totrans-168
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 该算法是经典的排序算法，称为计数排序。它在处理相对小范围的可能输入值时非常有用，例如我们这一例中只有十一种可能的值。
- en: 这种优化运用了我见过的最巧妙的魔法查找。
  id: totrans-169
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 这种优化运用了我见过的最巧妙的魔法查找。
- en: 想象一下，我们正在遍历数字数组，遇到了`5`。让我们问自己一个神奇的查找问题：“如果我能在`O(1)`时间内神奇地找到所需的信息，我能否让我的算法更快？”
  id: totrans-170
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 想象一下，我们正在遍历数字数组，遇到了`5`。让我们问自己一个神奇的查找问题：“如果我能在`O(1)`时间内神奇地找到所需的信息，我能否让我的算法更快？”
- en: 好吧，为了确定`5`是否是最长连续序列的一部分，我们需要知道数组中是否有`6`。我们还想知道是否有`7`、`8`，依此类推。
  id: totrans-171
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 好吧，为了确定`5`是否是最长连续序列的一部分，我们需要知道数组中是否有`6`。我们还想知道是否有`7`、`8`，依此类推。
- en: 我们可以在`O(1)`时间内完成每次查找，如果我们首先将数组中的所有数字存储在哈希表中；也就是说，数组`[10, 5, 12, 3, 55, 30, 4,
    11, 2]`如果移动到哈希表中，可能看起来是这样的：
  id: totrans-172
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 我们可以在`O(1)`时间内完成每次查找，如果我们首先将数组中的所有数字存储在哈希表中；也就是说，数组`[10, 5, 12, 3, 55, 30, 4,
    11, 2]`如果移动到哈希表中，可能看起来是这样的：
- en: '| ​  | {10: `true`, 5: `true`, 12: `true`, 3: `true`, 55: `true`, |'
  id: totrans-173
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | {10: `true`, 5: `true`, 12: `true`, 3: `true`, 55: `true`, |'
- en: '| ​  | 30: `true`, 4: `true`, 11: `true`, 2: `true`} |'
  id: totrans-174
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | 30: `true`, 4: `true`, 11: `true`, 2: `true`} |'
- en: 在这种情况下，如果我们遇到`2`，我们可以运行一个循环，不断检查哈希表中的下一个数字。如果找到了，我们就将当前序列的长度增加一。这个循环会重复这个过程，直到找不到序列中的下一个数字。每次查找只需一步。
  id: totrans-175
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们遇到`2`，我们可以运行一个循环，不断检查哈希表中的下一个数字。如果找到了，我们就将当前序列的长度增加一。这个循环会重复这个过程，直到找不到序列中的下一个数字。每次查找只需一步。
- en: 但是，你可能会问，这有什么帮助？想象一下我们的数组是`[6, 5, 4, 3, 2, 1]`。当我们遍历到`6`时，会发现从那里无法建立序列。当我们到达`5`时，会找到序列`5-6`。当我们到达`4`时，会找到序列`4-5-6`。当我们到达`3`时，会找到序列`3-4-5-6`，依此类推。我们仍然会经历大约`N²
    / 2`步来找到所有这些序列。
  id: totrans-176
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 但是，你可能会问，这有什么帮助？想象一下我们的数组是`[6, 5, 4, 3, 2, 1]`。当我们遍历到`6`时，会发现从那里无法建立序列。当我们到达`5`时，会找到序列`5-6`。当我们到达`4`时，会找到序列`4-5-6`。当我们到达`3`时，会找到序列`3-4-5-6`，依此类推。我们仍然会经历大约`N²
    / 2`步来找到所有这些序列。
- en: 答案是，我们只会在当前数字是序列的底部数字时开始构建序列。因此，当数组中有`3`时，我们不会构建`4-5-6`。
  id: totrans-177
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 答案是，我们只会在当前数字是序列的底部数字时开始构建序列。因此，当数组中有`3`时，我们不会构建`4-5-6`。
- en: 但我们怎么知道当前数字是否是序列的底部？通过进行一次神奇的查找！
  id: totrans-178
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 但我们怎么知道当前数字是否是序列的底部？通过进行一次神奇的查找！
- en: 怎么办？在运行循环寻找序列之前，我们会先进行一次`O(1)`的哈希表查找，以检查是否有比当前数字小`1`的数字。因此，如果当前数字是`4`，我们会首先检查数组中是否有`3`。如果有，我们就不必构建序列。我们只想从该序列的底部数字开始构建序列；否则，我们就会有冗余的步骤。
  id: totrans-179
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 怎么办？在运行循环寻找序列之前，我们会先进行一次`O(1)`的哈希表查找，以检查是否有比当前数字小`1`的数字。因此，如果当前数字是`4`，我们会首先检查数组中是否有`3`。如果有，我们就不必构建序列。我们只想从该序列的底部数字开始构建序列；否则，我们就会有冗余的步骤。
- en: 这是实现这个功能的代码：
  id: totrans-180
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 这是实现这个功能的代码：
- en: '| ​  | `function` longestSequenceLength(`array`) { |'
  id: totrans-181
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `function` longestSequenceLength(`array`) { |'
- en: '| ​  | `const` hashTable = {}; |'
  id: totrans-182
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `const` hashTable = {}; |'
- en: '| ​  | `let` greatestSequenceLength = `0`; |'
  id: totrans-183
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` greatestSequenceLength = `0`; |'
- en: '| ​  |  |'
  id: totrans-184
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `for` (`const` `number` `of` `array`) { |'
  id: totrans-185
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `for` (`const` `number` `of` `array`) { |'
- en: '| ​  | `hashTable[number] = true;` |'
  id: totrans-186
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `hashTable[number] = true;` |'
- en: '| ​  | } |'
  id: totrans-187
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  |  |'
  id: totrans-188
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `for` (`const` `number` `of` `array`) { |'
  id: totrans-189
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `for` (`const` `number` `of` `array`) { |'
- en: '| ​  | `if` (!`hashTable[number - 1]`) { |'
  id: totrans-190
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `if` (!`hashTable[number - 1]`) { |'
- en: '| ​  | `let` currentSequenceLength = `1`; |'
  id: totrans-191
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` currentSequenceLength = `1`; |'
- en: '| ​  | `let` currentNumber = `number`; |'
  id: totrans-192
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` currentNumber = `number`; |'
- en: '| ​  |  |'
  id: totrans-193
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `while` (`hashTable[currentNumber + 1]`) { |'
  id: totrans-194
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `while` (`hashTable[currentNumber + 1]`) { |'
- en: '| ​  | currentNumber += `1`; |'
  id: totrans-195
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | currentNumber += `1`; |'
- en: '| ​  | currentSequenceLength += `1`; |'
  id: totrans-196
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | currentSequenceLength += `1`; |'
- en: '| ​  |  |'
  id: totrans-197
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `if` (currentSequenceLength > greatestSequenceLength) { |'
  id: totrans-198
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `if` (currentSequenceLength > greatestSequenceLength) { |'
- en: '| ​  | greatestSequenceLength = currentSequenceLength; |'
  id: totrans-199
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | greatestSequenceLength = currentSequenceLength; |'
- en: '| ​  | } |'
  id: totrans-200
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  | } |'
  id: totrans-201
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  | } |'
  id: totrans-202
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  | } |'
  id: totrans-203
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  |  |'
  id: totrans-204
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `return` greatestSequenceLength; |'
  id: totrans-205
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `return` greatestSequenceLength; |'
- en: '| ​  | } |'
  id: totrans-206
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: In this algorithm, we take `N` steps to build the hash table. We take another
    `N` steps to iterate through the array. And we take about another `N` steps looking
    up numbers in the hash table to build the different sequences. All in all, this
    is about `3N`, which is reduced to `O(N)`.
  id: totrans-207
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 在这个算法中，我们进行`N`步来构建哈希表。我们又花费`N`步遍历数组。然后大约再花费`N`步在哈希表中查找数字以构建不同的序列。总而言之，这大约是`3N`，简化为`O(N)`。
- en: Copyright © 2024, `The Pragmatic Bookshelf`. Thank you!
  id: totrans-208
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: Copyright © 2024, `The Pragmatic Bookshelf`. Thank you!
- en: We hope you enjoyed this book and that you’re already thinking about what you
    want to learn next. To help make that decision easier, we’re offering you this
    gift.
  id: totrans-209
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们希望你喜欢这本书，并且已经在思考接下来想要学习的内容。为了帮助你更轻松地做出决定，我们给你提供了这个礼物。
- en: Head on over to [`https://pragprog.com`](https://pragprog.com) right now, and
    use the coupon code `BUYANOTHER2024` to save `30%` on your next ebook. Offer is
    void where prohibited or restricted. This offer does not apply to any edition
    of `The Pragmatic Programmer` ebook.
  id: totrans-210
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在就去看看[`https://pragprog.com`](https://pragprog.com)，使用优惠码`BUYANOTHER2024`在你下次购买电子书时享受`30%`的折扣。此优惠在法律禁止或限制的地方无效。此优惠不适用于任何版本的`The
    Pragmatic Programmer`电子书。
- en: And if you’d like to share your own expertise with the world, why not propose
    a writing idea to us? After all, many of our best authors started off as our readers,
    just like you. With up to a `50%` royalty, world-class editorial services, and
    a name you trust, there’s nothing to lose. Visit [`https://pragprog.com/become-an-author/`](https://pragprog.com/become-an-author/)
    today to learn more and to get started.
  id: totrans-211
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你想与世界分享自己的专业知识，为什么不向我们提议一个写作想法呢？毕竟，我们许多优秀的作者都是从我们的读者开始的，就像你一样。最高可获得`50%`的稿酬，世界级的编辑服务，以及你信任的名字，完全没有风险。今天就访问[`https://pragprog.com/become-an-author/`](https://pragprog.com/become-an-author/)了解更多信息并开始吧。
- en: Thank you for your continued support. We hope to hear from you again soon!
  id: totrans-212
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 感谢你一直以来的支持。我们希望不久后能再次听到你的消息！
- en: '`The Pragmatic Bookshelf`'
  id: totrans-213
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`The Pragmatic Bookshelf`'
- en: '![`images/Coupon.png`](images/Coupon.png)'
  id: totrans-214
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![`images/Coupon.png`](images/Coupon.png)'
