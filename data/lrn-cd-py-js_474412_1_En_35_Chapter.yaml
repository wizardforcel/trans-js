- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024J. L. ZuckarelliLearn coding with Python and JavaScript
    [https://doi.org/10.1007/978-3-658-42912-6_35](https://doi.org/10.1007/978-3-658-42912-6_35)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 作者，专有许可授予 Springer Fachmedien Wiesbaden GmbH，Springer Nature 旗下公司 2024J. L.
    Zuckarelli《学习 Python 和 JavaScript 编程》[https://doi.org/10.1007/978-3-658-42912-6_35](https://doi.org/10.1007/978-3-658-42912-6_35)
- en: '35. Loops: How Do I Repeat Program Instructions Efficiently?'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 35. 循环：如何高效地重复程序指令？
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1)München, GermanyOverview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Joachim L. Zuckarelli^([1](#Aff2) )(1)德国慕尼黑概述
- en: Like most other programming languages, JavaScript provides looping constructs
    that allow similar statements to be repeated. In practice, such loops are popular
    and frequently used, as they allow for a clear and elegant formulation of repetitions.
    In this chapter, we will take a closer look at the main types of loops in JavaScript
    and see them in action in a larger example.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他编程语言一样，JavaScript 提供了循环结构，可以重复相似的语句。实际上，这种循环非常流行且经常使用，因为它们可以清晰而优雅地表达重复的过程。在本章中，我们将详细了解
    JavaScript 中主要的循环类型，并通过一个较大的示例来演示它们的实际应用。
- en: 'In this chapter you will learn:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: how to use a counting **for** loop with a numeric run variable to execute a
    statement or block of statements for a specified number of repetitions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用带有数字运行变量的计数**for**循环，来执行语句或语句块，重复指定的次数
- en: how to easily loop through a set of objects (such as the contents of an array)
    with a **for-of** loop
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过**for-of**循环轻松遍历一组对象（例如数组的内容）
- en: how to develop head-controlled (**while**) and foot-controlled (**do-while**)
    conditional loops whose execution depends on a freely definable run condition
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何开发由头部控制（**while**）和由尾部控制（**do-while**）的条件循环，其执行取决于一个可以自由定义的运行条件
- en: 35.1 Counting Loops (for and for-of)
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 35.1 计数循环（for 和 for-of）
- en: 35.1.1 for-Loops with Numerical Run Variables
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 35.1.1 带有数值运行变量的**for**循环
- en: Structure and Function of the **for** Loop
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**for**循环的结构与功能'
- en: 'The normal **for** loop to repeat a block of code comes in the following form
    in JavaScript:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，标准的**for**循环用于重复代码块，形式如下：
- en: '**for**(initialization; check; increment) {*// Code block that is repeated*}'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**for**(初始化; 检查; 增量) {*// 被重复的代码块*}'
- en: 'Suppose we have an array of names that we want to loop through with a **for**
    loop:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名字数组，想通过**for**循环遍历它：
- en: '**>** friends = [''Peter'', ''Sophie'', ''Helen'', ''Mike'', ''Ben'']'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**>** friends = [''Peter'', ''Sophie'', ''Helen'', ''Mike'', ''Ben'']'
- en: 'As usual with counting loops, we need a (numerical) run variable, let’s call
    it **i**, which is first initialized with a start value. Since, as we know by
    now, indexing of arrays in JavaScript starts at 0, it is recommended to set the
    run variable **i** to this value at the beginning: **i = 0**. Next, we need to
    set a check condition in the loop header that must be met for the loop to continue.
    In our example, where we want to loop through the array from 0 to the last element,
    this condition must be: **i <= friends.length-1** (note that the last element
    has index **length-1**, because we are already starting the count at 0!). Finally,
    we have to tell the loop how much the run variable should be incremented in each
    step. In our example, the run variable is incremented by one. Thus, a loop that
    runs through the elements of the array and outputs them to the console would look
    like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数计数循环一样，我们需要一个（数值型）运行变量，假设它是**i**，并且首先使用起始值对其进行初始化。正如我们现在已经知道的，JavaScript
    中数组的索引是从 0 开始的，因此建议在开始时将运行变量**i**设置为 0：**i = 0**。接下来，我们需要在循环头部设置一个检查条件，只有满足此条件，循环才会继续。在我们的示例中，假设我们想要循环遍历从
    0 到最后一个元素的数组，这个条件必须是：**i <= friends.length-1**（请注意，最后一个元素的索引是**length-1**，因为我们已经从
    0 开始计数！）。最后，我们需要告诉循环在每一步中，运行变量应该增加多少。在我们的示例中，运行变量增加 1。因此，循环通过数组的元素并将它们输出到控制台的代码如下所示：
- en: '**for**(i = 0; i <= friends.length-1; i = i+1) {console.log(''Friend no. '',
    i+1, '': '', friends[i])}'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**for**(i = 0; i <= friends.length-1; i = i+1) {console.log(''Friend no. '',
    i+1, '': '', friends[i])}'
- en: 'The loop now starts with a value of 0 for the run variable and first checks
    whether the run condition is met. Because 0 is smaller than the length of the
    array reduced by one (namely four), the loop begins to execute the code in the
    loop body. It runs through this code in the first pass with 0 as the value of
    the run variable. The actual code executed is thus:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 循环现在从运行变量的值 0 开始，首先检查运行条件是否满足。因为 0 小于数组长度减一（即四），所以循环开始执行循环体中的代码。在第一次执行时，运行变量的值为
    0。实际执行的代码是：
- en: 'console.log(''Friend no. '', 1, '': '', friends[0])'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 'console.log(''朋友编号 '', 1, '': '', friends[0])'
- en: After the end of the loop body is reached, the execution jumps back to the loop
    header and increments the run variable according to the increment statement, in
    our example by one. Then the run condition is checked again and, if it is fulfilled,
    the code in the loop body is executed one more time. The loop continues these
    rounds until the run condition is no longer met after the next increment of the
    run variable. In our example if **i** were to be equal to 5 the run variable is
    now larger than the length of the array reduced by one, and the code block in
    the loop body is not executed again. Instead, the execution of the program continues
    after the **for** loop. The run variable retains its old value and is not incremented
    again.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环体执行完毕后，执行将跳回循环头，并根据增量语句增加运行变量，在我们的示例中为1。然后再次检查运行条件，如果满足条件，则循环体中的代码将再次执行。循环将继续进行这些回合，直到运行变量的下一个增量后，运行条件不再满足。在我们的示例中，如果**i**等于5，运行变量现在大于数组长度减一，循环体中的代码将不再执行。相反，程序的执行将继续在**for**循环之后。运行变量保持其旧值，不再递增。
- en: Instead of using the increment instruction **i = i+1**, we can use the increment
    operator **++** (which is unary because it only works with one operand) and simply
    write **i++**. The values of the run variables can also be decremented (so we
    could have run through the array from back to front). Then, of course, the start
    value to which the run variable is initialized must also be adjusted, otherwise
    the loop would not run at all. The best way to decrease the run variable by 1,
    is to use the decrement operator **--**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用增量操作符**++**（它是单目运算符，因为它只作用于一个操作数），而不是使用增量指令**i = i+1**，只需写**i++**。运行变量的值也可以递减（这样我们就可以从数组的末尾向前遍历）。当然，初始化运行变量的起始值也必须进行调整，否则循环将根本不会执行。最好的减少运行变量1的方法是使用递减操作符**--**。
- en: 'By the way: All loops in JavaScript can be exited with the **break** statement
    and sent to the next run with the **continue** statement. This is true not only
    for the **for** loop, but also **for-of**, **while, a**nd **do-while loops**,
    which we will look at in the following sections.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下：所有的JavaScript循环都可以通过**break**语句退出，并通过**continue**语句进入下一个循环。这不仅适用于**for**循环，也适用于**for-of**、**while**和**do-while**循环，我们将在接下来的章节中进行讲解。
- en: A Practical Example
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实际的例子
- en: The following example shows a **for** loop, more precisely two nested loops,
    in practical use. The goal this time is to develop a simple spreadsheet that can
    be used to enter numbers in the cells of a spreadsheet and then calculate the
    row and column totals. In the first step, the user enters the size of the spreadsheet.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个**for**循环，准确来说是两个嵌套的循环，在实际应用中的使用。这次的目标是开发一个简单的电子表格，可以在表格单元格中输入数字，并计算行和列的总和。在第一步中，用户输入电子表格的大小。
- en: The spreadsheet that is to be generated according to the user specifications
    can be seen in ◘ Fig. [35.1](#Fig1).![](../images/474412_1_En_35_Chapter/474412_1_En_35_Fig1_HTML.jpg)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户的规格生成的电子表格可以在◘ 图 [35.1](#Fig1) 中看到。![](../images/474412_1_En_35_Chapter/474412_1_En_35_Fig1_HTML.jpg)
- en: A screenshot of a spreadsheet document with 5 columns and 6 rows. A few of the
    cells have numerical data. Column 5 and row 6 have the sum of each column and
    rows, respectively.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含5列和6行的电子表格文档截图。其中一些单元格包含数字数据。第5列和第6行分别显示每列和每行的总和。
- en: Fig. 35.1
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 35.1
- en: Spreadsheet with 5 rows and 4 columns
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 具有5行4列的电子表格
- en: 'To enter the sheet size, we provide the user with the following simple web
    interface:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要输入表格大小，我们为用户提供了以下简单的网页界面：
- en: '**<!DOCTYPE html>****<html>****<head>****<title>**Spreadsheet**</title>****<noscript>**Please
    activate JavaScript!**</noscript>****</head>****<body>****<script** src="spreadsheet.js"**></script>****<h1>**Set
    Table Size**</h1>****<form>**Rows:**<br>****<input** id="rows" type="text" value="0"**><p></p>**Columns:**<br>****<input**
    id="columns" type="text" value="0"**><p></p>****<input** type="button" value="Create
    table"onclick="createTable()"**>****</form>****</body>****</html>**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**<!DOCTYPE html>****<html>****<head>****<title>**电子表格**</title>****<noscript>**请启用JavaScript！**</noscript>****</head>****<body>****<script**
    src="spreadsheet.js"**></script>****<h1>**设置表格大小**</h1>****<form>**行：**<br>****<input**
    id="rows" type="text" value="0"**><p></p>**列：**<br>****<input** id="columns" type="text"
    value="0"**><p></p>****<input** type="button" value="创建表格"onclick="createTable()"**>****</form>****</body>****</html>**'
- en: 'When you click the “Create Table” button, the JavaScript function **createTable()**
    from the **spreadsheet.js** file is called. This function looks like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击“创建表格”按钮时，**spreadsheet.js** 文件中的 JavaScript 函数 **createTable()** 被调用。这个函数如下所示：
- en: '1 **function** createTable() {2 **var** num_rows = Number(document.getElementById(''rows'').value);3
    **var** num_columns =Number(document.getElementById(''columns'').value);4 **var**
    i,f;56 document.write(''<H1>Spreadsheet document</H1>'');7 document.write(''<form><table>'');89
    *// Write cells*10 **for**(i = 1; i <= num_rows; i++) {11 document.write(''<tr>'');12
    **for**(f = 1; f <= num_columns; f++) {13 document.write(''<td><input id="R'',
    i, ''C'', f, ''" \type="text" value=""></td>'');14 }15 *// Add cell for sum column*16
    document.write(''<td><input id="SUM_R'', i, ''" type="text" \value="" readonly="true"
    style="background-color: \#d1d1d1; "></td>'')17 document.write(''</tr>'');18 }1920
    *// Add sum row*21 document.write(''<tr>'');22 **for**(f = 1; f <= num_columns;
    f++) {23 document.write(''<td><input id="SUM_C'', f, ''" type="text" \value=""
    readonly="true" style="background-color: \#d1d1d1;"></td>'');24 }25 document.write(''</tr>'');2627
    document.write(''</table>'');2829 document.write(''<input type="hidden" id="nrows"
    \value="'', num_rows,''">'');30 document.write(''<input type="hidden" id="ncolumns"
    \value="'', num_columns,''">'');3132 document.write("<p></p>")33 document.write(''<input
    type="button" value="Calculate" \onclick="calculate()">'');34 document.write("</form>");35
    }'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '1 **function** createTable() {2 **var** num_rows = Number(document.getElementById(''rows'').value);3
    **var** num_columns =Number(document.getElementById(''columns'').value);4 **var**
    i,f;56 document.write(''<H1>电子表格文档</H1>'');7 document.write(''<form><table>'');89
    *// 写入单元格*10 **for**(i = 1; i <= num_rows; i++) {11 document.write(''<tr>'');12
    **for**(f = 1; f <= num_columns; f++) {13 document.write(''<td><input id="R'',
    i, ''C'', f, ''" \type="text" value=""></td>'');14 }15 *// 为总和列添加单元格*16 document.write(''<td><input
    id="SUM_R'', i, ''" type="text" \value="" readonly="true" style="background-color:
    \#d1d1d1; "></td>'')17 document.write(''</tr>'');18 }1920 *// 添加总和行*21 document.write(''<tr>'');22
    **for**(f = 1; f <= num_columns; f++) {23 document.write(''<td><input id="SUM_C'',
    f, ''" type="text" \value="" readonly="true" style="background-color: \#d1d1d1;"></td>'');24
    }25 document.write(''</tr>'');2627 document.write(''</table>'');2829 document.write(''<input
    type="hidden" id="nrows" \value="'', num_rows,''">'');30 document.write(''<input
    type="hidden" id="ncolumns" \value="'', num_columns,''">'');3132 document.write("<p></p>")33
    document.write(''<input type="button" value="计算" \onclick="calculate()">'');34
    document.write("</form>");35 }'
- en: 'This JavaScript code creates the table for our spreadsheet. Simple tables have
    the following form in HTML:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 JavaScript 代码为我们的电子表格创建了表格。简单的表格在 HTML 中具有以下形式：
- en: '**<table>****<tr><td>**Row 1, column 1**</td><td>**Row 1, column 2**</td></tr>****<tr><td>**Row
    2, column 1**</td><td>**Row 2, column 2**</td></tr>****</table>**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**<table>****<tr><td>**第 1 行，第 1 列**</td><td>**第 1 行，第 2 列**</td></tr>****<tr><td>**第
    2 行，第 1 列**</td><td>**第 2 行，第 2 列**</td></tr>****</table>**'
- en: The individual table rows are represented by **tr** elements (*table row*),
    the cells they contain by **td** elements (*table data*).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 各个表格行由 **tr** 元素（*表格行*）表示，行中包含的单元格由 **td** 元素（*表格数据*）表示。
- en: The outer **for** loop with run variable **i**, whose loop head can be found
    in line 10, creates the rows of the table. In the body of this loop is another
    **for** loop, this one with the loop header in line 12\. This “inner loop” with
    run variable **f**, writes data for the current row, (i.e., the row indicated
    by run variable **i** in the “outer” **for loop**), one cell *for each column*.
    In this way, the two nested **for** loops completely “run through” the rectangular
    table schema.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 外层的 **for** 循环，运行变量 **i** 的循环头可以在第 10 行找到，创建表格的行。在这个循环的主体部分是另一个 **for** 循环，其循环头在第
    12 行。这个“内层循环”使用运行变量 **f**，为当前行（即由运行变量 **i** 在“外层” **for** 循环中指示的行）写入每个列的单元格。通过这种方式，两个嵌套的
    **for** 循环完整地“遍历”矩形表格结构。
- en: In lines 16/17 (this code is *not* in the inner loop!) another cell is written
    for the current line as part of a “Totals” column. Similarly, outside the two
    loops (lines 24–28), another loop is used to write a “Totals” row.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 16/17 行（此代码*不*在内层循环中！）为当前行写入另一个单元格，作为“总计”列的一部分。类似地，在两个循环之外（第 24–28 行），使用另一个循环来写入“总计”行。
- en: Note that we give our value cells IDs of the form **R*****x*****C*****y***,
    where **x** is the row and **y** is the column in which the cell is located. The
    summary rows or columns have IDs of the form **SUM_R*****x*** or **SUM_C*****y***.
    This type of systematic ID composition will allow us to easily access the individual
    cells.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们给值单元格分配了类似 **R*****x*****C*****y*** 的 ID，其中 **x** 是行号，**y** 是单元格所在的列号。汇总行或列的
    ID 采用 **SUM_R*****x*** 或 **SUM_C*****y*** 的形式。这种系统化的 ID 组成方式将使我们能够轻松访问各个单元格。
- en: 'The form elements in lines 29/30 also help us here: They are of type **hidden**
    and are ultimately nothing more than a hidden repository for information. We store
    the number of rows and columns here to be able to access them later when summing.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第29/30行中的表单元素也在这里帮助我们：它们的类型是**hidden**，最终它们只是信息的隐藏存储库。我们将行数和列数存储在这里，以便在求和时可以稍后访问它们。
- en: The summation is handled by the **calculate()** function, which the user can
    trigger via the button we create in line 33\. Alternatively, you can attach the
    function as an event handler to the **change** or **input** events of the individual
    cell input fields; to do this, you only need to supply the **onchange** or **oninput**
    property of the respective input element with a reference to the **calculate()**
    functions in line 13 (try it out!)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 求和由**calculate()**函数处理，用户可以通过我们在第33行创建的按钮触发该函数。或者，你可以将该函数作为事件处理程序附加到各个单元格输入字段的**change**或**input**事件上；为此，你只需在相应输入元素的**onchange**或**oninput**属性中提供对第13行**calculate()**函数的引用（试试看！）
- en: 'The code of the **calculate()** function looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**calculate()**函数的代码如下所示：'
- en: 1 **function** calculate() {2 **var** num_rows =Number(document.getElementById('nrows').value);3
    **var** num_columns =Number(document.getElementById('ncolumns').value);4 **var**
    i, f, sum, sum_column;56 *// Calculate row sums*7 **for**(i = 1; i <= num_rows;
    i++) {8 sum_cell = document.getElementById('SUM_R' + i);9 sum = 0;10 **for**(f
    = 1; f <= num_columns; f++) {11 sum = sum +Number(document.getElementById('R'
    + i + 'C'+ f).value);12 }13 sum_cell.value = sum;14 }1516 // Calculate column
    sums17 **for**(f = 1; f <= num_columns; f++) {18 sum_cell = document.getElementById('SUM_C'
    + f);19 sum = 0;20 **for**(i = 1; i <= num_rows; i++) {21 sum = sum +Number(document.getElementById('R'
    + i + 'C'+ f).value);22 }23 sum_cell.value = sum;24 }25 }
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 1 **function** calculate() {2 **var** num_rows = Number(document.getElementById('nrows').value);3
    **var** num_columns = Number(document.getElementById('ncolumns').value);4 **var**
    i, f, sum, sum_column;56 *// 计算行总和*7 **for**(i = 1; i <= num_rows; i++) {8 sum_cell
    = document.getElementById('SUM_R' + i);9 sum = 0;10 **for**(f = 1; f <= num_columns;
    f++) {11 sum = sum + Number(document.getElementById('R' + i + 'C' + f).value);12
    }13 sum_cell.value = sum;14 }1516 // 计算列总和17 **for**(f = 1; f <= num_columns;
    f++) {18 sum_cell = document.getElementById('SUM_C' + f);19 sum = 0;20 **for**(i
    = 1; i <= num_rows; i++) {21 sum = sum + Number(document.getElementById('R' +
    i + 'C' + f).value);22 }23 sum_cell.value = sum;24 }25 }
- en: '**calculate()** first queries the row and column counts from our two **hidden**
    form elements (lines 2 and 3). Then we calculate the row totals (lines 7–14) and
    column totals (lines 17–24). We take advantage of the fact that the IDs of the
    value cells have the form **R*****x*****C*****y*** and the cells of the sum rows
    and columns have IDs of the form **SUM_R*****x*** and **SUM_C*****y***, respectively.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**calculate()**首先从我们的两个**hidden**表单元素中查询行数和列数（第2行和第3行）。然后，我们计算行总和（第7-14行）和列总和（第17-24行）。我们利用了这样一个事实：数值单元格的ID形式为**R*****x*****C*****y***，而行和列总和单元格的ID形式分别为**SUM_R*****x***和**SUM_C*****y***。'
- en: In the case of row totals, for example, we go through all rows with the help
    of a **for** loop (line 7) and first select the respective cell of the “Totals”
    column (line 8). Afterwards, we only have to go through the individual value columns
    (row 10), add the contained numbers (line 11) and write the sum into the corresponding
    sum cell of this table row (row 13).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以行总和为例，我们通过**for**循环（第7行）遍历所有行，并首先选择“总和”列的相应单元格（第8行）。然后，我们只需要遍历各个数值列（第10行），加上其中的数字（第11行），并将总和写入该表格行的对应总和单元格（第13行）。
- en: 35.1 [10 min]What do two **for** loops look like that output our array **friends**
    to the console, where
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 35.1 [10分钟]如果输出我们的数组**friends**到控制台，两个**for**循环应该是什么样子的？
- en: a loop displays only every second entry
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个循环仅显示每隔一个的条目
- en: the other loop displays each entry, but proceeds from back to front?
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个循环显示每个条目，但是从后往前进行的？
- en: 35.2 [60 min]
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 35.2 [60分钟]
- en: Develop an application in which the user can first specify a color based on
    its red, green and blue components using sliders. Based on this color, a shading
    table is then to be expanded in such a way that each of the table cells shows
    a different color. In the horizontal the red and in the vertical the blue parts
    are to be increased in a total of 10 steps up to 255 (the maximum according to
    the RGB scheme). The green portion remains fixed at the value set by the user.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个应用程序，用户可以首先通过滑动条根据红色、绿色和蓝色分量指定一个颜色。根据此颜色，阴影表格将被扩展，以使每个表格单元显示不同的颜色。在水平方向上，红色部分增加，在垂直方向上，蓝色部分增加，共有10步，直到255（根据RGB方案的最大值）。绿色部分保持用户设置的值不变。
- en: The shading table should update automatically when the user moves one of the
    sliders.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户移动任一滑块时，阴影表应自动更新。
- en: Your finished application might then look like ◘ Fig. [35.2](#Fig2).![](../images/474412_1_En_35_Chapter/474412_1_En_35_Fig2_HTML.jpg)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你完成的应用程序可能看起来像图◘[35.2](#Fig2)。![](../images/474412_1_En_35_Chapter/474412_1_En_35_Fig2_HTML.jpg)
- en: A screenshot of the shading table in 10 columns and 10 rows of cells with multiple
    shades of colors. 3 sliders for red, green, and blue are above the table.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含10列10行单元格并有多种颜色阴影的阴影表截图。表格上方有三个滑块，分别用于红色、绿色和蓝色。
- en: Fig. 35.2
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 35.2
- en: Shading table in the exercise application
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 练习应用中的阴影表
- en: 'Some tips:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一些提示：
- en: Use the **toString()** method of the **Number** object to convert a decimal
    number to a hexadecimal number, which you need to display as an RGB color value
    in HTML-standard format **#RRGGBB**. As argument, **toString()** takes the base
    of the number system to convert to, which is **16** for hexadecimal numbers.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Number**对象的**toString()**方法将十进制数转换为十六进制数，这在HTML标准格式**#RRGGBB**中显示为RGB颜色值。**toString()**方法的参数是要转换的数字系统的基数，对于十六进制数来说是**16**。
- en: Remember that with the format **#RRGGBB** there must always be two digits per
    color part! Numbers smaller than 16 lead to *one-digit* hexadecimal numbers. These
    must then be preceded by a 0.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，使用格式**#RRGGBB**时，每个颜色部分必须始终有两个数字！小于16的数字会导致*一位数*的十六进制数。这些必须在前面加上0。
- en: The color components you calculate must be integers. To be on the safe side,
    round them with the **Math.floor(number)** function. This function returns the
    next smaller integer to the number passed as argument.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你计算的颜色组件必须是整数。为了确保安全，使用**Math.floor(number)**函数将其四舍五入。该函数会返回传入参数的下一个更小的整数。
- en: 35.1.2 for-Loop with Object Run Variable (for…of)
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 35.1.2 使用对象运行变量的for-循环（for…of）
- en: The second form of **for-loops** known to JavaScript does not count up or down
    a numeric run variable but runs through a set of objects; the content of the run
    variable is then the object to which the respective loop pass applies.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中已知的**for-loops**的第二种形式并不对数值型运行变量进行增减，而是遍历一组对象；此时，运行变量的内容就是相应循环迭代的对象。
- en: 'With this, the example from the previous section can then be written like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，上一节的示例可以这样写：
- en: '**>** friends = [**''**Peter**''**, **''**Sophie**''**, **''**Helen**''**,
    ''Mike**''**, **''**Mohamed**''**]**>** i = 0;for(myfriend of friends) {i++;console.log(**''**Friend
    no. **''**, i, **''**:**''**, myfriend)}'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**>** friends = [**''**Peter**''**, **''**Sophie**''**, **''**Helen**''**,
    ''Mike**''**, **''**Mohamed**''**]**>** i = 0;for(myfriend of friends) {i++;console.log(**''**Friend
    no. **''**, i, **''**:**''**, myfriend)}'
- en: We need to increment the variable **i** ourselves here. It is not the run variable
    of the loop (that is **myFriend**) but serves us here only to generate a consecutive
    number for our console output.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要手动增加变量**i**。它不是循环的运行变量（运行变量是**myFriend**），而仅仅作为我们在控制台输出时生成连续编号的工具。
- en: 'This will give you the following output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: 'Friend no. 1 : PeterFriend no. 2 : SophieFriend no. 3 : HellenFriend no. 4
    : MikeFriend no. 5 : Fatih'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'Friend no. 1 : PeterFriend no. 2 : SophieFriend no. 3 : HellenFriend no. 4
    : MikeFriend no. 5 : Fatih'
- en: 'Thus, the general form of the **for-of** loop is:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**for-of**循环的一般形式是：
- en: '***for***(runVariable of iterableObject) {*// Code block that is repeated*}'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '***for***(runVariable of iterableObject) {*// 这是重复的代码块*}'
- en: The *iterable object* we are iterating through here is an array. Other objects
    can also be iterable; for example, an object representing an address could be
    made so that its properties (such as the street name, house number, and zip code)
    are iterable and could therefore be traversed using a **for-of** loop. What this
    requires, however, is beyond entry-level JavaScript and thus beyond our scope
    here.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此遍历的*可迭代对象*是一个数组。其他对象也可以是可迭代的；例如，表示地址的对象可以使其属性（如街道名称、门牌号和邮政编码）变为可迭代的，从而能够通过**for-of**循环进行遍历。然而，要实现这一点，需要超出初级JavaScript的范围，因此不在我们本节的讨论范围内。
- en: 'By the way, strings, which can also be accessed in array notation (► Sect.
    [31.​4](474412_1_En_31_Chapter.xhtml#Sec10)), are also iterable objects and can
    be traversed with **for-of** loops:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，字符串（也可以用数组表示法访问，► 第[31.4](474412_1_En_31_Chapter.xhtml#Sec10)节）也是可迭代对象，可以通过**for-of**循环进行遍历：
- en: '**for**(character of **''**Hello World!**''**) {console.log(character);}'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**for**(character of **''**Hello World!**''**) {console.log(character);}'
- en: Note that when passing through the **for-of** loop, the run variable is not
    simply a *copy* of the element of our iterable object to which the current loop
    pass applies. It is, in effect, *the element itself*. Changes you make to the
    run variable in its **for-of** loop therefore affect the object being iterated
    through!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在通过**for-of**循环时，运行变量并不仅仅是我们可迭代对象元素的*副本*，它实际上就是*元素本身*。因此，在**for-of**循环中对运行变量所做的更改会影响正在被迭代的对象！
- en: 35.2 Conditional Loops (while and do-while)
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 35.2 条件循环（while和do-while）
- en: With the **while** as well as the **do-while** loop, JavaScript has two conditional
    loops. The **while** loop is *head-controlled*, i.e., the condition is checked
    at the beginning of the loop and the loop is therefore not run at all if the condition
    is not fulfilled right from the start. **d****o-while** is a *foot-controlled*
    loop. It runs at least once in any case; at the end of the first run. The condition
    is checked to determine whether the loop should run a second time, and for each
    subsequent loop.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**while**和**do-while**循环，JavaScript有两种条件循环。**while**循环是*头控型*的，也就是说，条件在循环开始时就会被检查，因此如果条件从一开始就没有满足，循环根本不会执行。**do-while**是*尾控型*循环。无论如何，它至少会执行一次；在第一次执行结束后，会检查条件是否满足以决定循环是否应该第二次执行，并在每次后续循环中如此。
- en: 'The two loops generally have the following structure:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个循环通常具有以下结构：
- en: '**while**(*condition*) {*// Code block that is repeated*}and**do** {*// Code
    block that is repeated*}**while**(*condition*)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**while**(*condition*) {*// 重复的代码块*}and**do** {*// 重复的代码块*}**while**(*condition*)'
- en: 'The output of our **friends** array from the previous section would be achieved
    with a **while** loop, for example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中得到的**friends**数组输出可以通过**while**循环来实现，例如：
- en: '**>** friends = [**''**Peter**''**, **''**Sophie**''**, **''**Helen**''**,
    ''Mike**''**, **''**Mohamed**''**]**>** i = 0;while(i <= friends.length - 1) {console.log(**''F**riend
    no. **''**, i+1, **''**: **''**, friends[i]);i = i + 1;}'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**>** friends = [**''**Peter**''**, **''**Sophie**''**, **''**Helen**''**,
    ''Mike**''**, **''**Mohamed**''**]**>** i = 0;while(i <= friends.length - 1) {console.log(**''F**riend
    no. **''**, i+1, **''**: **''**, friends[i]);i = i + 1;}'
- en: 'A formulation with **do-while** might look like this instead:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**do-while**的表达式可能看起来是这样的：
- en: i = 0;**do** {console.log('Friend no. **'**, i+1, **'**:**'**, friends[i]);i
    = i + 1;}**while**(i <= friends.length - 1)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0;**do** {console.log('Friend no. **'**, i+1, **'**:**'**, friends[i]);i
    = i + 1;}**while**(i <= friends.length - 1)
- en: '**do-while** loops should only be used if you can safely assume that the loop’s
    run condition will be satisfied on the first pass; here, that’s not a problem
    because we know we don’t have an empty array in front of us.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**do-while**循环应该仅在你可以安全地假设循环的运行条件在第一次迭代时就会满足时使用；在这里，这不是问题，因为我们知道前面没有一个空数组。'
- en: 'In our example, we have used **while** and **do-while** loops to solve a task
    for which one would normally use a **for** loop, since the number of runs can
    easily be determined with the help of the **length** property of the array. Conditional
    loops are normally used when the execution depends on a general condition and
    the number of passes cannot necessarily be determined in advance. However, our
    example nicely illustrates a principle that we encountered earlier: Any problem
    that can be solved with a counting loop can also be solved with a conditional
    loop, because when in doubt, you can also check as a condition the value of a
    numeric run variable that you manually increment, just as we did in our example.
    In this sense, the *counting* loop is a special form of the *conditional loop*,
    namely one whose condition checks a run variable, which the counting loop kindly
    also takes care of initializing and incrementing.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用了**while**和**do-while**循环来解决一个通常会使用**for**循环的任务，因为循环次数可以通过数组的**length**属性轻松确定。条件循环通常在执行依赖于一般条件且循环次数不能提前确定的情况下使用。然而，我们的例子很好地说明了我们之前遇到的一个原则：任何可以通过计数循环解决的问题，也可以通过条件循环来解决，因为在不确定的情况下，你也可以将一个数值运行变量的值作为条件进行检查，正如我们在例子中所做的那样。从这个意义上说，*计数*循环是一种特殊形式的*条件循环*，即其条件检查一个运行变量，而计数循环恰好负责初始化并递增该变量。
- en: 35.3 [10 min]Write two more versions of the **while** loop from this section
    that outputs our array **friends** to the console, where
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 35.3 [10 min] 编写另外两个版本的**while**循环，将此节中的**friends**数组输出到控制台，其中
- en: (a)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (a)
- en: Once the “run variable” **i** is initialized with 1 (instead of 0)
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦“运行变量”**i**初始化为1（而不是0）
- en: (b)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (b)
- en: The less-than operator is used in the condition (instead of the less-than-equal
    operator).
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 条件中使用的是小于操作符，而不是小于等于操作符。
- en: 35.4 [30 min]
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 35.4 [30 分钟]
- en: Develop a function **countCells()** that optionally counts the rows or the columns
    of the table that our spreadsheet application creates from ► Sect. [35.1.1](#Sec2).
    Use a **while** loop to step through the IDs of the cells. Take advantage of the
    fact that the **document.getElementById()** function returns **null** if an element
    with the specified ID could not be found.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个函数**countCells()**，该函数可选地计算我们的电子表格应用程序根据►节[35.1.1](#Sec2)创建的表格的行或列。使用**while**循环遍历单元格的ID。利用**document.getElementById()**函数的特点，如果找不到具有指定ID的元素，它会返回**null**。
- en: The function you develop here could be used by our **calculate()** function
    to get the number of rows and columns, if we didn’t “cache” it as information
    using **hidden** elements directly in the page source of the HTML document.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里开发的函数可以被我们的**calculate()**函数用来获取行和列的数量，前提是我们没有通过在HTML文档的页面源代码中使用**hidden**元素将其“缓存”。
- en: 35.3 Summary
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 35.3 总结
- en: In this chapter, we saw how to repeat code in JavaScript using counting (**for**,
    **for-of**) and conditional (**while**, **do-while**) loops.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用计数（**for**，**for-of**）和条件（**while**，**do-while**）循环在JavaScript中重复代码。
- en: 'Be sure to take the following points from this chapter:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保从本章中记住以下要点：
- en: In JavaScript, counting for **loops** have the form **for(*****initialization*****;**
    ***check*****;** ***increment*****) {** ***statements*** **}**. Here, a numeric
    run variable initialized to a value at the beginning is changed before each loop
    pass according to an increment statement and checked whether the new value satisfies
    a check condition. If this is the case, the following block of statements is run
    through, but if this is not the case, program execution continues after the loop
    and the run variable retains its value from before the last increment.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript中，计数循环的形式为**for(*****initialization*****;** ***check*****;** ***increment*****)
    {** ***statements*** **}**。这里，初始化为某个值的数字型运行变量在每次循环之前根据递增语句进行改变，并检查新值是否满足检查条件。如果满足条件，则执行后续的语句块；如果不满足条件，则程序继续执行循环后的代码，运行变量保持在上次递增前的值。
- en: The run variable can also be decreased, i.e., the run variable becomes smaller
    with each loop pass.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行变量也可以减少，即，随着每次循环运行，运行变量变小。
- en: Increases and decreases by one can be implemented with the increment operator
    **++** and the decrement operator **--** in the form **variable++** or **variable--**.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递增和递减操作可以通过递增操作符**++**和递减操作符**--**来实现，形式为**variable++**或**variable--**。
- en: A **for-of** loop of the form **for(*****runVariable*** **of** ***iterableObject*****)
    {** ***statements*** **}** can be used to iterate through objects whose elements
    are iterable, i.e. they can be put into any kind of order by JavaScript, such
    as arrays. In this case, the run variable is not a numeric value, but the element
    of the iterable object to which the current loop pass applies. Changes to the
    run variable affect the iterable object whose elements are being iterated through.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形式为**for(*****runVariable*** **of** ***iterableObject*****) {** ***statements***
    **}**的**for-of**循环可以用来遍历那些其元素是可迭代的对象，即它们可以被JavaScript以任何顺序排列的对象，比如数组。在这种情况下，运行变量不是数值，而是当前循环迭代应用的可迭代对象的元素。对运行变量的更改会影响正在遍历的可迭代对象。
- en: Conditional loops can be either head-driven in the form **while(*****condition*****)
    {** ***statements*** **}** or footer-driven with **do {** ***statements*** **}
    while(*****condition*****)**. Loops of the latter type are run at least once because
    the condition is not checked until the end.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件循环可以是头驱动的，形式为**while(*****condition*****) {** ***statements*** **}**，也可以是尾驱动的，形式为**do
    {** ***statements*** **} while(*****condition*****)**。后一种类型的循环至少执行一次，因为条件检查是在循环结束后进行的。
- en: 35.4 Solutions to the Exercises
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 35.4 练习解答
- en: Exercise 35.1
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 35.1
- en: 'A loop that displays only every second entry from the array might look like
    this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 只显示数组中每隔一个元素的循环可能如下所示：
- en: '**for**(i = 0;i <= friends.length-1; i=i+2) {console.log(**''**Friend no. **''**,
    i+1, **''**:**''**, friends[i]);}'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**for**(i = 0; i <= friends.length-1; i=i+2) {console.log(**''**Friend no.
    **''**, i+1, **''**:**''**, friends[i]);}'
- en: 'A loop that proceeds from back to front when displaying the array entries might
    look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个从后向前遍历数组条目的循环可能如下所示：
- en: '**for**(i = friends.length-1; i >= 0; i--) {console.log(**''F**riend no. **''**,
    i+1, **''**:**''**, friends[i]);}Exercise 35.2'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**for**(i = friends.length-1; i >= 0; i--) {console.log(**''F**riend no. **''**,
    i+1, **''**:**''**, friends[i]);} 练习 35.2'
- en: 'The interface of our shading table application could be designed in HTML code
    like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的阴影表格应用程序的界面可以像这样用 HTML 代码设计：
- en: '**<!DOCTYPE html>****<html>****<head>****<title>**Color Table**</title>****<noscript>**Please
    activate JavaScript!**</noscript>****</head>****<body>****<script** src="colortable.js"**></script>****<form>**<**p>**Red:
    **<input** id="red" type="range" min=0max=255 value="0" onchange="colorsNew()"**><p>****<p>**Green:
    **<input** id="green" type="range" min=0max=255 value="0" onchange="colorsNew()"**><p>****<p>**Blue:
    **<input** id="blue" type="range" min=0max=255 value="0" onchange="colorsNew()"**><p>****</form>****<table**
    id="colortable"**>****</table>****</body>****</html>**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**<!DOCTYPE html>****<html>****<head>****<title>**色彩表格**</title>****<noscript>**请启用
    JavaScript！**</noscript>****</head>****<body>****<script** src="colortable.js"**></script>****<form>**<**p>**红色：**<input**
    id="red" type="range" min=0max=255 value="0" onchange="colorsNew()"**><p>****<p>**绿色：**<input**
    id="green" type="range" min=0max=255 value="0" onchange="colorsNew()"**><p>****<p>**蓝色：**<input**
    id="blue" type="range" min=0max=255 value="0" onchange="colorsNew()"**><p>****</form>****<table**
    id="colortable"**>****</table>****</body>****</html>**'
- en: 'For this purpose, the JavaScript file **colortable.js**:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为此目的，JavaScript 文件**colortable.js**：
- en: '**function** colorsNew() {**var** colorRed = Number(document.getElementById(''red'').value);**var**
    colorGreen = Number(document.getElementById(''green'').value);**var** colorBlue
    = Number(document.getElementById(''blue'').value);**var** tab = document.getElementById(''colortable'');**var**
    i,f, colorValue, stepRed, stepBlue;stepRed = Math.floor((255-colorRed)/10);stepBlue
    = Math.floor((255-colorBlue)/10);tableHTML = "";**for**(i = 1; i <= 10; i**++**){tableHTML
    = tableHTML + ''<tr>'';**for**(f = 1; f <= 10; f**++**) {colorRedNew = (colorRed
    + i*stepRed).toString(16);colorGreenNew = colorGreen.toString(16);colorBlueNew
    = (colorBlue + f*stepBlue).toString(16);if(colorRedNew.length == 1)colorRedNew
    = ''0'' + colorRedNew;if(colorGreenNew.length == 1)colorGreenNew = ''0'' + colorGreenNew;if(colorBlueNew.length
    == 1)colorBlueNew = ''0'' + colorBlueNew;colorVal = "#" + colorRedNew + colorGreenNew
    + colorBlueNew;tableHTML = tableHTML + ''<td style="background-color: '' +colorValue
    + ''; color: '' + colorValue + ''">xxxx</td>'';}tableHTML = tableHTML + ''</tr>'';}tab.innerHTML
    = tableHTML;}Exercise 35.3'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**function** colorsNew() {**var** colorRed = Number(document.getElementById(''red'').value);**var**
    colorGreen = Number(document.getElementById(''green'').value);**var** colorBlue
    = Number(document.getElementById(''blue'').value);**var** tab = document.getElementById(''colortable'');**var**
    i,f, colorValue, stepRed, stepBlue;stepRed = Math.floor((255-colorRed)/10);stepBlue
    = Math.floor((255-colorBlue)/10);tableHTML = "";**for**(i = 1; i <= 10; i**++**){tableHTML
    = tableHTML + ''<tr>'';**for**(f = 1; f <= 10; f**++**) {colorRedNew = (colorRed
    + i*stepRed).toString(16);colorGreenNew = colorGreen.toString(16);colorBlueNew
    = (colorBlue + f*stepBlue).toString(16);if(colorRedNew.length == 1)colorRedNew
    = ''0'' + colorRedNew;if(colorGreenNew.length == 1)colorGreenNew = ''0'' + colorGreenNew;if(colorBlueNew.length
    == 1)colorBlueNew = ''0'' + colorBlueNew;colorVal = "#" + colorRedNew + colorGreenNew
    + colorBlueNew;tableHTML = tableHTML + ''<td style="background-color: '' +colorValue
    + ''; color: '' + colorValue + ''">xxxx</td>'';}tableHTML = tableHTML + ''</tr>'';}tab.innerHTML
    = tableHTML;}练习 35.3'
- en: (a)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (a)
- en: 'A **while** loop that goes through the array and starts at 1:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个**while**循环，遍历数组并从1开始：
- en: i = 1;**while**(i <= friends.length) {console.log(**'**Friend no. **'**, i,
    **'**:**'**, friends[i-1]);i = i + 1;}
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: i = 1;**while**(i <= friends.length) {console.log(**'**Friend no. **'**, i,
    **'**:**'**, friends[i-1]);i = i + 1;}
- en: (b)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (b)
- en: 'A **while** loop that traverses the array and uses the less operator in the
    run condition:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个**while**循环，遍历数组并在运行条件中使用小于运算符：
- en: i = 0;**while**(i < friends.length) {console.log(**'F**riend no. **'**, i+1,
    **'**:**'**, friends[i]);i = i + 1;}Exercise 35.4
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0;**while**(i < friends.length) {console.log(**'F**riend no. **'**, i+1,
    **'**:**'**, friends[i]);i = i + 1;}练习 35.4
- en: 'The function **countCells()** could look like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 函数**countCells()**可以如下所示：
- en: '**function** countCells(columnRow = ''column'') {**var** num = 0;**var** id;**do**
    {num = num + 1;**if**(columnRow == ''column'') {id = ''R1C'' + num;}**else** {id
    = ''R'' + num + ''C1'';}}**while**(document.getElementById(id) != **null**)**return**
    num - 1;}'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**function** countCells(columnRow = ''column'') {**var** num = 0;**var** id;**do**
    {num = num + 1;**if**(columnRow == ''column'') {id = ''R1C'' + num;}**else** {id
    = ''R'' + num + ''C1'';}}**while**(document.getElementById(id) != **null**)**return**
    num - 1;}'
- en: We work here with an argument **columnRow**, which has the default value "**column"**
    and specifies whether the number of columns or rows is to be returned. The number
    is then determined by composing cell IDs in a **do-while** loop (we assume here
    that at least one column or row exists, so that we can also test the run condition
    of the loop at the end) and attempting to select these cells with **getElementById()**.
    If this fails because the cell does not exist, **getElementById()** returns **null**
    and the loop ends. The number of rows/columns **num** incremented in the loop
    is then the return value of the function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用一个参数**columnRow**，其默认值为"**column**"，用于指定是返回列数还是行数。然后，通过在**do-while**循环中组合单元格ID来确定数量（我们假设至少存在一列或一行，这样我们也可以在循环结束时测试循环的运行条件），并尝试使用**getElementById()**选择这些单元格。如果失败了，因为单元格不存在，**getElementById()**将返回**null**，并且循环结束。在循环中递增的行/列数**num**将是函数的返回值。
