- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024 J. L. Zuckarelli Learn coding with Python and JavaScript
    [`https://doi.org/10.1007/978-3-658-42912-6_15`](https://doi.org/10.1007/978-3-658-42912-6_15)
  id: totrans-0
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: © 作者（们），独家授权给Springer Fachmedien Wiesbaden GmbH，Springer Nature的一部分，2024年J.
    L. Zuckarelli《学习Python和JavaScript编程》 [`https://doi.org/10.1007/978-3-658-42912-6_15`](https://doi.org/10.1007/978-3-658-42912-6_15)
- en: '`15. Loops: How Do I Repeat Program Instructions Efficiently?`'
  id: totrans-1
  prefs:
  - PREF_H1
  stylish: true
  type: TYPE_NORMAL
  zh: '`15. 循环：如何高效地重复程序指令？`'
- en: Joachim L. Zuckarelli^([1](#Aff2) )(1) München, Germany Overview
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: Joachim L. Zuckarelli^([1](#Aff2) )(1) 德国慕尼黑 概述
- en: Practically all programming languages use loops to execute similar parts of
    the code several times in succession. This not only saves a lot of manual and
    error-prone work, but also allows you to write code that you don't know in advance
    how often it will be executed. With the help of loops you can elegantly implement
    the repetition of program statements.
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 几乎所有编程语言都使用循环来连续执行相似的代码部分。这不仅节省了大量的手工和容易出错的工作，还能让你编写不清楚事先会执行多少次的代码。在循环的帮助下，你可以优雅地实现程序语句的重复执行。
- en: 'In this chapter you will learn the following:'
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 本章你将学到以下内容：
- en: What loops are, and how they differ from functions, which can also be used to
    execute program code repeatedly
  id: totrans-5
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 循环是什么，以及它们如何与函数不同，后者也可以用来重复执行程序代码
- en: What the difference is between counting and conditional loop constructs
  id: totrans-6
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 计数循环和条件循环结构之间有什么区别
- en: How to develop a counting loop, and what role the `run variable` plays in it
  id: totrans-7
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何开发一个计数循环，以及`run variable`在其中扮演什么角色
- en: How to program a conditional loop and what the difference is between the condition
    check at the beginning (`head control`) and at the end of the loop (`foot control`)
  id: totrans-8
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何编写条件循环，以及循环开始时（`头部控制`）和循环结束时（`尾部控制`）条件检查的区别
- en: How to end loops prematurely or continue with the next loop pass.
  id: totrans-9
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何提前结束循环或继续执行下一次循环。
- en: '`15.1 Loops and Their Variants`'
  id: totrans-10
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`15.1 循环及其变体`'
- en: '`Loops versus Functions`'
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`循环与函数`'
- en: 'Essentially, there are two ways to repeat program code that you have written
    once: You can swap it out into functions/procedures that can be called again.
    We have already looked at how this works in ► Chap. [`12`](474412_1_En_12_Chapter.xhtml).
    Or you can wrap the code to be repeated in so-called `loops.` This is exactly
    what this chapter is about.'
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 本质上，有两种方法可以重复你编写的程序代码：你可以将其封装到可以重新调用的函数/过程里。我们已经在►第[`12`](474412_1_En_12_Chapter.xhtml)章中了解了这种方法是如何工作的。或者，你可以将要重复的代码封装在所谓的`循环`中。这正是本章讨论的内容。
- en: The difference between the two approaches is that with loops, the same program
    code is run through and executed `directly several times in succession.` For example,
    you could go through a product price list line by line, product by product, and
    increase the price of all products that belong to a certain category by 10%. The
    use case for functions, though, is different; here, it is not a matter of repeating
    a certain part of the program `several times in immediate succession,` but of
    making the program code independent to such an extent that it can be called from
    `different places in the program at` any time.
  id: totrans-13
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这两者之间的区别在于，使用循环时，相同的程序代码会被直接连续执行`多次`。例如，你可以逐行、逐个产品地遍历产品价格列表，并将属于某一类别的所有产品价格提高10%。而函数的使用情况则不同；这里并非重复程序的某一部分`多次连续`执行，而是将程序代码独立化，以便可以在程序的`不同地方随时调用`。
- en: 这两种重复方法的共同点在于，这样可以避免在程序中多次编写相同的程序代码。这提高了程序的可维护性，因为对要重复的部分只需进行一次更改。另一种选择是在每个需要使用它的地方重复程序代码（而不是调用函数）或多次连续重复（而不是使用循环），结果是你必须在程序中每个出现的地方都对这段代码进行更改。这既繁琐又容易出错。在循环的情况下，另一个问题是，在编写程序时，通常你甚至不知道确切需要多少次重复代码。想想你要遍历的产品列表，以便将特定类别中所有产品的价格提高`10%`。在编写程序时，你可能不知道这个列表将包含多少个产品！如果第`79`个产品因为种类扩展而突然添加到现有的`78`个产品中会发生什么？循环在这里提供了一个解决方案。
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这两种重复方法的共同点在于，这样可以避免在程序中多次编写相同的程序代码。这提高了程序的可维护性，因为对要重复的部分只需进行一次更改。另一种选择是在每个需要使用它的地方重复程序代码（而不是调用函数）或多次连续重复（而不是使用循环），结果是你必须在程序中每个出现的地方都对这段代码进行更改。这既繁琐又容易出错。在循环的情况下，另一个问题是，在编写程序时，通常你甚至不知道确切需要多少次重复代码。想想你要遍历的产品列表，以便将特定类别中所有产品的价格提高`10%`。在编写程序时，你可能不知道这个列表将包含多少个产品！如果第`79`个产品因为种类扩展而突然添加到现有的`78`个产品中会发生什么？循环在这里提供了一个解决方案。
- en: 循环的类型
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 循环的类型
- en: 循环基本上有两种变体：要么是`counting loops`，要么是`conditional`循环。对于计数循环，从一开始就很清楚——至少在原则上——它们会被运行多少次。这种循环适合我们处理产品列表的问题。我们应该能够轻松确定此列表上有多少个产品。但我们也知道运行一次完整的产品列表所需的循环次数。
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 循环基本上有两种变体：要么是`计数循环`，要么是`条件`循环。对于计数循环，从一开始就很清楚——至少在原则上——它们会被运行多少次。这种循环适合我们处理产品列表的问题。我们应该能够轻松确定此列表上有多少个产品。但我们也知道运行一次完整的产品列表所需的循环次数。
- en: 对于条件循环，想象以下场景：我们有一个程序，将用户输入的开尔文温度值转换为摄氏度。开尔文的温度始终大于或等于`0`。零开尔文是绝对零度，没有任何热量，它永远不能更冷；这个绝对零度对应于摄氏温度表上的`-273.15
    °C`。用户需要一个接一个地输入开尔文温度。每个开尔文温度都会转换为摄氏度。如果用户在任何时候输入负的开尔文温度，程序应该终止。这里使用循环是个好主意，因为从开尔文到摄氏度的转换过程总是相同的。然而，在这种情况下，我们无法事先知道将会有多少次循环。这取决于用户的输入。这里的选择是一个`conditional`循环，即只要满足某个条件，循环就会继续运行；在我们这里的例子中，条件是用户输入的温度大于或等于`0`。一旦用户输入了一个负温度，条件将不再满足，循环将停止。
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 对于条件循环，想象以下场景：我们有一个程序，将用户输入的开尔文温度值转换为摄氏度。开尔文的温度始终大于或等于`0`。零开尔文是绝对零度，没有任何热量，它永远不能更冷；这个绝对零度对应于摄氏温度表上的`-273.15
    °C`。用户需要一个接一个地输入开尔文温度。每个开尔文温度都会转换为摄氏度。如果用户在任何时候输入负的开尔文温度，程序应该终止。这里使用循环是个好主意，因为从开尔文到摄氏度的转换过程总是相同的。然而，在这种情况下，我们无法事先知道将会有多少次循环。这取决于用户的输入。这里的选择是一个`conditional`循环，即只要满足某个条件，循环就会继续运行；在我们这里的例子中，条件是用户输入的温度大于或等于`0`。一旦用户输入了一个负温度，条件将不再满足，循环将停止。
- en: '`15.2 Counting Loops`'
  id: totrans-18
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`15.2 计数循环`'
- en: 带有数字运行变量的循环
  id: totrans-19
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 带有数字运行变量的循环
- en: 'Counting loops are successive repetitions of program code, used where the number
    of repetitions can be determined in advance. But are the repetitions of the program
    code really absolutely identical? Let’s think back to the example of the product
    price list that we want to go through to make all products of a certain category
    10% more expensive. Now, if we found a product in the category and one of the
    previous products already belonged to the same category, is the code that is executed
    in both cases exactly the same? No, apparently not; for the price increase must
    be made once for one product and once for the other. So, the program code, similar
    as it is in both cases, must “refer” to a different product each time. Put another
    way: We need to know where exactly in our loop we currently are, i.e., which product
    is currently being processed.'
  id: totrans-20
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 计数循环是程序代码的连续重复，用于那些可以预先确定重复次数的情况。但是，程序代码的重复真的完全相同吗？让我们回想一下要处理的产品价格列表，我们希望将某个类别的所有产品价格提高10%。现在，如果我们找到了该类别中的一个产品，而之前的某个产品已经属于同一类别，那么在两种情况下执行的代码是否完全相同？显然不是；因为价格上涨必须分别对每个产品执行一次。因此，程序代码虽然在两种情况下相似，但每次必须“引用”不同的产品。换句话说：我们需要知道在循环中的确切位置，即当前正在处理哪个产品。
- en: This is exactly what the `run variable` allows us to do. It is incremented by
    a certain value (usually one) with each loop pass. So, you always know which loop
    pass you are currently in. And we can use this variable in the program code that
    is repeated through our loop, for example to address the individual elements of
    a field that represents our product price list.
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这正是`run variable`允许我们做的事情。它在每次循环时按一定的值（通常为1）递增。所以，你总是知道当前是第几次循环。而且我们可以在程序代码中使用这个变量，代码会在循环中重复执行，例如用于处理表示产品价格列表的字段中的各个元素。
- en: 'Let’s take a closer look at the whole thing as pseudo-code:'
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们仔细看看整个过程，以下是伪代码：
- en: '`For p From 1 To length(products) Begin If products[p].category = "Garden Furniture"
    Then products[p].price = products[p].price * 1.1 End`'
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`For p From 1 To length(products) Begin If products[p].category = "Garden Furniture"
    Then products[p].price = products[p].price * 1.1 End`'
- en: In this example, we assume that `products` is a field of instances (i.e., objects)
    of the `Product` class that has the attributes `category` and `price` (scroll
    back to ► Sect. [11.​7](474412_1_En_11_Chapter.xhtml#Sec10) if you have forgotten
    or are vague about the concepts of “fields”, “classes” and “instances/objects”
    from object-oriented programming). The run variable in this example is the (integer)
    variable `p`. It runs, as the line `For p From 1 To length(products)` indicates,
    from the value 1 to the function value `length(products)`, which we want to assume
    represents the length of the field `products`, i.e. the number of products contained.
    With each loop pass, `p` is automatically increased by one. The program code to
    be repeated is located between the `Begin` and `End` keywords in a code block.
    We have already seen code blocks in connection with functions (► Sect. [13.​1](474412_1_En_13_Chapter.xhtml#Sec1))
    and If-Then constructs (► Sect. [14.​3](474412_1_En_14_Chapter.xhtml#Sec3)). The
    code, which is between `Begin` and `End`, is executed as long as the run variable
    `p` is less than or equal to the specified maximum value, in our case `length(products)`.
  id: totrans-24
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这个例子中，我们假设`products`是`Product`类实例（即对象）组成的字段，具有`category`和`price`属性（如果你忘记了或对面向对象编程中的“字段”、“类”和“实例/对象”的概念模糊不清，请回滚查看►
    第[11.7节](474412_1_En_11_Chapter.xhtml#Sec10)）。在这个例子中，运行变量是整数变量`p`。正如`For p From
    1 To length(products)`这一行所示，它从值1开始，到`length(products)`的函数值为止，我们假设它表示字段`products`的长度，即包含的产品数量。在每次循环中，`p`都会自动增加1。要重复的程序代码位于`Begin`和`End`关键字之间，构成一个代码块。我们在涉及函数（►
    第[13.1节](474412_1_En_13_Chapter.xhtml#Sec1)）和If-Then结构（► 第[14.3节](474412_1_En_14_Chapter.xhtml#Sec3)）时已经见过代码块。位于`Begin`和`End`之间的代码会在运行变量`p`小于或等于指定的最大值时执行，在我们这个例子中是`length(products)`。
- en: 我们现在在循环中使用`run`变量作为索引，访问当前循环周期中要处理的字段元素`products[p]`。在这里，你可以看到，尽管我们总是重复相同的代码，但每次执行的代码却有所不同，因为每个循环周期处理的是不同的产品对象，即相应的元素`products[p]`，因此，第一个循环周期处理的是`products[1]`，第二个处理的是`products[2]`，最后一个处理的是`products[length(products)]`。
  id: totrans-25
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们现在在循环中使用`run`变量作为索引，访问当前循环周期中要处理的字段元素`products[p]`。在这里，你可以看到，尽管我们总是重复相同的代码，但每次执行的代码却有所不同，因为每个循环周期处理的是不同的产品对象，即相应的元素`products[p]`，因此，第一个循环周期处理的是`products[1]`，第二个处理的是`products[2]`，最后一个处理的是`products[length(products)]`。
- en: 计数循环的遍历示意图见`◘ Fig. [15.1](#Fig1)`。![](../images/474412_1_En_15_Chapter/474412_1_En_15_Fig1_HTML.jpg)
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 计数循环的遍历示意图见`◘ 图 [15.1](#Fig1)`。![](../images/474412_1_En_15_Chapter/474412_1_En_15_Fig1_HTML.jpg)
- en: 计数循环的流程图。条件下输入一个递增的运行变量。将其分类为未满足和满足。满足的情况后，运行变量递增，循环表达式块，最后结束。
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 计数循环的流程图。条件下输入一个递增的运行变量。将其分类为未满足和满足。满足的情况后，运行变量递增，循环表达式块，最后结束。
- en: '`Fig. 15.1`'
  id: totrans-28
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`图 15.1`'
- en: 计数循环的流程图
  id: totrans-29
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 计数循环的流程图
- en: 对象运行变量的循环
  id: totrans-30
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 对象运行变量的循环
- en: 一些编程语言提供了计数循环的特殊变体，使得像我们上面的例子这样的任务变得更加简单。在这里，不是计数一个`run`变量，然后将其用作对象数组的索引，而是循环直接遍历对象数组，逐个处理数组中的每个单独对象。
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一些编程语言提供了计数循环的特殊变体，使得像我们上面的例子这样的任务变得更加简单。在这里，不是计数一个`run`变量，然后将其用作对象数组的索引，而是循环直接遍历对象数组，逐个处理数组中的每个单独对象。
- en: 这可能看起来像这样：
  id: totrans-32
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这可能看起来像这样：
- en: '`**For Each**` `p` `**In**` `products` `**Begin**` `**If**` `p.category = "Garden
    Furniture"` `**Then**` `p.price = p.price * 1.1` `**End**`'
  id: totrans-33
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`**For Each**` `p` `**In**` `products` `**Begin**` `**If**` `p.category = "Garden
    Furniture"` `**Then**` `p.price = p.price * 1.1` `**End**`'
- en: 这个在我们的伪代码中以关键字`**For Each**`引入的循环，简单地按顺序遍历字段`products`中的所有元素。每次循环时，当前字段元素存储在运行变量`p`中。注意与上面例子中的计数循环的区别：在这里，运行变量`p`不是一个表示循环已经运行多少次的数字，而是当前在循环焦点中的字段`products`的当前元素。
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这个在我们的伪代码中以关键字`**For Each**`引入的循环，简单地按顺序遍历字段`products`中的所有元素。每次循环时，当前字段元素存储在运行变量`p`中。注意与上面例子中的计数循环的区别：在这里，运行变量`p`不是一个表示循环已经运行多少次的数字，而是当前在循环焦点中的字段`products`的当前元素。
- en: 因此，在循环体内，即在循环重复的代码块中，当前对象`p`可以像产品对象一样被使用，例如，可以调整其属性。此时重要的是要理解，在大多数编程语言中，我们的变量`p`并不是字段`products`相应元素的*副本*，而最终是*元素本身*。听起来有些抽象，但这确实是一个关键区别：毕竟，如果`p`只是当前上升的`products`中特定元素的副本，那么我们对`p`所做的任何更改当然不会影响`products`中的真实元素；毕竟，我们只是在处理副本，而原始元素会保持不受我们更改的影响。但事实并非如此。实际上，`p`*就是*字段`products`中相应的元素。因此，对`p`所做的更改直接改变了我们字段`products`中的相应产品。
  id: totrans-35
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 因此，在循环体内，即在循环重复的代码块中，当前对象`p`可以像产品对象一样被使用，例如，可以调整其属性。此时重要的是要理解，在大多数编程语言中，我们的变量`p`并不是字段`products`相应元素的*副本*，而最终是*元素本身*。听起来有些抽象，但这确实是一个关键区别：毕竟，如果`p`只是当前上升的`products`中特定元素的副本，那么我们对`p`所做的任何更改当然不会影响`products`中的真实元素；毕竟，我们只是在处理副本，而原始元素会保持不受我们更改的影响。但事实并非如此。实际上，`p`*就是*字段`products`中相应的元素。因此，对`p`所做的更改直接改变了我们字段`products`中的相应产品。
- en: 'As you can see, this loop is a bit more elegant than the loop above. The only
    disadvantage here is: Without counting with the help of an extra variable, which
    we manually increase with each loop run, we now do not know how many runs of the
    loop have taken place so far. Our run variable is simply no longer a counter.
    However, if it is simply a matter of passing through the products in our `products`
    field in sequence, this need not be a disadvantage.'
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个循环比上面的循环要更优雅。唯一的缺点是：没有额外变量的帮助，我们无法知道循环已经执行了多少次，因为我们没有手动增加一个计数器。我们的运行变量简单地不再是一个计数器。然而，如果问题仅仅是按顺序遍历`products`字段中的产品，这并不一定是缺点。
- en: Examples in Different Programming Languages
  id: totrans-37
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 不同编程语言中的示例
- en: Let’s look at it in two concrete programming languages, PHP, which is specifically
    made for server-side programs and is used on most websites, and the Microsoft
    Office macro language VBA.
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们来看一下在两种具体的编程语言中如何实现这个问题，PHP专门用于服务器端程序，并且被大多数网站使用，另外一种是微软的Office宏语言VBA。
- en: 'First, here are the two loop variants in PHP:'
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 首先，下面是PHP中的两种循环变体：
- en: '`for` (`$p=0; $p <= count($produts)-1; $p++`) `{` `if` (`$products[$p]->category
    == "Garden Furniture"`) `$products[$p]->price = $producte[$p]->price * 1.1` `}`
    `foreach` (`$products` `as` `&$p`) `{` `if` (`$p->category == "Garden Furniture"`)
    `$p->price = $p->price * 1.1` `}`'
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`for` (`$p=0; $p <= count($produts)-1; $p++`) `{` `if` (`$products[$p]->category
    == "Garden Furniture"`) `$products[$p]->price = $producte[$p]->price * 1.1` `}`
    `foreach` (`$products` `as` `&$p`) `{` `if` (`$p->category == "Garden Furniture"`)
    `$p->price = $p->price * 1.1` `}`'
- en: The counting loop with numeric run variable is introduced here by the keyword
    `for`, the loop iterating through the field with `foreach`. These are the keywords
    used in most programming languages for these loop types.
  id: totrans-41
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 带有数字运行变量的计数循环在这里通过关键字`for`引入，循环通过`foreach`遍历字段。这些是大多数编程语言中用于这些循环类型的关键字。
- en: '`The` **for` loop contains three specifications in parentheses:'
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`The` **for** 循环包含三种括号中的规范：'
- en: '1.'
  id: totrans-43
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '1.'
- en: What the run variable is called (variable names are always prefixed with a dollar
    sign in PHP) and at what value it should start (fields start at index 0 by default
    in PHP, so the first element would be as `products[0]`).
  id: totrans-44
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 运行变量的名称（在PHP中，变量名总是以美元符号$开头）以及它应该从哪个值开始（PHP中，字段默认从索引0开始，因此第一个元素为`products[0]`）。
- en: '2.'
  id: totrans-45
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '2.'
- en: How long it should run; in our case as long as its value is less than or equal
    to the number of field elements (`count($products)`) minus 1; “minus 1” because
    indexing starts at 0. If the first field element has the index 0, then the last
    field element has the index `count($products)-1` (i.e., with 10 field elements,
    the index of the last one is 9).
  id: totrans-46
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 它应该运行多久；在我们的例子中，只要其值小于或等于字段元素的数量（`count($products)`）减去 1；“减去 1”是因为索引从 0 开始。如果第一个字段元素的索引是
    0，那么最后一个字段元素的索引就是 `count($products)-1`（即，如果有 10 个字段元素，最后一个的索引是 9）。
- en: '3.'
  id: totrans-47
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '3.'
- en: How it should be incremented; so far, we have assumed that the run variable
    is incremented by 1 with each loop pass. However, this does not necessarily have
    to be the case. For example, we could also just look at every second product;
    then the last part of the `for` statement would be `$p = $p + 2` (`$p++` is a
    shorthand for `$p = $p + 1`).
  id: totrans-48
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 如何递增它；到目前为止，我们假设每次循环执行时，run 变量递增 1。然而，这不一定是必须的。例如，我们也可以只看每隔一个产品；那么 `for` 语句的最后部分将是
    `$p = $p + 2`（`$p++` 是 `$p = $p + 1` 的简写）。
- en: In PHP, the attributes of an object are accessed with the help of the arrow
    operator (`->`). We had always used the dot for this in our pseudo-code so far.
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在 PHP 中，对象的属性是通过箭头操作符（`->`）访问的。到目前为止，我们在伪代码中一直使用的是点操作符。
- en: 'Another specific feature is found in the second loop variant, the `foreach`
    loop: Here, the element `$p` currently processed by the loop is named. However,
    this is preceded by an ampersand. This ensures that the variable `$p`, as we discussed
    above, actually represents the corresponding product object and not just a copy
    of the currently processed product object in the `products` field. If we were
    to forgo the ampersand, the assignment `$p->price = $p->price * 1.1` would merely
    process a copy of the object and not the object itself, which is part of our `products`
    field.'
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 另一个特定的特点出现在第二种循环变体——`foreach` 循环：在这里，循环当前处理的元素 `$p` 被命名。然而，这前面加了一个与符号。这确保了变量
    `$p`，如我们上面所讨论的，实际上表示的是相应的产品对象，而不仅仅是 `products` 字段中当前处理的产品对象的副本。如果我们不加与符号，那么赋值
    `$p->price = $p->price * 1.1` 仅会处理对象的副本，而不是对象本身，这个对象是我们 `products` 字段的一部分。
- en: 'Now the same in VBA:'
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在是 VBA 中的相同实现：
- en: '`For p = 1 To length(products) Step 1` `If products(p).category = "Garden Furniture"
    Then` `products(p).price = products(p).price * 1.1` `Next` *Rem ATTENTION: This
    loop does not lead to the same result!* `For Each p In products` `If p.category
    = "Garden Furniture" Then` `p.price = p.price * 1.1` `Next`'
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`For p = 1 To length(products) Step 1` `If products(p).category = "Garden Furniture"
    Then` `products(p).price = products(p).price * 1.1` `Next` *注意：这个循环不会得到相同的结果!*
    `For Each p In products` `If p.category = "Garden Furniture" Then` `p.price =
    p.price * 1.1` `Next`'
- en: 'As you can see, the syntax of the `For` loop (and also the field and object
    accesses as well as the if-then conditions) is structured a little differently
    in VBA than in PHP, but the basic concepts are completely identical. However,
    there is one important difference in the `For Each` loop: Unlike in PHP, the run
    variable `p` in VBA is always a *copy of* the respective element from our `products`
    field. There is no way to create the run variable so that changes to it are reflected
    in the original element of our `products` field. If we want to change the `products`
    field itself, we have to use the first variant of the counting loop with a numeric
    run variable.'
  id: totrans-53
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如你所见，`For` 循环的语法（以及字段和对象访问、if-then 条件）在 VBA 中的结构与 PHP 略有不同，但基本概念完全相同。然而，在 `For
    Each` 循环中有一个重要的区别：与 PHP 不同，VBA 中的运行变量 `p` 总是我们 `products` 字段中相应元素的*副本*。没有办法创建运行变量，使得对它的更改能反映到我们
    `products` 字段中的原始元素。如果我们想更改 `products` 字段本身，我们必须使用第一种带有数字型运行变量的计数循环。
- en: Nested Loops
  id: totrans-54
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 嵌套循环
- en: 'Loops can also be nested within each other. Imagine you have a two-dimensional
    array whose rows represent the different variants of one and the same product
    and whose columns represent the different warehouses of a company. The values
    in the array represent the number of pieces in each case. For example, if `stock[7,3]
    = 65`，this means that 65 items of the 7th product variant are currently available
    in the 3rd warehouse. If you now want to count how many copies of the product
    (regardless of which variant) are available in total, i.e., across all warehouses,
    a nested, counting loop is suitable for this:'
  id: totrans-55
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 循环也可以相互嵌套。假设你有一个二维数组，其中的行表示同一产品的不同变体，列表示公司的不同仓库。数组中的值表示每种情况中的数量。例如，如果`stock[7,3]
    = 65`，这意味着第7个产品变体在第3个仓库中当前有65个库存。如果你现在想统计该产品（无论是哪个变体）在所有仓库中的总数，适合使用一个嵌套的计数循环来实现：
- en: '`total = 0` `For p From 1 To number_variants Begin` `For w From 1 To number_of_warehouses
    Begin` `total = total + stock[p,w]` `End` `End`'
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`total = 0` `For p From 1 To number_variants Begin` `For w From 1 To number_of_warehouses
    Begin` `total = total + stock[p,w]` `End` `End`'
- en: 'The outer loop goes through the rows of the two-dimensional field, that is,
    the product variants, while the inner loop goes through the warehouses. This means
    that the loop works its way forward by starting a new row, then going through
    all the columns for this row (inner loop) and then switching to the next row (outer
    loop). In this way, the entire field is traversed once. Its individual elements,
    `stock[p,w]`，i.e., the number of product variants in the respective warehouse,
    are added up with the help of the variable `total` by adding the field `total[p,w]`
    just processed by the loops to the current state of this variable; the assignment
    `total = total + total[p,w]` does nothing else: It adds the respective field contents
    to the current value of `total` and again assigns the result to the variable `total`.
    After the nested loops have run through, the variable `total` contains the total
    number of all product variants across all warehouses.'
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 外层循环遍历二维字段的行，即产品变体，而内层循环遍历仓库。这意味着，循环首先从新的一行开始，然后遍历该行的所有列（内层循环），接着切换到下一行（外层循环）。通过这种方式，整个字段会被遍历一遍。它的每个元素，`stock[p,w]`，即在各自仓库中的产品变体数量，通过变量`total`的帮助进行累加，方法是将当前处理的字段`total[p,w]`加到该变量的当前状态；赋值`total
    = total + total[p,w]`实际上并没有其他作用：它只是将对应字段的内容加到`total`的当前值，并将结果重新赋值给`total`。在嵌套循环运行结束后，变量`total`包含了所有仓库中所有产品变体的总数。
- en: Exit Loops Prematurely
  id: totrans-58
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 提前退出循环
- en: 'Most programming languages provide a way to exit a counting loop early. This
    can be useful if, for example, you are writing a piece of code to check if there
    is a product of a special category, say “garden furniture”, among the products.
    One way to check this is to go through the entire field and check if the current
    field element is a product of that category. Once such a product is found, the
    question of whether there are `any` products in the “Garden Furniture” category
    is answered. The rest of the field doesn’t really need to be run through, it only
    costs unnecessary computing time and of course doesn’t change anything in the
    result. So, it would be appropriate to stop the loop at this point. In our pseudo
    code it could look like this:'
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 大多数编程语言提供了一种提前退出计数循环的方法。例如，如果你正在编写一段代码来检查某个特定类别的产品，比如“花园家具”，是否出现在产品列表中，这种方法就非常有用。检查的方法之一是遍历整个字段，检查当前字段元素是否属于该类别的产品。一旦找到这样的产品，问题就变成了是否有`any`产品属于“花园家具”类别。此时，剩下的字段就不需要继续遍历，因为它只会浪费不必要的计算时间，当然也不会改变结果。因此，在这个点停止循环是合适的。在我们的伪代码中，它可能是这样的：
- en: '`found = FALSE For Each p In products Begin If p.category = "Garden Furniture"
    Then Begin found = True Break End End`'
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`found = FALSE For Each p In products Begin If p.category = "Garden Furniture"
    Then Begin found = True Break End End`'
- en: Using the variable`found`，we can determine after the loop whether a product
    of the category “garden furniture” has been found. If such a product is found
    during a loop pass, the variable`found`，which we initially initialized with the
    value`FALSE`，is set to`TRUE`and the loop is exited immediately.
  id: totrans-61
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用变量`found`，我们可以在循环结束后判断是否找到“花园家具”类别的产品。如果在循环过程中找到这样的产品，变量`found`（最初我们将其初始化为`FALSE`）会被设置为`TRUE`，并立即退出循环。
- en: Most programming languages have a statement that causes the current loop pass
    to end and the loop to simply continue with the next pass.
  id: totrans-62
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 大多数编程语言都有一个语句，能够使当前的循环遍历结束，然后直接进入下一次遍历。
- en: 15.3 Conditional Loops
  id: totrans-63
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 15.3 条件循环
- en: Functionality and Types of Conditional Loops
  id: totrans-64
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 条件循环的功能和类型
- en: Conditional loops differ from counting loops in that it is not known in advance
    how many times the loop will be run. Instead, the execution depends on whether
    a certain condition, the `run condition`，is met. As long as this is the case,
    the loop runs. If the run condition is no longer fulfilled at some point, the
    loop terminates, and program execution continues behind the loop.
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 条件循环与计数循环的不同之处在于，不事先知道循环将运行多少次。相反，循环的执行取决于是否满足某个特定条件，称为`运行条件`。只要条件成立，循环就会继续。如果运行条件在某个时刻不再满足，循环终止，程序继续执行循环后的部分。
- en: 'Let’s take the example from the introduction to this chapter: Here, the user
    is prompted for a temperature in Kelvin and then this temperature is converted
    to degrees Celsius until he enters a negative Kelvin temperature. Then the program
    knows to abort, because negative temperatures in Kelvin are physically impossible
    according to the definition of the Kelvin scale. So, the running condition for
    our conditional loop is that the user enters a positive Kelvin temperature. When
    he does, the program converts the temperature to degrees Celsius and asks him
    for the next Kelvin temperature.'
  id: totrans-66
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们以本章开头的示例为例：在这里，用户被提示输入一个开尔文温度，然后该温度会被转换为摄氏度，直到用户输入一个负的开尔文温度为止。然后程序知道要中止，因为根据开尔文温标的定义，负的开尔文温度在物理上是不可能的。所以，我们的条件循环的运行条件是用户输入一个正的开尔文温度。当用户输入时，程序将温度转换为摄氏度，并要求用户输入下一个开尔文温度。
- en: 'In our pseudo-code, this loop could then look like this:'
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在我们的伪代码中，这个循环看起来可能是这样的：
- en: '`kelvin = input("Please enter temperature in Kelvin: ") While kelvin >=0 Begin
    show(kelvin, " Kelvin are: ", kelvin – 273.15,“ degrees Celsius”) kelvin = input("Please
    enter temperature in Kelvin: ") End`'
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`kelvin = input("Please enter temperature in Kelvin: ") While kelvin >=0 Begin
    show(kelvin, " Kelvin are: ", kelvin – 273.15,“ degrees Celsius”) kelvin = input("Please
    enter temperature in Kelvin: ") End`'
- en: 所以，我们首先在实际循环之前读取一个开尔文温度。这是必要的，以便循环的运行条件可以有意义地进行检查。运行条件在关键字`While`之后定义。接着是当运行条件`kelvin
    >= 0`满足时要执行的代码块。具体来说，输入的温度被转换为开尔文，并显示结果。然后用户输入一个新的开尔文温度。由于循环遇到了关键字`End`，它跳回开始，这导致它在用户输入新的开尔文温度时检查运行条件是否仍然满足。
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 所以，我们首先在实际循环之前读取一个开尔文温度。这是必要的，以便循环的运行条件可以有意义地进行检查。运行条件在关键字`While`之后定义。接着是当运行条件`kelvin
    >= 0`满足时要执行的代码块。具体来说，输入的温度被转换为开尔文，并显示结果。然后用户输入一个新的开尔文温度。由于循环遇到了关键字`End`，它跳回开始，这导致它在用户输入新的开尔文温度时检查运行条件是否仍然满足。
- en: 在我们的例子中，条件在循环开始时被检查。然而，检查也可以在结束时进行。那我们就会有一个所谓的`foot-controlled`循环，与上述的`head-controlled`循环相对。
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在我们的例子中，条件在循环开始时被检查。然而，检查也可以在结束时进行。那我们就会有一个所谓的`foot-controlled`循环，与上述的`head-controlled`循环相对。
- en: 它看起来是这样的：
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 它看起来是这样的：
- en: '`kelvin = input("Please enter temperature in Kelvin: ")` `Do` `Begin` `If`
    `kelvin >= 0` `Then` `show(kelvin, " Kelvin are: ", kelvin – 273.15, " degrees
    Celsius")` `kelvin = input("Please enter temperature in Kelvin: ")` `End` `End`
    `While` `kelvin >= 0`'
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`kelvin = input("Please enter temperature in Kelvin: ")` `Do` `Begin` `If`
    `kelvin >= 0` `Then` `show(kelvin, " Kelvin are: ", kelvin – 273.15, " degrees
    Celsius")` `kelvin = input("Please enter temperature in Kelvin: ")` `End` `End`
    `While` `kelvin >= 0`'
- en: 由于条件在这里仅在最后检查，因此循环在达到条件检查之前总是会运行一次。这种结构在我们的例子中有些复杂，因为我们仍需在循环内检查用户的输入是否是一个有效的开尔文温度（即大于或等于0），或者指示用户希望中止循环。仅在开尔文温度大于或等于0时，转换为摄氏度才会在我们的`foot-controlled`循环中发生。否则，在输入后，循环内部不会发生任何事情。循环接着检查运行条件，确定它不再满足，且不会进入另一个循环迭代，而是继续循环后的程序。
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 由于条件在这里仅在最后检查，因此循环在达到条件检查之前总是会运行一次。这种结构在我们的例子中有些复杂，因为我们仍需在循环内检查用户的输入是否是一个有效的开尔文温度（即大于或等于0），或者指示用户希望中止循环。仅在开尔文温度大于或等于0时，转换为摄氏度才会在我们的`foot-controlled`循环中发生。否则，在输入后，循环内部不会发生任何事情。循环接着检查运行条件，确定它不再满足，且不会进入另一个循环迭代，而是继续循环后的程序。
- en: ◘ 图 [15.2](#Fig2) 和 [15.3](#Fig3) 各自展示了一个`head-controlled`循环和一个`foot-controlled`循环的顺序示意图。![](../images/474412_1_En_15_Chapter/474412_1_En_15_Fig2_HTML.jpg)
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: ◘ 图 [15.2](#Fig2) 和 [15.3](#Fig3) 各自展示了一个`head-controlled`循环和一个`foot-controlled`循环的顺序示意图。![](../images/474412_1_En_15_Chapter/474412_1_En_15_Fig2_HTML.jpg)
- en: '`head-controlled`条件循环的流程图。输入给定给运行条件，该条件被分类为未满足和已满足。已满足的条件后跟一个表达式循环块并结束。'
  id: totrans-75
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`head-controlled`条件循环的流程图。输入给定给运行条件，该条件被分类为未满足和已满足。已满足的条件后跟一个表达式循环块并结束。'
- en: 图 15.2
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 15.2
- en: '`head-controlled`条件循环的流程图'
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`head-controlled`条件循环的流程图'
- en: '![](../images/474412_1_En_15_Chapter/474412_1_En_15_Fig3_HTML.jpg)'
  id: totrans-78
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![](../images/474412_1_En_15_Chapter/474412_1_En_15_Fig3_HTML.jpg)'
- en: '`foot-controlled`条件循环的流程图。输入给定给表达式循环块。它后跟一个运行条件，该条件被分类为未满足和已满足。'
  id: totrans-79
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`foot-controlled`条件循环的流程图。输入给定给表达式循环块。它后跟一个运行条件，该条件被分类为未满足和已满足。'
- en: 图 15.3
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 15.3
- en: '`foot-controlled`条件循环的流程图'
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`foot-controlled`条件循环的流程图'
- en: 我们的例子中的循环看起来整体上有点幼稚和牵强。通常在这种情况下，你会使用一个`head-controlled`循环。
  id: totrans-82
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们的例子中的循环看起来整体上有点幼稚和牵强。通常在这种情况下，你会使用一个`head-controlled`循环。
- en: 不同编程语言中的示例
  id: totrans-83
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 不同编程语言中的示例
- en: Here are two implementations of our Kelvin-Celsius conversion program in real
    programming languages, one in Pascal, one in VBA.
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里有两个我们开尔文-摄氏度转换程序在实际编程语言中的实现，一个是 Pascal，另一个是 VBA。
- en: 'First the Pascal version:'
  id: totrans-85
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 首先是 Pascal 版本：
- en: '`program` temperatureconversion; `var` kelvin: real; `begin` kelvin = `readln`(''Please
    enter temperature in Kelvin: ''); `while` kelvin >= 0 `do` `begin` `writeln`(kelvin,
    '' Kelvin are: '', kelvin - 273.15, '' degrees Celsius''); kelvin = `readln`(''Please
    enter temperature in Kelvin: ''); `end` `end.` '
  id: totrans-86
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`program` temperatureconversion; `var` kelvin: real; `begin` kelvin = `readln`(''请输入开尔文温度：'');
    `while` kelvin >= 0 `do` `begin` `writeln`(kelvin, '' 开尔文是：'', kelvin - 273.15,
    '' 摄氏度''); kelvin = `readln`(''请输入开尔文温度：''); `end` `end.` '
- en: 'Now the whole thing in VBA:'
  id: totrans-87
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在在 VBA 中的整个实现：
- en: '`Dim` kelvin `As` Double; kelvin = `InputBox`("Please enter temperature in
    Kelvin: ") `While` kelvin >= 0 `MsgBox` (Str(kelvin) & " Kelvin are: " & Str(kelvin
    - 273.15) & " degrees Celsius") kelvin = `InputBox`("Please enter temperature
    in Kelvin: ") `Wend`'
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Dim` kelvin `As` Double; kelvin = `InputBox`("请输入开尔文温度：") `While` kelvin >=
    0 `MsgBox` (Str(kelvin) & " 开尔文是： " & Str(kelvin - 273.15) & " 摄氏度") kelvin =
    `InputBox`("请输入开尔文温度：") `Wend`'
- en: As you can see, the keywords for conditional loops in Pascal and VBA are `while...do`
    and `While`，as in most other programming languages. The block of code to be repeated
    is enclosed in Pascal with `begin` and `end`，in VBA it starts directly after the
    run condition and ends with the keyword `Wend`。
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如你所见，Pascal 和 VBA 中条件循环的关键字是 `while...do` 和 `While`，这与大多数其他编程语言相似。Pascal 中要重复的代码块用
    `begin` 和 `end` 包裹，而在 VBA 中，它直接从运行条件后开始，并以 `Wend` 关键字结束。
- en: Just as in the case of counting loops, most programming languages also have
    special statements to exit a conditional loop completely (often `break`)，or to
    abort the current run and continue with the next run (often `continue`）。
  id: totrans-90
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 就像计数循环一样，大多数编程语言也有特殊语句可以完全退出一个条件循环（通常是 `break`），或者中止当前运行并继续下一个运行（通常是 `continue`）。
- en: The Relationship of Counting and Conditional Loops
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 计数循环与条件循环的关系
- en: 'Counting loops can also be written as conditional loops, but not vice versa.
    All we need to do for this is to formulate a condition that is satisfied for as
    long as the counting loop would run. In the example of the previous section, where
    we want to increase the price of all products in the category “garden furniture”
    by 10%, it would look like this in pseudo-code:'
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 计数循环也可以写成条件循环，但反之则不行。我们只需要做的是制定一个条件，在计数循环运行时它会一直满足。在前一节的例子中，我们想把“花园家具”类别的所有产品价格提高
    10%，它的伪代码如下：
- en: '`p = 1` `While` `p <= length(products)` `Begin` `If` products[`p`].category
    = "Garden Furniture" `Then` products[`p`].price = products[`p`].price * 1.1 `p
    = p + 1` `End`'
  id: totrans-93
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`p = 1` `While` `p <= length(products)` `Begin` `If` products[`p`].category
    = "Garden Furniture" `Then` products[`p`].price = products[`p`].price * 1.1 `p
    = p + 1` `End`'
- en: Again, similar to the counting loop, we work with a run variable. Only this
    time, we ourselves have to take care of incrementing this variable with each loop
    pass. We do this with the statement `p = p + 1`。The running condition of the loop
    is now that the value of this run variable is at most as large as the length of
    the field `products`。We also have to initialize the run variable ourselves before
    the first loop pass, which the counting loop also did for us. You can see, however,
    that it is quite possible to “convert” counting loops into conditional loops,
    because in the end the counting repetition is also based on a condition. The other
    way round, of course, is not possible, because in the case of a conditional loop
    we do not know how often it will be repeated, which is precisely the prerequisite
    for a counting loop.
  id: totrans-94
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 同样，类似于计数循环，我们使用了一个运行变量。只是这次，我们必须自己处理每次循环时这个变量的递增。我们通过语句 `p = p + 1` 来做到这一点。循环的运行条件现在是该运行变量的值最大不能超过字段
    `products` 的长度。我们还需要在第一次循环前自己初始化这个运行变量，而计数循环是自动为我们初始化的。然而，你可以看到，将计数循环“转换”为条件循环是完全可能的，因为最终计数的重复也是基于一个条件的。当然，反过来则不行，因为在条件循环中，我们不知道它会重复多少次，而这正是计数循环的前提条件。
- en: 15.1 [3 min] What is the problem with the following loop? `x = 1` `While` `x
    <> 100` `Begin` `show`("Loop pass no. ", (x + 1) / 2) `x = x + 2` `End` 15.2 [3
    min]
  id: totrans-95
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 15.1 [3 分钟] 以下循环有什么问题？ `x = 1` `While` `x <> 100` `Begin` `show`("循环通过次数：",
    (x + 1) / 2) `x = x + 2` `End` 15.2 [3 分钟]
- en: What types of loops are there and how do they differ?
  id: totrans-96
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 循环有哪些类型，它们有什么区别？
- en: 15.3 [3 min]
  id: totrans-97
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 15.3 [3 分钟]
- en: Why can you use a conditional loop to replicate a counting loop, but not the
    other way around?
  id: totrans-98
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为什么你可以使用条件循环来复制计数循环，但反过来却不行？
- en: '! 15.4 [5 min]'
  id: totrans-99
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '! 15.4 [5 分钟]'
- en: Consider how a loop could be used to process user input on a graphical user
    interface.
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 考虑如何在图形用户界面中使用循环来处理用户输入。
- en: 15.4 Your Roadmap to Learning a New Programming Language
  id: totrans-101
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 15.4 学习新编程语言的路线图
- en: When you learn a new programming language …
  id: totrans-102
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当你学习一门新的编程语言时……
- en: 'you’ll discover:'
  id: totrans-103
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你将发现：
- en: which forms of counting loops there are and what role the run variable has in
    them (“count variable” or current element of a set of objects that is being run
    through)
  id: totrans-104
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 有哪些形式的计数循环，它们中运行变量的作用是什么（“计数变量”或作为循环集合中当前元素的对象）
- en: what forms of conditional loops there are, in particular whether there are only
    head-controlled loops or also foot-controlled loops,
  id: totrans-105
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 有哪些形式的条件循环，特别是是否只有头控制循环，还是也有脚控制循环，
- en: what possibilities there are to exit loops prematurely or at least to abort
    the current loop pass and continue the loop with the next pass.
  id: totrans-106
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 提前退出循环或者至少中止当前循环并继续下一个循环的可能性有哪些。
- en: 15.5 Solutions to the Exercises
  id: totrans-107
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 15.5 习题答案
- en: Exercise 15.1
  id: totrans-108
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 15.1
- en: The problem with this loop is that it will never end, so it is an infinite loop.
    The variable `x`，whose value is checked before each loop pass, is first initialized
    with the value 1 before the loop and then increased by 2 with each loop pass.
    Its value is therefore always odd. Therefore, the variable will never take the
    value 100, which would cause the loops to terminate. The loop continues to run
    indefinitely (or until the memory is no longer sufficient to hold the high values
    of the variable `x`).
  id: totrans-109
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这个循环的问题在于它永远不会结束，所以这是一个无限循环。变量`x`，它的值在每次循环前被检查，最初在循环前被初始化为1，并在每次循环时增加2。因此，它的值始终是奇数。因此，该变量永远不会达到100，这将导致循环终止。循环将无限运行下去（或者直到内存不足以保存变量`x`的高值）。
- en: Exercise 15.2
  id: totrans-110
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 15.2
- en: There are counting and conditional loops. In the case of counting loops, the
    number of times the loop will be run is, in principle, known before the first
    loop run. These loops work with a run variable. This run variable is a numerical
    value which, starting from a start value, is changed according to a fixed rule
    (for example, increased by one) until it reaches a fixed end value. Alternatively,
    the loop passes through a set of objects and the run variable represents a different
    object from this set for each pass. In this way, certain definable sets of objects
    (such as customers, products, sales transactions) can be run through in a simple
    manner. Within the loop, you can then work with the respective object that is
    currently in focus and that is represented by the run variable.
  id: totrans-111
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 有计数循环和条件循环。在计数循环的情况下，循环将运行的次数原则上在第一次循环之前就可以知道。这些循环使用一个运行变量。该运行变量是一个数值，从起始值开始，按照固定的规则（例如，每次增加一）进行变化，直到达到固定的结束值。或者，循环遍历一组对象，每次循环时运行变量代表这一组对象中的一个不同元素。通过这种方式，可以简单地遍历某些可定义的对象集合（如客户、产品、销售交易）。在循环中，你可以处理当前聚焦的对象，而这个对象由运行变量表示。
- en: Unlike counting loops, the traversal of a conditional loop depends on whether
    a condition, which is checked before (head-controlled loops) or after each pass
    (foot-controlled loops), is satisfied. This condition can also depend on values
    that arise during the loop passes, such as calculated values or user input. Therefore,
    with conditional loops, it is not necessarily possible to say before the first
    loop pass how many times the loop will be run in total.
  id: totrans-112
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与计数循环不同，条件循环的遍历依赖于一个条件，这个条件在每次循环前（头控制循环）或每次循环后（脚控制循环）被检查是否满足。这个条件也可能依赖于在循环过程中产生的值，例如计算值或用户输入。因此，在条件循环中，通常无法在第一次循环前确定循环将运行多少次。
- en: Exercise 15.3
  id: totrans-113
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 15.3
- en: A counting loop is ultimately a special case of the conditional loop. The condition
    is that the value of the run variable moves within a certain value range (between
    the start value and the end value) or – if the set of objects is run through and
    the run variable represents the “current” object – that there are still objects
    left in the set of objects being run through that have not yet “had their turn”.
    Because a run condition also comes into play here, a counting loop with its run
    condition can also be formulated as a conditional loop. However, this does not
    work the other way round, because in the case of conditional loops it does not
    have to be clear in advance how often the loop is run, which is a prerequisite
    for a counting loop. Think of a conditional loop whose execution depends on user
    input. Since it is not foreseeable in which loop pass the user will make the crucial
    input that will cause the loop to terminate, we cannot tell how many times the
    loops will be run.
  id: totrans-114
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 计数循环最终是条件循环的一种特殊情况。其条件是运行变量的值在某个特定范围内变化（在起始值和结束值之间），或者——如果对象集合被遍历，而运行变量代表的是“当前”对象——在正在遍历的对象集合中，仍然有对象尚未“轮到”。由于这里也涉及到运行条件，因此，带有运行条件的计数循环也可以表示为一个条件循环。然而，反过来就不行了，因为对于条件循环来说，事先并不需要明确知道循环会执行多少次，而这是计数循环的前提。想象一个依赖于用户输入的条件循环。由于无法预见用户在哪一轮输入中做出关键输入，从而导致循环终止，我们无法确定循环会执行多少次。
- en: Of course, there are cases in which the number of runs can be known in advance,
    even for conditional loops, namely when nothing can change during the loop runs
    on those variables that decide in the run condition whether the loop will be run
    a second time or not. Then, even with a conditional loop, it is clear from the
    beginning how often it will run, and it could also be written as a counting loop.
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当然，也有一些情况，预先就能知道循环的运行次数，即使是条件循环，例如，当在循环过程中决定是否再次执行循环的变量在运行期间不会发生变化时。这样，即使是条件循环，从一开始就能明确知道它会运行多少次，实际上也可以将其写成一个计数循环。
- en: Exercise 15.4
  id: totrans-116
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 15.4
- en: 'A graphical user interface is normally characterized by the fact that the user
    can choose from different actions. Each of these actions triggers an event to
    which the program can react with a corresponding event handling routine. However,
    this process can also be represented as a loop. To do this, we would read in an
    action from the user again and again in an infinite loop and then process this
    action within the loop. This could look stylized like this:'
  id: totrans-117
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图形用户界面通常的特点是，用户可以从不同的操作中进行选择。这些操作中的每一个都会触发一个事件，程序可以通过相应的事件处理程序做出反应。然而，这个过程也可以表现为一个循环。为了实现这一点，我们会在一个无限循环中反复读取用户的操作，并在循环中处理这个操作。这个过程可以像这样风格化地表示：
- en: '`abort = FALSE` **While** `abort = FALSE` **Begin** `action = read()` **Switch**
    `action` **Begin** **Case** …: … **Case** …: … // Treatment of all possible cases
    **Case** `"Exit"`: `abort = TRUE` **End** **End**'
  id: totrans-118
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`abort = FALSE` **当** `abort = FALSE` **开始** `action = read()` **切换** `action`
    **开始** **案例** …: … **案例** …: … // 处理所有可能的情况 **案例** `"Exit"`: `abort = TRUE` **结束**
    **结束**'
- en: If you are not completely familiar with the `Switch-Case` construct, simply
    go back a few pages to ► Sect. [14.​6](474412_1_En_14_Chapter.xhtml#Sec6).
  id: totrans-119
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你还不完全熟悉 `Switch-Case` 结构，可以回到前几页查看 ► 第 [14.​6](474412_1_En_14_Chapter.xhtml#Sec6)节。
