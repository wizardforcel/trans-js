- en: Greedy Algorithms
  id: totrans-0
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 贪婪算法
- en: This next tactic can speed up some of the most stubborn algorithms. It doesn’t
    work in every situation, but when it does, it can be a game changer.
  id: totrans-1
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这个下一步策略可以加速一些最顽固的算法。它并不适用于每种情况，但在适用时，它可能会改变游戏规则。
- en: Let’s talk about writing greedy algorithms.
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们谈谈编写贪婪算法。
- en: This may sound like a strange term, but here’s what it means. A greedy algorithm
    is one that, in each step, chooses what appears to be the best option at that
    moment in time. This will make sense with a basic example.
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这听起来可能是一个奇怪的术语，但它的意思是这样的：贪婪算法是在每一步中选择当时看起来最好的选项。这会通过一个基本示例变得清晰。
- en: Array Max
  id: totrans-4
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 数组最大值
- en: Let’s write an algorithm that finds the greatest number in an array. One way
    we can do this is to use nested loops and check each number against every other
    number in the array. When we find the number that is greater than every other
    number, it means we’ve found the greatest number in the array.
  id: totrans-5
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们编写一个算法，找到数组中的最大数字。我们可以通过嵌套循环来做到这一点，检查数组中的每个数字与其他每个数字。当我们找到一个大于其他所有数字的数字时，就意味着我们找到了数组中的最大数字。
- en: As is typical for such algorithms, this approach takes `O(N²)` time.
  id: totrans-6
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 正如这种算法的典型特征，这种方法的时间复杂度是 `O(N²)`。
- en: Another approach would be to sort the array in ascending order and return the
    final value from the array. If we use a fast sorting algorithm like `Quicksort`,
    this would take `O(N log N)` time.
  id: totrans-7
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 另一种方法是将数组按升序排序，并返回数组中的最后一个值。如果我们使用像 `Quicksort` 这样的快速排序算法，这将需要 `O(N log N)`
    的时间。
- en: 'A third option is the greedy algorithm:'
  id: totrans-8
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第三个选项是贪婪算法：
- en: '| ​  | `function` max(`array`) { |'
  id: totrans-9
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `function` max(`array`) { |'
- en: '| ​  | `if` (`array.length === 0`) { `return` `null`; } |'
  id: totrans-10
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `if` (`array.length === 0`) { `return` `null`; } |'
- en: '| ​  |  |'
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `let` greatestNumber = `array[0]`; |'
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` greatestNumber = `array[0]`; |'
- en: '| ​  |  |'
  id: totrans-13
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `for` (`const` `number` `of` `array`) { |'
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `for` (`const` `number` `of` `array`) { |'
- en: '| ​  | `if` (`number > greatestNumber`) { |'
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `if` (`number > greatestNumber`) { |'
- en: '| ​  | greatestNumber = `number`; |'
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | greatestNumber = `number`; |'
- en: '| ​  | } |'
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  | } |'
  id: totrans-18
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  |  |'
  id: totrans-19
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `return` greatestNumber; |'
  id: totrans-20
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `return` greatestNumber; |'
- en: '| ​  | } |'
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: 'After ensuring the array isn’t empty, we say the following:'
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在确保数组不为空后，我们说：
- en: '| ​  | `let` greatestNumber = `array[0]`; |'
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` greatestNumber = `array[0]`; |'
- en: This line “assumes” that the first number in the array is the greatestNumber.
    Now, this is a “greedy” assumption; that is, we’re declaring the first number
    to be the greatestNumber because it’s the greatest number we’ve encountered so
    far. Of course, it’s also the only number we’ve encountered so far! But that’s
    what a greedy algorithm does—it chooses what appears to be the best option based
    on the information available at that moment in time.
  id: totrans-24
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这一行“假设”数组中的第一个数字是 greatestNumber。现在，这是一个“贪婪”的假设；也就是说，我们将第一个数字声明为 greatestNumber，因为它是我们迄今为止遇到的最大数字。当然，它也是我们迄今为止遇到的唯一数字！但这就是贪婪算法的作用——它根据当时可用的信息选择看起来最好的选项。
- en: Next, we iterate over all the numbers in the array. As we find any number that
    is greater than the greatestNumber, we make this new number the greatestNumber.
    Here too, we’re being greedy; each step selects the best option based on what
    we know at that moment in time.
  id: totrans-25
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，我们遍历数组中的所有数字。当我们找到任何大于 greatestNumber 的数字时，我们就把这个新数字设为 greatestNumber。在这里，我们同样是贪婪的；每一步都基于我们当时所知的信息选择最佳选项。
- en: We’re basically like a child in a candy shop grabbing the first candy we see,
    but as soon as we see a bigger candy, we drop the first one and grab the bigger
    one.
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们基本上就像一个在糖果店里的孩子，抓住我们看到的第一块糖果，但一旦看到更大的糖果，我们就会扔掉第一块，抓住更大的那块。
- en: Yet, this seemingly naive greediness actually works. By the time we’re done
    with the function, our greatestNumber will indeed be the greatest number in the
    entire array.
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，这种看似幼稚的贪婪实际上是有效的。当我们完成这个函数时，我们的 greatestNumber 确实会是整个数组中的最大数字。
- en: And while being greedy isn’t a virtue in a societal context, it can do wonders
    for algorithm speed. This algorithm takes just `O(N)` time, as we touch each number
    in the array just once.
  id: totrans-28
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 尽管在社会背景下，贪婪并不是一种美德，但它可以极大地提升算法的速度。这个算法只需要 `O(N)` 的时间，因为我们每个数字只接触一次。
- en: Largest Subsection Sum
  id: totrans-29
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 最大子区间和
- en: Let’s see another example of how greed pays off.
  id: totrans-30
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们看看另一个贪婪算法如何获得好处的例子。
- en: We’re going to write a function that accepts an array of numbers and returns
    the largest sum that could be computed from any “subsection” of the array.
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们要编写一个函数，该函数接受一个数字数组，并返回可以从数组的任何“子区间”计算出的最大和。
- en: 'Here’s what I mean. Let’s take the following array:'
  id: totrans-32
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我是这个意思。让我们来看以下数组：
- en: '| ​  | `[3, -4, 4, -3, 5, -9]` |'
  id: totrans-33
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `[3, -4, 4, -3, 5, -9]` |'
- en: If we computed the sum of all the numbers in this array, we’d get `-4`。
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果我们计算这个数组中所有数字的和，我们会得到`-4`。
- en: 'But we can also compute the sum of subsections of the array:'
  id: totrans-35
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 但我们也可以计算数组子区段的和：
- en: '![`images/tips_for_code_optimization/subsection_sums.png`](images/tips_for_code_optimization/subsection_sums.png)'
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![`images/tips_for_code_optimization/subsection_sums.png`](images/tips_for_code_optimization/subsection_sums.png)'
- en: When I refer to subsections, I mean contiguous subsections；that is，一个子区段是包含一系列数字的数组的一部分。
  id: totrans-37
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当我提到子区段时，我是指连续的子区段；即，一个子区段是包含一系列数字的数组的一部分。
- en: The following is not a contiguous subsection, since the numbers are not in a
    row：
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下不是一个连续的子区段，因为数字不在一行：
- en: '![`images/tips_for_code_optimization/not_in_a_row.png`](images/tips_for_code_optimization/not_in_a_row.png)'
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![`images/tips_for_code_optimization/not_in_a_row.png`](images/tips_for_code_optimization/not_in_a_row.png)'
- en: Our job is to find the largest sum that can be computed from any subsection
    within the array. In our example, the largest sum is `6`，derived from the following
    subsection：
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们的任务是找到可以从数组中任何子区段计算得出的最大和。在我们的例子中，最大的和是`6`，来源于以下子区段：
- en: '![`images/tips_for_code_optimization/largest_sum_6.png`](images/tips_for_code_optimization/largest_sum_6.png)'
  id: totrans-41
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![`images/tips_for_code_optimization/largest_sum_6.png`](images/tips_for_code_optimization/largest_sum_6.png)'
- en: To make the discussion simpler, let’s assume the array contains at least one
    positive number.
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为了简化讨论，假设数组至少包含一个正数。
- en: Now, how can we write the code to calculate the largest subsection sum？
  id: totrans-43
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在，我们该如何编写代码来计算最大的子区段和呢？
- en: One approach would be to calculate the sum of every subsection within the array
    and pick out the greatest one. However, there are about `N² / 2` subsections for
    `N` items in an array, so the mere generation of the different subsections would
    take `O(N²)` time.
  id: totrans-44
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一种方法是计算数组中每个子区段的和，并挑选出最大的那个。然而，对于`N`个项目的数组，约有`N² / 2`个子区段，因此仅生成不同的子区段就需要`O(N²)`的时间。
- en: Again, let’s start by dreaming up the best-imaginable Big `O`。We definitely
    need to inspect each number at least once, so we can’t beat `O(N)`。So let’s make
    `O(N)` our goal.
  id: totrans-45
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 再次，让我们从构思最佳的 Big `O`开始。我们肯定需要至少检查每个数字一次，所以我们不能超过`O(N)`。因此，让`O(N)`成为我们的目标。
- en: At first glance, `O(N)` seems beyond our reach. How can we add up multiple subsections
    by iterating over the array a single time？
  id: totrans-46
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 乍一看，`O(N)`似乎超出了我们的能力范围。我们如何能通过仅一次遍历数组来计算多个子区段的和呢？
- en: Let’s see what happens if we get a little greedy…
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们看看如果我们稍微贪心一下会发生什么…
- en: A greedy algorithm in this context would attempt to “grab” the greatest sum
    at each step as we iterate over the array. Here’s what this might look like as
    we iterate over the earlier example array.
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这个上下文中，贪心算法会尝试在我们遍历数组的每一步“抓住”最大的和。这可能在我们遍历早期示例数组时看起来是这样的。
- en: Starting at the front of the array, we encounter a `3`。In perfect greedy fashion,
    we’ll say that our greatest sum is `3`：
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 从数组的前面开始，我们遇到了一个`3`。以完美的贪心方式，我们会说我们的最大和是`3`：
- en: '![`images/tips_for_code_optimization/encounter_3.png`](images/tips_for_code_optimization/encounter_3.png)'
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![`images/tips_for_code_optimization/encounter_3.png`](images/tips_for_code_optimization/encounter_3.png)'
- en: Next, we reach the `-4`。When we add this to the previous number of `3`，we get
    a current sum `-1`。So `3` is still our greatest sum：
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，我们遇到了`-4`。当我们将其加到之前的`3`上时，得到当前和`-1`。因此`3`仍然是我们的最大和：
- en: '![`images/tips_for_code_optimization/encounter_negative_4.png`](images/tips_for_code_optimization/encounter_negative_4.png)'
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![`images/tips_for_code_optimization/encounter_negative_4.png`](images/tips_for_code_optimization/encounter_negative_4.png)'
- en: We then hit the `4`。If we add this to our current sum, we get `3`：
  id: totrans-53
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然后我们遇到了`4`。如果我们将其加到当前和上，我们得到`3`：
- en: '![`images/tips_for_code_optimization/encounter_4.png`](images/tips_for_code_optimization/encounter_4.png)'
  id: totrans-54
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![`images/tips_for_code_optimization/encounter_4.png`](images/tips_for_code_optimization/encounter_4.png)'
- en: As of now, `3` is still the greatest sum.
  id: totrans-55
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 到目前为止，`3`仍然是最大的和。
- en: The next number we reach is a `-3`。This puts our current sum at `0`：
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们接下来的数字是`-3`。这使得我们的当前和为`0`：
- en: '![`images/tips_for_code_optimization/encounter_negative_3.png`](images/tips_for_code_optimization/encounter_negative_3.png)'
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![`images/tips_for_code_optimization/encounter_negative_3.png`](images/tips_for_code_optimization/encounter_negative_3.png)'
- en: Again, while `0` is our current sum, `3` is still our greatest sum.
  id: totrans-58
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 再次强调，虽然`0`是我们当前的和，`3`仍然是我们最大的和。
- en: 'Next, we reach the `5`\. This makes our current sum `5`\. In our greed, we’ll
    declare this to be the greatest sum, as it’s the greatest sum we’ve encountered
    so far:'
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，我们到达`5`。这使得我们的当前和为`5`。在我们的贪心之下，我们会宣布这是最大的和，因为这是我们迄今为止遇到的最大和：
- en: '![images/tips_for_code_optimization/encounter_5.png](images/tips_for_code_optimization/encounter_5.png)'
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/encounter_5.png](images/tips_for_code_optimization/encounter_5.png)'
- en: 'We then reach the last number, which is `-9`\. This deflates our current sum
    to `-4`:'
  id: totrans-61
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然后我们到达最后一个数字`-9`。这使我们当前的和降至`-4`：
- en: '![images/tips_for_code_optimization/encounter_negative_9.png](images/tips_for_code_optimization/encounter_negative_9.png)'
  id: totrans-62
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/encounter_negative_9.png](images/tips_for_code_optimization/encounter_negative_9.png)'
- en: By the time we get to the end of the array, our greatest sum is `5`\. So if
    we follow this pure-greed approach, it would appear that our algorithm should
    return `5`.
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当我们到达数组的末尾时，我们的最大和为`5`。所以如果我们遵循这种纯贪婪的方法，似乎我们的算法应该返回`5`。
- en: 'However, `5` is not the greatest subsection sum. A subsection in the array
    yields a sum of `6`:'
  id: totrans-64
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，`5`并不是最大的子区间和。数组中的一个子区间的和为`6`：
- en: '![images/tips_for_code_optimization/largest_sum_6.png](images/tips_for_code_optimization/largest_sum_6.png)'
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/largest_sum_6.png](images/tips_for_code_optimization/largest_sum_6.png)'
- en: The problem with our algorithm is that we only calculated the largest sum based
    on subsections that always begin with the first number in the array. But other
    subsections begin with numbers later on in the array as well, and we haven’t accounted
    for those.
  id: totrans-66
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们算法的问题在于我们只计算了从数组中第一个数字开始的子区间的最大和。但其他子区间也可能以数组中后面的数字开始，而我们并没有考虑这些情况。
- en: Our greedy algorithm, then, didn’t pan out as we’d hoped.
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 那么，我们的贪婪算法没有达到我们希望的效果。
- en: But we shouldn’t give up yet! Often, we need to tweak greedy algorithms a bit
    to get them to work.
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 但我们还不应该放弃！通常，我们需要稍微调整贪婪算法才能使其有效。
- en: 'Let’s see if finding a pattern may help. (It usually does.) As we’ve seen before,
    the best way to find a pattern is to generate lots of examples. So let’s come
    up with some examples of arrays with their largest subsection sums and see if
    we discover anything interesting:'
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们看看找到一个模式是否会有所帮助。（通常会。）正如我们之前所见，寻找模式的最佳方法是生成大量示例。所以让我们提出一些数组及其最大子区间和的示例，看看是否能发现什么有趣的东西：
- en: '![images/tips_for_code_optimization/largest_sum_examples.png](images/tips_for_code_optimization/largest_sum_examples.png)'
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/largest_sum_examples.png](images/tips_for_code_optimization/largest_sum_examples.png)'
- en: 'When analyzing these cases, an interesting question emerges: why is it that
    in some cases, the greatest sum comes from a subsection that starts at the beginning
    of the array, and in other cases it doesn’t?'
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在分析这些情况时，一个有趣的问题浮现出来：为什么在某些情况下，最大和来自一个从数组开始的子区间，而在其他情况下却不是？
- en: 'In looking at these cases, we can see that when the greatest subsection doesn’t
    start at the beginning, it’s because a negative number broke the streak:'
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在观察这些情况时，我们可以看到，当最大的子区间不从开始处开始时，是因为一个负数打断了连胜：
- en: '![images/tips_for_code_optimization/streak_breakers.png](images/tips_for_code_optimization/streak_breakers.png)'
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/streak_breakers.png](images/tips_for_code_optimization/streak_breakers.png)'
- en: The greatest subsection would’ve been derived from the beginning of the array,
    but a negative number killed the streak, and the greatest subsection has to start
    later on in the array.
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 最大的子区间本应来自数组的开始，但一个负数破坏了连胜，导致最大子区间必须从数组的后面开始。
- en: 'But wait a second. In some cases, the greatest subsection includes a negative
    number, and the negative number didn’t break the streak:'
  id: totrans-75
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 但等一下。在某些情况下，最大的子区间包含一个负数，而这个负数并没有打断连胜：
- en: '![images/tips_for_code_optimization/unbroken_streak.png](images/tips_for_code_optimization/unbroken_streak.png)'
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/unbroken_streak.png](images/tips_for_code_optimization/unbroken_streak.png)'
- en: So what’s the difference?
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 那么区别是什么？
- en: 'The pattern is this: if the negative number causes the preceding subsection’s
    sum to sink to a negative number, the streak is broken. But if the negative number
    simply lowers the current subsection’s sum, and the sum remains a positive number,
    the streak isn’t broken.'
  id: totrans-78
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这个模式是这样的：如果负数导致前一个子区间的和降到负数，连胜就被打断。但如果负数只是降低了当前子区间的和，而和仍然是正数，那么连胜就没有被打断。
- en: If we think about it, this makes sense. If, as we’re iterating through the array,
    our current subsection’s sum becomes less than 0, we’re best off just resetting
    the current sum to 0. Otherwise, the current negative sum will just detract from
    the greatest sum we’re trying to find.
  id: totrans-79
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果我们仔细想想，这就有道理。如果在我们遍历数组时，当前子区间的和变得小于0，我们最好将当前和重置为0。否则，当前的负和只会减少我们想要找到的最大和。
- en: So let’s use this insight to tweak our greedy algorithm.
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 所以让我们利用这个见解来调整我们的贪心算法。
- en: 'Again, let’s start with the 3. The greatest sum is currently 3:'
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 再次，让我们从 3 开始。当前最大总和为 3：
- en: '![images/tips_for_code_optimization/encounter_3.png](images/tips_for_code_optimization/encounter_3.png)'
  id: totrans-82
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/encounter_3.png](images/tips_for_code_optimization/encounter_3.png)'
- en: 'Next, we encounter the -4. This would make our current sum -1:'
  id: totrans-83
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，我们遇到了 -4。这将使我们的当前总和为 -1：
- en: '![images/tips_for_code_optimization/encounter_negative_4.png](images/tips_for_code_optimization/encounter_negative_4.png)'
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/encounter_negative_4.png](images/tips_for_code_optimization/encounter_negative_4.png)'
- en: 'Since we’re trying to find the subsection with the greatest sum, and our current
    sum is a negative number, we need to reset the current sum to 0 before continuing
    on to the next number:'
  id: totrans-85
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 由于我们试图找到最大总和的子部分，而当前总和是负数，我们需要在继续到下一个数字之前将当前总和重置为 0：
- en: '![images/tips_for_code_optimization/reset_sum_to_zero.png](images/tips_for_code_optimization/reset_sum_to_zero.png)'
  id: totrans-86
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/reset_sum_to_zero.png](images/tips_for_code_optimization/reset_sum_to_zero.png)'
- en: We’ll also start a brand-new subsection beginning with the next number.
  id: totrans-87
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们还将以下一个数字开始一个全新的子部分。
- en: Again, the reasoning is that if the next number is positive, we may as well
    just start the next subsection from there, without letting the current negative
    number drag down the sum. Instead, we’re going to perform a reset by setting the
    current sum to 0 and considering the next number to be the beginning of a new
    subsection.
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 再次，推理是如果下一个数字是正数，我们不妨从那里开始下一个子部分，而不是让当前的负数拖低总和。相反，我们将通过将当前总和重置为 0 来执行重置，并将下一个数字视为新子部分的开始。
- en: So let’s continue.
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 所以让我们继续。
- en: 'We now reach a 4. Again, this is the beginning of a new subsection, so the
    current sum is 4, which also becomes the greatest sum we’ve seen yet:'
  id: totrans-90
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们现在达到了 4。这又是一个新子部分的开始，所以当前总和是 4，这也成为了我们迄今为止看到的最大总和：
- en: '![images/tips_for_code_optimization/greatest_sum_is_4.png](images/tips_for_code_optimization/greatest_sum_is_4.png)'
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/greatest_sum_is_4.png](images/tips_for_code_optimization/greatest_sum_is_4.png)'
- en: 'Next, we encounter the -3. The current sum is now 1:'
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，我们遇到了 -3。当前的总和现在是 1：
- en: '![images/tips_for_code_optimization/current_sum_is_1.png](images/tips_for_code_optimization/current_sum_is_1.png)'
  id: totrans-93
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/current_sum_is_1.png](images/tips_for_code_optimization/current_sum_is_1.png)'
- en: 'We next come upon a 5. This makes the current sum 6, which is the greatest
    sum as well:'
  id: totrans-94
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们接下来遇到了 5。这使得当前总和为 6，这也是最大的总和：
- en: '![images/tips_for_code_optimization/current_sum_is_6.png](images/tips_for_code_optimization/current_sum_is_6.png)'
  id: totrans-95
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/current_sum_is_6.png](images/tips_for_code_optimization/current_sum_is_6.png)'
- en: Finally, we reach the -9. This would make the current sum -3, in which case
    we’d reset it to 0. However, we’ve also reached the end of the array, and we can
    conclude the greatest sum is 6. And, indeed, that is the correct result.
  id: totrans-96
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 最后，我们达到了 -9。这将使当前总和为 -3，在这种情况下，我们将其重置为 0。然而，我们也达到了数组的末尾，可以得出最大总和是 6。确实，这就是正确的结果。
- en: 'Here’s the code for this approach:'
  id: totrans-97
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是这个方法的代码：
- en: '| ​  | `function` maxSum(array) { |'
  id: totrans-98
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `function` maxSum(array) { |'
- en: '| ​  | `let` currentSum = 0; |'
  id: totrans-99
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` currentSum = 0; |'
- en: '| ​  | `let` greatestSum = 0; |'
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` greatestSum = 0; |'
- en: '| ​  |  |'
  id: totrans-101
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `for` (`const` num `of` array) { |'
  id: totrans-102
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `for` (`const` num `of` array) { |'
- en: '| ​  | `if` (currentSum + num < 0) { |'
  id: totrans-103
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `if` (currentSum + num < 0) { |'
- en: '| ​  | currentSum = 0; |'
  id: totrans-104
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | currentSum = 0; |'
- en: '| ​  | } `else` { |'
  id: totrans-105
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } `else` { |'
- en: '| ​  | currentSum += num; |'
  id: totrans-106
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | currentSum += num; |'
- en: '| ​  | `if` (currentSum > greatestSum) { |'
  id: totrans-107
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `if` (currentSum > greatestSum) { |'
- en: '| ​  | `greatestSum = currentSum;` |'
  id: totrans-108
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `greatestSum = currentSum;` |'
- en: '| ​  | } |'
  id: totrans-109
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  | } |'
  id: totrans-110
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  | } |'
  id: totrans-111
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  |  |'
  id: totrans-112
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `return` greatestSum; |'
  id: totrans-113
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `return` greatestSum; |'
- en: '| ​  | } |'
  id: totrans-114
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: Using this greedy algorithm, we were able to solve this thorny problem in just
    `O(N)` time, as we loop through the array of numbers just once. That’s a great
    improvement over our initial `O(N²)` approach. In terms of space, this algorithm
    is `O(1)`, as we don’t generate any extra data.
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用这个贪心算法，我们能够在 `O(N)` 时间内解决这个棘手的问题，因为我们只遍历了一次数字数组。这比我们最初的 `O(N²)` 方法有了很大的改进。在空间方面，这个算法是
    `O(1)`，因为我们不生成任何额外的数据。
- en: While the discovery of a pattern helped us discover the precise solution, by
    adopting the greedy mindset, we knew what kind of pattern we were looking for
    in the first place.
  id: totrans-116
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 虽然发现一个模式帮助我们找到了精确的解决方案，但通过采用贪心思维方式，我们一开始就知道我们在寻找什么样的模式。
- en: Greedy Stock Predictions
  id: totrans-117
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 贪心股票预测
- en: Let’s look at one more greedy algorithm.
  id: totrans-118
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们再看看一个贪心算法。
- en: Say we’re writing financial software that makes stock predictions. The particular
    algorithm we’re working on now looks for a positive trend for a given stock.
  id: totrans-119
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 假设我们正在编写能够进行股票预测的金融软件。我们现在正在研究的特定算法寻找给定股票的正向趋势。
- en: Specifically, we’re writing a function that accepts an array of stock prices
    and determines whether there are any three prices that create an upward trend.
  id: totrans-120
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 具体来说，我们正在编写一个接受股票价格数组并确定是否存在任何三个价格创建向上趋势的函数。
- en: 'For example, take this array of stock prices that represents the price of a
    given stock over time:'
  id: totrans-121
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 例如，这是一个代表给定股票随时间变化的股票价格数组：
- en: '| ​  | `[22, 25, 21, 18, 19.6, 17, 16, 20.5]` |'
  id: totrans-122
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `[22, 25, 21, 18, 19.6, 17, 16, 20.5]` |'
- en: 'Although it may be difficult to spot at first, there are three prices that
    form an upward trend:'
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 虽然一开始可能难以发现，但有三个价格形成了向上的趋势：
- en: '![`images/tips_for_code_optimization/upward_trend.png`](images/tips_for_code_optimization/upward_trend.png)'
  id: totrans-124
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![`images/tips_for_code_optimization/upward_trend.png`](images/tips_for_code_optimization/upward_trend.png)'
- en: As we go from left to right, there are three prices where a “right-hand” price
    is greater than a “middle” price, which in turn is greater than a “left-hand”
    price.
  id: totrans-125
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当我们从左到右时，有三个价格，其中一个“右侧”价格大于“中间”价格，而“中间”价格反过来又大于“左侧”价格。
- en: 'The following array, on the other hand, does not contain a three-point upward
    trend:'
  id: totrans-126
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 另一方面，以下数组不包含三点向上趋势：
- en: '| ​  | `[50, 51.25, 48.4, 49, 47.2, 48, 46.9]` |'
  id: totrans-127
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `[50, 51.25, 48.4, 49, 47.2, 48, 46.9]` |'
- en: Our function should return `true` if the array contains an upward trend of three
    prices and `false` if it does not.
  id: totrans-128
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果数组包含三个价格的向上趋势，我们的函数应返回`true`，否则返回`false`。
- en: So how do we go about this?
  id: totrans-129
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 那么我们该如何处理呢？
- en: One way we can do this is with three nested loops. As one loop iterates over
    each stock price, a second loop iterates over all the stock prices that follow.
    And for each round of the second loop, a third nested loop checks all the prices
    that follow the second price. As we point to each set of three stock prices, we
    check whether they’re in ascending order. As soon as we find such a set, we return
    `true`. But if we complete the loops without finding any such trend, we return
    `false`.
  id: totrans-130
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们可以通过三重嵌套循环来实现这一点。当一个循环迭代每个股票价格时，第二个循环迭代后续的所有股票价格。而对于第二个循环的每一轮，第三个嵌套循环检查后续第二个价格的所有价格。当我们指向每组三个股票价格时，我们检查它们是否按升序排列。一旦我们找到这样的一组，我们返回`true`。但如果我们完成循环而没有找到任何这样的趋势，我们返回`false`。
- en: The time complexity of this algorithm is `O(N³)`. That’s pretty slow! Is there
    any way we can optimize this?
  id: totrans-131
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这个算法的时间复杂度为`O(N³)`。速度相当慢！有没有什么方法可以优化呢？
- en: Let’s first think about the best-imaginable Big O. We definitely need to inspect
    each stock price to find a trend, so we know that our algorithm cannot be faster
    than `O(N)`. Let’s see if we can optimize for such a speed.
  id: totrans-132
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们首先考虑最佳的 Big O。我们肯定需要检查每个股票价格来找出趋势，因此我们知道我们的算法不可能比`O(N)`更快。让我们看看是否可以优化这样的速度。
- en: Once again, it’s time to get greedy.
  id: totrans-133
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 再次，现在是贪婪的时候了。
- en: To apply the greedy mentality to our case, we’d want to somehow keep grabbing
    what we think is the lowest point of our three-price upward trend. It would also
    be cool if we can use the same greedy approach to constantly grab what we think
    are the middle and highest points of that trend.
  id: totrans-134
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 要将贪婪思维应用于我们的情况，我们希望以某种方式始终获取我们认为是三价格向上趋势最低点的值。如果我们能够使用相同的贪婪方法不断获取我们认为是该趋势中的中间和最高点的值，那将会很棒。
- en: 'Here’s what we’ll do:'
  id: totrans-135
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是我们将要做的：
- en: We’ll assume the first price from the array is the lowest point in the three-price
    upward trend.
  id: totrans-136
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们假设数组中的第一个价格是三价格向上趋势中的最低点。
- en: 至于中间价格，我们将其初始化为一个保证大于数组中最高股票价格的数字。为此，我们将其设置为`infinity`。这个步骤乍一看可能是最不直观的，但你很快会看到我们为什么需要这样做。
  id: totrans-137
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 至于中间价格，我们将其初始化为一个保证大于数组中最高股票价格的数字。为此，我们将其设置为`infinity`。这个步骤乍一看可能是最不直观的，但你很快会看到我们为什么需要这样做。
- en: 然后我们将按照以下步骤对整个数组进行一次遍历：
  id: totrans-138
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然后我们将按照以下步骤对整个数组进行一次遍历：
- en: 如果当前价格低于我们迄今为止遇到的最低价格，这个价格将成为新的最低价格。
  id: totrans-139
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果当前价格低于我们迄今为止遇到的最低价格，这个价格将成为新的最低价格。
- en: 如果当前价格高于最低价格但低于中间价格，我们将中间价格更新为当前价格。
  id: totrans-140
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果当前价格高于最低价格但低于中间价格，我们将中间价格更新为当前价格。
- en: 如果当前价格高于中间价格，这意味着我们发现了一个三价格上升趋势！
  id: totrans-141
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果当前价格高于中间价格，这意味着我们发现了一个三价格上升趋势！
- en: 让我们看看这个操作。首先，我们将从一个简单的例子开始，处理这个股票价格数组：
  id: totrans-142
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们看看这个操作。首先，我们将从一个简单的例子开始，处理这个股票价格数组：
- en: '![images/tips_for_code_optimization/array_of_stocks.png](images/tips_for_code_optimization/array_of_stocks.png)'
  id: totrans-143
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/array_of_stocks.png](images/tips_for_code_optimization/array_of_stocks.png)'
- en: 我们开始遍历数组，从`5`开始。我们一开始就充满贪婪，假设这个`5`是三点趋势中的最小价格，如下数组所示：
  id: totrans-144
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们从`5`开始遍历数组。我们一开始就充满贪婪，假设这个`5`是三点趋势中的最低价格，如下数组所示：
- en: '![images/tips_for_code_optimization/stock_5.png](images/tips_for_code_optimization/stock_5.png)'
  id: totrans-145
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/stock_5.png](images/tips_for_code_optimization/stock_5.png)'
- en: 接下来，我们处理`2`。因为`2`低于`5`，我们变得更加贪婪，假设`2`现在是趋势中的最低价格：
  id: totrans-146
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，我们处理`2`。因为`2`低于`5`，我们变得更加贪婪，假设`2`现在是趋势中的最低价格：
- en: '![images/tips_for_code_optimization/stock_2.png](images/tips_for_code_optimization/stock_2.png)'
  id: totrans-147
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/stock_2.png](images/tips_for_code_optimization/stock_2.png)'
- en: 我们到达数组中的下一个数字，`8`。这个数字高于我们的最低点，所以我们保持最低点为`2`。然而，它低于当前的中间价格，即`infinity`，所以我们现在贪婪地将`8`赋值为我们三点趋势中的中间点：
  id: totrans-148
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们到达数组中的下一个数字，`8`。这个数字高于我们的最低点，所以我们保持最低点为`2`。然而，它低于当前的中间价格，即`infinity`，所以我们现在贪婪地将`8`赋值为我们三点趋势中的中间点：
- en: '![images/tips_for_code_optimization/stock_8.png](images/tips_for_code_optimization/stock_8.png)'
  id: totrans-149
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/stock_8.png](images/tips_for_code_optimization/stock_8.png)'
- en: 接下来，我们到达`4`。这个值高于`2`，所以我们继续假设`2`是我们趋势中的最低点。然而，由于`4`低于`8`，我们将`4`作为我们的新中间点，而不是`8`。这也是出于贪婪，因为通过降低我们的中间点，我们增加了找到更高价格的机会，从而形成我们所寻求的趋势。因此，`4`是我们的新中间点：
  id: totrans-150
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，我们到达`4`。这个值高于`2`，所以我们继续假设`2`是我们趋势中的最低点。然而，由于`4`低于`8`，我们将`4`作为我们的新中间点，而不是`8`。这也是出于贪婪，因为通过降低我们的中间点，我们增加了找到更高价格的机会，从而形成我们所寻求的趋势。因此，`4`是我们的新中间点：
- en: '![images/tips_for_code_optimization/stock_4.png](images/tips_for_code_optimization/stock_4.png)'
  id: totrans-151
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/stock_4.png](images/tips_for_code_optimization/stock_4.png)'
- en: 数组中的下一个数字是`3`。我们将最低价格保持为`2`，因为`3`大于它。但我们将其作为我们的新中间点，因为它低于`4`：
  id: totrans-152
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 数组中的下一个数字是`3`。我们将最低价格保持为`2`，因为`3`大于它。但我们将其作为我们的新中间点，因为它低于`4`：
- en: '![images/tips_for_code_optimization/stock_3.png](images/tips_for_code_optimization/stock_3.png)'
  id: totrans-153
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/stock_3.png](images/tips_for_code_optimization/stock_3.png)'
- en: 最后，我们到达`7`，这是数组中的最后一个值。因为`7`大于我们的中间价格（`3`），这意味着数组包含一个上升的三点趋势，我们的函数可以返回`true`：
  id: totrans-154
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 最后，我们到达`7`，这是数组中的最后一个值。因为`7`大于我们的中间价格（`3`），这意味着数组包含一个上升的三点趋势，我们的函数可以返回`true`：
- en: '![images/tips_for_code_optimization/stock_7.png](images/tips_for_code_optimization/stock_7.png)'
  id: totrans-155
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/stock_7.png](images/tips_for_code_optimization/stock_7.png)'
- en: Note that two such trends exist in the array. There’s `2-3-7`，but there’s also
    `2-4-7`。Ultimately, though, this doesn’t matter to us, since we’re just trying
    to determine whether this array contains any upward trend; so finding a single
    instance is enough to return `true`。
  id: totrans-156
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 注意数组中存在两种这样的趋势。一个是`2-3-7`，但还有一个是`2-4-7`。不过，这对我们来说并不重要，因为我们只是想确定这个数组是否包含任何上升趋势；因此找到一个实例就足以返回`true`。
- en: 'Here’s an implementation of this algorithm:'
  id: totrans-157
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是该算法的一种实现：
- en: '| ​  | `function` `isIncreasingTriplet(array)` { |'
  id: totrans-158
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `function` `isIncreasingTriplet(array)` { |'
- en: '| ​  | `let` `lowestPrice = array[0];` |'
  id: totrans-159
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` `lowestPrice = array[0];` |'
- en: '| ​  | `let` `middlePrice = `**Infinity**`;` |'
  id: totrans-160
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `let` `middlePrice = `**Infinity**`;` |'
- en: '| ​  |  |'
  id: totrans-161
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `for` (`const` price `of` array) { |'
  id: totrans-162
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `for` (`const` price `of` array) { |'
- en: '| ​  | `if` (price <= `lowestPrice`) { |'
  id: totrans-163
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `if` (price <= `lowestPrice`) { |'
- en: '| ​  | `lowestPrice = price;` |'
  id: totrans-164
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `lowestPrice = price;` |'
- en: '| ​  | } `else` `if` (price <= `middlePrice`) { |'
  id: totrans-165
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } `else` `if` (price <= `middlePrice`) { |'
- en: '| ​  | `middlePrice = price;` |'
  id: totrans-166
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `middlePrice = price;` |'
- en: '| ​  | } `else` { |'
  id: totrans-167
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } `else` { |'
- en: '| ​  | `return` `true`; |'
  id: totrans-168
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `return` `true`; |'
- en: '| ​  | } |'
  id: totrans-169
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  | } |'
  id: totrans-170
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: '| ​  |  |'
  id: totrans-171
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  |  |'
- en: '| ​  | `return` `false`; |'
  id: totrans-172
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | `return` `false`; |'
- en: '| ​  | } |'
  id: totrans-173
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ​  | } |'
- en: One counterintuitive aspect of this algorithm is worth pointing out. Specifically,
    in some scenarios it would appear this algorithm wouldn’t work, yet it does.
  id: totrans-174
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这个算法的一个反直觉的方面值得指出。具体来说，在某些情况下，这个算法似乎不起作用，但实际上是有效的。
- en: 'Let’s take a look at this scenario:'
  id: totrans-175
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们看看这个场景：
- en: '![images/tips_for_code_optimization/second_stock_example.png](images/tips_for_code_optimization/second_stock_example.png)'
  id: totrans-176
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/second_stock_example.png](images/tips_for_code_optimization/second_stock_example.png)'
- en: Let’s see what happens when we apply our algorithm to this array.
  id: totrans-177
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们看看当我们将算法应用于这个数组时会发生什么。
- en: 'At first, the 8 becomes our lowest point:'
  id: totrans-178
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 起初，`8`成为我们的最低点：
- en: '![images/tips_for_code_optimization/second_example_stock_8.png](images/tips_for_code_optimization/second_example_stock_8.png)'
  id: totrans-179
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/second_example_stock_8.png](images/tips_for_code_optimization/second_example_stock_8.png)'
- en: 'Then the 9 becomes our middle point:'
  id: totrans-180
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然后`9`成为我们的中间点：
- en: '![images/tips_for_code_optimization/second_example_stock_9.png](images/tips_for_code_optimization/second_example_stock_9.png)'
  id: totrans-181
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/second_example_stock_9.png](images/tips_for_code_optimization/second_example_stock_9.png)'
- en: 'Next, we reach the 7。Because this is lower than our lowest point, we update
    the lowest point to be 7:'
  id: totrans-182
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，我们到达`7`。因为这低于我们的最低点，我们将最低点更新为`7`：
- en: '![images/tips_for_code_optimization/second_example_stock_7.png](images/tips_for_code_optimization/second_example_stock_7.png)'
  id: totrans-183
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/second_example_stock_7.png](images/tips_for_code_optimization/second_example_stock_7.png)'
- en: 'We then reach the 10:'
  id: totrans-184
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然后我们到达`10`：
- en: '![images/tips_for_code_optimization/second_example_stock_10.png](images/tips_for_code_optimization/second_example_stock_10.png)'
  id: totrans-185
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![images/tips_for_code_optimization/second_example_stock_10.png](images/tips_for_code_optimization/second_example_stock_10.png)'
- en: Because the 10 is greater than the current middle point (9) our function returns
    `true`。Now, this is the correct response since our array indeed contains the trend
    of `8-9-10`。However, by the time our function is done, our lowest point variable
    is pointing to the `7`。But the `7` is not part of the upward trend!
  id: totrans-186
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 因为`10`大于当前的中间点`9`，我们的函数返回了`true`。现在，这是正确的响应，因为我们的数组确实包含`8-9-10`的趋势。然而，当我们的函数完成时，最低点变量指向的是`7`。但`7`并不是上升趋势的一部分！
- en: Despite this being the case, our function still returned the correct response.
    And this is because all our function needs to do is reach a number that is higher
    than the middle point. Because the middle point was only established once we already
    found a lower point before it, as soon as we reach a number higher than the middle
    point, it still means an upward trend is present in the array. This is true even
    though we ended up overwriting the lower point to be some other number later on.
  id: totrans-187
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 尽管如此，我们的函数仍然返回了正确的响应。这是因为我们函数所需做的只是达到一个高于中间点的数字。由于中间点只是在找到其前面的低点后才建立的，一旦我们达到一个高于中间点的数字，这仍然意味着数组中存在上升趋势。即使我们最后将低点覆盖成了其他数字，这一点依然成立。
- en: In any case, our greedy approach paid off, as we only iterated over our array
    a single time. This is an astounding improvement, as we turned an algorithm that
    ran at `O(N³)` into one of `O(N)`。
  id: totrans-188
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 无论如何，我们的贪心方法取得了成功，因为我们只对数组迭代了一次。这是一个惊人的改进，因为我们将一个运行时间为`O(N³)`的算法转变为`O(N)`。
- en: 当然，贪心算法并不总是有效。但它是你在优化算法时可以尝试的另一个工具。
  id: totrans-189
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当然，贪心算法并不总是有效。但它是你在优化算法时可以尝试的另一个工具。
