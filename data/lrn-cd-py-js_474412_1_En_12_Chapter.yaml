- en: © The Author(s), under exclusive license to `Springer Fachmedien Wiesbaden GmbH`,
    part of `Springer Nature` `2024J. L. Zuckarelli`Learn coding with `Python` and
    `JavaScript` [`https://doi.org/10.1007/978-3-658-42912-6_12`](https://doi.org/10.1007/978-3-658-42912-6_12)
  id: totrans-0
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: © 作者，独家授权给`Springer Fachmedien Wiesbaden GmbH`，`Springer Nature`的一部分 `2024J.
    L. Zuckarelli`学习编码，使用`Python`和`JavaScript` [`https://doi.org/10.1007/978-3-658-42912-6_12`](https://doi.org/10.1007/978-3-658-42912-6_12)
- en: '`12. How Do I Input and Output Data?`'
  id: totrans-1
  prefs:
  - PREF_H1
  stylish: true
  type: TYPE_NORMAL
  zh: '`12. 如何进行数据输入和输出？`'
- en: '`Joachim L. Zuckarelli`^([1](#Aff2)  )(1)`München, Germany`Overview'
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Joachim L. Zuckarelli`^([1](#Aff2)  )(1)`慕尼黑，德国`概述'
- en: In the last chapter we dealt with the question of how data can be stored with
    the help of variables in such a way that we can work with them in the program.
    We now turn to the question of how we can bring data into the program from the
    outside (in this context we speak in a broader sense of “data input”) and also
    get it out of the program again (“data output”). This involves both data input
    and data output directly from/to the user, as well as input and output in the
    context of files and databases. In this chapter, we deal with how a program communicates
    with its “outside world”。
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了如何利用变量存储数据，以便在程序中使用。现在，我们转向如何将外部数据引入程序（在此背景下，我们广义上称之为“数据输入”），并将数据从程序中输出（“数据输出”）。这涉及到直接从用户输入和输出数据，以及通过文件和数据库进行输入输出。在本章中，我们将讨论程序如何与其“外部世界”进行通信。
- en: 'You will learn the following:'
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你将学习以下内容：
- en: What distinguishes the two key basic modes of direct user input and output,
    graphical user interfaces and console applications, and when which form is preferable
  id: totrans-5
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 区分直接用户输入和输出、图形用户界面以及控制台应用程序这两种关键基本模式的特点，并在何种情况下更适合使用哪种形式
- en: Which the most important control elements on graphical user interfaces are
  id: totrans-6
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 图形用户界面上最重要的控制元素是什么
- en: How to design graphical user interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何设计图形用户界面
- en: How to read data from and write data to files
  id: totrans-8
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何从文件中读取数据并写入数据
- en: How to work with databases in the basics.
  id: totrans-9
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何在基础中使用数据库。
- en: '`12.1 Forms of Data Input and Output`'
  id: totrans-10
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`12.1 数据输入和输出的形式`'
- en: Most programs communicate in one way or another with their “environment”。 The
    “environment” includes, of course, first and foremost the user of the program,
    who provides information and makes decisions. But part of the environment are
    also other objects and phenomena whose properties and states have an influence
    on the program flow. For example, if we are talking about software that is supposed
    to proactively turn up your heating when it starts to get cold, the current (and
    possibly predicted) temperatures are part of the program’s relevant environment.
    Of course, the program can only process information about this environment if
    it is made known to it in the form of data. In this chapter we want to take a
    closer look at this “making known”。 It is therefore a question of how information
    can be “entered” into the program in the form of data.
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 大多数程序以某种方式与它们的“环境”进行通信。所谓“环境”当然首先是程序的用户，用户提供信息并做出决策。但环境的一部分也包括其他对象和现象，它们的属性和状态对程序流程有影响。例如，如果我们在谈论一种软件，它能够在天气变冷时主动提高你的暖气温度，那么当前（以及可能的预测）温度就是程序相关环境的一部分。当然，程序只能在数据的形式下处理关于这个环境的信息。因此，本章我们想更深入地了解这种“传递信息”的过程。问题在于，如何将信息以数据的形式“输入”到程序中。
- en: When the term “input” is used, the first thing that comes to mind is probably
    direct input by the user, and especially input with the aid of a `keyboard`. But
    of course, this is not the only way that the user can provide data to the program.
    Other input devices, of which `microphone`, `webcam`, `mouse`, `joystick`, or
    `touchscreen` are only a few examples, allow you to input very different kinds
    of data—for example sound, video, position, direction and speed data. But not
    all input comes directly from the user. `Files` and `databases` are also possible
    sources of data input that a program works with. The program for heating control,
    for example, will perhaps query data from the `database` of a `meteorological
    service` via a web interface to determine whether the heating needs to be turned
    on, and if so, when, and how much.
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当提到“输入”时，首先想到的可能是用户的直接输入，特别是借助`键盘`的输入。但当然，这并不是用户向程序提供数据的唯一方式。其他输入设备，例如`麦克风`、`摄像头`、`鼠标`、`游戏杆`或`触摸屏`，仅是其中一些例子，它们可以输入各种不同类型的数据——例如声音、视频、位置、方向和速度数据。但并非所有输入都直接来自用户。`文件`和`数据库`也是程序处理的可能数据来源。例如，供暖控制程序可能会通过Web界面从`气象服务`的`数据库`查询数据，以确定是否需要开启供暖，并且如果需要，何时开启以及开启多少。
- en: Conversely, a wide range of options are available for `outputting` data. Examples
    of this are, above all, the output on the screen and the writing of data to files
    and databases.
  id: totrans-13
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 相反，输出数据有许多不同的方式可供选择。最典型的例子是屏幕输出以及将数据写入文件和数据库。
- en: In this chapter, we will deal with three types of data input and output in programs—input
    or output by or to the user via a `user interface` of some kind, as well as working
    with `files` and `databases`. Since the latter is not a trivial matter and usually
    requires knowledge of a separate programming language (a query language) developed
    specifically for this purpose, we will only cover this subject area here in an
    overview, but at least in such a way that you develop a solid understanding of
    this enormously important field in the practice of modern software development.
    Of course, there are other ways in which data can get into your program or be
    made available from your program, for example via `APIs` (Application Programming
    Interfaces). As an introductory book, however, we will concentrate on the three
    mentioned above.
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 本章将讨论程序中的三种数据输入和输出方式——通过某种形式的`用户界面`与用户进行输入或输出，以及如何与`文件`和`数据库`进行交互。由于后者并非一项简单的任务，通常需要掌握为此目的特别开发的独立编程语言（查询语言），因此我们这里只会对这一领域进行概述，但至少会让你对这一现代软件开发实践中的极为重要的领域有一个扎实的理解。当然，还有其他方式可以将数据输入到程序中或从程序中获取数据，例如通过`API`（应用程序编程接口）。不过，作为一本入门书籍，我们将集中讨论上述三种方式。
- en: '`12.2 Graphical or Non-Graphical: That Is the Question Here`'
  id: totrans-15
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`12.2 图形界面还是非图形界面：这是问题所在`'
- en: Since the advent of operating systems with graphical user interfaces and the
    triumph of the World Wide Web, we have become accustomed to entering and viewing
    data on attractively designed `graphical user interfaces` (GUIs, or, because `graphical`
    is the standard today anyway, simply UIs). What “attractive” means in this context
    depends on taste and the technical possibilities of the respective time and technological
    environment.
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 自从带有图形用户界面的操作系统出现，以及万维网的崛起以来，我们已经习惯于在设计精美的`图形用户界面`（GUI，或者因为“图形”已经是今天的标准，直接称为UI）上输入和查看数据。在这个背景下，“精美”意味着什么取决于个人品味以及当时技术环境的技术可能性。
- en: What GUIs of all times and all technical varieties have in common is that they
    try to make the input of data as convenient as possible for the user by means
    of suitable `control elements`. For example, by not having to enter numbers from
    a given range of values via the keyboard, but by allowing them to be conveniently
    defined by means of sliders.
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 所有时代和所有技术种类的图形用户界面（GUI）共同点在于，它们试图通过合适的`控制元素`使数据输入对用户尽可能方便。例如，用户无需通过键盘输入一个给定范围的数字，而是可以通过滑块方便地定义这些数字。
- en: Especially in the course of the increasing importance of mobile and web applications,
    completely new job descriptions have developed, those of the `user interface designer`
    (`UI designer`) and the `user experience designer` (`UX designer`). While the
    `UI designer` technically designs the interface and “wires” it to the program
    code behind it, the `UX designer` is intensively concerned with the end users
    and their behavior. In a sense, he is the `UI designer`’s market researcher and
    tries to find the optimal way for end users to interact with the application.
    The `UI designer` can then implement the `UX designer`'s findings in the user
    interface. While the `UI designer` is more concerned with the “inside”, with technical
    design, the work of the `UX designer` is more concerned with the “outside” and
    consists mainly of understanding the end users and their way of working.
  id: totrans-18
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 尤其是在移动和 Web 应用日益重要的过程中，出现了全新的职位描述，分别是`用户界面设计师`（`UI 设计师`）和`用户体验设计师`（`UX 设计师`）。`UI
    设计师`负责技术性地设计界面，并将其“连接”到后端的程序代码，而`UX 设计师`则深入关注最终用户及其行为。从某种意义上讲，他是`UI 设计师`的市场研究员，试图找出最终用户与应用程序互动的最佳方式。然后，`UI
    设计师`可以将`UX 设计师`的研究成果实施到用户界面中。虽然`UI 设计师`更关注“内部”，即技术设计，而`UX 设计师`的工作则更关注“外部”，主要是理解最终用户及其工作方式。
- en: If you’re not professionally involved in programming, you’ll usually be a `developer`,
    `UX designer` and `UI designer` all rolled into one. This is more work, but it
    also means that you can let your creativity run wild when designing your interfaces.
    However, you will also have to consider the needs and desires of your users, unless
    you are developing the software exclusively for yourself.
  id: totrans-19
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你没有专业从事编程工作，通常你会是一个`开发者`、`用户体验设计师`和`用户界面设计师`的综合体。这意味着工作量更多，但也意味着你在设计界面时可以放开手脚，发挥你的创造力。然而，你还需要考虑用户的需求和愿望，除非你是在为自己独自开发软件。
- en: With the triumph of graphical user interfaces, `console applications` have almost
    completely gone out of fashion in the end-user area. Those who worked with operating
    systems such as `MS-DOS` in their early computer days, or who today operate a
    `Linux` system and do so not exclusively via one of the graphical front-ends for
    `Linux`, may still remember with a pleasant shiver. `Console applications` offer
    only one form of direct input by the user, namely via the keyboard.
  id: totrans-20
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 随着图形用户界面的盛行，`控制台应用`几乎在最终用户领域完全过时。那些在早期使用过如`MS-DOS`等操作系统的人，或今天使用`Linux`系统且不完全通过`Linux`的图形前端操作的人，或许还能愉快地记得那段历史。`控制台应用`仅提供一种用户直接输入的方式，即通过键盘。
- en: 'A central difference, however, is not only in how the interface appears visually
    and in terms of ease of use. The program flow of `console applications` is usually
    quite different from that of applications with `GUIs`. Based on Karl Marx’s famous
    dictum that being determines consciousness, one could say: “The interface determines
    programming”. This is because `console applications` are usually `linear programs`,
    they run step by step. For example, first something is displayed (such as: “Please
    enter your username”); then the program waits for user input. Once the user has
    made his input and confirmed it with `<ENTER>` or `<RETURN>`, the program’s next
    output follows (“Please enter your password”); the program waits again until the
    user has made his input and confirmed it. Then the program processes the input
    (checks `username` and `password` for validity, for example) and responds again
    with an output (“Access granted.”), and so on.'
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，主要的区别不仅在于界面的视觉表现和易用性。`控制台应用`的程序流程通常与带有`图形用户界面`（`GUI`）的应用程序大不相同。基于卡尔·马克思的名言“存在决定意识”，可以说：“界面决定编程”。这是因为`控制台应用`通常是`线性程序`，按步骤运行。例如，首先显示某些内容（比如：“请输入用户名”）；然后程序等待用户输入。一旦用户输入并通过
    `<ENTER>` 或 `<RETURN>` 确认，程序会输出下一个提示（“请输入密码”）；程序再次等待，直到用户输入并确认。然后程序处理输入（例如检查`用户名`和`密码`的有效性），并再次输出响应（“访问权限已授予”），以此类推。
- en: 这与图形用户界面不同。在这里，程序通常不会指定用户操作的确切顺序。在我们的示例中，用户也可以先输入密码，然后再输入用户名。只有点击登录按钮才会触发程序检查用户输入。考虑到诸如文字处理程序的图形用户界面时，这一差异变得更加明显，在此界面中，用户可以使用按钮访问各种功能，或者直接开始处理文档文本。这种与程序的交互方式是`非线性的`。相反，程序观察用户的行为并对`事件`做出响应，例如点击按钮或从菜单中选择功能。因此，具有图形用户界面的程序通常是`事件驱动的`。如果用户触发了某个事件，程序会跳转到描述在此事件发生时应做什么的代码位置。如果用户随后触发了另一个事件，程序再次跳转到正确的位置，无论该段代码在程序的源代码中的具体位置在哪里。与控制台应用程序严格按顺序执行一行代码、构成线性语句序列不同，在事件驱动编程中，处理“跳跃”于一组语句到另一组语句，具体取决于用户的行为。
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这与图形用户界面不同。在这里，程序通常不会指定用户操作的确切顺序。在我们的示例中，用户也可以先输入密码，然后再输入用户名。只有点击登录按钮才会触发程序检查用户输入。考虑到诸如文字处理程序的图形用户界面时，这一差异变得更加明显，在此界面中，用户可以使用按钮访问各种功能，或者直接开始处理文档文本。这种与程序的交互方式是`非线性的`。相反，程序观察用户的行为并对`事件`做出响应，例如点击按钮或从菜单中选择功能。因此，具有图形用户界面的程序通常是`事件驱动的`。如果用户触发了某个事件，程序会跳转到描述在此事件发生时应做什么的代码位置。如果用户随后触发了另一个事件，程序再次跳转到正确的位置，无论该段代码在程序的源代码中的具体位置在哪里。与控制台应用程序严格按顺序执行一行代码、构成线性语句序列不同，在事件驱动编程中，处理“跳跃”于一组语句到另一组语句，具体取决于用户的行为。
- en: 在►`Chap. [14](474412_1_En_14_Chapter.xhtml)`中，当我们讨论如何使程序响应用户输入时，我们将更详细地研究事件驱动程序。在本章中，我们将首先处理数据输入的可能性，即接口本身。
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在►`Chap. [14](474412_1_En_14_Chapter.xhtml)`中，当我们讨论如何使程序响应用户输入时，我们将更详细地研究事件驱动程序。在本章中，我们将首先处理数据输入的可能性，即接口本身。
- en: '`12.2.1` 图形用户界面'
  id: totrans-24
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`12.2.1` 图形用户界面'
- en: '`12.2.1.1` 重要控件'
  id: totrans-25
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`12.2.1.1` 重要控件'
- en: 图形用户界面上使用的控件可能因操作系统（例如，`Windows`、`macOS`、`Android`、`iOS`）和平台（计算机、平板电脑、智能手机）而异。然而，几乎所有操作系统和平台上都存在许多元素。
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图形用户界面上使用的控件可能因操作系统（例如，`Windows`、`macOS`、`Android`、`iOS`）和平台（计算机、平板电脑、智能手机）而异。然而，几乎所有操作系统和平台上都存在许多元素。
- en: 在接下来的部分中，我们将简要查看最重要的控件元素及其核心属性。除了此处提到的属性外，这些控件还具有许多其他特征。它们中的一些是特定于各自的控件元素，其他则是所有控件或至少绝大多数控件所共有的。后者包括在表面上的位置、尺寸（高度和宽度）、可见性（控件元素当前是否可见或是否被隐藏？）、可用性（用户当前能否使用该控件元素？它是激活状态，还是非激活状态，从而被锁定且“灰显”？）、名称（以便在程序中进行引用）和颜色。
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将简要查看最重要的控件元素及其核心属性。除了此处提到的属性外，这些控件还具有许多其他特征。它们中的一些是特定于各自的控件元素，其他则是所有控件或至少绝大多数控件所共有的。后者包括在表面上的位置、尺寸（高度和宽度）、可见性（控件元素当前是否可见或是否被隐藏？）、可用性（用户当前能否使用该控件元素？它是激活状态，还是非激活状态，从而被锁定且“灰显”？）、名称（以便在程序中进行引用）和颜色。
- en: '`Edit`字段`图形用户界面`提供`edit`字段用于经典键盘输入。根据类型或设置，这些字段允许在一行或多行中输入信息（◘ 图[12.1](#Fig1)、[12.2](#Fig2)和[12.3](#Fig3)）。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig1_HTML.jpg)'
  id: totrans-28
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Edit`字段`图形用户界面`提供`edit`字段用于经典键盘输入。根据类型或设置，这些字段允许在一行或多行中输入信息（◘ 图[12.1](#Fig1)、[12.2](#Fig2)和[12.3](#Fig3)）。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig1_HTML.jpg)'
- en: 一个输入字段的屏幕截图显示文本输入。
  id: totrans-29
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个输入字段的屏幕截图显示文本输入。
- en: 图`12.1`
  id: totrans-30
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图`12.1`
- en: 输入字段的示例
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 输入字段的示例
- en: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig2_HTML.jpg)'
  id: totrans-32
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig2_HTML.jpg)'
- en: 一个输入字段的屏幕截图上有十个点。
  id: totrans-33
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个输入字段的屏幕截图上有十个点。
- en: 图`12.2`
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图`12.2`
- en: 输入字段的示例
  id: totrans-35
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 输入字段的示例
- en: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig3_HTML.jpg)'
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig3_HTML.jpg)'
- en: 一个输入字段的屏幕截图显示了右侧带有垂直滚动条的外语文本。
  id: totrans-37
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个输入字段的屏幕截图显示了右侧带有垂直滚动条的外语文本。
- en: 图`12.3`
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图`12.3`
- en: 输入字段的示例
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 输入字段的示例
- en: '`edit`字段通常可以进行广泛配置，或者提供不同属性的不同`edit`字段。例如，用户的密码输入可以通过简单地不显示任何内容或显示特定字符来进行掩码处理。此外，输入的信息通常可以在输入时进行验证。例如，这可以用于强制用户输入数字输入；如果用户输入字母，则该文本根本不会被`edit`字段接受为输入。有时，不同输入的不同部分需要进行不同格式的处理（例如，当输入需要显示语法高亮的程序代码时）；这时需要一个能够处理不同文本格式的输入字段。'
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`edit`字段通常可以进行广泛配置，或者提供不同属性的不同`edit`字段。例如，用户的密码输入可以通过简单地不显示任何内容或显示特定字符来进行掩码处理。此外，输入的信息通常可以在输入时进行验证。例如，这可以用于强制用户输入数字输入；如果用户输入字母，则该文本根本不会被`edit`字段接受为输入。有时，不同输入的不同部分需要进行不同格式的处理（例如，当输入需要显示语法高亮的程序代码时）；这时需要一个能够处理不同文本格式的输入字段。'
- en: '`按钮`按钮是屏幕上定义的可单击区域，用户通常通过它触发操作，例如保存文档或发送消息（◘ 图[12.4](#Fig4)）。按钮的最重要特征是其标签和在单击按钮时执行的程序部分的链接。视觉外观通常也由一个符号图像主导，该图像风格化了按钮触发的操作。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig4_HTML.jpg)'
  id: totrans-41
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`按钮`按钮是屏幕上定义的可单击区域，用户通常通过它触发操作，例如保存文档或发送消息（◘ 图[12.4](#Fig4)）。按钮的最重要特征是其标签和在单击按钮时执行的程序部分的链接。视觉外观通常也由一个符号图像主导，该图像风格化了按钮触发的操作。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig4_HTML.jpg)'
- en: 一个按钮的屏幕截图显示，`Say, hello world`在双引号中。
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个按钮的屏幕截图显示，`Say, hello world`在双引号中。
- en: 图`12.4`
  id: totrans-43
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图`12.4`
- en: 按钮的示例
  id: totrans-44
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 按钮的示例
- en: '`菜单`像按钮一样，菜单用于让用户触发操作。重点是从各种选项中选择菜单项。这也解释了控件元素的名称，用户以类似于餐厅菜单的方式使用它。此外，菜单及其项的名称、用户通过单击项可以触发的操作等重要属性，再次类似于按钮（◘
    图[12.5](#Fig5)）。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig5_HTML.jpg)'
  id: totrans-45
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`菜单`像按钮一样，菜单用于让用户触发操作。重点是从各种选项中选择菜单项。这也解释了控件元素的名称，用户以类似于餐厅菜单的方式使用它。此外，菜单及其项的名称、用户通过单击项可以触发的操作等重要属性，再次类似于按钮（◘
    图[12.5](#Fig5)）。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig5_HTML.jpg)'
- en: 一个屏幕截图显示了带有标签`menu 1`和`menu 2`的菜单栏。`menu 1`标签下的下拉菜单显示了`menu item 1.1`、`menu
    item 1.2`和`menu item 1.3`。`menu item 1.2`被高亮显示。
  id: totrans-46
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个屏幕截图显示了带有标签`menu 1`和`menu 2`的菜单栏。`menu 1`标签下的下拉菜单显示了`menu item 1.1`、`menu
    item 1.2`和`menu item 1.3`。`menu item 1.2`被高亮显示。
- en: 图`12.5`
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图`12.5`
- en: 菜单的示例
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 菜单的示例
- en: '`Checkboxes and Radio Buttons` `Checkboxes` and `radio buttons` are control
    elements that allow the user to make a selection between several options. Unlike
    buttons and menus, clicking on one of these elements does not usually trigger
    an immediate action. Instead, `checkboxes` and `radio buttons` are usually used
    to specify settings that control the exact behavior of actions that the user later
    triggers elsewhere, such as by clicking on a button or menu item. For example,
    the user could use a `radio button` to choose whether to open a file read-only
    or not. The actual action, the opening of the file, is triggered later by clicking
    on a button `“Open file”`. What exactly a click on this button does (whether the
    file is opened in read-only mode or in such a way that it can also be modified)
    is determined by the setting previously made with the help of the `radio button`
    (◘ Figs. [`12.6`](#Fig6) and [`12.7`](#Fig7)).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig6_HTML.jpg)'
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`复选框和单选按钮` `复选框`和`单选按钮`是控制元素，允许用户在多个选项之间进行选择。与按钮和菜单不同，点击这些元素通常不会立即触发操作。相反，`复选框`和`单选按钮`通常用于指定设置，以控制用户在其他地方触发的操作的具体行为，例如通过点击按钮或菜单项。举例来说，用户可以通过`单选按钮`选择是否以只读模式打开文件。实际操作，即打开文件，是通过稍后点击“打开文件”按钮来触发的。点击该按钮究竟会执行什么操作（文件是否以只读模式打开，或以可以修改的方式打开）由之前通过`单选按钮`设置的选项决定（◘
    图 [`12.6`](#Fig6) 和 [`12.7`](#Fig7)）。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig6_HTML.jpg)'
- en: A screenshot of a list reading `checkbox 1` and `checkbox 2`。 Both have square-shaped
    checkboxes in front of them, where `checkbox 1` is selected.
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 显示一个列表的截图，其中有`复选框 1`和`复选框 2`。它们前面都有方形复选框，其中`复选框 1`被选中。
- en: Fig. 12.6
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 12.6
- en: Examples of `checkboxes`
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`复选框` 示例'
- en: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig7_HTML.jpg)'
  id: totrans-53
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig7_HTML.jpg)'
- en: A screenshot of a list reading `radio button 1` and `radio button 2`。 Both have
    circular buttons in front of them, where `radio button 2` is selected.
  id: totrans-54
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 显示一个列表的截图，其中有`单选按钮 1`和`单选按钮 2`。它们前面都有圆形按钮，其中`单选按钮 2`被选中。
- en: Fig. 12.7
  id: totrans-55
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 12.7
- en: Examples of `radio buttons`
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`单选按钮` 示例'
- en: '`Checkboxes` often appear in multiples, `radio buttons` always. The difference
    between the usually square `checkboxes` and the round `radio buttons` is that
    *only one option* can be selected from a group of such control elements in the
    case of `radio buttons`, but *several can* be clicked on in the case of `checkboxes`.'
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`复选框`通常是成组出现的，而`单选按钮`总是单独出现。通常是方形的`复选框`和圆形的`单选按钮`之间的区别在于，*在`单选按钮`的情况下*，只能从一组控制元素中选择一个选项，而在`复选框`的情况下，*可以选择多个*。'
- en: '`Toggle Buttons` Similar to `checkboxes`, `toggle` buttons allow you to toggle
    an option on or off. Unlike `checkboxes`, however, there are no checkmarks to
    indicate whether the option is currently selected or not. Instead, the appearance
    is modeled after a slide switch. `Toggle buttons` have become popular with the
    triumph of the mobile operating systems `iOS` and `Android` but are now also available
    on other platforms (◘ Fig. [`12.8`](#Fig8)).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig8_HTML.jpg)'
  id: totrans-58
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`切换按钮` 类似于`复选框`，允许你切换选项的开启或关闭。然而，与`复选框`不同，`切换按钮`没有勾选标记来指示选项当前是否被选中。相反，其外观模仿了滑动开关。随着移动操作系统`iOS`和`Android`的流行，`切换按钮`变得非常流行，现在其他平台上也可以使用（◘
    图 [`12.8`](#Fig8)）。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig8_HTML.jpg)'
- en: A screenshot of a `toggle button` resembles a horizontally oriented bright cylindrical
    structure with a sphere at the right.
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 显示一个`切换按钮`的截图，外形类似一个水平方向的明亮圆柱体，右侧有一个球形按钮。
- en: Fig. 12.8
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 12.8
- en: Example of a `toggle button`
  id: totrans-61
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`切换按钮` 示例'
- en: '`Sliders` `Sliders` are control elements that allow you to make a selection
    along a scale, i.e., between options that can be arranged in an order based on
    some criterion. Like `radio buttons` and `checkbox/toggle buttons`, a change in
    the current selection by the user does not usually trigger an immediate action.
    In most cases they are used to make a setting that takes effect later when the
    user triggers an action, such as clicking on a button or menu item (though sometimes
    changes made by the user have a direct effect, such as when the slider is used
    to scale a graphic that automatically updates when the slider control is moved).
    Its most important setting is the scale, the gradation in which the user can adjust
    the slider control, particularly the number and designation of the expressions
    (◘ Figs. [`12.9`](#Fig9) and [`12.10`](#Fig10)).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig9_HTML.jpg)'
  id: totrans-62
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`滑块` `滑块`是控制元素，允许你沿着一个刻度进行选择，即在基于某些标准排列的选项之间进行选择。与`单选按钮`和`复选框/切换按钮`一样，用户更改当前选择通常不会触发立即的操作。在大多数情况下，它们用于进行设置，该设置在用户触发某个操作时生效，比如点击按钮或菜单项（尽管有时用户的更改会直接生效，例如当滑块用于缩放图形并且在滑块控制器移动时自动更新时）。其最重要的设置是刻度，用户可以调整滑块控制的渐变，特别是表达式的数量和标识（◘
    图[`12.9`](#Fig9) 和 [`12.10`](#Fig10)）。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig9_HTML.jpg)'
- en: A screenshot of a slider with a rectangular scale reading measurements at the
    bottom. A bright shaded block moves on the scale.
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 滑块的截图，带有一个矩形刻度，底部显示测量值。一个亮色的阴影块在刻度上移动。
- en: Fig. `12.9`
  id: totrans-64
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图`12.9`
- en: Example of a slider
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 滑块示例
- en: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig10_HTML.jpg)'
  id: totrans-66
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig10_HTML.jpg)'
- en: A screenshot of a slider resembles a horizontal bar with a small spherical structure
    surrounded by rays at the left, and a big spherical structure surrounded by rays
    at the right. A dot moves on the bar.
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 滑块的截图，类似于一个水平条形，左侧有一个小的球形结构，周围有光芒，右侧有一个大的球形结构，周围也有光芒。一个点在条形上移动。
- en: Fig. `12.10`
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图`12.10`
- en: Example of a slider
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 滑块示例
- en: '`List Views`/`List Boxes` `List views` or `list boxes` are “flat”, non-hierarchical
    lists of items that allow the user to select one or more of these items. An example
    of the use of `list views` are `file managers` that list the files contained in
    a folder. In this case, the elements shown in the list view can be provided with
    icons. Sometimes, in addition to the name of the element, other properties of
    the elements are displayed in extra columns of the list view, for example, their
    size or the date of their last modification. In addition to the type of display
    (icons, additional columns for supplementary element properties), an important
    property that can be specified when using `list views` is whether the user should
    be able to select only a single element at a time or several elements at once
    (◘ Fig. [`12.11`](#Fig11)).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig11_HTML.jpg)'
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`列表视图`/`列表框` `列表视图`或`列表框`是“平面”的、非层次化的项目列表，允许用户选择其中一个或多个项目。`列表视图`的一个例子是`文件管理器`，它列出了文件夹中的文件。在这种情况下，列表视图中显示的元素可以配有图标。有时，除了元素的名称外，元素的其他属性会显示在列表视图的额外列中，例如，它们的大小或最后修改日期。除了显示类型（图标、附加列用于显示附加元素属性），使用`列表视图`时可以指定的一个重要属性是用户是否只能一次选择一个元素，还是可以一次选择多个元素（◘
    图[`12.11`](#Fig11)）。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig11_HTML.jpg)'
- en: A screenshot of a list with three columns. The column headers are `element`,
    `property 1`, and `property 2`。`Element` has items `1` to `4`。`Property 1` has
    `property 1.1`, `2.1`, `3.1`, and `4.1`。`Property 2` has `1.2`, `2.2`, `3.2`,
    and `4.2`。
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 三列的列表截图。列标题分别为`元素`、`属性1`和`属性2`。`元素`包含项目`1`到`4`。`属性1`包含`属性1.1`、`2.1`、`3.1`和`4.1`。`属性2`包含`1.2`、`2.2`、`3.2`和`4.2`。
- en: Fig. `12.11`
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图`12.11`
- en: Example of a list view
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 列表视图示例
- en: '`Tree Views` are similar to lists in the sense that they allow multiple elements
    to be displayed. Unlike lists, however, they have a tree-like structure, i.e.,
    they display hierarchical relationships between the elements. A classic example
    for the use of `tree views` are the `folder views` in file managers, where the
    hierarchy of the folders is typically displayed as a tree structure. This is a
    very good way to represent hierarchical relationships of any kind, such as the
    structure of an organization or a hierarchy of products, ranging from broad product
    categories down to individual products. Unlike `list views`，`tree views` typically
    have no additional columns for displaying further properties of the hierarchically
    arranged elements (◘ `Fig. [12.12](#Fig12)`)。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig12_HTML.jpg)'
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`树视图`类似于列表，因为它们允许显示多个元素。然而，与列表不同的是，树视图具有类似树状的结构，即它们显示元素之间的层级关系。`树视图`的经典应用示例是文件管理器中的`文件夹视图`，在这里，文件夹的层级通常以树状结构显示。这是一种非常好的表示任何层级关系的方法，例如组织结构或产品的层级，从广泛的产品类别到单个产品。与`列表视图`不同，`树视图`通常没有额外的列来显示层次排列元素的其他属性（◘
    `图 [12.12](#Fig12)`）。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig12_HTML.jpg)'
- en: A screenshot of a menu displays the expanded view of a list under `node 1` and
    `node 2`。`Node 1` has `element 1.1` and `element 1.2`。`Node 2` has `element 3`。
  id: totrans-75
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一张菜单的截图显示了`节点 1`和`节点 2`下的列表展开视图。`节点 1`包含`元素 1.1`和`元素 1.2`。`节点 2`包含`元素 3`。
- en: '`Fig. 12.12`'
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`图. 12.12`'
- en: Example of a `tree view`
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`树视图`的示例'
- en: '`Pickers` are control elements that allow you to make a selection from several
    predefined options, usually without immediately triggering any action. In this
    respect, they are similar to `radio buttons`，which also allow a selection of settings
    from several predefined alternatives. However, the types and forms in which pickers
    appear are very different. Sometimes they allow the selection from a predefined,
    but large and complex set of possibilities. A good example of such a choice is
    the `date picker` that has become commonplace on mobile and non-mobile platforms.
    Two very different examples of such `date pickers` are shown in ◘ `Figs. [12.13](#Fig13)`
    and `Figs. [12.14](#Fig14)`。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig13_HTML.jpg)'
  id: totrans-78
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`选择器`是允许你从多个预定义选项中做出选择的控制元素，通常不会立即触发任何操作。在这方面，它们类似于`单选按钮`，也允许从多个预定义的选项中选择设置。然而，选择器出现的类型和形式非常不同。有时它们允许从一个预定义的，但庞大而复杂的选项集合中进行选择。一个很好的例子是已经在移动平台和非移动平台上普及的`日期选择器`。这种`日期选择器`的两个非常不同的例子展示在◘
    `图 [12.13](#Fig13)`和`图 [12.14](#Fig14)`中。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig13_HTML.jpg)'
- en: A screenshot of the list of dates in three columns in the format of `date`，`month`，and
    `year`。`7` dates are listed from year `2021` to `2027`。A tick mark and a cross
    mark are at the bottom. The date `07 05 2024` is highlighted。
  id: totrans-79
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一张显示日期列表的截图，列表有三列，格式为`日期`、`月份`和`年份`。列出了`2021`年到`2027`年的`7`个日期。底部有勾选标记和叉号。日期`07
    05 2024`被高亮显示。
- en: '`Fig. 12.13`'
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`图. 12.13`'
- en: Examples of `date pickers`
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`日期选择器`的示例'
- en: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig14_HTML.jpg)'
  id: totrans-82
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig14_HTML.jpg)'
- en: A screenshot of a `calendar` displays `May 2023` with up and down arrows to
    the right. The date `1` starts on a `Monday` and the last date `30` is on a `Sunday`。The
    date `27` is highlighted which falls on a `Saturday`。
  id: totrans-83
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一张`日历`截图显示了`2023年5月`，右侧有上下箭头。日期`1`从`星期一`开始，最后一天`30`是`星期日`。日期`27`被高亮显示，标记为`星期六`。
- en: '`Fig. 12.14`'
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`图. 12.14`'
- en: Examples of `date pickers`
  id: totrans-85
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`日期选择器`的示例'
- en: Of course, `pickers` do not necessarily have to be based on such a complex selection
    situation as the date. `Pickers` are often used to select from a manageable list
    of simple text options. In this sense, `pickers` also include the good old `combo
    box` as shown in ◘ `Fig. [12.15](#Fig15)`，which presents a list of selection options
    that expands downwards。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig15_HTML.jpg)
  id: totrans-86
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当然，`选择器`不一定必须基于像日期这样的复杂选择情况。`选择器`常用于从一个可管理的简单文本选项列表中进行选择。从这个意义上说，`选择器`还包括经典的`组合框`，如◘
    `图 [12.15](#Fig15)`所示，它展示了一个向下展开的选择列表。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig15_HTML.jpg)
- en: A screenshot of a dropdown under the `combo box 1` field. It lists `Entry 1`,
    `Entry 2`, `Entry 3`, `Entry 4`, and `Entry 5`。
  id: totrans-87
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个`组合框 1`字段下的下拉框截图。它列出了`条目 1`、`条目 2`、`条目 3`、`条目 4`和`条目 5`。
- en: '`Fig. 12.15`'
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`图. 12.15`'
- en: Example of a `combo box`
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`组合框`的示例'
- en: '`12.2.1.2 Developing Graphical User Interfaces`'
  id: totrans-90
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`12.2.1.2 开发图形用户界面`'
- en: Now that we have looked at some popular controls for graphical user interfaces,
    the question naturally arises as to how exactly one technically develops an interface.
    Somehow the arrangement of controls and their properties have to be defined. The
    best interface design you have thought up and perhaps sketched out on paper or
    with the help of a graphics or presentation program won’t help you if you can’t
    turn it into a truly usable program interface, a real GUI.
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些常见的图形用户界面控件，接下来自然会产生一个问题：如何具体技术性地开发一个界面。控件的排列和它们的属性必须要被定义出来。你所设计的最好的界面，即使是你在纸上或通过图形设计或演示程序草拟出来的界面，如果你不能将它转换成一个真正可用的程序界面——一个真正的GUI——那也无济于事。
- en: This is often done with the help of the `Integrated Development Environments`
    (`IDE`s), which we already learned about in ► Sect. `[8.​1.​3](474412_1_En_8_Chapter.xhtml#Sec4)`.
    These often allow you to “click” together graphical user interfaces without programming
    by selecting the different controls and placing them where you want them. ◘ Fig.
    `[12.16](#Fig16)` shows the integrated development environment of `Delphi`. Here
    you can see how a graphical user interface is being created. On the right (the
    “Palette” area), different control elements can be selected, which can then be
    placed in the program window using drag & drop. Their size can also be adjusted
    using the mouse. In the “Object Inspector” on the left, you can see the properties
    of the currently selected control element, in this case the selected button. The
    selected property you can see here is the “Caption”, the label of the button.
    Other properties are, for example, the shape the cursor should take when you move
    the mouse over the button (`Cursor`), the font of the button caption (`Font`)
    or the height of the control (`Height`). Obviously, even with a simple button
    you can make quite a few settings to define the appearance and behavior in detail.![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig16_HTML.jpg)
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这通常是通过使用我们在► 第 `[8.1.3](474412_1_En_8_Chapter.xhtml#Sec4)节` 中学习的`集成开发环境`（`IDE`）来实现的。这些环境通常允许你通过选择不同的控件并将它们放置到你想要的位置，来“点击”组合图形用户界面，而无需编程。◘
    图 `[12.16](#Fig16)` 展示了`Delphi`的集成开发环境。这里你可以看到如何创建图形用户界面。在右侧（“调色板”区域），可以选择不同的控件元素，然后通过拖放将它们放置到程序窗口中。它们的大小也可以使用鼠标进行调整。在左侧的“对象检查器”中，你可以看到当前选中控件元素的属性，这里是选中的按钮。你可以看到的选定属性是“标题”（Caption），即按钮的标签。其他属性例如，当鼠标悬停在按钮上时，光标应显示的形状（`Cursor`）、按钮标题的字体（`Font`）或控件的高度（`Height`）。显然，即使是一个简单的按钮，你也可以进行相当多的设置来详细定义它的外观和行为。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig16_HTML.jpg)
- en: A screenshot of the test project - `Delphi 11 community edition` - `unit 2`
    window with three panels. Panel 1 lists the tools under the structure and object
    inspector. Panel 2 is the workspace displays the `button 1` under the `unit 2`.
    Panel 3 lists the options under `test projects` and `palette`.
  id: totrans-93
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 测试项目的屏幕截图——`Delphi 11社区版`——`unit 2`窗口，包含三个面板。面板1列出了结构和对象检查器下的工具。面板2是工作区，显示了`unit
    2`下的`按钮1`。面板3列出了`测试项目`和`调色板`下的选项。
- en: Fig. `12.16`
  id: totrans-94
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 `12.16`
- en: Designing a graphical user interface with `Delphi`
  id: totrans-95
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用`Delphi`设计图形用户界面
- en: On the “Events” tab of the object explorer you would get an overview of the
    `events` that this control can trigger. In addition to the click, you can also
    move the mouse over the button. For more information, see ► Sect. `[14.​7](474412_1_En_14_Chapter.xhtml#Sec7)`,
    where we will look at events in more detail.
  id: totrans-96
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在对象浏览器的“事件”标签页中，你可以查看该控件可以触发的`事件`概述。除了点击事件外，你还可以将鼠标移动到按钮上。有关更多信息，请参见► 第 `[14.7](474412_1_En_14_Chapter.xhtml#Sec7)节`，我们将在其中详细讨论事件。
- en: By the way, `Delphi` stores the graphical user interface internally (called
    “form” there) as a code file. You can see this in ◘ Fig. `[12.17](#Fig17)`. You
    could also edit the interface by adding or deleting elements in this text file
    or by changing the characteristics of their properties. More convenient, of course,
    is editing by drag & drop in `WYSIWYG` mode (`what you see is what you get`),
    as seen in ◘ Fig. `[12.16](#Fig16)`.![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig17_HTML.jpg)
  id: totrans-97
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 顺便提一下，`Delphi`将图形用户界面（在其中称为“表单”）作为代码文件内部存储。你可以在 ◘ 图 `[12.17](#Fig17)` 中看到这一点。你还可以通过编辑这个文本文件来添加或删除元素，或者更改它们的属性特征。当然，更方便的方式是在`所见即所得`（WYSIWYG）模式下进行拖放编辑，如在
    ◘ 图 `[12.16](#Fig16)` 中所示。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig17_HTML.jpg)
- en: A screenshot of test project - `Delphi 11 community edition` - `unit 2` window
    with 3 panels. Panel 1 has the structure and object inspector. Panel 2 is the
    workspace that displays a program under `unit 2`. Panel 3 lists the options under
    test projects and palette.
  id: totrans-98
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 测试项目的截图——`Delphi 11 Community Edition`——`unit 2` 窗口，包含 3 个面板。面板 1 显示结构和对象检查器，面板
    2 是工作区，显示`unit 2`下的程序，面板 3 列出了测试项目和调色板下的选项。
- en: Fig. `12.17`
  id: totrans-99
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图示 `12.17`
- en: Graphical user interface as `Delphi` stores it internally
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图形用户界面，`Delphi` 如何在内部存储
- en: Some programming languages are designed to define graphical user interfaces
    directly in the program code, similar to the way `Delphi` does it in the background.
    The individual elements of the interface are then usually objects in the sense
    of object-oriented programming. They are created by program statements, placed,
    adjusted with respect to their properties, and “wired” to the rest of the program
    code. You will learn more about this procedure using `Python` as an example in
    ► Sect. `[22.​2](474412_1_En_22_Chapter.xhtml#Sec2)`. In ► Sect. `[32.​4](474412_1_En_32_Chapter.xhtml#Sec4)`,
    we will see how, in the case of `JavaScript`, the interface is designed with program
    code, but in a different language (namely `HTML`) than the one in which the actual
    program is written.
  id: totrans-101
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一些编程语言被设计为直接在程序代码中定义图形用户界面，类似于`Delphi`在后台实现的方式。界面的各个元素通常是面向对象编程中意义上的对象。它们通过程序语句创建，按照属性进行布局和调整，并与程序的其他部分“连接”起来。你将在►
    Sect. `[22.​2](474412_1_En_22_Chapter.xhtml#Sec2)`中通过`Python`的示例学到更多关于这一过程的内容。在►
    Sect. `[32.​4](474412_1_En_32_Chapter.xhtml#Sec4)`中，我们将看到在`JavaScript`的情况下，界面是通过程序代码设计的，但与实际程序编写的语言不同（即`HTML`语言）。
- en: '`12.2.2 Console Applications`'
  id: totrans-102
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`12.2.2 控制台应用程序`'
- en: How Console Applications Work
  id: totrans-103
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 控制台应用程序的工作原理
- en: Console applications do not have a graphical user interface, only a text interface.
    They run either in the operating system’s console or terminal (for example, `Linux
    Bash`, `Mac Terminal`, or `MS-DOS prompt`) or in an integrated development environment.
    In the former case, they are programs that the operating system can execute directly
    (i.e., programs already in machine code) or programs in an interpreted language
    that are executed by calling the interpreter in the operating system’s console
    and having it execute the program code. When executing in an `Integrated Development
    Environment`, the program is called from the development environment, i.e., a
    graphical user interface, but it only has a text interface itself, so it practically
    runs like a console application. Again, the programming language interpreter is
    called and executes the program, except that the console in which it runs is hard-coded
    into the `IDE`. In Part III of the book, we will develop console applications
    with `Python` and call them from a graphical `IDE`.
  id: totrans-104
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 控制台应用程序没有图形用户界面，只有文本界面。它们通常运行在操作系统的控制台或终端中（例如，`Linux Bash`、`Mac Terminal` 或
    `MS-DOS prompt`），或者运行在集成开发环境中。在前者情况下，它们是操作系统可以直接执行的程序（即，已经是机器码的程序），或者是以解释语言编写的程序，这些程序通过调用操作系统控制台中的解释器来执行程序代码。在`集成开发环境`中运行时，程序是从开发环境中调用的，即通过图形用户界面调用，但它本身只有文本界面，因此实际上像控制台应用程序一样运行。同样，程序语言解释器被调用并执行程序，唯一不同的是，它运行的控制台已经硬编码到`IDE`中。在本书的第三部分，我们将使用`Python`开发控制台应用程序，并从图形`IDE`中调用它们。
- en: 'The special feature of console applications is that they usually run in a strictly
    linear fashion. Whereas the user can decide for himself via the event-driven graphical
    user interface which functions he calls in which order, in the console application
    he follows the sequence that is permanently built into the program. Here is a
    simple example (where `>` shows something entered by the user):'
  id: totrans-105
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 控制台应用程序的一个特点是，它们通常按严格的线性方式运行。用户可以通过事件驱动的图形用户界面自行决定调用哪些功能以及以何种顺序调用，而在控制台应用程序中，用户必须遵循程序中固定的顺序。这里是一个简单的示例（其中
    `>` 表示用户输入的内容）：
- en: 'Please enter the temperature in degrees Celsius:`>` 23 Conversion to Kelvin
    or degrees Fahrenheit (`K/F`)? `>` `K` 23 degrees Celsius in degrees Kelvin is:
    `296.15`.'
  id: totrans-106
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 请输入温度（摄氏度）：`>` 23 转换为开尔文或华氏度（`K/F`）？ `>` `K` 23 摄氏度转为开尔文是：`296.15`。
- en: 'In a graphical user interface, you might be able to use a radio button to select
    which temperature system to convert your input to. And most importantly, you probably
    could have made this selection `before` you entered the temperature to be converted
    in degrees Celsius. Not so with the console application with its text interface:
    it dictates what you have to enter and when. In this case, the program does not
    run event-driven, but linear.'
  id: totrans-107
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在图形用户界面中，你可能能够使用单选按钮来选择将输入的温度转换为哪种温标。而且最重要的是，你可能可以在输入要转换的摄氏温度之前就做出这个选择。控制台应用程序则不同，采用文本界面：它规定了你需要输入什么以及何时输入。在这种情况下，程序不是事件驱动的，而是线性的。
- en: 'Here are two examples of how the first part of the above program might look
    in two programming languages, Pascal and Python; first in Python:'
  id: totrans-108
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 下面是该程序前部分在两种编程语言中可能的样子，首先是 Python：
- en: '`temp_celsius = input(''Please enter the temperature in degrees Celsius:'')target_scale
    = input(''Conversion to Kelvin or degrees Fahrenheit (K/F)?'')`'
  id: totrans-109
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`temp_celsius = input(''请输入摄氏温度:'')target_scale = input(''转换为开尔文还是华氏度 (K/F)?'')`'
- en: As you can see, it’s quite simple to query an input from the user. Since you
    don’t have to declare variables in Python, each input is ultimately just a single
    line of code.
  id: totrans-110
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如你所见，从用户查询输入是非常简单的。由于在 Python 中不需要声明变量，每次输入最终不过是一行代码。
- en: 'Now the whole thing in Pascal:'
  id: totrans-111
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在来看 Pascal 中的完整代码：
- en: '`program temp var temp_celsius : real; target_scale : char; begin write("Please
    enter the temperature in degrees Celsius:"); readln(temp_scale); write("Conversion
    to Kelvin or degrees Fahrenheit (K/F)?"); readln(target_scale); end.`'
  id: totrans-112
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`program temp var temp_celsius : real; target_scale : char; begin write("请输入摄氏温度:");
    readln(temp_scale); write("转换为开尔文还是华氏度 (K/F)?"); readln(target_scale); end.`'
- en: In Pascal, the variables we use must be declared, a floating-point number variable
    (`real`) and a variable that takes only a single character (`char`). The input
    as such is done here using the `readln()` function, which stands for `read line`,
    which means that after the input, a line break is automatically done so that the
    next output starts on a new line. Without the `ln`, the cursor would simply stop
    after the input. So, the next output would start exactly at that point. There
    is an analogous distinction in output, where a distinction is made between `write()`
    and `writeln()`.
  id: totrans-113
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在 Pascal 中，我们使用的变量必须先声明，包括浮点数变量（`real`）和只能存储一个字符的变量（`char`）。输入操作可以通过 `readln()`
    函数来实现，`readln()` 代表的是 `read line`，意味着输入后会自动换行，以便下一个输出从新的一行开始。如果没有 `ln`，光标将在输入结束后停在同一行。因此，下一次输出将直接从当前位置开始。在输出中也有类似的区别，`write()`
    和 `writeln()` 就是这样的区分。
- en: Why Console Applications at All?
  id: totrans-114
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为什么要使用控制台应用程序？
- en: 'There is one important question we haven’t answered yet: Why would anyone develop
    a console application at all, today, when there are so many fascinating options
    for graphical interfaces available? The most obvious reason is that it’s easier
    and faster. For example, if you want to try something out, like a new function
    library or a certain algorithm, it would be a waste of time to put a lot of work
    into designing a perfect graphical interface. Most of the time, a very simple
    console application that allows only rudimentary text interaction with the user
    is enough. Concentrate your work on the essentials and not on visual attractiveness
    and good usability, which is not necessary for your actual purpose!'
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们还有一个重要的问题尚未解答：为什么在今天有这么多引人入胜的图形界面选项可供选择时，仍然有人开发控制台应用程序呢？最明显的原因是它更简单、更快速。例如，如果你想尝试某些新功能库或某个特定算法，花费大量时间设计一个完美的图形界面就是浪费时间。大多数时候，一个简单的控制台应用程序，仅允许与用户进行基础的文本交互，已经足够了。将精力集中在核心功能上，而不是视觉吸引力和良好的可用性上，因为这些对于你的实际目的并不必要！
- en: '`To understand even better why console applications have not yet gone out of
    fashion, it is worth taking a look at professional or at least ambitious software
    developers. They greatly appreciate command line tools that run in the console.
    And this for several reasons: For one, working with command-line programs is more
    ergonomic, because you can perform all tasks with just one input instrument, the
    keyboard, and you don’t have to laboriously use the mouse to call up the corresponding
    buttons or menu items in a graphical development environment. In addition, command
    line parameters, special control options that are passed directly to the console
    program when it is called, allow the program behavior to be controlled effortlessly
    and very precisely, which would be incomparably more tedious with a whole series
    of clicks on a graphical interface. Also, console applications are regularly less
    demanding in terms of system resource consumption (especially memory and processing
    power), which can mean they run faster. It is therefore not surprising that many
    developer tools come as console applications, for example the well-known versioning
    tool *git* or the text editor *vi*. As a rule, these tools have the same parameters
    and control options on all operating system platforms, making it easy for the
    developer to switch back and forth between different platforms. And finally, although
    no developer would ever openly admit it, it’s also kind of cooler, nerdier to
    work on the console command line than to click together your commands on a graphical
    user interface, just like any “normal” user.`'
  id: totrans-116
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`为了更好地理解为什么控制台应用程序至今没有过时，值得看看一些专业的或至少有抱负的软件开发者。他们非常欣赏运行在控制台中的命令行工具。这有几个原因：首先，使用命令行程序更符合人体工程学，因为你可以只使用一个输入工具——键盘，执行所有任务，而不必费力地使用鼠标去点击图形开发环境中的按钮或菜单项。此外，命令行参数作为调用控制台程序时直接传递给程序的特殊控制选项，能够让程序的行为精确、毫不费力地控制，这在图形界面中要通过一系列的点击来完成，显得繁琐得多。而且，控制台应用程序通常对系统资源（尤其是内存和处理能力）的需求较低，这可能意味着它们运行得更快。因此，许多开发工具以控制台应用程序的形式出现并不令人惊讶，例如著名的版本控制工具*git*或文本编辑器*vi*。通常，这些工具在所有操作系统平台上具有相同的参数和控制选项，使得开发者在不同平台间切换变得非常容易。最后，尽管没有开发者会公开承认，但在控制台命令行上工作，比在图形用户界面上像“正常”用户一样点击命令，确实有一种更酷、更极客的感觉。`'
- en: Many professional developers use a computer with *MacOS* or *Linux* as the operating
    system instead of a Windows-based system. Asked about the reasons, many say that
    these two operating systems offer the better console, so they can work more comfortably
    on these systems. It’s no wonder then that Microsoft, whose strategic thrust is
    explicitly to cater especially to the needs of developers, has released a modern
    console app in the summer of 2019 that aims to put Windows operating systems back
    into the competition for developers’ favor.
  id: totrans-117
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 许多专业开发者使用的是*MacOS*或*Linux*作为操作系统，而不是基于 Windows 的系统。当问及原因时，许多人表示这两个操作系统提供了更好的控制台，使得他们在这些系统上工作更加舒适。难怪微软会在
    2019 年夏季发布一款现代化的控制台应用程序，旨在让 Windows 操作系统重新进入开发者青睐的竞争中。
- en: '`12.1`'
  id: totrans-118
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`12.1`'
- en: '`Explain two ways in which graphical user interfaces can be developed.`'
  id: totrans-119
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`解释开发图形用户界面应用程序的两种方式。`'
- en: '`12.2`'
  id: totrans-120
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`12.2`'
- en: '`Explain the basic difference in program flow between console applications
    and those with a graphical user interface.`'
  id: totrans-121
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`解释控制台应用程序和图形用户界面应用程序在程序流程上的基本区别。`'
- en: '`12.3`'
  id: totrans-122
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`12.3`'
- en: '`List two advantages of console applications over graphical user interface
    applications.`'
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`列举两个控制台应用程序相对于图形用户界面应用程序的优势。`'
- en: '`12.3 Working with Files`'
  id: totrans-124
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`12.3 与文件的操作`'
- en: 'The Fastest Way: Immediate Reading and Writing of FilesData can not only be
    entered by the user but can also come from files. Working with files is basically
    always the same and very simply structured:'
  id: totrans-125
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 最佳方式：文件的即时读取与写入数据不仅可以由用户输入，还可以来自文件。与文件的操作基本上总是相同且结构简单：
- en: '`The file in question is opened`'
  id: totrans-126
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`相关文件已打开`'
- en: '`Their content is read out (or content is written into them)`'
  id: totrans-127
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`它们的内容被读取（或写入内容）`'
- en: '`The file is closed.`'
  id: totrans-128
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`文件已关闭。`'
- en: 一些编程语言具有允许您直接编辑文件的函数，而无需明确担心打开和关闭它们。以下是三个示例。首先是来自 F#（“F Sharp”）的示例：`File.WriteAllText("test.txt",
    "A sample text written directly")`
  id: totrans-129
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一些编程语言提供了可以直接编辑文件的函数，无需显式地关心文件的打开和关闭。以下是三个示例。首先是来自 F#（“F Sharp”）的示例：`File.WriteAllText("test.txt",
    "A sample text written directly")`
- en: PHP 中的相同内容：
  id: totrans-130
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: PHP 中的相同内容：
- en: '`file_put_contents("test.txt", "A sample text written directly")`'
  id: totrans-131
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`file_put_contents("test.txt", "A sample text written directly")`'
- en: 最后，在 R 中：
  id: totrans-132
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 最后，在 R 中：
- en: '`cat("A sample text, written directly ", file = "test.txt", append = TRUE)`'
  id: totrans-133
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`cat("A sample text, written directly ", file = "test.txt", append = TRUE)`'
- en: 在所有这三种情况下，文本“A sample text, written directly”会写入名为`test.txt`的文件。该文件不必明确打开或关闭；所使用的函数会在我们干预之前处理这些。
  id: totrans-134
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在所有这三种情况下，文本“A sample text, written directly”会写入名为`test.txt`的文件。该文件不必明确打开或关闭；所使用的函数会在我们干预之前处理这些。
- en: Modes of File Processing
  id: totrans-135
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 文件处理模式
- en: 然而，所有这些语言也具有独立执行上述三步的函数。如果，例如，您想多次从同一个文件中写入或读取数据，那么每次打开和关闭文件都是低效的。在这种情况下，您肯定不会使用刚才考虑的函数，而是首先打开文件，然后多次写入或读取数据，并在所有工作完成后再关闭文件。
  id: totrans-136
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，所有这些语言也具有独立执行上述三步的函数。如果，例如，您想多次从同一个文件中写入或读取数据，那么每次打开和关闭文件都是低效的。在这种情况下，您肯定不会使用刚才考虑的函数，而是首先打开文件，然后多次写入或读取数据，并在所有工作完成后再关闭文件。
- en: 我们在 F#、PHP 和 R 中看到的写入操作，如果名为`test.txt`的文件不存在，将创建一个新文件，然后将我们的示例文本写入该新文件。但如果文件已经存在，其内容将被简单地覆盖，而不会提示或确认。仅在第三个示例，即统计语言
    R 中，使用了选项`append=TRUE`来控制现有文件内容不会被覆盖，而是将我们的文本附加到现有内容上。
  id: totrans-137
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们在 F#、PHP 和 R 中看到的写入操作，如果名为`test.txt`的文件不存在，将创建一个新文件，然后将我们的示例文本写入该新文件。但如果文件已经存在，其内容将被简单地覆盖，而不会提示或确认。仅在第三个示例，即统计语言
    R 中，使用了选项`append=TRUE`来控制现有文件内容不会被覆盖，而是将我们的文本附加到现有内容上。
- en: 因此，写入与写入并不相同。实际上，文件可以打开的模式基本上有三种：
  id: totrans-138
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 因此，写入与写入并不相同。实际上，文件可以打开的模式基本上有三种：
- en: Read（通常是`read`或`r`）
  id: totrans-139
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 读取（通常是`read`或`r`）
- en: Writing（通常是`write`或`w`）
  id: totrans-140
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 写入（通常是`write`或`w`）
- en: Append（通常是`append`或`a`）
  id: totrans-141
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 追加（通常是`append`或`a`）
- en: 模式“Write”和“Append”在所需名称的文件尚不存在时会定期创建一个新文件。它们在处理现有文件内容的方式上有所不同。在“Write”模式下，这些内容通常会被完全替换。在许多编程语言中，混合模式也是可能的，例如`ra`（读取
    = `r` 和追加 = `a`）。
  id: totrans-142
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 模式“Write”和“Append”在所需名称的文件尚不存在时会定期创建一个新文件。它们在处理现有文件内容的方式上有所不同。在“Write”模式下，这些内容通常会被完全替换。在许多编程语言中，混合模式也是可能的，例如`ra`（读取
    = `r` 和追加 = `a`）。
- en: Incidentally, for historical reasons and the way file systems have always worked,
    there is no `insert` mode. So, you normally can’t just open a file, go to a specific
    location within the file, and then just insert additional content there. Instead,
    although it’s awkward, you have to rebuild the contents of the file in a variable
    in your program, that is, read the existing first part of the file into a variable
    (such as a `string variable`), then append the contents to be inserted to that
    variable, and finally read the back part of the file and append that to the new
    contents variable as well. Afterwards you can open the file in `write` mode and
    write the content of the variable into the file. This way you have completely
    overwritten the old file content, but in fact, you have only inserted something.
  id: totrans-143
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 顺便说一下，由于历史原因和文件系统一直以来的工作方式，文件中没有`insert`模式。因此，您通常不能只是打开一个文件，跳到文件中的特定位置，然后在那里插入额外的内容。相反，虽然这很尴尬，您必须在程序中将文件内容重建到一个变量中，也就是说，首先将现有文件的第一部分读入一个变量（如`string
    variable`），然后将要插入的内容附加到该变量中，最后读取文件的后半部分并将其附加到新内容变量中。然后，您可以以`write`模式打开文件，将变量的内容写入文件。通过这种方式，您完全覆盖了旧文件内容，但实际上，您只是插入了一些内容。
- en: 'The situation is different when reading: Here you can regularly move the `file
    pointer`，which indicates where the next operation in the file should take place,
    to any position in the file. When opening a file in `write` mode, on the other
    hand, the `file pointer` is automatically set to the beginning of the file (and
    cannot be moved away from there, at least not without actually writing something),
    and when opening it in `append` mode, it is set to the end of the file.'
  id: totrans-144
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 读取时情况有所不同：在这里，您可以定期移动`file pointer`，它表示下一次操作应该发生的位置，您可以将其移动到文件中的任何位置。而在以`write`模式打开文件时，`file
    pointer`会自动设置到文件的开头（并且不能移开，至少不在不实际写入任何内容的情况下），而在以`append`模式打开时，它会设置到文件的末尾。
- en: Besides the type of editing operation to be performed on the file, the modes
    for opening files also differ with respect to another characteristic, namely whether
    the edited files are `text` or `binary files`. The difference between the two
    is most obvious with numbers. The number `32,000` is `0111110100000000` in binary
    terms, i.e., a 16-bit sequence of zeros and ones. Two bytes (8 bits each) are
    sufficient to store this value. In a `text file`, however, the number `32,000`
    would be considered text. So, if it is stored, the individual characters, “3”,
    “2”, “0”, “0” and again “0” are stored. The resulting file would then be 5 bytes
    in size. Differences between `text` and `binary files` also exist in the encoding
    of line breaks and the signaling of the end of the file, for which `text files`
    have a special character, the `EOF` character (end of file). `Text files` are
    usually such that you see letters and numbers when you open them. For example,
    program code that you write is stored in a `text file`. On the other hand, if
    you open, say, a `PDF` file or an executable program file with a `text editor`,
    all you will see is a seemingly random pattern of strange special characters;
    these are `binary files` that your `text editor` is trying to represent as `text`.
    To deal with the two different basic types of files, many programming languages
    have separate modes for writing, appending, and reading `text files` and `binary
    files`.
  id: totrans-145
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 除了文件编辑操作的类型外，打开文件的模式还取决于另一个特征，即编辑的文件是`文本文件`还是`二进制文件`。这两者之间的区别在处理数字时最为明显。数字`32,000`在二进制表示中是`0111110100000000`，即一个16位的零一序列。两个字节（每个字节8位）就足够存储这个值。然而，在一个`文本文件`中，数字`32,000`会被视为文本。因此，如果它被存储，那么单独的字符“3”，“2”，“0”，“0”和再次的“0”会被存储。最终的文件大小将是5个字节。`文本文件`和`二进制文件`之间的差异还体现在换行符的编码和文件结束的标识上，`文本文件`有一个特殊的字符，即`EOF`字符（文件结束）。`文本文件`通常是这样，打开时你可以看到字母和数字。例如，你写的程序代码就是存储在一个`文本文件`中的。另一方面，如果你用`文本编辑器`打开一个`PDF`文件或一个可执行程序文件，你所看到的将是一些看似随机的特殊字符图案；这些就是`二进制文件`，你的`文本编辑器`正在尝试将它们表示为`文本`。为了处理这两种基本类型的文件，许多编程语言为写入、附加和读取`文本文件`和`二进制文件`提供了不同的模式。
- en: 'Now let’s take a closer look at opening, editing and closing files. In general,
    these operations can be represented in our pseudo-code like this:'
  id: totrans-146
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在让我们仔细看看打开、编辑和关闭文件。一般来说，这些操作可以用我们的伪代码表示如下：
- en: '`my_file = open("test.txt", "w")` `write(my_file, "First sample text written
    to the file.")` `write(my_file, "Another sample text.")` `close(my_file)`'
  id: totrans-147
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`my_file = open("test.txt", "w")` `write(my_file, "First sample text written
    to the file.")` `write(my_file, "Another sample text.")` `close(my_file)`'
- en: In most languages, when a file is opened, a variable of a special type is returned.
    In our pseudo-code, we get back a variable `my_file` from the `open()` function
    we use to open the file `text.txt` in write mode (`w`)。From now on, we work with
    this variable so that the functions we use to edit the file know which file our
    instructions refer to; after all, we could have a whole series of different files
    open in parallel.
  id: totrans-148
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在大多数语言中，当打开文件时，会返回一个特殊类型的变量。在我们的伪代码中，我们通过使用`open()`函数打开文件`text.txt`（以写入模式`w`），从中返回一个变量`my_file`。从现在开始，我们将使用这个变量，以便我们使用的编辑文件的函数知道我们的指令是针对哪个文件的；毕竟，我们可能会并行打开多个不同的文件。
- en: 'In object-oriented programming languages, the file variable will regularly
    be an object, which then has special methods that can be used to manipulate the
    file (flip back a few pages to the last chapter if the topic of objects and methods
    seems unfamiliar). Then writing and closing the file might look something like
    this:'
  id: totrans-149
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在面向对象的编程语言中，文件变量通常是一个对象，该对象具有可以用来操作文件的特殊方法（如果对象和方法的话题不太熟悉，请翻回前几章）。然后，写入和关闭文件可能看起来像这样：
- en: '`my_file = open("test.txt", "w")` `my_file.write("Another sample text.")` `my_file.close()`
    Examples in Different Programming Languages'
  id: totrans-150
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`my_file = open("test.txt", "w")` `my_file.write("Another sample text.")` `my_file.close()`
    不同编程语言中的示例'
- en: Let’s look at this in some actual existing programming languages.
  id: totrans-151
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们看看在一些实际的编程语言中是如何处理的。
- en: 'Here is an example in C:'
  id: totrans-152
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是一个C语言的示例：
- en: '`#include <stdio.h>` `int main() {FILE *my_file; my_file = fopen("test.txt",
    "w"); fprintf(my_file, "First sample text written to file."); fprintf(my_file,
    "Another sample text."); fclose(my_file);}`'
  id: totrans-153
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`#include <stdio.h>` `int main() {FILE *my_file; my_file = fopen("test.txt",
    "w"); fprintf(my_file, "First sample text written to file."); fprintf(my_file,
    "Another sample text."); fclose(my_file);}`'
- en: The code looks considerably more complicated than it actually is. To make it
    work, the first statement must include a special standard program library called
    `stdio.h`，which provides the functions for input and output. The main program
    in C is itself a function, `main()`，which is called automatically when the program
    is executed. What should happen then is inside the function and is what we are
    actually interested in here. In C, variables must be registered before they are
    used for the first time. Here, a variable of type `FILE` is declared, and the
    asterisk is used to create a `pointer` to such a variable, but we won’t concern
    ourselves with the implications at this point. The variable just created then
    takes the return value of the function `fopen()` (for `file open`), which we use
    to open file `test.txt` in write mode (`w`)。If this file does not exist yet, it
    will be created. After that we write with the function `fprintf()` (for `file
    print formatted`) into the just opened file, which we reference with the help
    of our variable `my_file`。Afterwards we close the file with `fclose()`。
  id: totrans-154
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这段代码看起来比实际情况要复杂得多。为了使其正常工作，第一行语句必须包含一个名为`stdio.h`的特殊标准程序库，该库提供输入输出函数。在 C 中，主程序本身是一个函数`main()`，它在程序执行时会自动调用。接下来应该发生的事情就在这个函数内，而这正是我们真正关心的部分。在
    C 中，变量必须在第一次使用之前进行声明。在这里，声明了一个类型为`FILE`的变量，并使用星号创建了该变量的`指针`，但我们暂时不关注这方面的内容。然后，刚刚创建的变量接收了`fopen()`函数的返回值（用于打开文件），我们用它来以写入模式（`w`）打开文件`test.txt`。如果该文件尚不存在，它会被创建。之后，我们使用`fprintf()`函数（即`file
    print formatted`）向刚打开的文件写入数据，操作时使用我们创建的变量`my_file`。写入完成后，我们使用`fclose()`关闭文件。
- en: 'The same process would look like this in Pascal:'
  id: totrans-155
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在 Pascal 中，同样的过程如下所示：
- en: '`program FileWrite; var my_file: TextFile; begin AssignFile(my_file, ''test.txt'');
    rewrite(my_file); write(my_file, ''First sample text to be written to the file.'');
    write(my_file, ''Another sample text.''); CloseFile(my_file); end.`'
  id: totrans-156
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`program FileWrite; var my_file: TextFile; begin AssignFile(my_file, ''test.txt'');
    rewrite(my_file); write(my_file, ''First sample text to be written to the file.'');
    write(my_file, ''Another sample text.''); CloseFile(my_file); end.`'
- en: Here we first declare a variable `my_file`. This variable is then assigned the
    reference to our file `test.txt` with a special function called `AssignFile()`.
    Up to this point, it is not at all clear in which mode the file is to be opened.
    That is not determined until the `rewrite()` function is called, which opens the
    file for writing. After writing, the file is closed at the end of the program
    with `CloseFile()`.
  id: totrans-157
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这里，我们首先声明一个变量`my_file`。然后通过一个名为`AssignFile()`的特殊函数，将此变量赋值为文件`test.txt`的引用。到目前为止，文件应以何种模式打开尚不明确。直到调用`rewrite()`函数时，文件才会以写入模式打开。写入后，程序结束时使用`CloseFile()`关闭文件。
- en: So Pascal differs from C in that here the special function `rewrite()` is used
    when opening the file in write mode, whereas in C the general function `fopen()`
    is used, where a function argument, i.e. a setting we pass to the function when
    calling it, determines in which mode the file should be opened.
  id: totrans-158
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 所以，Pascal 与 C 的不同之处在于，当以写入模式打开文件时，这里使用了特殊的函数`rewrite()`，而在 C 中则使用通用的函数`fopen()`，其中一个函数参数（即我们在调用函数时传递的设置）决定了文件应该以哪种模式打开。
- en: 'Analogously, there is a special function in Pascal for opening files in read
    mode: `reset()`. If the first line from file `test.txt` is to be read, the corresponding
    Pascal code would look like this:'
  id: totrans-159
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 类似地，在 Pascal 中有一个特殊的函数用于以读取模式打开文件：`reset()`。如果需要读取文件`test.txt`中的第一行，Pascal 中的对应代码如下：
- en: '`program FileWrite; var my_file: TextFile; first_line: string; begin AssignFile(my_file,
    ''test.txt''); reset(my_file); readln(my_file, first_line); CloseFile(my_file);
    end.`'
  id: totrans-160
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`program FileWrite; var my_file: TextFile; first_line: string; begin AssignFile(my_file,
    ''test.txt''); reset(my_file); readln(my_file, first_line); CloseFile(my_file);
    end.`'
- en: The function `readln()` (*read line*) is used, which reads a line from the file
    opened in read mode (first argument of the function) and stores it in the variable
    `first_line` (second argument). After that, the file pointer is automatically
    advanced to the next line, even without our intervention. If we were to read in
    a line again, this time it would be the second line.
  id: totrans-161
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用函数`readln()`（*读取一行*），该函数从以读取模式打开的文件中读取一行（函数的第一个参数），并将其存储在变量`first_line`（第二个参数）中。之后，文件指针会自动推进到下一行，甚至无需我们干预。如果我们再次读取一行，那么这将是第二行。
- en: Work with Files Beyond Reading and Writing Local Files
  id: totrans-162
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 超越读取和写入本地文件的文件操作
- en: The files that are read do not necessarily have to be located on your local
    system. Provided that the files are not subject to any conflicting access protection,
    an Internet address (or `URL`, a `Uniform Resource Locator`) can regularly be
    specified as the file name in most programming languages. Files that are located
    on a web server, and that your browser reads and displays as a web page, can be
    read using a program you have written yourself just as if it were a file on your
    local computer.
  id: totrans-163
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 读取的文件不一定必须位于本地系统上。只要文件不受任何冲突的访问保护，大多数编程语言通常可以将互联网地址（或`URL`，统一资源定位符）指定为文件名。位于web服务器上的文件，你的浏览器作为网页读取和显示的文件，也可以通过你自己编写的程序读取，就像它是本地计算机上的文件一样。
- en: In addition to the functions for opening, reading, writing and closing files,
    many programming languages offer functions for working with the file system, such
    as creating or reading directories in the file system, or copying, moving, deleting
    or renaming files and directories. Functions for determining the file size or
    for checking whether a file exists at a certain path are also part of the standard
    scope of programming languages. Checking whether a file exists is useful to avoid
    an error or even uncontrolled program crash if your code tries to access a file
    that does not exist.
  id: totrans-164
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 除了用于打开、读取、写入和关闭文件的功能，许多编程语言还提供与文件系统交互的功能，例如在文件系统中创建或读取目录，或复制、移动、删除或重命名文件和目录。用于确定文件大小或检查某个路径下文件是否存在的功能，也是编程语言标准功能的一部分。检查文件是否存在有助于避免错误，甚至是当代码试图访问一个不存在的文件时引发未控制的程序崩溃。
- en: 当然，这里讨论的方法仅代表几乎所有编程语言具有的基本功能，尽管它们在各自设计上可能略有不同。此外，许多编程语言提供——无论是开箱即用还是通过扩展库——许多其他功能，用于处理文件。例如，读取或写入特殊文件格式（如图像文件或某些流行软件应用程序（如Microsoft
    Office）的专有格式的文件），或通过适当的网络协议（如`FTP`（`File Transfer Protocol`））与服务器交换文件。
  id: totrans-165
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当然，这里讨论的方法仅代表几乎所有编程语言具有的基本功能，尽管它们在各自设计上可能略有不同。此外，许多编程语言提供——无论是开箱即用还是通过扩展库——许多其他功能，用于处理文件。例如，读取或写入特殊文件格式（如图像文件或某些流行软件应用程序（如Microsoft
    Office）的专有格式的文件），或通过适当的网络协议（如`FTP`（`File Transfer Protocol`））与服务器交换文件。
- en: '`12.4`'
  id: totrans-166
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`12.4`'
- en: '`Explain the differences between the various options available when opening
    a file.`'
  id: totrans-167
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`解释打开文件时可用的各种选项之间的差异。`'
- en: '`12.4 Working with Databases`'
  id: totrans-168
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`12.4 与数据库的交互`'
- en: 在专业软件开发实践中，`working with databases`扮演着重要角色。我们今天所知的大多数web服务基本上是一个数据库（`"backend"`）和一个允许用户与存储在数据库中的数据交互的web用户界面（`"frontend"`）的结合。这对于web商店和社交网络都是如此。在专业环境中，读取和写入数据库因此成为数据输入和输出的常态，而不是例外。在非专业软件开发领域，`working
    with databases`的角色当然没有那么重要。因此，由于这个主题并不简单，我们将在本节中仅覆盖一些基础知识，以便给你提供一个主题的概述，并将细节留给更高级的编程课程。
  id: totrans-169
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在专业软件开发实践中，`working with databases`扮演着重要角色。我们今天所知的大多数web服务基本上是一个数据库（`"backend"`）和一个允许用户与存储在数据库中的数据交互的web用户界面（`"frontend"`）的结合。这对于web商店和社交网络都是如此。在专业环境中，读取和写入数据库因此成为数据输入和输出的常态，而不是例外。在非专业软件开发领域，`working
    with databases`的角色当然没有那么重要。因此，由于这个主题并不简单，我们将在本节中仅覆盖一些基础知识，以便给你提供一个主题的概述，并将细节留给更高级的编程课程。
- en: 'Most databases are collections of data tables that can be related to each other.
    They are called `relational` because the tables ultimately describe relations
    (relationships) between certain objects and their properties. As a stylized example,
    look at ◘ `Tables [12.1](#Tab1)`, `[12.2](#Tab2)`, and `[12.3](#Tab3)`. ◘ `Table
    [12.1](#Tab1)` contains the data of customers. The individual customers in the
    rows (in the context of the database, we speak of `data records`) can be uniquely
    identified via the column (in database language: the `field`) **CUSTOMERID**.
    ◘ `Table [12.2](#Tab2)` shows the products. These also have some descriptive fields
    as well as a unique ID, the field **PRODUCTID**. ◘ `Table [12.3](#Tab3)` represents
    the orders that the customers have placed. In this table, an order is identified
    by its own ID (**ORDERID**), the customer, the products that the customer ordered,
    and the order date. You can see that customers and products are represented by
    their IDs, and thus by `references to` the **CUSTOMER** and **PRODUCT** tables,
    respectively. Each row represents a combination of customer and ordered product.
    For example, you can see from purchase order **B0002** that customer **C00003**
    (Mason Thomas) ordered `two` products (namely **P001—**the garden shovel, and
    **P002—**the balcony table). Accordingly, in the **ORDER** assignment table, this
    order is described by `two` records. `Table 12.1`'
  id: totrans-170
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 大多数数据库是数据表的集合，这些表之间可以相互关联。它们被称为`关系型`数据库，因为这些表最终描述了某些对象及其属性之间的关系。例如，查看 ◘ `表格
    [12.1](#Tab1)`、`[12.2](#Tab2)` 和 `12.3](#Tab3)`。◘ `表格 [12.1](#Tab1)` 包含客户数据。表格中的每一行代表一个独立的客户（在数据库术语中，我们称之为
    `数据记录`），可以通过列（在数据库语言中称为 `字段`） **CUSTOMERID** 唯一标识。◘ `表格 [12.2](#Tab2)` 显示产品数据。这些产品也有一些描述字段以及唯一的ID字段
    **PRODUCTID**。◘ `表格 [12.3](#Tab3)` 表示客户所下的订单。在这个表格中，一个订单通过自己的ID (**ORDERID**)
    以及客户、客户所订购的产品和订单日期来标识。你可以看到，客户和产品通过它们的ID进行表示，因此分别通过对 **CUSTOMER** 和 **PRODUCT**
    表的 `引用` 来实现。每一行代表客户与订购产品的组合。例如，从订单 **B0002** 可以看到，客户 **C00003**（Mason Thomas）订购了
    `两` 件产品（分别是 **P001—**花园铲子和 **P002—**阳台桌子）。因此，在 **ORDER** 关联表中，这个订单由 `两` 条记录来描述。`表格
    12.1`
- en: Example data for table `CUSTOMER`
  id: totrans-171
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 表格 `CUSTOMER` 示例数据
- en: '| `Customerid` | `Name` | `First name` | `Email` | `Street` | `City` | `Zipcode`
    |'
  id: totrans-172
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `客户ID` | `姓氏` | `名字` | `电子邮件` | `街道` | `城市` | `邮政编码` |'
- en: '| `---` | `---` | `---` | `---` | `---` | `---` | `---` |'
  id: totrans-173
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `---` | `---` | `---` | `---` | `---` | `---` | `---` |'
- en: '| `C00001` | `Collins` | `Ethan` | `ecollins@my-emails.com` | `123 Oak Street,
    Apt 4B` | `New York, NY` | `10001` |'
  id: totrans-174
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `C00001` | `Collins` | `Ethan` | `ecollins@my-emails.com` | `123 Oak Street,
    Apt 4B` | `New York, NY` | `10001` |'
- en: '| `C00002` | `Rodriguez` | `Olivia` | `me@oliviarodriguez.com` | `456 Pine
    Avenue, Suite 9C` | `Chicago, IL` | `90001` |'
  id: totrans-175
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `C00002` | `Rodriguez` | `Olivia` | `me@oliviarodriguez.com` | `456 Pine
    Avenue, Suite 9C` | `Chicago, IL` | `90001` |'
- en: '| `C00003` | `Thomas` | `Mason` | `mason.thomas@thomas-winery.com` | `789 Maple
    Drive` | `Los Angeles, CA` | `60601` |'
  id: totrans-176
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `C00003` | `Thomas` | `Mason` | `mason.thomas@thomas-winery.com` | `789 Maple
    Drive` | `Los Angeles, CA` | `60601` |'
- en: '| `C00004` | `Wilson` | `Anna` | `anna@thewilsonfamily.com` | `321 Elm Street,
    Apartment 7D` | `Houston, TX` | `77002` |'
  id: totrans-177
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `C00004` | `Wilson` | `Anna` | `anna@thewilsonfamily.com` | `321 Elm Street,
    Apartment 7D` | `Houston, TX` | `77002` |'
- en: '`Table 12.2`'
  id: totrans-178
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`表格 12.2`'
- en: Example data for table `PRODUCT`
  id: totrans-179
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 表格 `PRODUCT` 示例数据
- en: '| `Product ID` | `Description` | `Price` |'
  id: totrans-180
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `产品ID` | `描述` | `价格` |'
- en: '| `---` | `---` |'
  id: totrans-181
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `---` | `---` |'
- en: '| `P001` | `Garden shovel, stainless steel` | `10.99` |'
  id: totrans-182
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `P001` | `不锈钢花园铲` | `10.99` |'
- en: '| `P002` | `Balcony table, plastic, green` | `24.99` |'
  id: totrans-183
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `P002` | `阳台桌子，塑料，绿色` | `24.99` |'
- en: '`Table 12.3`'
  id: totrans-184
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`表格 12.3`'
- en: Example data for table `ORDER`
  id: totrans-185
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 表格 `ORDER` 示例数据
- en: '| `Order ID` | `Customer ID` | `Product ID` | `Date` |'
  id: totrans-186
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `订单ID` | `客户ID` | `产品ID` | `日期` |'
- en: '| `---` | `---` | `---` | `---` |'
  id: totrans-187
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `---` | `---` | `---` | `---` |'
- en: '| `B0001` | `C00001` | `P001` | `2019-06-01 0:08 AM` |'
  id: totrans-188
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `B0001` | `C00001` | `P001` | `2019-06-01 0:08 AM` |'
- en: '| `B0002` | `C00003` | `P001` | `2018-12-05 7:49 AM` |'
  id: totrans-189
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `B0002` | `C00003` | `P001` | `2018-12-05 7:49 AM` |'
- en: '| `B0002` | `C00003` | `P002` | `2018-12-05 7:49 AM` |'
  id: totrans-190
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `B0002` | `C00003` | `P002` | `2018-12-05 7:49 AM` |'
- en: '| `B0003` | `C00002` | `P001` | `2019-05-16 9:58 PM` |'
  id: totrans-191
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `B0003` | `C00002` | `P001` | `2019-05-16 9:58 PM` |'
- en: Of course, we could have repeated all the customer and product data in the **ORDER**
    table; however, this would not only make the table unnecessarily large, but would
    also make data maintenance much more difficult, because changes to a customer’s
    master data (for example, his address) would then have to be made in two places
    in the database, the **CUSTOMER** table and the **ORDER** table. This would increase
    the risk of inconsistent data. These problems are avoided by the reference technique
    used here.
  id: totrans-192
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当然，我们本可以将所有的客户和产品数据重复存储在**ORDER**表中；然而，这不仅会使表变得不必要地庞大，还会使数据维护变得更加困难，因为如果要更改客户的主数据（例如地址），就必须在数据库中的两个地方进行更改：**CUSTOMER**表和**ORDER**表。这将增加数据不一致的风险。通过此处使用的引用技术，避免了这些问题。
- en: 定义基本对象仅一次并通过引用它们的ID或键来映射它们之间关系的过程被称为`规范化`。数据库系统确保这些引用始终有效，因此在`ORDER`表中被引用的客户不能从`CUSTOMER`表中删除，因为那样会使其现有的订单数据不一致。
  id: totrans-193
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 定义基本对象仅一次并通过引用它们的ID或键来映射它们之间关系的过程被称为`规范化`。数据库系统确保这些引用始终有效，因此在`ORDER`表中被引用的客户不能从`CUSTOMER`表中删除，因为那样会使其现有的订单数据不一致。
- en: By the way, our example tables here are not yet perfectly normalized。`订单`的日期实际上附加在`订单`本身上，而不是属于一个订单的客户和产品的单独组合，这些组合存储在`ORDER`表中。完整的规范化可以通过从`ORDER`表中移除产品（仅保留`订单`的ID、客户和日期在`ORDER`中）来实现，并通过它们的键在一个单独的表中存储订单与所订购产品之间的分配关系。
  id: totrans-194
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 顺便提一下，我们这里的示例表还没有完美规范化。`订单`的日期实际上附加在`订单`本身上，而不是属于一个订单的客户和产品的单独组合，这些组合存储在`ORDER`表中。完整的规范化可以通过从`ORDER`表中移除产品（仅保留`订单`的ID、客户和日期在`ORDER`中）来实现，并通过它们的键在一个单独的表中存储订单与所订购产品之间的分配关系。
- en: Data stored in databases in this way can be queried。用于此目的的特殊编程语言是`SQL`，或`结构化查询语言`。可以用这种语言来制定查询，并由数据库系统处理，然后返回查询的数据作为结果。最重要的`SQL`语句是`SELECT`。`SELECT`的语法基本上相当简单（尽管可以在许多地方扩展以创建更复杂的查询）：`SELECT`***fields***
    `FROM`***table*** `WHERE`***condition***。
  id: totrans-195
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以这种方式存储在数据库中的数据可以被查询。用于此目的的特殊编程语言是`SQL`，或`结构化查询语言`。可以用这种语言来制定查询，并由数据库系统处理，然后返回查询的数据作为结果。最重要的`SQL`语句是`SELECT`。`SELECT`的语法基本上相当简单（尽管可以在许多地方扩展以创建更复杂的查询）：`SELECT`***fields***
    `FROM`***table*** `WHERE`***condition***。
- en: The statement
  id: totrans-196
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 该语句
- en: '`SELECT` FIRSTNAME, NAME `FROM` CUSTOMER `WHERE` `LOCATION = ''New York, NY''`查询所有来自`CUSTOMER`表的数据记录，其中字段`CITY`的值为`"New
    York, NY"`。然而，并非所有字段都要显示，而是仅显示字段`FIRSTNAME`和`NAME`。因此，此语句的结果是一个仅包含这些字段的表，对于相关的数据记录，在示例中如◘表[12.4](#Tab4)所示。在我们的`SELECT`语句的情况下，结果表仅由一条记录组成，即Ethan
    Collins的记录。表12.4'
  id: totrans-197
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`SELECT` FIRSTNAME, NAME `FROM` CUSTOMER `WHERE` `LOCATION = ''New York, NY''`查询所有来自`CUSTOMER`表的数据记录，其中字段`CITY`的值为`"New
    York, NY"`。然而，并非所有字段都要显示，而是仅显示字段`FIRSTNAME`和`NAME`。因此，此语句的结果是一个仅包含这些字段的表，对于相关的数据记录，在示例中如◘表[12.4](#Tab4)所示。在我们的`SELECT`语句的情况下，结果表仅由一条记录组成，即Ethan
    Collins的记录。表12.4'
- en: Result of our `SQL` sample query with `SELECT`
  id: totrans-198
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们的`SQL`示例查询结果使用`SELECT`
- en: '| First name | Name |'
  id: totrans-199
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| First name | Name |'
- en: '| --- | --- |'
  id: totrans-200
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Ethan | Collins |'
  id: totrans-201
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| Ethan | Collins |'
- en: 然而，`SQL`不仅可以用于从数据库中查询数据，还可以向数据库写入数据。为此，使用`INSERT`和`UPDATE`语句，分别用于将`新`记录插入到表中（`INSERT`）或更新`现有`记录（`UPDATE`），即更改记录（或同时更改多个记录）的一个或多个字段的值。
  id: totrans-202
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，`SQL`不仅可以用于从数据库中查询数据，还可以向数据库写入数据。为此，使用`INSERT`和`UPDATE`语句，分别用于将`新`记录插入到表中（`INSERT`）或更新`现有`记录（`UPDATE`），即更改记录（或同时更改多个记录）的一个或多个字段的值。
- en: From most programming languages, databases can be addressed (often with the
    help of extension libraries, covered in the following chapter), fed with SQL statements
    and their results received and processed.
  id: totrans-203
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，可以访问数据库（通常借助扩展库，在下章中介绍），并且可以向数据库提供`SQL`语句，接收并处理其结果。
- en: 12.5 Your Roadmap to Learning a New Programming Language
  id: totrans-204
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 12.5 学习新编程语言的路线图
- en: If you are learning a new programming language …
  id: totrans-205
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你正在学习一门新的编程语言……
- en: 'you’ll discover:'
  id: totrans-206
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你将会发现：
- en: which types of user interfaces (GUIs, console) you can equip your programs with,
  id: totrans-207
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以为程序配置哪些类型的用户界面（图形界面、控制台），
- en: if console applications are supported, which functions are available for the
    output of data as well as for the input of data by the user,
  id: totrans-208
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果支持控制台应用程序，提供哪些函数用于数据输出以及用户输入数据，
- en: if graphical interfaces are supported, how they are designed (`graphical WYSIWYG`
    development in `IDE`, description of the interface in the code) and which controls
    are available to you for the design of your graphical user interface and which
    essential properties/configuration options they offer,
  id: totrans-209
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果支持图形界面，它们是如何设计的（在`IDE`中进行图形`WYSIWYG`开发，代码中描述接口）以及哪些控件可用于设计你的图形用户界面，它们提供哪些基本属性/配置选项，
- en: how to open (and close) files for reading, writing or appending data, in particular
    what different editing modes are available when opening and how to distinguish
    between opening text and binary files,
  id: totrans-210
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何打开（和关闭）文件以读取、写入或追加数据，特别是打开时可用的不同编辑模式，以及如何区分打开文本文件和二进制文件，
- en: what functions are available to write data into or read data from open files,
  id: totrans-211
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 可用于写入或读取打开文件中的数据的函数有哪些，
- en: '`if` you plan to work with databases, how to connect to databases as well as
    send `SQL` statements to the database and process the returned results.'
  id: totrans-212
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`如果`你计划使用数据库，如何连接数据库以及如何向数据库发送`SQL`语句并处理返回的结果。'
- en: '`12.6 Solutions to the Exercises`'
  id: totrans-213
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`12.6 练习的解决方案`'
- en: '`Exercise 12.1`'
  id: totrans-214
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Exercise 12.1`'
- en: Graphical user interfaces can be designed via an `Integrated Development Environment
    (IDE)` in `WYSIWYG` mode, where the individual control elements are selected and
    placed on the program interface with the mouse. Typically, the properties of the
    controls can be conveniently accessed. The user interface is thus created without
    having to “program” it. But many programming languages also allow the user interface
    to be created as part of the program code. The individual controls are then mostly
    objects that can be created from within the program—just like other objects—and
    placed on the interface. The properties of the controls can be accessed via the
    attributes of the objects representing them.
  id: totrans-215
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图形用户界面可以通过`集成开发环境（IDE）`的`所见即所得（WYSIWYG）`模式来设计，在这种模式下，用户可以通过鼠标选择并将各个控件放置在程序界面上。通常，控件的属性可以方便地访问。因此，用户界面是无需“编程”就能创建的。但许多编程语言也允许将用户界面作为程序代码的一部分来创建。各个控件通常是可以从程序内部创建的对象——就像其他对象一样——并放置在界面上。控件的属性可以通过表示它们的对象的属性来访问。
- en: '`Task 12.2`'
  id: totrans-216
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`任务 12.2`'
- en: '`Console` applications usually run in a completely linear fashion where the
    user is guided through the program, and the program determines the sequence of
    the user’s work. In applications with graphical interfaces, the user usually has
    more control over the order in which he or she executes which steps. For example,
    the user can click on buttons in any order. In this sense, the program does not
    determine user behavior; instead, it responds to `events` that the user triggers.
    For example, if the user clicks on a button, the associated event is triggered,
    and the program code intended for that event is executed. Although this type of
    event-oriented program control can, in principle, be reproduced in console applications,
    it is much less common there than in applications with graphical user interfaces.'
  id: totrans-217
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`控制台` 应用程序通常以完全线性的方式运行，用户在程序中被引导，而程序决定用户工作的顺序。在带有图形界面的应用程序中，用户通常对执行步骤的顺序有更多的控制。例如，用户可以按任意顺序点击按钮。从这个角度来看，程序并不决定用户的行为；相反，它响应用户触发的`事件`。例如，如果用户点击一个按钮，相关的事件就会被触发，然后为该事件编写的程序代码将被执行。虽然这种基于事件的程序控制原则上可以在控制台应用程序中实现，但在控制台应用程序中比在图形用户界面应用程序中要少得多。'
- en: '`Exercise 12.3`'
  id: totrans-218
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`练习 12.3`'
- en: 控制台应用程序通常快速且易于使用，前提是你熟悉它。当从控制台调用时，程序的行为通常可以通过命令行参数进行控制。所有控制操作都可以用键盘执行，这也便利了可用性，而图形用户界面通常需要指点工具（通常是鼠标），因此需要在输入设备之间切换手或双手。控制台应用程序在开发上也有优势，因为它们通常比图形用户界面应用程序的编程工作量更少。此外，开发控制台应用程序所需的编程语言知识水平通常低于开发图形用户界面的要求。
  id: totrans-219
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 控制台应用程序通常快速且易于使用，前提是你熟悉它。当从控制台调用时，程序的行为通常可以通过命令行参数进行控制。所有控制操作都可以用键盘执行，这也便利了可用性，而图形用户界面通常需要指点工具（通常是鼠标），因此需要在输入设备之间切换手或双手。控制台应用程序在开发上也有优势，因为它们通常比图形用户界面应用程序的编程工作量更少。此外，开发控制台应用程序所需的编程语言知识水平通常低于开发图形用户界面的要求。
- en: 练习 12.4
  id: totrans-220
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 12.4
- en: 在大多数编程语言中，打开文件的模式首先根据每种情况允许的编辑操作有所不同。文件可以以常规方式打开以进行读取（`read` / `r`）、写入（`write`
    / `w`）或追加（`append` / `a`）。以写入模式打开时，现有文件会被完全覆盖。如果要向现有文件追加数据，则必须以追加模式打开。第二个区别是文件是作为文本文件还是二进制文件打开，这主要影响写入数据的编码方式。
  id: totrans-221
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，打开文件的模式首先根据每种情况允许的编辑操作有所不同。文件可以以常规方式打开以进行读取（`read` / `r`）、写入（`write`
    / `w`）或追加（`append` / `a`）。以写入模式打开时，现有文件会被完全覆盖。如果要向现有文件追加数据，则必须以追加模式打开。第二个区别是文件是作为文本文件还是二进制文件打开，这主要影响写入数据的编码方式。
