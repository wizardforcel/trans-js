- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024J. L. ZuckarelliLearn coding with Python and JavaScript
    [https://doi.org/10.1007/978-3-658-42912-6_25](https://doi.org/10.1007/978-3-658-42912-6_25)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 作者（们），根据 Springer Fachmedien Wiesbaden GmbH 独家许可，隶属于 Springer Nature 2024
    J. L. Zuckarelli 使用 Python 和 JavaScript 编程 [https://doi.org/10.1007/978-3-658-42912-6_25](https://doi.org/10.1007/978-3-658-42912-6_25)
- en: '25. Loops: How Do I Repeat Program Instructions Efficiently?'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 25. 循环：如何高效地重复程序指令？
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1)München, GermanyOverview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Joachim L. Zuckarelli^([1](#Aff2) )(1)德国慕尼黑概述
- en: Next, we focus on the effective repetition of (almost) identical program instructions,
    a technique that allows for the elegant resolution of a lot of problems that would
    be hard so solve otherwise. Python employs both counting (for) and conditional
    (while) loops. A unique feature of Python is list comprehension expressions **derived
    from for loops**, enabling the concise comfortable of lists.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们关注有效重复（几乎）相同程序指令的技巧，这一技巧使得优雅地解决许多否则难以解决的问题成为可能。Python 使用计数（for）循环和条件（while）循环。Python
    的一个独特特点是**源自 for 循环**的列表推导式，它能够简洁地构建列表。
- en: 'In this chapter you will learn:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你将学习：
- en: How to formulate (counting) **for-**loops
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构造（计数）**for** 循环
- en: how to formulate (conditional) **while** loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构造（条件）**while** 循环
- en: how to nest loops inside each other
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将循环嵌套在彼此内部
- en: what list comprehension expressions are, and how you can use them to create
    lists in an elegant way
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是列表推导式，以及如何使用它们优雅地创建列表
- en: how to end loops or individual passes of loops early, and when this is useful
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何提前结束循环或单次循环，并且何时这样做是有用的
- en: 25.1 Counting Loops (for)
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 25.1 计数循环（for）
- en: 25.1.1 Simple for-Loops
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 25.1.1 简单的 for 循环
- en: Structure of for-Loops
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: for 循环的结构
- en: Counting loops in Python are introduced with the keyword **for**; therefore,
    we will refer to them simply as **for**-loops in the following. With **for**-loops
    in Python, a run variable is not incremented with each loop pass, as is the case
    in many other languages, but an *object* is always *passed through* that has elements
    that can be addressed one after the other. Such an object is also called *iterable*
    in Python because you can “shimmy” from one element to the next step by step.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的计数循环通过关键字 **for** 引入；因此，以下我们将其称为 **for** 循环。在 Python 中，**for** 循环并不像许多其他语言那样每次循环时递增一个运行变量，而是始终“传递”一个包含可以一个接一个访问的元素的*对象*。这样的对象在
    Python 中也叫做*可迭代对象*，因为你可以一步步地“摇动”到下一个元素。
- en: Examples of such objects are lists or tuples. They all have elements that a
    counting loop can process one after the other. It is not important that the elements
    in the object are in a fixed order, as is the case with lists and tuples. The
    only thing that matters is that (except for the last one, of course) a *next*
    element can always be found. This is also the case, for example, with sets and
    dictionaries, in which the elements are not stored sequentially, or in an order
    that can be exploited by the programmer. Nevertheless, the elements of sets and
    dictionaries naturally do have an internal sequence (usually the sequence in which
    the elements were added to the set or dictionary) and thus a *next* element can
    always be determined for these objects as well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这类对象的例子有列表或元组。它们都有可以被计数循环逐一处理的元素。对象中的元素是否按固定顺序排列并不重要（如列表和元组中的情况）。唯一重要的是，（当然除了最后一个元素）总能找到一个*下一个*元素。例如，集合和字典也是如此，尽管它们的元素不是按顺序存储的，也没有按照程序员可以利用的顺序排列。然而，集合和字典的元素自然有一个内部顺序（通常是元素加入集合或字典的顺序），因此对于这些对象，也总是可以确定一个*下一个*元素。
- en: 'If the iterability of objects and the traversal of their elements seems rather
    abstract to you, don’t worry: In the following example, you can see how simple
    **for**-loops are constructed in Python. Here we have a loop that does nothing
    but output the numbers between 1 and 10 on the screen:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得对象的可迭代性以及遍历其元素有些抽象，不必担心：在以下例子中，你可以看到如何在 Python 中构建简单的 **for** 循环。这里有一个循环，它仅仅在屏幕上输出从
    1 到 10 的数字：
- en: '**for** i **in** [1,2,3,4,5,6,7,8,9,10]:print(i)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**for** i **in** [1,2,3,4,5,6,7,8,9,10]: print(i)'
- en: 'In Python, **for**-loops also have a run variable, in our example **i**. It
    is defined directly after the **for** keyword. The run variable takes the value
    of an element of the traversed object on each loop pass. In our example, the object
    being passed through is a list with the numbers 1 to 10\. In sequence, the run
    variable **i** is now loaded with the value of a list element; in the first loop
    pass with 1, in the second with 2, until the run variable finally takes on the
    value of the last list element, 10\. Our list is iterable, so Python always knows
    which element is next in line for the next loop pass. We can also work with the
    changing value of the run variable in the code block that is executed on each
    loop pass, and that’s exactly what we’re doing here in the example: the code block
    is indented following the *head* of the loop introduced with the **for** keyword
    and terminated with a colon. In our example, the code block consists of only one
    statement, the output of the run variable. If you execute the code of the example,
    you will get the numbers from 1 to 10 as output, as expected.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，**for** 循环也有一个运行变量，在我们的例子中是 **i**。它是在 **for** 关键字后面直接定义的。运行变量在每次循环时获取被遍历对象的一个元素值。在我们的例子中，被遍历的对象是一个包含数字
    1 到 10 的列表。按顺序，运行变量 **i** 将依次赋值为列表元素的值；第一次循环时是 1，第二次是 2，直到最后一次循环时，运行变量的值为最后一个元素
    10。我们的列表是可迭代的，所以 Python 始终知道下一个循环传递中应使用哪个元素。我们还可以在每次循环时，使用运行变量的值来执行代码块，这正是我们在这里例子中所做的：代码块位于
    **for** 关键字引入的 *头部* 后面，并以冒号结束。在我们的例子中，代码块只有一条语句，即输出运行变量的值。如果你执行这个例子中的代码，你将得到从
    1 到 10 的输出，正如预期的那样。
- en: 'It is not always practical to specify a list of numbers as explicitly as we
    did in our example, especially if the list is very long, or if its bounds are
    not yet known at the time the program is developed and result from variables in
    the program. In these cases, the function **range(*****start*****,** ***stop*****,**
    ***step*****=1)** is a useful tool. It generates a sequence of numbers between
    **start** and **stop** in the interval of **step**, where the latter is an optional
    argument and is assumed to be 1 if it is not explicitly specified when calling
    the range. Note: The value **stop** itself is not part of the generated sequence
    of numbers. You may recognize here the analogy to indexing with an index range;
    in ► Sect. [21.​6.​1.​2](474412_1_En_21_Chapter.xhtml#Sec16) we discussed this
    kind of indexing using the colon operator. You can easily visualize this by typing
    **list(range(1,10))** in the Python console. You get a sequence of integers from
    1 to 9\. The return object of **range()** is an object of class **range** and
    must first be converted to a list for output, because the **__str__()** method
    (see ► Sect. [21.​1](474412_1_En_21_Chapter.xhtml#Sec1) for details on **__str__()**)
    of the **range** class does not display the sequence of numbers itself—try it!.
    However, this object can be iterated.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际情况中，像我们在例子中那样显式地指定一个数字列表并不总是可行，尤其是当列表非常长，或者当程序开发时尚不知道列表的边界，而这些边界是由程序中的变量决定的。在这些情况下，**range(*****start*****,**
    ***stop*****,** ***step*****=1)** 函数是一个有用的工具。它生成一个从 **start** 到 **stop** 之间按 **step**
    间隔的数字序列，其中 **step** 是一个可选参数，如果调用时未显式指定，则默认为 1。注意：**stop** 本身不包含在生成的数字序列中。你可能会注意到，这里有一个类似于使用索引范围进行索引的类比；在►第[21.6.1.2节](474412_1_En_21_Chapter.xhtml#Sec16)我们讨论了使用冒号操作符进行这种索引。你可以通过在
    Python 控制台中输入 **list(range(1,10))** 来直观地理解这一点。你会得到一个从 1 到 9 的整数序列。**range()**
    函数的返回对象是 **range** 类的一个对象，必须先转换为列表才能输出，因为 **range** 类的 **__str__()** 方法（详见►第[21.1节](474412_1_En_21_Chapter.xhtml#Sec1)关于
    **__str__()**）并不会直接显示数字序列本身——试试看！不过，这个对象是可以迭代的。
- en: 'This would simplify our example above to:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子可以简化为：
- en: '**for** i **in** range(1,11):print(i)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**for** i **in** range(1,11):print(i)'
- en: 'Now consider the following example, where we adjust the value of our run variable
    during the loop:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下例子，我们在循环中调整了运行变量的值：
- en: my_range = range(1,11)**for** i **in** my_range:i = 2print(my_range)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: my_range = range(1,11)**for** i **in** my_range:i = 2print(my_range)
- en: The output generated by the final **print()** statement shows that the object
    **my_range** has not changed, although we assign the value 2 to our run variable
    **i**, which represents a different element of **my_range** on each loop pass.
    However, this obviously has no effect. The reason is that the run variable in
    a **for**-loop always represents only a *copy of* the element that is currently
    in focus. Thus, by assigning **i=2**, we do not change the respective element
    of our **range** object at all, but only the run variable itself.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最终**print()**语句生成的输出显示，尽管我们将值2赋给了运行变量**i**（它在每次循环时代表**my_range**中的不同元素），但**my_range**对象本身并没有发生变化。然而，这显然没有影响。原因是，在**for**循环中，运行变量始终仅代表当前聚焦元素的*副本*。因此，通过赋值**i=2**，我们并没有改变**range**对象的相应元素，而只是改变了运行变量本身。
- en: Examples of for-Loops
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: for循环示例
- en: Now, outputting a sequence of numbers is not necessarily a particularly useful
    application of **for**-loops. Therefore, in the next example, we look at a simple
    encryption algorithm, also known as *ROT13*. Each character of a string can be
    interpreted as a numeric code that uniquely identifies the character in the particular
    character set. For example, in the very common UTF-8 character set, the number
    code 65 represents the capital “A”, 66, the capital “B”, and so on. The lowercase
    letters follow from 97\. The ROT13 algorithm takes advantage of this convertibility
    of letters into numbers by simply incrementing each letter code by a specific
    number—13 in the original. Thus, “A” (code 65) becomes “N” (code 78), “B” (code
    66) becomes “O” (code 79), and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输出一系列数字并不一定是**for**循环的特别有用的应用。因此，在下一个示例中，我们来看一个简单的加密算法，也叫做*ROT13*。字符串中的每个字符都可以被解释为一个数字代码，该代码在特定字符集内唯一地标识该字符。例如，在非常常见的UTF-8字符集中，数字代码65代表大写字母“A”，66代表大写字母“B”，依此类推。小写字母从97开始。ROT13算法利用了字母到数字的可转换性，通过将每个字母代码增加一个特定的数字（原始算法中是13）来实现加密。因此，“A”（代码65）变成了“N”（代码78），“B”（代码66）变成了“O”（代码79），依此类推。
- en: 'We want to develop a function **rot13(s: str, decode: bool, shift: int=13)**
    that takes the string argument **s**, and depending on the **bool** argument **decode**
    either encodes or decodes this string. This should use a character code shift
    of 13 by default, but it should also be possible to set a different shift using
    the argument of the same name.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '我们希望开发一个函数**rot13(s: str, decode: bool, shift: int=13)**，该函数接收字符串参数**s**，根据**bool**类型的**decode**参数来决定是编码还是解码该字符串。默认情况下，它使用字符代码偏移量13，但也可以通过相同名称的参数来设置不同的偏移量。'
- en: 'Of course, the question arises as to where exactly a **for**-loop comes into
    play here. But you probably already guessed: As you already know, the string **s**
    can of course be broken down into a list of characters; we can run through this
    list and thus process each individual character of the string in turn. To do this,
    we use the functions **ord(*****character*****)** and **chr(*****code*****)**,
    which return the numeric code for a given character and the character for a numeric
    code, respectively.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，问题是**for**循环究竟在这里起什么作用。但你可能已经猜到：如你所知，字符串**s**当然可以分解为一个字符列表；我们可以遍历这个列表，从而逐个处理字符串中的每个字符。为此，我们使用**ord(*****character*****)**和**chr(*****code*****)**函数，前者返回给定字符的数字代码，后者返回数字代码对应的字符。
- en: 'The function **rot13()** could then look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 函数**rot13()**可能看起来像这样：
- en: '**def** rot13(s: str, decode: bool, shift: int = 13) -> str:s = list(s)res
    = list()**for** c **in** s:**if** decode == **True**:res.append(chr(ord(c) - shift))**else**:res.append(chr(ord(c)
    + shift))**return** ''''.join(res)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**def** rot13(s: str, decode: bool, shift: int = 13) -> str: s = list(s) res
    = list() **for** c **in** s: **if** decode == **True**: res.append(chr(ord(c)
    - shift)) **else**: res.append(chr(ord(c) + shift)) **return** ''''.join(res)'
- en: The **for**-loop runs through the string **s**, which we have previously converted
    into a list of individual characters. The run variable **c** therefore represents
    a different character of the string **s** in each loop pass.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**for**循环遍历字符串**s**，我们之前已将其转换为一个包含单个字符的列表。因此，运行变量**c**在每次循环中代表字符串**s**中的一个不同字符。'
- en: With **append()** we gradually build a new list containing characters of the
    encoded or decoded string. Finally, we **join()** the characters of the list to
    a string, append it to an empty string (whose **join()** method we use for this)
    and return it as a return value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**append()**我们逐渐构建一个新列表，包含编码或解码后的字符串字符。最后，我们使用**join()**将列表中的字符连接成一个字符串，将其附加到一个空字符串（我们为此使用**join()**方法）并将其作为返回值返回。
- en: We can now call the function with **print(rot13('HELLO WORLD', False))**, for
    example, which prints **URYY\-d\_YQ** to the console. With **print(rot13('URYY\-d\_YQ',
    True))** we can decode the encoded text again. If the end result is **'HELLO WORLD'**
    again, you know your function is working correctly!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过调用 **print(rot13('HELLO WORLD', False))** 来测试这个函数，例如，它会将 **URYY\-d\_YQ**
    打印到控制台。使用 **print(rot13('URYY\-d\_YQ', True))** 我们可以再次解码编码后的文本。如果最终结果是 **'HELLO
    WORLD'**，那么你就知道你的函数工作正常了！
- en: To conclude this section, let’s look at another example. This time, we want
    to write a program that lets the user enter a directory and then lists the subdirectories
    and files it contains. To do this, we will use functions from the standard Python
    package **os**. This package provides ways to access operating system functionality
    and resources. This includes functions that allow you to work with the file system.
    The beauty of **os** here is that it is designed to be cross-platform; therefore,
    a program that uses **os** functions and works on your Windows computer will work
    just as well on a Mac or Linux computer. You do not have to worry about the specifics
    of these different operating systems. The **os** package provides a uniform, cross-platform
    programming interface for all of these systems that abstracts from the specifics
    of the systems.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这一部分内容时，我们来看看另一个例子。这一次，我们想写一个程序，让用户输入一个目录，然后列出该目录包含的子目录和文件。为此，我们将使用来自标准 Python
    包 **os** 的函数。这个包提供了访问操作系统功能和资源的方法，其中包括允许你与文件系统交互的函数。**os** 的优点在于它是跨平台设计的；因此，使用
    **os** 函数的程序不仅能在你的 Windows 计算机上运行，也能在 Mac 或 Linux 计算机上运行。你无需担心这些操作系统的具体细节。**os**
    包为所有这些系统提供了一个统一的、跨平台的编程接口，抽象了系统的具体实现。
- en: 'The code of our program could now look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序代码现在看起来可以是这样的：
- en: '**from** os **import** listdir, sep**from** os.path **import** isdir, isfile,
    getsizedirectory = input(''Please enter a directory: '')**if** isdir(directory):**if**
    directory[directory.__len__() - 1] != sep:directory = directory + sepprint(''\nContents
    of:'', directory)content = listdir(directory)print(''\n----- Directories:'')**for**
    elem **in** content:**if** isdir(directory + elem):print(elem)print(''\n-----
    Files:'')**for** elem **in** content:**if** isfile(directory + elem):print(directory
    + elem, ''\tSize: '',getsize(directory + elem), sep = '''')'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**从** os **导入** listdir, sep **从** os.path **导入** isdir, isfile, getsizedirectory
    = input(''请输入一个目录: '')**如果** isdir(directory):**如果** directory[directory.__len__()
    - 1] != sep:directory = directory + sepprint(''\n目录内容:'', directory)content =
    listdir(directory)print(''\n----- 目录:'')**对于** elem **在** content:**如果** isdir(directory
    + elem):print(elem)print(''\n----- 文件:'')**对于** elem **在** content:**如果** isfile(directory
    + elem):print(directory + elem, ''\t大小: '',getsize(directory + elem), sep = '''')'
- en: 'You can tell from the imports which elements of the **os** module we want to
    use. The **listdir(*****path*****)** function returns the contents of the specified
    directory as a list. The constant **sep** represents the separator used in path
    specifications on the respective system, i.e., the backslash (**\**) for Windows,
    the forward slash (**/**) for Linux. Finally, using the **isdir(*****path*****)**
    and **isfile(*****path*****)** functions from the **path** module, we can determine
    whether a given directory or file path leads to a valid directory or file. Both
    functions return a **bool** value. The last imported function, **getsize(*****filename*****)**,
    returns the size of the specified file in bytes. Please note: Whenever you specify
    a file, the full path must be included, otherwise the file will not be found.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从导入的内容看出我们要使用 **os** 模块中的哪些元素。**listdir(*****path*****)** 函数返回指定目录的内容，作为一个列表。常量
    **sep** 表示在各个系统中路径规范使用的分隔符，即 Windows 中的反斜杠（**\**），Linux 中的正斜杠（**/**）。最后，使用 **path**
    模块中的 **isdir(*****path*****)** 和 **isfile(*****path*****)** 函数，我们可以判断给定的目录或文件路径是否指向一个有效的目录或文件。这两个函数都会返回一个
    **bool** 值。最后导入的函数 **getsize(*****filename*****)** 返回指定文件的大小（单位为字节）。请注意：每次指定文件时，必须包含完整的路径，否则文件将无法找到。
- en: The code uses two **for**-loops that step through the directory contents determined
    by **listdir()**. The first loop processes only the directories, so that these
    are then at the top in the program output, the second only files, which then appear
    below the directory list in the output.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了两个 **for** 循环，它们遍历由 **listdir()** 确定的目录内容。第一个循环只处理目录，这样这些目录就会在程序输出的最前面显示，第二个循环只处理文件，它们会显示在输出中目录列表的下面。
- en: 25.1 [10 min]
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 25.1 [10分钟]
- en: Write a function that removes all vowels from a string.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，从字符串中移除所有元音字母。
- en: 25.2 [10 min]
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 25.2 [10分钟]
- en: Write a function that completely reverses a string, converting it to uppercase.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 写一个函数，完全反转一个字符串，并将其转换为大写字母。
- en: 25.1.2 Nested for-Loops
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 25.1.2 嵌套的 for 循环
- en: '**for**-loops can also be nested within each other. Consider the following
    example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**for**循环也可以相互嵌套。考虑以下示例：'
- en: letters = ['A','B','C','D','E','F','G']numbers = [1,2,3,4,5,6,7,8,8,10]**for**
    b **in** letters:**for** z **in** numbers:print(b + str(z), ' ', end = '')print('\n')
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: letters = ['A','B','C','D','E','F','G']numbers = [1,2,3,4,5,6,7,8,8,10]**for**
    b **in** letters:**for** z **in** numbers:print(b + str(z), ' ', end = '')print('\n')
- en: 'Here we see two **for**-loops: an *outer* loop that runs through the list of
    letters from A to G and an *inner* loop that takes care of the numbers from 1
    to 10\. The inner loop is indented in the code block of the outer loop. With each
    run of the outer loop, the inner **for** construct is run through completely,
    i.e. the numbers from 1 to 10 are processed. After that, the outer loop goes into
    its next pass, that is, into processing the next letter. What do you think this
    little program will output?'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们看到两个**for**循环：一个*外部*循环遍历从 A 到 G 的字母列表，一个*内部*循环处理从 1 到 10 的数字。内部循环在外部循环的代码块中缩进。每次运行外部循环时，内部**for**构造都会完全执行一次，也就是说，从
    1 到 10 的数字都会被处理。之后，外部循环进入下一次迭代，也就是处理下一个字母。你认为这个小程序会输出什么？
- en: 'This is what we see when we run the program:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序时我们看到的输出如下：
- en: A1 A2 A3 A4 A5 A6 A7 A8 A10B1 B2 B3 B4 B5 B6 B7 B8 B10C1 C2 C3 C4 C5 C6 C7 C8
    C10D1 D2 D3 D4 D5 D6 D7 D8 D10E1 E2 E3 E4 E5 E6 E7 E8 E10F1 F2 F3 F4 F5 F6 F7
    F8 F10G1 G2 G3 G4 G5 G6 G7 G8 G10
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: A1 A2 A3 A4 A5 A6 A7 A8 A10B1 B2 B3 B4 B5 B6 B7 B8 B10C1 C2 C3 C4 C5 C6 C7 C8
    C10D1 D2 D3 D4 D5 D6 D7 D8 D10E1 E2 E3 E4 E5 E6 E7 E8 E10F1 F2 F3 F4 F5 F6 F7
    F8 F10G1 G2 G3 G4 G5 G6 G7 G8 G10
- en: Thus, for the letter currently being passed through in the outer loop, **b from**
    in the list **letters**, the program writes the combination of this letter and
    *all* numbers from 1 to 10 passed through in the inner loop, one after the other;
    note the argument assignment **end = ''** in the function **print()**, which causes
    *no* line break to occur after each output. Only after the inner loop has been
    completely traversed is a newline (**\n**) output and the outer loop goes into
    the next pass. Note, that the **print('\n')** is on the indentation level of the
    outer, not the inner loop. So, the outer loop code block consists of the complete
    inner **for**-loop and the **print()** statement that creates the newline.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于当前在外部循环中传递的字母**b from**在列表**letters**中的情况，程序将这个字母与从 1 到 10 的所有数字在内部循环中逐一组合输出；注意函数**print()**中的参数赋值**end
    = ''**，它使得每次输出后*不会*产生换行符。只有在内部循环完全遍历完后，才会输出换行符（**\n**），然后外部循环进入下一次迭代。请注意，**print('\n')**位于外部循环的缩进级别，而非内部循环的缩进级别。因此，外部循环代码块包含了完整的内部**for**循环和创建换行符的**print()**语句。
- en: Of course, not only two but even more **for**-loops can be nested in this way.
    However, you have to be careful with the runtime of the program, because each
    additional **for**-loop basically multiplies the number of loop passes by its
    own pass count.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，不仅仅是两个，甚至更多的**for**循环也可以以这种方式进行嵌套。但是，你必须小心程序的运行时间，因为每增加一个**for**循环，基本上都会将循环的次数乘以它自己的迭代次数。
- en: 25.1.3 List Comprehension Expressions
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 25.1.3 列表推导式
- en: A special feature in Python are *list comprehension expressions*. What may sound
    scary at first is nothing more than a **for**-loop that generates a list. For
    such **for**-loops there is a compact, elegant notation, the list comprehension
    expression.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的一个特殊特性是*列表推导式*。乍一听可能让人觉得很吓人，但它其实只是一个生成列表的**for**循环。对于这种**for**循环，有一种简洁优雅的写法，即列表推导式。
- en: 'In the last section, we used the **listdir()** function from the **os** module
    to determine the contents of a directory as a list and then used the **isfile()**
    function in a **for**-loop to check each element to see whether it was a file
    (and not a directory). Only if it was indeed a file did we output the item to
    the screen. We did the same with directories in another **for**-loop. This way
    we could cleanly separate directories and files in the output. It would have been
    easier to create two lists from the beginning, one with the files, one with the
    directories, and then display them with two simple **for**-loop**s**. This is
    a task that is tailor-made for the use of list comprehension expressions. Consider
    the following formulation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了 **os** 模块中的 **listdir()** 函数来获取目录内容并将其作为列表，然后在 **for** 循环中使用 **isfile()**
    函数检查每个元素，查看它是否是文件（而不是目录）。只有在确认它是文件时，我们才会将该项目输出到屏幕上。对于目录，我们在另一个 **for** 循环中做了相同的操作。通过这种方式，我们可以在输出中清晰地区分目录和文件。其实，最开始就创建两个列表，一个存放文件，一个存放目录，再用两个简单的
    **for** 循环显示它们会更容易。这正是使用列表推导式的理想场景。考虑以下写法：
- en: content = listdir(directory)files = [f **for** f **in** content **if** isfile(directory
    + f)]directories = [f **for** f **in** content **if** isdir(directory + f)]
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: content = listdir(directory)files = [f **for** f **in** content **if** isfile(directory
    + f)]directories = [f **for** f **in** content **if** isdir(directory + f)]
- en: First, we get the contents of our selected directory with **listdir()**. Then
    we use two list comprehension expressions to filter out the files and directories
    from the list **content**. The list comprehension expression returns something,
    namely the elements that should be in the result list. What is returned is initially
    enclosed in the square brackets that signal the construction of a list; in our
    example, this is **f**. Now follows a **for**-loop, namely **for f in content**.
    This loops through each element of the list **content**. However, only those elements
    are returned that satisfy the condition defined by **if**, i.e., in our first
    example, all those elements for which the function **isfile()** returns the value
    **True**. The list comprehension expression thus goes through all elements of
    **content**, the list with the directory contents, and returns those that are
    files.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 **listdir()** 获取所选目录的内容。然后，我们使用两个列表推导式从列表 **content** 中筛选出文件和目录。列表推导式返回某些内容，即应包含在结果列表中的元素。返回的内容最初会被包含在方括号内，表示正在构造一个列表；在我们的示例中，这就是
    **f**。接下来是 **for** 循环，即 **for f in content**。该循环会遍历列表 **content** 中的每个元素。然而，只有那些满足
    **if** 定义的条件的元素才会被返回；例如，在第一个示例中，所有 **isfile()** 函数返回值为 **True** 的元素才会被返回。因此，列表推导式会遍历
    **content** 中的所有元素（即目录内容的列表），并返回那些是文件的元素。
- en: 'The **if** condition is optional. For example, if we wanted to get a list of
    all items in the directory, but in upper case, we could omit the condition, but
    we would still modify the result before returning it by calling the **upper()**
    function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**if** 条件是可选的。例如，如果我们想要获取目录中所有项目的列表，但需要将它们转换为大写字母，我们可以省略该条件，但在返回结果之前，我们仍然可以通过调用
    **upper()** 函数对结果进行修改：'
- en: content_capitalized = [f.upper() **for** f **in** content]
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: content_capitalized = [f.upper() **for** f **in** content]
- en: This example also shows that the expression that is “fed” with new elements
    by the **for**-loop of the list comprehension expression can also be a more complex
    expression than simply the object itself returned by the **for**-loop; in this
    case, a method is called for this object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例还展示了，列表推导式中由 **for** 循环传入新元素的表达式，可以比 **for** 循环返回的对象本身更复杂；在这种情况下，调用了该对象的方法。
- en: Another example is the following, where we square the value of the variable
    returned by the **for**-loop if the variable itself is evenly divisible by two,
    that is, an even number. To do this, we use the modulo operator **%**, which returns
    the remainder of a division.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例是，在下面的情况下，如果变量的值可以被 2 整除（即是偶数），我们将对由 **for** 循环返回的变量进行平方。为此，我们使用了取模运算符
    **%**，它返回除法的余数。
- en: squares = [x*x **for** x **in** range(1,11) **if** x % 2 == 0]
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: squares = [x*x **for** x **in** range(1,11) **if** x % 2 == 0]
- en: Here, the expression that is fed with values by the **for**-loop is just **x*x**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由 **for** 循环传入的表达式只是 **x*x**。
- en: 'So, list comprehension expressions generally have the following form (where,
    we have already seen, the condition is optional):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，列表推导式通常具有以下形式（我们已经看到，条件是可选的）：
- en: list = [*expression* **for** *variable* **in** *iterable_object* **if** *condition*]25.3
    [5 min]
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: list = [*表达式* **for** *变量* **in** *可迭代对象* **if** *条件*]25.3 [5 分钟]
- en: 'Write a list comprehension expression that summarizes the uppercase letters
    from A to Z as a list. Tip: Work with functions the **ord(*****characters*****)**
    and **chr(*****code*****)** that we also used in ► Sect. [25.1.1](#Sec2).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个列表推导式，汇总从 A 到 Z 的大写字母作为列表。提示：使用我们在 ► 第 [25.1.1](#Sec2) 节中也使用过的 **ord(*****字符*****)**
    和 **chr(*****编码*****)** 函数。
- en: What would an equivalent **for**-loop look like that produces the letter list
    without a list comprehension expression?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用列表推导式，等效的 **for** 循环会是什么样子呢？
- en: 25.2 Conditional Loops (while)
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 25.2 条件循环（while）
- en: Python allows a conditional loop construction with the **while** loop, i.e.,
    a loop that runs as long as a run condition is fulfilled. Python’s **while** loop
    is *head-controlled*, which means that the condition is checked *before* each
    run. If the condition is not fulfilled even before the first potential run, the
    loop is not run at all.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许使用带有条件的循环结构，即 **while** 循环，循环在满足运行条件时继续执行。Python 的 **while** 循环是 *头控型*，意味着条件在每次运行之前都会被检查。如果条件在第一次运行前就没有满足，循环将根本不会执行。
- en: 'A **while** loop can of course be used to simulate the same behavior as a **for**-loop.
    In the following example, a **while** loop outputs the numbers 1 to 10 on the
    screen:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**while** 循环当然可以用来模拟与 **for** 循环相同的行为。在以下示例中，**while** 循环将数字 1 到 10 输出到屏幕：'
- en: i = 1**while** i <= 10:print(i)i = i + 1
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: i = 1**while** i <= 10:print(i)i = i + 1
- en: We initialize a variable **i**, which we use as a run variable, with the value
    1\. Before each run, the loop checks whether the condition that **i** is less
    than or equal to 10 is still met. If it is, the block of code that begins after
    the colon, indented as usual, is run. The loop then jumps back to the loop head,
    where the run condition is checked again.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化一个变量 **i**，作为运行变量，并将其赋值为 1。在每次运行之前，循环会检查条件是否仍然满足，即 **i** 是否小于或等于 10。如果满足，冒号后面的代码块将被执行，代码块会按常规缩进。然后，循环会跳回循环头，再次检查运行条件。
- en: The most common mistake in such a construction is to forget to also increment
    the run variable (as happened to the author in his first attempt), because unlike
    the **for**-loop, the **while** loop does not perform this task itself. The **while**
    loop stubbornly continues to run as long as the run condition is met. We have
    to take care of the rest ourselves. If the run condition is *always* fulfilled,
    we have created an infinite loop, which is usually undesirable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种结构中最常见的错误是忘记增加运行变量（这正是作者在第一次尝试时犯的错误），因为与 **for** 循环不同，**while** 循环不会自动执行此任务。**while**
    循环只要满足运行条件就会固执地继续运行。我们必须自己处理其他部分。如果运行条件*始终*满足，就会创建一个无限循环，这通常是不希望的。
- en: The **while** loop shows its true strength, however, when—unlike in the example
    above—the number of loop passes cannot be determined in advance. For example,
    because the passing through the loop depends on an event that results from an
    interaction with the user. Consider the following example. It lists all files
    contained in a directory selected by the user and allows him to open or start
    one of these files. We accomplish the latter with the **startfile(*****file*****)**
    function from the **os** module, which we have already used in the previous sections.
    In our simple application, the user can specify the file to be opened/started
    by a number with which the file is listed. We also offer the user the possibility
    to change the directory or to quit the program completely. The core of the program
    consists of a **while** loop, in which we ask the user again and again for his
    action wishes (variable **choice**), and which enters via a letter (**'d'** for
    read directory, **'s'** for open/start file, **'q'** for quit). The condition
    of the **while** loop is that the user’s choice is different from **'q'**. As
    long as this is the case, the program continues to run, if this is no longer the
    case, the program ends.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**while** 循环真正显示其强大之处的是，当——与上面的示例不同——循环的次数无法提前确定时。例如，因为循环的执行依赖于与用户交互所产生的事件。考虑以下示例。它列出了用户选择的目录中所有的文件，并允许用户打开或启动其中的一个文件。我们通过
    **os** 模块中的 **startfile(*****file*****)** 函数来实现后者，这个函数我们在之前的部分已经使用过。在我们这个简单的应用中，用户可以通过一个编号来指定要打开/启动的文件。我们还提供了让用户更改目录或完全退出程序的选项。程序的核心是一个
    **while** 循环，在该循环中，我们一遍又一遍地询问用户希望执行的操作（变量 **choice**），并根据用户输入的字母（**''d''** 代表读取目录，**''s''**
    代表打开/启动文件，**''q''** 代表退出）作出相应的操作。**while** 循环的条件是用户的选择不同于 **''q''**。只要条件成立，程序就会继续运行，否则程序结束。'
- en: 'Here is the complete program code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的程序代码：
- en: '**from** os **import** listdir, startfile**from** os.path **import** isfile,
    isdirchoice = ''''dir_exists = **False****while** choice != ''q'':choice = input(''Read
    directory (d), start file (s),'' \''quit (q)? '')**if** choice != ''q'':**if**
    choice == ''d'':directory = input(''Please enter a directory: '')**if** isdir(directory):dir_exists
    = **True**files = [f **for** f **in** listdir(directory) **if** isfile(f) == **True**]number
    = 0**for** f **in** files:**if** isfile(directory + f):number = number + 1print(number,
    '': '', f, sep = '''')**else**:print(''"'', directory, ''" is not a valid directory!","Please
    try again.'', sep = '''')dir_exists = **False****elif** choice == ''s'':**if**
    dir_exists == **True**:number = int(input(''Please enter file number: ''))**if**
    number >= 1 **and** number <= files.__len__():startfile(directory + files[number
    - 1])**else**:print(''No directory loaded!'')**else**:print(''Input '', choice,
    '' is not permitted! Please try again.'',sep = '''')'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**from** os **import** listdir, startfile **from** os.path **import** isfile,
    isdir choice = '''' dir_exists = **False** **while** choice != ''q'': choice =
    input(''读取目录 (d)，启动文件 (s)，退出 (q)? '') **if** choice != ''q'': **if** choice ==
    ''d'': directory = input(''请输入目录: '') **if** isdir(directory): dir_exists = **True**
    files = [f **for** f **in** listdir(directory) **if** isfile(f) == **True**] number
    = 0 **for** f **in** files: **if** isfile(directory + f): number = number + 1
    print(number, '': '', f, sep = '''') **else**: print(''"'', directory, ''" 不是有效目录！",
    "请再试一次。'', sep = '''') dir_exists = **False** **elif** choice == ''s'': **if**
    dir_exists == **True**: number = int(input(''请输入文件编号: '')) **if** number >= 1
    **and** number <= files.__len__(): startfile(directory + files[number - 1]) **else**:
    print(''没有加载目录！'') **else**: print(''输入 '', choice, '' 不允许！请再试一次。'', sep = '''')'
- en: When you run the program, please note that the directory specification must
    always end with a path separator, i.e. the backslash (**\**) on Windows systems
    or the forward slash (**/**) on Mac and Linux systems, otherwise the file path
    assembled in the program will be invalid.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，请注意目录规范必须始终以路径分隔符结尾，即在 Windows 系统中是反斜杠 (**\**)，在 Mac 和 Linux 系统中是正斜杠
    (**/**)，否则程序中拼接的文件路径将无效。
- en: Within the **while** loop, the query of the action desired by the user takes
    place first. If this choice is different from **'q'**, the actions **'s'** (start)
    and **'d'** (read directory) are checked and processed. Otherwise, if the user
    has entered **'x'**, nothing happens inside the **while** loop, so the loop jumps
    back to checking the run condition in the loop head and determines that the run
    condition **choice != 'q'** is no longer met. Therefore, the program processing
    continues after the code block of the **while** loop. In our example, this terminates
    the program.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在**while**循环内，首先会询问用户想要执行的操作。如果用户选择的操作不是**'q'**，则会检查并处理**'s'**（开始）和**'d'**（读取目录）操作。否则，如果用户输入了**'x'**，则**while**循环内不发生任何事情，循环会跳回检查循环头部的运行条件，并且判断运行条件**choice
    != 'q'**不再满足。因此，程序在**while**循环的代码块之后继续执行。在我们的示例中，这将终止程序。
- en: As you can see from this program example, with **while** loops we can ultimately
    create event control by waiting for user input, processing it when it comes, and
    then waiting again for the next user input, until the user wants to exit the program.
    The **main**loop**()** function in the **tkinter** programs from ► Sect. [22.​2](474412_1_En_22_Chapter.xhtml#Sec2)
    ultimately does nothing else. Event control is therefore not witchcraft but can
    be implemented with classic control structures such as **while** and **if**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从这个程序示例中看到的，使用**while**循环，我们可以最终通过等待用户输入、处理输入并再次等待下一个用户输入来实现事件控制，直到用户希望退出程序。►第[22.2节](474412_1_En_22_Chapter.xhtml#Sec2)中的**tkinter**程序中的**mainloop()**函数最终做的就是这些。事件控制因此并非巫术，而是可以通过经典的控制结构，如**while**和**if**来实现的。
- en: 25.4 [20 min]
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 25.4 [20分钟]
- en: Write a program that uses the **convert_temperature()** function from ► Sect.
    [24.​1.​2](474412_1_En_24_Chapter.xhtml#Sec3) to convert temperatures between
    Kelvin and degrees Celsius (and vice versa). The user of the program should be
    offered a “menu” of actions **'k'** (conversion from degrees Celsius to Kelvin),
    **'c'** (conversion from Kelvin to degrees Celsius) and **'q'** (exit program)
    until they enter **'q'** to exit the program.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，使用**convert_temperature()**函数（来自►第[24.1.2节](474412_1_En_24_Chapter.xhtml#Sec3)）将温度在开尔文与摄氏度之间转换（以及反向转换）。程序的用户应当被提供一个操作菜单，**'k'**（摄氏度到开尔文的转换）、**'c'**（开尔文到摄氏度的转换）和**'q'**（退出程序），直到用户输入**'q'**退出程序。
- en: 25.3 Exiting Loops Prematurely and Restarting Them
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 25.3 提前退出循环并重新启动
- en: Ending Loops by Statement
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过语句结束循环
- en: With the statements **break** and **continue**, Python offers possibilities
    to control the flow of **for** and **while** loops even more precisely. Calling
    the **break** statement causes the loop to terminate and program execution and
    to continue *after* the loop code block.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**break**和**continue**语句，Python提供了更精确控制**for**和**while**循环流的可能性。调用**break**语句会终止循环，程序执行将继续*在*循环代码块之后。
- en: 'Consider the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '**while True:**x = input(''Your input: '')**if** x == ''x'':**break**print(''Your
    input was: '', x)print(''Loop completed.'')'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**while True:** x = input(''请输入：'') **if** x == ''x'': **break** print(''您的输入是：'',
    x) print(''循环完成。'')'
- en: This **while** loop has a condition (**True**), which by definition is always
    met. Principally, it would run forever. However, we put in a condition that makes
    sure it only runs until the user enters **'x'**. When that happens, the loop is
    terminated with the **break** statement in place. The call to **print()**, which
    is inside the loop code block but after the **break** is no longer executed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个**while**循环有一个条件（**True**），根据定义这个条件始终为真。原则上，它会一直运行下去。然而，我们加入了一个条件，确保它只在用户输入**'x'**之前运行。当这种情况发生时，循环会通过**break**语句终止。位于循环代码块中的**print()**调用在**break**之后不再执行。
- en: The following function uses **break** to exit a **for**-loop early. This can
    be useful, for example, when determining whether something exists. Once an instance
    of what is being searched for has been found, further loop passes no longer make
    sense, since they can no longer change the result of the search. In this situation,
    it is smart to exit the loop to save computation time and speed up program execution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数使用**break**提前退出**for**循环。这在某些情况下是非常有用的，例如在判断某物是否存在时。一旦找到了正在搜索的实例，进一步的循环遍历就没有意义，因为它们已经无法改变搜索的结果。在这种情况下，退出循环是明智的，可以节省计算时间并加快程序执行速度。
- en: The following example shows a function that checks the files in a directory
    to see if there is an Excel file with a size of more than 1 MB (= 1,000,000 bytes).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个函数，该函数检查目录中的文件，查看是否存在大于1 MB（即1,000,000字节）的Excel文件。
- en: '**from** os **import** listdir**from** os.path **import** isfile, getsize**def**
    big_excel(directory: str) -> bool:files = [f **for** f **in** listdir(directory)
    **if** isfile(directory + f)**and** (f[-5:].lower()== ''.xlsx''**or** f[-4:].lower()
    == ''.xls'')]res = **False****for** f **in** files:**if** getsize(directory +
    f) > 1000000:res = **True****break****return** res'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**from** os **import** listdir**from** os.path **import** isfile, getsize**def**
    big_excel(directory: str) -> bool:files = [f **for** f **in** listdir(directory)
    **if** isfile(directory + f)**and** (f[-5:].lower()== ''.xlsx''**or** f[-4:].lower()
    == ''.xls'')]res = **False****for** f **in** files:**if** getsize(directory +
    f) > 1000000:res = **True****break****return** res'
- en: To do this, a list of Excel files in the directory to be searched, which is
    passed to the function as the **directory** argument, is first generated, using
    a list comprehension expression. This checks which file names have an extension
    that indicates Excel files (for the sake of simplicity, we will only search for
    **.xls** and **.xlsx** files here and ignore other possible file name extensions
    of Excel files). The list comprehension expression thus checks the condition that
    the respective directory content item is a file and that its name ends in **.xls**
    or **.xlsx**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先生成一个Excel文件列表，该列表是通过列表推导式从待搜索的目录中生成的，并作为**directory**参数传递给函数。这个列表推导式检查哪些文件名具有表示Excel文件的扩展名（为了简化起见，我们这里只搜索**.xls**和**.xlsx**文件，忽略其他可能的Excel文件扩展名）。列表推导式因此检查了各个目录项是否为文件，并且其名称是否以**.xls**或**.xlsx**结尾。
- en: Then a **for**-loop goes through the list generated by the list comprehension
    expression and checks with the **getsize(file)** function whether any of these
    files is larger than 1 MB. Once such a file is found, the loop is exited with
    **break**. Before that, the return value **res** of the function is switched from
    its default value **False**, to which it was initialized before the start of the
    loop, to **True**. After the loop, the **return** statement is executed, which
    returns this value to the caller.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，**for**-循环遍历由列表推导式生成的列表，并使用**getsize(file)**函数检查这些文件中是否有大于1 MB的文件。一旦找到这样的文件，循环通过**break**退出。在此之前，函数的返回值**res**从其默认值**False**切换为**True**，该默认值在循环开始前已初始化。在循环之后，执行**return**语句，将该值返回给调用者。
- en: 'Of course, the condition that the file size must exceed 1 MB could have been
    included in the list comprehension expression and then the **for**-loop could
    have been omitted altogether (How? Try it out!) But the example shows how you
    can make a search loop efficient by terminating it as soon as the thing you are
    looking for has been found. The same effect could have been achieved with a **while**
    loop, which would have to look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，文件大小必须超过1 MB的条件本可以包含在列表推导式中，然后完全可以省略**for**-循环（如何做？试试看！）但这个例子展示了如何通过在找到所需内容后立即终止搜索循环，使得搜索更高效。相同的效果也可以通过**while**循环实现，代码应该像这样：
- en: i = 0res = **False****while** i <= files.length() **and** res == **False**:**if**
    getsize(directory + files[i]) > 1000000:res = **True**i = i + 1
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0res = **False****while** i <= files.length() **and** res == **False**:**if**
    getsize(directory + files[i]) > 1000000:res = **True**i = i + 1
- en: The formulation with the **for**-loop seems a bit more intuitive (and avoids
    the risk of forgetting to increment the run variable **i**).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**for**-循环的写法似乎更直观一些（并且避免了忘记递增运行变量**i**的风险）。
- en: Continue Loops per Instruction with the Next Run
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过当前循环并执行下一次
- en: 'While **break** completely exits the loop within which it is called, the **continue**
    statement causes the loop execution to simply continue with the next loop pass.
    This can be seen in the following example, where we loop through the numbers from
    1 to 10 in a **for**-loop, but “pinch off” the **print()** statement located in
    the loop code block for all even numbers by sending the loop into its next pass
    beforehand with **continue**:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**break**完全退出其所在的循环，而**continue**语句则使循环继续执行下一个循环周期。我们可以在下面的示例中看到这一点，其中我们通过一个**for**-循环遍历1到10之间的数字，但通过使用**continue**提前跳过所有偶数的**print()**语句，直接进入下一个循环周期：
- en: '**for** i **in** range(1,10):**if** i % 2 == 0:**continue**print(i)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**for** i **in** range(1,10):**if** i % 2 == 0:**continue**print(i)'
- en: Here we use the *modulo operator* **%**, which returns the division remainder;
    if this is 0, it is an even number and the loop continues with the next pass,
    the call to **print()** at the end of the loop code block is then not reached
    at all. It is only reached for odd numbers, so that only these are output to the
    screen.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用了*取模运算符* **%**，它返回除法的余数；如果结果是 0，说明是偶数，循环将继续进行下一次迭代，此时循环代码块末尾的**print()**函数不会被执行。只有在奇数情况下，才会执行它，因此屏幕上只会输出奇数。
- en: 25.4 Summary
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 25.4 小结
- en: In this chapter, we have looked at **for** and **while** loops, as well as list
    comprehension expressions based on the **for**-loops**.** We also saw how loops
    or the current loop pass can be exited early.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了**for**和**while**循环，以及基于**for**-循环的列表推导表达式。我们还看到了如何提前退出循环或当前的循环迭代。
- en: 'Be sure to take the following points from this chapter:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必记住本章中的以下几点：
- en: Python knows the **for** construct as a counting loop that iterates through
    the elements of an iterable object; an object is iterable if Python can “shimmy”
    from one element/component of the object to the next (as is the case with lists,
    tuples, sets, or dictionaries, for example).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 将 **for** 构造视为一个计数循环，它遍历一个可遍历对象的元素；如果 Python 能够从对象的一个元素或组件移动到下一个元素（例如，列表、元组、集合或字典等对象），那么这个对象就是可遍历的。
- en: 'The basic structure of the **for**-loop is: **for** ***variable*** **in** ***iterable_object*****:**
    ***code_block***; the **variable** represents a different element that is part
    of ***iterable_object*** on each loop pass.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**for**-循环的基本结构是：**for** ***变量*** **in** ***可遍历对象*** ：***代码块***；**变量**代表每次循环中，***可遍历对象***
    的一个不同元素。'
- en: Changes to the run variable do *not* change the element of the traversed iterable
    object that it represents.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于变量的修改*不会*改变它所代表的可遍历对象的元素。
- en: '**for**-loops can be nested arbitrarily.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**for**-循环可以任意嵌套。'
- en: 'A special kind of **for**-loop is the list comprehension expression. It produces
    a list with a very compact syntax; the general form is: **list = [*****expression***
    **for variable in** ***iterable_object*** **if** ***condition*****]**, so for
    example the list of squared even numbers from 1 to 10: **squared = [x*x for x
    in range(1,11) if x % 2 == 0]**, where **%** is the modulo operator that returns
    the remainder of a division.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种特殊的**for**-循环是列表推导表达式。它用非常紧凑的语法生成一个列表；其一般形式是：**list = [*****表达式*** **for 变量
    in** ***可遍历对象*** **if** ***条件***]，例如从 1 到 10 的平方偶数列表：**squared = [x*x for x in
    range(1,11) if x % 2 == 0]**，其中**%**是取模运算符，用于返回除法的余数。
- en: 'Conditional loops are constructed with **while**; their general form is: **while**
    ***condition*****:** ***code_block***.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件循环是通过**while**构建的，它们的一般形式是：**while** ***条件*** ：***代码块***。
- en: Both **for** and **while** loops can be exited early with the **break** statement.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**for**和**while**循环都可以通过**break**语句提前退出。'
- en: The **continue** statement terminates the current loop pass and continues the
    loop with the next pass.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**continue** 语句终止当前的循环迭代，并继续下一次循环。'
- en: 25.5 Solutions to the Exercises
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 25.5 练习答案
- en: Exercise 25.1
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 25.1
- en: 'A function that removes all vowels from a string might look like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个去除字符串中所有元音字母的函数可能是这样的：
- en: '**def** remove_vowels(s: str) -> str:res = list()s = list(s)**for** i **in**
    range(0,s.__len__(),1):**if** s[i] **not in** (''a'',''e'',''i'',''o'',''u''):res.append(s[i])**return**
    ''''.join(res)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**def** remove_vowels(s: str) -> str:res = list()s = list(s)**for** i **in**
    range(0,s.__len__(),1):**if** s[i] **not in** (''a'',''e'',''i'',''o'',''u''):res.append(s[i])**return**
    ''''.join(res)'
- en: 'Test whether the function has the desired effect:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 测试函数是否具有预期效果：
- en: 'print(remove_vowels(''Hello world!''))Exercise 25.2To reverse the characters
    in the string, the string, which has been converted into a list of individual
    characters, is run through *from back to front* in a **for**-loop. The increment,
    the third argument of the **range()** function, is therefore −1\. Because **range()**
    runs to *before* the specified boundary, the second range boundary must also be
    −1 so that the last index value returned is 0, thus allowing access to the first
    character of **s**.**def** invert_capitalization(s: str) -> str:s = list(s)res
    = list()**for** i **in** range(s.__len__() - 1, -1, -1):res.append(s[i].capitalize())**return**
    str(''''.join(res))'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(remove_vowels(''Hello world!''))第25.2题为了反转字符串中的字符，首先将字符串转换成一个字符列表，然后通过**for**循环从*后向前*遍历该列表。因此，**range()**函数的增量参数（三个参数中的第三个）为-1。因为**range()**会运行到*指定边界之前*，所以第二个边界也必须是-1，这样最后一个返回的索引值就是0，从而可以访问字符串**s**的第一个字符。**def**
    invert_capitalization(s: str) -> str: s = list(s) res = list() **for** i **in**
    range(s.__len__() - 1, -1, -1): res.append(s[i].capitalize()) **return** str(''''.join(res))'
- en: 'The function could then, for example, be called like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数可以像这样调用：
- en: print(invert_ capitalization('Hello world!'))Exercise 25.3
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: print(invert_ capitalization('Hello world!'))第25.3题
- en: 'A list comprehension expression that summarizes the letters from **A** to **Z**
    as a list might look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将字母从**A**到**Z**总结为列表的列表推导式可能看起来像这样：
- en: capital_letters = [chr(b) **for** b **in** range(ord('A'), ord('Z')+1)]
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: capital_letters = [chr(b) **对于** b **在** range(ord('A'), ord('Z')+1)]
- en: 'So we run through the character codes with the variable **b** starting with
    the code of the letter A, up to the code of the letter Z (Note: **range()** returns
    a range of values which no longer contains the specified right/upper limit, therefore
    **+1**). We then convert these codes back into letters using the **chr()** function.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们用变量**b**遍历字符编码，从字母A的编码开始，到字母Z的编码结束（注意：**range()**返回一个值的范围，但不包含指定的右边界/上限，因此需要**+1**）。然后我们使用**chr()**函数将这些编码转换回字母。
- en: 'An equivalent **for**-loop would look like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个等效的**for**循环会是这样：
- en: capital_letters = list()**for** b **in** range(ord('A'), ord('Z')+1):capital_letters.append(chr(b))Exercise
    25.4
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'capital_letters = list() **for** b **in** range(ord(''A''), ord(''Z'')+1):
    capital_letters.append(chr(b))第25.4题'
- en: 'For example, the program might look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，程序可能会是这样：
- en: 'choice = ''''**while** choice != ''q'':choice = input(''Conversion Celsius
    to Kelvin (k), Kelvin to Celsius (c), quit (q)? '')**if** choice == ''k'':temp
    = input(''Please enter a temperature in degrees Celsius: '')orig_unit = ''Grad
    Celsius''target_unit = ''Kelvin''to_celsius = False**elif** choice == ''c'':temp
    = input(''Please enter a temperature in Kelvin: '')orig_unit = ''Kelvin''target_unit
    = ''degrees Celsius''to_celsius = True**elif** choice == ''q'':**pass****else**:print(''"'',
    choice, ''" is not a valid input. Please try again.'', sep = '''')**if** choice
    == ''k'' **or** choice == ''c'':res = convert_temperature(float(temp), to_celsius)**if**
    res != -1000:print(temp, orig_unit, ''are'', res, target_unit)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: choice = ''**当** choice != 'q'：choice = input('摄氏度转开尔文（k），开尔文转摄氏度（c），退出（q）？')**如果**
    choice == 'k'：temp = input('请输入摄氏度温度：')orig_unit = '摄氏度' target_unit = '开尔文' to_celsius
    = False**elif** choice == 'c'：temp = input('请输入开尔文温度：')orig_unit = '开尔文' target_unit
    = '摄氏度' to_celsius = True**elif** choice == 'q'：**跳过** **else**：print('"', choice,
    '" 不是有效的输入，请再试一次。', sep = '')**如果** choice == 'k' **或** choice == 'c'：res = convert_temperature(float(temp),
    to_celsius)**如果** res != -1000：print(temp, orig_unit, '是', res, target_unit)
- en: Note that the program uses the **convert_temperature()** function from ► Sect.
    [24.​1.​2](474412_1_En_24_Chapter.xhtml#Sec3). You will need this code to run
    the program. Furthermore, please note that the variable **choice**, which takes
    the user’s command, must already be initialized before the **while** loop. Otherwise,
    the **while** loop will encounter a non-existent variable when checking its run
    condition, which will trigger an error message.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，程序使用了来自► Sect. [24.​1.​2](474412_1_En_24_Chapter.xhtml#Sec3)的**convert_temperature()**函数。你需要这个代码来运行程序。另外，请注意，接收用户命令的变量**choice**必须在**while**循环之前初始化。否则，**while**循环在检查运行条件时会遇到一个不存在的变量，这将触发错误信息。
