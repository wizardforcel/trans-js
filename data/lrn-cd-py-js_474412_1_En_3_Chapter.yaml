- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024J. L. ZuckarelliLearn coding with Python and JavaScript
    [https://doi.org/10.1007/978-3-658-42912-6_3](https://doi.org/10.1007/978-3-658-42912-6_3)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 2024 J. L. Zuckarelli, 独家许可给Springer Fachmedien Wiesbaden GmbH，Springer Nature的一部分《使用Python和JavaScript学习编码》
    [https://doi.org/10.1007/978-3-658-42912-6_3](https://doi.org/10.1007/978-3-658-42912-6_3)
- en: 3. What Is a Programming Language?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 什么是编程语言？
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1)München, GermanyOverview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Joachim L. Zuckarelli^([1](#Aff2) )(1)德国慕尼黑概述
- en: 'Programming ultimately means giving instructions to the computer. This is done
    in a special language that both we as programmers and the computer understand:
    a programming language. Programming languages and natural languages have a lot
    in common, but they also have some important differences.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编程最终意味着给计算机指令。这是通过一种特殊的语言完成的，这种语言既被我们作为程序员所理解，也被计算机所理解：编程语言。编程语言和自然语言有很多相似之处，但它们也有一些重要的区别。
- en: In this chapter we deal with programming languages and thus with the crucial
    question of how we make ourselves understood by the computer, and how the computer
    manages to understand us and carry out our instructions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论编程语言，因此也涉及如何使计算机理解我们，以及计算机如何理解我们并执行我们的指令这一关键问题。
- en: 3.1 Languages for Humans, Languages for Machines
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 面向人类的语言，面向机器的语言
- en: So far, we have dealt with *what* programming is and *why* it makes sense to
    learn it. Only the question of *how* remains to be dealt with. How do we program?
    How exactly do we tell the computer what the algorithm, i.e., the sequence of
    steps it is to process, looks like?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了*什么*是编程以及*为什么*学习它是有意义的。现在只剩下*如何*去做的问题了。我们如何编程？我们到底如何告诉计算机算法，也就是它需要处理的步骤顺序？
- en: 'Somehow, the algorithm must be written down in a way the computer can understand.
    Now, as we know, computers work in a binary mode, they ultimately distinguish
    only two states, zero and one, on and off, voltage present and voltage absent.
    It is therefore natural to assume that we have to write programs in a binary way
    in order for the computer to understand them. Fortunately, this is not the case.
    If you look over the shoulder of a programmer, you will see that he or she writes
    texts in a language that is basically readable by humans. In the text you will
    recognize many English terms. A typical line of program text could read something
    like:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，算法必须以计算机能够理解的方式写下来。正如我们所知，计算机以二进制模式工作，它们最终只能区分两种状态：零和一，开和关，有电压和无电压。因此，自然会认为我们必须以二进制方式编写程序，才能让计算机理解它们。幸运的是，事实并非如此。如果你从程序员身后看，你会看到他们编写的文本基本上是人类可读的。在这些文本中，你会看到许多英语术语。一个典型的程序文本行可能是这样的：
- en: '**if** value <0 **then** print "Value is less than zero"'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**if** value <0 **then** print "Value is less than zero"'
- en: Even though many of the terms used are familiar from English, the language used
    by the programmer is an *artificial* language, a *programming language*. There
    are other artificial languages that are not programming languages, such as the
    lingua franca *Esperanto*, developed by the Polish ophthalmologist *Ludwik Lejzer
    Zamenhof*, or *Klingon*, the native language of the alien Klingon race known from
    *Star Trek*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多使用的术语在英语中是熟悉的，但程序员使用的语言是*人工*语言，*编程语言*。还有其他不是编程语言的人工语言，例如由波兰眼科医生*卢德维克·莱泽·扎门霍夫*开发的世界语*Esperanto*，或是《星际迷航》中的外星人克林贡种族的母语*Klingon*。
- en: Like human languages, programming languages also have a grammar, the *syntax,*
    which describes which formulations are permissible and which are not. Nevertheless,
    programming languages differ significantly from human languages.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 像人类语言一样，编程语言也有语法，*句法*，它描述了哪些表达方式是允许的，哪些是不允许的。尽管如此，编程语言与人类语言在很多方面仍有显著差异。
- en: '1.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Programming languages are less complex, both in terms of grammar/syntax and
    in the terms used and their meaning (called *semantics*). The good news for you
    is that you don’t have to learn such a large vocabulary!
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编程语言在语法/句法和所使用的术语及其含义（称为*语义*）方面不如自然语言复杂。对你来说，好消息是你不需要学习那么庞大的词汇量！
- en: '2.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: The grammatical rules must be strictly observed, otherwise you will not be understood.
    That is the bad news. In normal conversational situations, the human counterpart
    understands a sentence even if it is not quite grammatically correct. This is
    important, given the fact that only native speakers and speakers with a lot of
    experience can really master a language without errors. But this kind of internal
    error correction, or error-tolerant comprehension, requires mental performances
    that we commonly associate with intelligence. Now the problem—as you can guess—is
    that computers are simply not intelligent. They have no tolerance for error and
    only accept and understand correctly formed sentences. This is what makes programming
    difficult and, from time to time, frustrating, especially when the computer doesn’t
    want (or just can’t, because it doesn’t have free will) to understand you. Because
    the language must be so precise, its formulations often seem awkward, which makes
    it completely unusable as an everyday language. This brings us to the next point.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 语法规则必须严格遵守，否则你将无法被理解。这是坏消息。在正常的对话场合，即使句子在语法上不完全正确，人类对方也能理解。这一点很重要，考虑到只有母语者和有丰富经验的人才能真正无误地掌握一门语言。但这种内部错误修正或容错理解，通常需要我们与智慧相关的心理表现。现在的问题——正如你可以猜到的——是计算机根本不智能。它们对错误没有容忍度，只接受并理解正确的句子。这正是编程困难并时常让人沮丧的原因，尤其是当计算机不愿意（或根本不能，因为它没有自由意志）理解你时。由于语言必须如此精确，它的表述常常显得生硬，这使得它完全无法作为日常语言使用。这就引出了下一个话题。
- en: '3.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Programming languages are not made to be spoken. Two programmers are not going
    to talk in a programming language when they meet for lunch. But of course, programmers
    sometimes speak strangely because they talk about parts of a program written in
    a programming language and quote parts of the program to do so.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编程语言不是为了被口头使用而设计的。两个程序员在午餐时不会用编程语言交谈。但当然，程序员有时会说得很奇怪，因为他们谈论的是用编程语言写的程序部分，并且引用程序中的部分内容来进行交流。
- en: '4.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Programming languages in the strict sense (there are some descriptive languages
    that could be considered exceptions) are not made to transfer information, but
    solely to give instructions to the computer.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 严格意义上的编程语言（虽然有些描述性语言可以视作例外）并不是用来传递信息的，而仅仅是为了向计算机发出指令。
- en: 'Thus, although programming languages, as artificial languages, are designed
    to be considerably simpler than natural languages, both in terms of their grammar
    and vocabulary, the works of the authors, i.e., programmers, who use these languages
    are of considerable complexity and scope. Some examples:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管编程语言作为人工语言，在语法和词汇方面设计得比自然语言简单得多，但使用这些语言的作者，即程序员们的工作，却是相当复杂和庞大的。以下是一些例子：
- en: The programs that controlled NASA Apollo 11 lunar module and brought Neil Armstrong
    and Buzz Aldrin safely to the moon, had a length of about 40 thousand lines; that
    is 645 normally written pages.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制 NASA 阿波罗 11 登月舱并成功将尼尔·阿姆斯特朗和巴兹·奥尔德林送上月球的程序，大约有 4 万行；也就是 645 页正常的书面文字。
- en: The Microsoft Windows 3.1 operating system had about 2.5 million lines; a little
    over 40,000 pages.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软 Windows 3.1 操作系统约有 250 万行；大约 40,000 页。
- en: The office application suite, Microsoft Office 2013, draws its functionality
    from about 44 million lines of program code, which could be printed on about 694,000
    pages.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 办公软件套件 Microsoft Office 2013 的功能来自约 4400 万行程序代码，打印出来大约是 694,000 页。
- en: The social network Facebook is based on about 61 million lines of program code
    and thus about 984,000 pages.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交网络 Facebook 基于约 6100 万行程序代码，因此大约有 984,000 页。
- en: According to a Google developer, all Google applications together have about
    2 billion (!) lines; printed out, that would be about 32,300,000 pages.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据 Google 的一位开发人员说，所有 Google 应用程序加起来大约有 20 亿（！）行；打印出来大约是 32,300,000 页。
- en: 'For comparison: Goethe’s *Faust* has 12,111 lines, which corresponds to 195
    pages.Comparisons between these different programs are not easy, because:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 做个比较：歌德的 *浮士德* 有 12,111 行，相当于 195 页。比较这些不同程序之间的差异并不容易，因为：
- en: '1.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: different programming languages need a different number of lines for the same
    operation,
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不同的编程语言在进行相同操作时需要的代码行数不同，
- en: '2.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: personal programming styles differ,
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 个人编程风格各不相同，
- en: '3.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: the way the program code is formatted (which influences the readability and
    thus “maintainability” of the code) may differ.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序代码的格式化方式（这会影响代码的可读性，从而影响其“可维护性”）可能有所不同。
- en: All these factors have an influence on the program size.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些因素都会影响程序的大小。
- en: However, you can see already that software programs are often extensive, and
    sometimes extraordinarily complex, works.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您已经可以看到，软件程序通常是庞大且有时极其复杂的作品。
- en: 3.2 Translation and Execution of Programming Languages
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 编程语言的翻译与执行
- en: In the previous chapter, we had noted that most programming languages use English
    terms. This is mainly because the development of programming languages has been
    mainly driven in the English-speaking world, although the first real programming
    language was the invention of the German *Konrad Zuse,* to whom we will return
    later. Of course, one could just as easily design a programming language whose
    commands are all borrowed from a language other than English, such as Spanish,
    French, or Chinese. However, it is obvious that this is not normally done, except
    possibly for pedagogical purposes, given the dominant role of English as the world’s
    lingua franca and the understandable desire of every creator of a new programming
    language to see his work spread as widely as possible.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们曾提到大多数编程语言使用英语术语。这主要是因为编程语言的发展主要是在英语国家推动的，尽管第一种真正的编程语言是德国人*Konrad Zuse*的发明，我们稍后会提到他。当然，也可以很容易设计一种编程语言，其命令全部借用其他语言，如西班牙语、法语或中文。然而，很明显，通常不会这么做，除非出于教学目的，因为英语作为世界通用语的主导地位，以及每位新编程语言创作者都希望看到自己的作品尽可能广泛传播的可理解愿望。
- en: However, we have not yet solved the problem that the computer can handle neither
    English nor any other human language. But if the computer only understands zeros
    and ones, how does it cope with programming languages based on English? What is
    obviously missing is some step between writing the instructions of the program
    in a human-readable programming language, and its execution by the computer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然没有解决计算机无法处理英语或任何其他人类语言的问题。但如果计算机只理解零和一，那么它是如何处理基于英语的编程语言的呢？显然缺少的步骤是在用人类可读的编程语言编写程序指令与计算机执行这些指令之间的某个环节。
- en: This task is performed by the *compiler*. The compiler translates the program
    into a language that the computer understands directly, the *machine language*.
    This machine language knows only a very limited set of basic commands, such as
    loading individual values into the processor’s registers, i.e., the small memory
    elements whose contents are accessible to the processor to work with.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务由*编译器*完成。编译器将程序翻译成计算机可以直接理解的语言——*机器语言*。这种机器语言只知道一组非常有限的基本命令，例如将单个值加载到处理器的寄存器中，即可以供处理器操作的小型存储元件。
- en: It’s a bit like having to explain a route to someone who doesn’t know the place.
    Whereas a person who knows the area would easily find his way to the meeting point
    from his current location with the instruction “Go to Time Square, we’ll meet
    there,” you have to break down the directions for the person who doesn’t know
    the area to more elementary components. For example, you could say “Go straight
    ahead to the second traffic light. Then turn left. Then go straight until the
    next intersection. There, turn right and go straight until you hit the square.”
    It is the same with machine language. It is the stream of instructions, broken
    down to elementary processor operations, that result from a program written in
    a programming language. The human-readable program may contain many “shortcuts”
    and references to already known sequences of instructions, but for the processor,
    all of this must be reduced to the basic operations that it can perform. This
    machine code runs directly on the computer’s processor. If you work with Windows,
    you’re probably familiar with the **.exe** and **.com** files. These are the programs
    translated into machine code that the computer understands and can execute directly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点像需要向一个不了解情况的人解释路线。而一个熟悉这个地方的人，只需根据“去时代广场，我们在那里见”这条指示，就能轻松找到去集合地点的路，而你需要将方向指示拆解成更基本的组成部分，才能让不熟悉的人理解。例如，你可以说“直走到第二个红绿灯，然后左转。然后再直走直到下一个交叉口。在那里右转，继续走直到你看到广场。”机器语言也一样。它是由程序员用编程语言编写的程序，通过拆解成基本的处理器操作生成的指令流。人类可读的程序可能包含许多“快捷方式”以及对已经知道的指令序列的引用，但对于处理器来说，所有这些都必须简化为它可以执行的基本操作。这些机器码直接在计算机的处理器上运行。如果你使用Windows操作系统，你可能已经熟悉**.exe**和**.com**文件。这些是已经翻译成计算机可以理解并直接执行的机器代码的程序。
- en: 'An *interpreter* works somewhat differently. The interpreter (which is itself
    a program) executes the program step by step; it “interprets” the program code.
    It is clear that the interpreter ultimately has to pass the program to be executed
    to the computer in machine language, otherwise the computer would not be able
    to understand it. But in the case of the interpreter, this translation takes place
    while the program is running (“at runtime,” as programmers say). So, the program
    itself does not run *directly* on the computer, but is mediated by the interpreter.
    However, this also means: You can’t just run the program everywhere, you always
    need the interpreter to get the source code of the program running on a computer.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*解释器*的工作方式略有不同。解释器（本身就是一个程序）逐步执行程序；它“解释”程序代码。显然，解释器最终必须将程序传递给计算机，以机器语言执行，否则计算机无法理解它。但在解释器的情况下，这种翻译发生在程序运行时（正如程序员所说，“运行时”）。因此，程序本身并不*直接*在计算机上运行，而是通过解释器进行中介。然而，这也意味着：你不能随便在任何地方运行程序，始终需要解释器才能让程序源代码在计算机上运行。'
- en: Compiling, or the translation of the human-readable program code into a machine
    language understandable to the computer, usually has speed advantages because
    the translation itself takes time and is done by the compiler in advance. At runtime,
    there is then no need to spend time translating. For our purposes, considerations
    of code execution speed are not quite so important, but when it comes to computationally
    intensive or time-critical applications (think, for example, of monitoring systems
    in intensive care medicine), such considerations are certainly highly relevant.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编译，或者将人类可读的程序代码翻译成计算机能够理解的机器语言，通常具有速度优势，因为翻译本身需要时间，并且由编译器提前完成。在运行时，便不再需要花费时间进行翻译。对于我们的目的，代码执行速度的考虑并不是特别重要，但在涉及计算密集型或时间关键型应用（比如在重症监护医学中的监控系统）时，这些考虑无疑是高度相关的。
- en: 'There is still a middle ground between compiler and interpreter. It works like
    this: First, a *bytecode compiler* generates an “intermediate code” from the source
    code of the program. This is very similar to machine language but is independent
    of the processor architecture. The problem with machine language is that it depends
    on exactly how the processor is built. Different processor types understand only
    “their” machine language. Bytecode, on the other hand, is machine-independent
    and so can easily be generated on one type of system and then executed on other
    types of systems. The code is said to be “portable”. The generation of the bytecode
    is done during the development of the program. At runtime, a just-in-time *compiler*
    (JIT compiler) generates the machine-specific code from the bytecode. To a certain
    extent, the JIT compiler is a bytecode interpreter. It reads the “precompiled”
    bytecode and passes instructions to the processor in the respective machine language
    of the system used for execution. This is faster than executing the untranslated
    source code directly, as a classical interpreter would do.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器和解释器之间仍然存在一种中间地带。它是这样工作的：首先，一个*字节码编译器*从程序的源代码生成“中间代码”。这与机器语言非常相似，但与处理器架构无关。机器语言的问题在于它依赖于处理器的具体构建方式。不同类型的处理器只理解“它们自己的”机器语言。而字节码则是机器无关的，因此可以在一种系统类型上生成，然后在其他类型的系统上执行。这样的代码被称为“可移植的”。字节码的生成是在程序开发过程中完成的。在运行时，即时编译器（JIT编译器）会从字节码生成特定于机器的代码。在某种程度上，JIT编译器就是一个字节码解释器。它读取“预编译”的字节码，并将指令传递给处理器，指令的格式是针对所使用系统的机器语言。这比直接执行未经翻译的源代码要快，后者通常是经典的解释器所做的。
- en: The most prominent example of this approach of using a combination of bytecode
    compiler during development and JIT compiler at runtime, is the popular Java programming
    language. (Java’s JIT compilers are also referred to as “runtime environments”
    because they form the environment in which the Java program is executed.) Thanks
    to its JIT compilers which are adapted to the respective system, Java not only
    runs on computers with very different operating systems such as Windows, MacOS
    or Linux, but also on various other devices such as cars or refrigerators.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结合在开发期间使用字节码编译器并在运行时使用即时编译器（JIT）的方式的最显著例子就是流行的Java编程语言。（Java的JIT编译器也被称为“运行时环境”，因为它们构成了Java程序执行的环境。）得益于其适应各自系统的JIT编译器，Java不仅能够在具有不同操作系统的计算机上运行，如Windows、MacOS或Linux，还能在各种其他设备上运行，如汽车或冰箱。
- en: Typically, it is considered a property of a programming language whether it
    is compiled or interpreted. However, there are also languages that are basically
    interpreted, but for which there is then nevertheless the possibility of bytecode
    compilation. Interpreters, too, may compile parts of the code that are particularly
    computationally intensive or are often traversed, and sometimes even all of the
    code, directly into executable machine code; this is also called JIT compilation.
    So, the world is indeed still a bit more colorful, and compiler construction in
    computer science is an art (and discipline) in itself.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编程语言是否是编译型语言或解释型语言是一个重要特性。然而，也有一些语言基本上是解释型的，但仍然可以进行字节码编译。解释器也可以将那些特别计算密集或经常被遍历的代码部分，甚至有时是所有代码，直接编译成可执行的机器码；这种方式也被称为JIT编译。因此，世界的确更加丰富多彩，计算机科学中的编译器构建本身是一门艺术（和学科）。
- en: 3.3 From Machine Language to High-Level Language
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 从机器语言到高级语言
- en: 'All well and good with compiling and interpreting. But the question arises:
    Couldn’t you just write a program directly in machine language? Of course, this
    would be possible, but it would not be easy at all, on the contrary, it would
    be extremely tedious, and the result would be very difficult to understand. In
    addition, the program would have to be written in such a way that it takes into
    account the peculiarities of the processor on which it is to run. If you suddenly
    want it to run on a completely different system architecture, you might have to
    modify it considerably in many places. Programming in machine language is therefore
    not recommended. In the early days of computers, however, that was exactly what
    was needed. Ultimately, even the decoy card programs of *Charles Babbage* and
    colleagues are software written in the machine language that Babbage’s *Analytical
    Engine* would have understood directly had it ever been built during his lifetime.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和解释的方式很好。但问题来了：难道不能直接用机器语言编写程序吗？当然，这是可以的，但这并不容易，反而极其繁琐，而且结果会非常难以理解。此外，程序必须以考虑运行该程序的处理器特性为前提来编写。如果你突然希望它在完全不同的系统架构上运行，你可能需要在许多地方进行大量修改。因此，不推荐用机器语言编程。然而，在计算机的早期阶段，这正是所需要的。最终，即使是*查尔斯·巴贝奇*和同事们的诱饵卡程序，也是用机器语言编写的软件，如果巴贝奇的*解析机*在他生前建造完成，它本可以直接理解这些代码。
- en: 'In order to at least simplify the trouble of writing directly in machine language,
    *assembler languages* appeared from the 1940s onwards. Assembler languages are
    ultimately machine code in a readable form. For the (manageably) numerous machine
    commands, short commands (*mnemonics*) were created, which can be translated one-to-one
    into machine code. In other words: the assembler instructions correspond exactly
    to the instruction set of the processor. Programming in assembler is still incredibly
    tedious. For example, an assembler instruction is:MOV AL, 6Fh'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了至少简化直接用机器语言编写程序的麻烦，*汇编语言*自20世纪40年代起出现。汇编语言本质上是机器代码的一种可读形式。对于（可管理的）大量机器指令，创建了简短的指令（*助记符*），这些指令可以一对一地转换为机器代码。换句话说：汇编指令与处理器的指令集完全对应。用汇编语言编程仍然极为繁琐。例如，一个汇编指令是：MOV
    AL, 6Fh
- en: 'This tells the computer: load the value 111 (6Fh means 111 in the hexadecimal
    number system, that is, in the sixteen-based number system) into the processor
    register AL. To use a simple instruction written in a high-level language, such
    as:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉计算机：将值111（6Fh在十六进制数字系统中表示111，即十六进制数系统中的111）加载到处理器寄存器AL中。为了使用用高级语言编写的简单指令，例如：
- en: print "Hello World!"
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: print "Hello World!"
- en: in assembler, it requires a whole series of such operations. Above all, however,
    with assembler one is still dependent on the respective processor architecture.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，这需要一系列这样的操作。然而，最重要的是，使用汇编语言仍然依赖于各自的处理器架构。
- en: It is easier with the *high-level languages*. High-level languages abstract
    from the processor architecture because their interpreters or compilers take over
    the consideration of the specifics of the target processor, so that the developer
    is relieved of this task. He writes his program only once; afterwards it can be
    translated into the machine language of completely different processor architectures.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*高级语言*则更为简便。高级语言从处理器架构中抽象出来，因为它们的解释器或编译器会处理目标处理器的特性，从而使开发者免去这项任务。他只需要编写一次程序；之后它可以被翻译成完全不同处理器架构的机器语言。
- en: The high-level languages, unlike assembler code and (even more so) machine code,
    are easier to read because they use English terms for the instructions. Many of
    these commands combine a whole series of machine commands, which means that one
    line of high-level language code may generate many different machine code commands
    when compiled. The programmer, of course, no longer needs to worry about these
    details. No wonder, then, that practically all programming languages in use today
    are such high-level languages.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 高级语言与汇编代码和（更甚于）机器代码不同，它们更易于阅读，因为它们使用英文术语来表示指令。这些命令中的许多结合了一整套机器命令，这意味着编译后，一行高级语言代码可能会生成多条不同的机器代码指令。当然，程序员不再需要担心这些细节。因此，几乎所有现代使用的编程语言都是高级语言，也就不足为奇了。
- en: The first simple high-level language was developed in the 1940s by the German
    engineer *Konrad Zuse* and was called *Plankalkül*. With *Plankalkül,* Zuse achieved
    a groundbreaking development that should have paved the way for modern software
    development in the first place. Due to World War II Zuse’s work remained unnoticed
    for a long time. The first implementation (i.e., usable technical realization)
    of Zuse’s *Plankalkül* took place in 1975 and was done by *Joachim Hohmann* in
    the context of his dissertation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种简单的高级语言是在1940年代由德国工程师*孔拉德·祖泽*开发的，名为*Plankalkül*。通过*Plankalkül*，祖泽实现了一项突破性的进展，本应为现代软件开发铺平道路。然而，由于第二次世界大战，祖泽的工作长时间未受到关注。*Plankalkül*的首次实现（即可用的技术实现）发生在1975年，由*约阿希姆·霍曼*在其博士论文的背景下完成。
- en: The breakthrough of high-level languages, on the other hand, came with *ALGOL*
    (short for *Algorithmic Language*), which was developed in the USA in the late
    1950s/early 1960s mainly for academic purposes and largely without reference to
    the pioneering work of *Konrad Zuse*. Even before that, in the 1950s, the American
    computer scientist *Grace Hopper* had designed the first working compiler. *Hopper*,
    who died in 1992 and was posthumously honored with the Presidential Medal of Freedom,
    the highest civilian award of the United States, was also involved in the development
    of the programming language *COBOL* (*Common Business-Oriented Language*). *COBOL*
    was a language widely used in a business context. Together with *FORTRAN* (*Formula
    Translation*), developed by *John Backus in* 1957 and mainly used in technical
    and scientific work, it completes the collection of early, truly operational high-level
    languages.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 而高级语言的突破则出现在*ALGOL*（*算法语言*）上，它是在1950年代末至1960年代初由美国开发的，主要用于学术目的，且在很大程度上与*孔拉德·祖泽*的开创性工作无关。在此之前，1950年代，美国计算机科学家*格雷斯·霍普*设计了第一个可用的编译器。*霍普*于1992年去世，死后被追授总统自由勋章，这是美国的最高平民荣誉奖项，她还参与了编程语言*COBOL*（*面向商业的通用语言*）的开发。*COBOL*是一种在商业领域广泛使用的语言。与*FORTRAN*（*公式翻译*）一起，*FORTRAN*由*约翰·巴克斯*于1957年开发，主要用于技术和科学工作，二者共同构成了早期真正实用的高级语言的集合。
