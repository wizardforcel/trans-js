- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024J. L. ZuckarelliLearn coding with Python and JavaScript
    [https://doi.org/10.1007/978-3-658-42912-6_33](https://doi.org/10.1007/978-3-658-42912-6_33)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 作者（们），独家授权给Springer Fachmedien Wiesbaden GmbH，Springer Nature的一部分，2024J. L.
    Zuckarelli《用Python和JavaScript学习编程》 [https://doi.org/10.1007/978-3-658-42912-6_33](https://doi.org/10.1007/978-3-658-42912-6_33)
- en: '33. Functions & Methods: How Do I Work with Program Functions to Work with
    Data and Trigger Actions?'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 33. 函数与方法：如何使用程序函数处理数据并触发操作？
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1)München, GermanyOverview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Joachim L. Zuckarelli^([1](#Aff2)  )(1)德国慕尼黑概览
- en: Moving forward, we will examine functions, which are considered the backbone
    of programming in JavaScript, similar to their role in various other coding languages.
    After all, not only do you constantly work with predefined functions that JavaScript
    offers out-of-the-box or that you get from extension libraries, but you also regularly
    write your own functions; in particular, the event handlers that take a central
    role in event-driven JavaScript applications. So, it’s no wonder that an intensive
    study of functions is a core part of our tour through JavaScript.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究函数，它们被认为是JavaScript编程的核心，就像它们在其他各种编程语言中的作用一样。毕竟，你不仅会不断使用JavaScript提供的现成函数，或者从扩展库中获得函数，还会经常编写自己的函数；尤其是事件驱动的JavaScript应用中扮演核心角色的事件处理程序。所以，深入研究函数成为我们探索JavaScript过程中的核心内容也就不足为奇了。
- en: 'In this chapter you will learn:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学到：
- en: how to define and call functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定义和调用函数
- en: how functions process arguments and return results
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数如何处理参数并返回结果
- en: that functions are also objects, and what consequences this has
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数也是对象，这带来了哪些后果
- en: how the scopes of variables are cut in JavaScript—especially with regard to
    functions—and how this affects the accessibility of variables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的作用域在JavaScript中是如何被切割的——特别是与函数相关的作用域——以及这如何影响变量的可访问性
- en: how to extend the available functions beyond the standard language with external
    libraries, and how to find suitable extension libraries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过外部库扩展可用函数，超出标准语言的范围，并且如何找到合适的扩展库
- en: what frameworks are and how they differ from libraries
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是框架，它们与库有何不同
- en: 33.1 Working with Functions
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 33.1 使用函数
- en: 33.1.1 Definition of Functions
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.1.1 函数的定义
- en: Defining Functions
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 定义函数
- en: 'Functions are defined in JavaScript with the keyword **function**. Any arguments
    are placed after the function identifier in round brackets, which are necessary
    even if the function is not passed any arguments at all. The program code that
    is executed when the function is called follows as a code block in curly braces.
    A simple function that just prints “Hello World” to the console would look like
    this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数是通过关键字**function**定义的。任何参数都放在函数标识符后的圆括号中，即使函数没有传递任何参数，圆括号也是必须的。当函数被调用时，执行的程序代码会作为代码块放在大括号内。一个简单的函数，它只是在控制台打印“Hello
    World”，看起来是这样的：
- en: '**function** hello() {console.log(''Hello World! '');}'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**function** hello() {console.log(''Hello World! '');}'
- en: 'It could now be called from the program (or the console):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以从程序中（或控制台）调用它：
- en: hello();
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: hello();
- en: If you forget the round brackets when calling the function in the console, which
    can happen quickly if the function takes no arguments, you will be shown the source
    code of the function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在控制台调用函数时忘记加圆括号，尤其是当函数没有参数时，这种情况很容易发生，你将看到函数的源代码。
- en: Functions as Objects
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对象的函数
- en: 'Functions in JavaScript are objects themselves, of type **function**, as can
    be easily verified:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的函数本身就是对象，类型为**function**，这可以轻松验证：
- en: '**>** typeof(hello)"function"'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**>** typeof(hello)"function"'
- en: 'Because they are objects, they can also be assigned to other variable objects:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是对象，它们也可以被分配给其他变量对象：
- en: '**>** greeting = hello**>** greetings()Hello World!'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**>** greeting = hello**>** greetings()Hello World!'
- en: If we had written **greeting = hello()** here, we would have assigned the function
    *value* of **hello()** to a variable **greeting,** because **hello()** is nothing
    more than a call to the function of the same name. (As we will see below, this
    function value would be **undefined** because the function does not explicitly
    return a value).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这里写了**greeting = hello()**，我们实际上是将**hello()**的*值*赋给了变量**greeting**，因为**hello()**不过是调用了同名的函数。（正如我们稍后将看到的，这个函数值会是**undefined**，因为该函数没有显式返回值）。
- en: 'As objects, they also have a number of methods and properties; the **toString()**
    function, for example, returns the source text of the function as a string:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对象，它们还拥有若干方法和属性；例如，**toString()**函数会将函数的源代码作为字符串返回：
- en: '**>** greeting.toString()"function hello() {console.log(''Hello World!'');}"'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**>** greeting.toString()"function hello() {console.log(''Hello World!'');}"'
- en: The round brackets must not be used after the function name (**greeting**) here,
    because we do not want to *call* the function and get its return value, but only
    access the function object’s methods and properties.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，函数名称（**greeting**）后不能使用圆括号，因为我们不想*调用*函数并获取其返回值，而只是想访问函数对象的方法和属性。
- en: 'The fact that functions are objects also becomes clear in other places where
    we can work with them, just as with any other object. In ► Sect. [31.​5.​2](474412_1_En_31_Chapter.xhtml#Sec13)
    we saw how objects can be created using the **var** keyword. This is exactly what
    we can do with function objects:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为对象的特性在其他地方也很明显，我们可以像处理任何其他对象一样处理它们。在►第[31.5.2节](474412_1_En_31_Chapter.xhtml#Sec13)中，我们看到过如何使用**var**关键字创建对象。这正是我们可以用函数对象做的事情：
- en: '**var** hello = **function**() {console.log(''Hello World!'');}'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**var** hello = **function**() {console.log(''Hello World!'');}'
- en: Here, we initialize a variable **hello** with a function expression, which is
    introduced with the keyword **function**. Subsequently, **hello** is a callable
    object and can be executed with **hello()**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用函数表达式初始化一个变量**hello**，该表达式由关键字**function**引入。此后，**hello**是一个可调用的对象，可以通过**hello()**来执行。
- en: Because **hello** is now a real object, we can also add properties to it—which
    may seem a bit strange
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因为**hello**现在是一个真正的对象，我们也可以向它添加属性——这看起来可能有些奇怪。
- en: '**>** hello.counter = 5**>** typeof(hello)"function"**>** hello.counter5'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**>** hello.counter = 5**>** typeof(hello)"function"**>** hello.counter5'
- en: The object remains of type **function**, but now has an additional property,
    **counter**. When we created objects using constructor functions in ► Sect. [31.​5.​5](474412_1_En_31_Chapter.xhtml#Sec16),
    we did something very similar (scroll back again to the constructor function of
    the **Product** object type). The constructor function ultimately wrote properties
    of the current object, using the keyword **this**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象仍然是**function**类型，但现在有了一个额外的属性——**counter**。当我们在►第[31.5.5节](474412_1_En_31_Chapter.xhtml#Sec16)中使用构造函数创建对象时，我们做了类似的事情（可以回顾一下**Product**对象类型的构造函数）。构造函数最终通过使用**this**关键字写入当前对象的属性。
- en: 'Because functions are simply objects, they can also be used as properties in
    other objects, giving those objects callable *methods*. Suppose we wanted to develop
    an object that would hold a date, broken down into its constituent parts, and
    have a **display()** method that would output the date in a responsive format.
    We could define such an object as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数本质上是对象，它们也可以作为其他对象的属性使用，从而使这些对象拥有可调用的*方法*。假设我们想要开发一个对象，用于保存一个日期，并将日期拆解为组成部分，同时拥有一个**display()**方法，可以以响应式格式输出日期。我们可以按如下方式定义这个对象：
- en: '**var** shortdate = {day: 0,month: 0,year: 0,display: **function**() {console.log(**this**.year
    + ''/'' + **this**.month + ''/'' +**this**.day)}}'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**var** shortdate = {day: 0, month: 0, year: 0, display: **function**() {console.log(**this**.year
    + ''/'' + **this**.month + ''/'' + **this**.day)}}'
- en: 'Note the keyword **this**. We already encountered it in ► Sect. [31.​5.​5](474412_1_En_31_Chapter.xhtml#Sec16),
    and it establishes a reference to the current context in which (as here) a property
    or method is called. So, with **this.day** we access the **day** property in the
    current context, and that is the context of the object definition. If you omit
    the **this** keyword, JavaScript doesn’t understand what **day** is supposed to
    be, because no variable of that name exists inside the **display()** function.
    After this declaration, we can work with the object by entering the date components
    and then calling the **display()** function:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意关键字**this**。我们在►第[31.5.5节](474412_1_En_31_Chapter.xhtml#Sec16)中已经遇到过它，它用于建立当前上下文的引用，在该上下文中（如这里）调用属性或方法。因此，使用**this.day**我们可以访问当前上下文中的**day**属性，而这个上下文就是对象定义的上下文。如果省略**this**关键字，JavaScript将无法理解**day**代表的是什么，因为在**display()**函数内部没有定义名为**day**的变量。在此声明之后，我们可以通过输入日期组件，然后调用**display()**函数来操作对象：
- en: shortdate.day = 14;shortdate.month = 12;shortdate.year = 2025;shortdate.display();
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: shortdate.day = 14;shortdate.month = 12;shortdate.year = 2025;shortdate.display();
- en: This method call gives us the output **2025/12/14**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法调用会输出**2025/12/14**。
- en: So, as you can see, we can very easily populate an object with callable methods,
    because the methods are ultimately just properties of the objects, and they are
    properties of type **function**. These differ from other properties of the object
    only in that they are callable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如你所看到的，我们可以非常轻松地用可调用的方法填充一个对象，因为这些方法最终只是对象的属性，而它们是**function**类型的属性。它们与对象的其他属性的区别仅在于它们是可调用的。
- en: 'Advanced Topics I: Functions in Functions'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 高级话题 I：函数中的函数
- en: 'A special feature of JavaScript is that functions can also be defined within
    functions. A simple (though admittedly not very meaningful in terms of content)
    example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的一个特殊功能是函数也可以在函数内部定义。一个简单的（尽管在内容上并不非常有意义）例子：
- en: '**function** helloWorld() {**function** hello() {console.log(''Hello'');}**function**
    world() {console.log(''World!'');}hello();world();}'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**function** helloWorld() {**function** hello() {console.log(''Hello'');}**function**
    world() {console.log(''World!'');}hello();world();}'
- en: Here we define within the function **helloWorld()** two further functions **hello()**
    and w**orld()**, which respectively cause an output in the console. Then both
    functions are called. In this way, two new lines **Hello** and **World!** are
    created in the console.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在函数**helloWorld()**内定义了两个进一步的函数**hello()**和**world()**，它们分别在控制台输出内容。然后，两个函数都被调用。这样，控制台中会生成两行**Hello**和**World!**。
- en: 'Alternatively, we could have created the (“sub”) functions by object assignments:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们也可以通过对象赋值来创建（“子”）函数：
- en: '**function** helloWorld() {hello = **function**() {console.log(''Hello'');}world
    = **function**() {console.log(''World!'');}hello();world();}'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**function** helloWorld() {hello = **function**() {console.log(''Hello'');}world
    = **function**() {console.log(''World!'');}hello();world();}'
- en: Defining functions within functions may seem like a syntactical gimmick at first
    glance, but it has a practical use in this second variant when working with code
    modules.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部定义函数，乍一看可能像是一个语法上的花招，但在处理代码模块时，这种第二种变体有实际的应用。
- en: 'By the way, what would have happened if we had written **this.hello = function...**
    and **this.world = function...** in the definitions of the (“sub”) functions?
    Then we would have developed a *constructor function* for a **helloWorld** object,
    which gives two properties to the object, namely the two functions. Then we could
    have created objects of this type and accessed their two (function) properties
    (i.e., methods):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便问一下，如果我们在（“子”）函数的定义中写了**this.hello = function...**和**this.world = function...**会发生什么呢？那我们就会为**helloWorld**对象开发一个*构造函数*，为对象提供两个属性，即这两个函数。然后我们可以创建这种类型的对象，并访问它们的两个（函数）属性（即方法）：
- en: 'hi = **new** helloWorld();hi.hello();Advanced Topics II: Anonymous Functions'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: hi = **new** helloWorld();hi.hello();高级话题 II：匿名函数
- en: Functions normally have a name under which they can be called. However, there
    is also the possibility to define functions that do not have their own name, or
    *anonymous* functions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通常有一个名称，通过这个名称可以被调用。然而，也可以定义没有自己名称的函数，或者*匿名*函数。
- en: 'A simple example is this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子是这样：
- en: (**function**() {console.log('Hello World')}) ()
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: (**function**() {console.log('Hello World')}) ()
- en: You will first see round brackets containing a function definition, but without
    a function identifier. The parenthesis expression returns a function (a function
    object) that we *immediately call again*. This can be seen by the pair of parentheses
    at the end. They are the usual parentheses that are also used when calling a “normal”
    function with a function identifier but with no arguments. This way, the function
    does not need any name and can still be called, but in our example only in the
    direct context of its definition, because otherwise we lack the “handle” to touch
    it with.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会看到圆括号中包含一个函数定义，但没有函数标识符。括号表达式返回一个函数（一个函数对象），我们会*立即再次调用它*。这可以通过结尾的括号对看出。它们是通常用于调用“普通”函数时使用的括号，虽然没有参数。这种方式下，函数不需要任何名称，仍然可以被调用，但在我们的例子中，只能在其定义的直接上下文中调用，因为否则我们就缺少可以触碰它的“把手”。
- en: 'For “syntax gourmets”, there is a way to create such a “handle”, which we have
    used before. We assign the anonymous function to an object. To do this, let’s
    look again at an example from above:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“语法美食家”来说，有一种方法可以创建这样的“把手”，我们之前用过。我们将匿名函数赋值给一个对象。为了做到这一点，让我们再次看看上面的一个例子：
- en: '**var** hello = function() {console.log(''Hello World!'');}'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**var** hello = function() {console.log(''Hello World!'');}'
- en: 'Here we create a variable named **hello**, but the function we assign to it
    has no identifier. If you enter the name of the *variable* in the console, the
    source code of the function is displayed; however, no function identifier is visible
    in it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为**hello**的变量，但赋给它的函数没有标识符。如果你在控制台输入*变量*的名称，将会显示该函数的源代码；然而，函数中并没有显示函数标识符：
- en: '**>** hellof () {console.log(''Hello World!'');}'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**>** hellof () {console.log(''Hello World!'');}'
- en: 'Although it may seem a bit confusing, we have created an object called **hello**
    that represents a function, but the function itself is anonymous, so it has no
    name. However, if we define the function by using a function identifier, we again
    get a function object; this time, however, the function has a name:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这看起来有点令人困惑，但我们创建了一个名为**hello**的对象，它代表一个函数，但该函数本身是匿名的，因此没有名字。然而，如果我们使用函数标识符来定义该函数，我们仍然会得到一个函数对象；不过，这次函数是有名字的：
- en: '**>** var hello = function hello() {console.log(''Hello World!'');}**>** hellof
    hello() {console.log(''Hello World!'');}'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**>** var hello = function hello() {console.log(''Hello World!'');}**>** hellof
    hello() {console.log(''Hello World!'');}'
- en: So, we don’t necessarily have to call anonymous functions directly after their
    definition, we can also catch them in an object. Just like the “functions in functions”,
    anonymous functions are also useful when it comes to constructing entire code
    modules. In “everyday programming” it is functions with function identifiers that
    are mostly used.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不一定要在定义后立即调用匿名函数，也可以将其捕获在对象中。就像“函数中的函数”一样，匿名函数在构建整个代码模块时也非常有用。在“日常编程”中，通常使用的是带有函数标识符的函数。
- en: 33.1.2 Return Values
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.1.2 返回值
- en: 'Functions can return objects using the **return** statement. The following
    function generates and returns a random number between 0 and 10:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以使用**return** 语句返回对象。以下函数生成并返回一个介于 0 和 10 之间的随机数：
- en: '**function** getRandomNumber() {**var** randomNumber;randomNumber = Math.round(Math.random()*10,0);**return**
    randomNumber;}'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**function** getRandomNumber() {**var** randomNumber;randomNumber = Math.round(Math.random()*10,0);**return**
    randomNumber;}'
- en: The **return** statement can also be written like a function instead of using
    the keyword **return**, in our case as **return(randomNumber)**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**return** 语句也可以像函数一样编写，而不是使用关键字**return**，在我们的例子中就是**return(randomNumber)**。'
- en: 'Functions that do not have a **return** statement do their job (in our case
    printing something to the console) but return **undefined**:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 没有**return**语句的函数会完成它们的工作（在我们的例子中是打印一些内容到控制台），但返回**undefined**：
- en: '**>** function hello() {console.log(''Hello World!'');}**>** res = hello()Hello
    World**>** resundefined'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**>** function hello() {console.log(''Hello World!'');}**>** res = hello()Hello
    World**>** resundefined'
- en: 33.1.3 Arguments and Parameters of Functions
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.1.3 函数的参数和参数列表
- en: Foundations of Arguments and Parameters
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 参数和实参的基础
- en: The functions of mathematics are assignment rules that assign a value to one
    or more arguments. So far, we have only considered functions that have managed
    entirely without arguments. As a rule, however, functions become useful precisely
    because you can call them with arguments and thereby control their behavior or
    pass data to them for processing in this way.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 数学函数是赋值规则，它们将一个值赋给一个或多个参数。到目前为止，我们只考虑了完全没有参数的函数。然而，通常情况下，函数之所以有用，正是因为你可以在调用它们时传递参数，从而控制它们的行为或传递数据供其处理。
- en: Terminologically, we have so far been less selective than is often seen with
    JavaScript. Here, it is not uncommon to distinguish between *parameters* and *arguments.*
    Parameters are the abstract values listed in the function *definition* that a
    function accepts, while arguments are the concrete values that are actually passed
    to the function when it is *called.*
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从术语上讲，我们到目前为止的描述比 JavaScript 中常见的要宽泛一些。在这里，区分*参数*和*实参*并不罕见。参数是列在函数*定义*中的抽象值，函数接受这些值，而实参则是在函数*调用*时实际传递给函数的具体值。
- en: In JavaScript, parameters are specified in the function definition without a
    type. This means that the programmer must take care of any necessary type checks
    himself.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，参数在函数定义中指定时没有类型。这意味着程序员必须自己进行必要的类型检查。
- en: 'The previously used example of converting temperature from Kelvin to degrees
    Celsius would then look like this using function arguments (but without checking
    the type of the parameter):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 之前用来将温度从开尔文转换为摄氏度的示例，使用函数参数后将变成这样（但没有检查参数的类型）：
- en: '**function** kelvinToCelsius(kelvin) {**return** kelvin - 273.15;}'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**function** kelvinToCelsius(kelvin) {**return** kelvin - 273.15;}'
- en: '**kelvin** is a *parameter* of the function. If we call the function later,
    for example, with the Kelvin temperature 54, then 54 is the *argument* for the
    parameter **kelvin**. Multiple parameters would be separated by commas in the
    function definition.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**kelvin** 是函数的 *参数*。如果稍后我们调用该函数，比如传入温度 54 的开尔文温标，那么 54 就是参数 **kelvin** 的 *实参*。函数定义中的多个参数会用逗号分隔。'
- en: Changing Arguments Within the Function
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部修改参数
- en: In JavaScript, arguments are always passed as *values* if the data types of
    the arguments are elementary data types, such as **number**, **string**, or **boolean**;
    thus, if you pass a variable to a function and the function changes the argument
    passed to it, the original variable does not change. In a sense, the function
    works with a copy of the value passed to it, not the variable itself. So, the
    passing is done by *value.*
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，当参数的数据类型是基本数据类型（如 **number**、**string** 或 **boolean**）时，参数始终以
    *值* 的形式传递；因此，如果将一个变量传递给函数，并且函数修改了传入的参数，那么原始变量并不会改变。从某种意义上说，函数是操作传入的值的副本，而不是变量本身。所以，传递是通过
    *值* 完成的。
- en: However, if you pass a more complex object to the variable and make a change
    to it, the object passed to the function does change. The passing is then done
    by *reference*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你传递了一个更复杂的对象并对其进行了更改，那么传递给函数的对象会发生改变。这时，传递是通过 *引用* 完成的。
- en: 'The following example illustrates the difference:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了这种区别：
- en: '**function** Product(price, name) {**this**.price = price;**this**.name = name;}**var**
    chair = new Product(24.99, ''Garden chair'');**var** purchased = false;**function**
    setPrice(article, price) {article.price = price;}**function** purchase(purchaseStatus)
    {purchaseStatus = true;}In the example, we again use the object type **Product**,
    whose constructor function we first call to create a **Product** object called
    **chair** and initialize some properties, including the price, which is set to
    **24.99**. We also create a **boolean** variable **purchased**, which indicates
    whether something has already been sold and is initialized to **false**. Following
    are the definitions of two functions: **setPrice(article, price)**, which changes
    the price of a product passed to it as its first argument, and **purchase(purchaseStatus)**,
    which takes a **boolean** variable as a sales indicator and sets it to **true**
    (or not, as we’ll see). Let’s try both functions in the console:**>** setPrice(chair,
    50.89)**>** purchase(purchased)**>** chair.price50.89**>** purchasedfalse'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**function** Product(price, name) {**this**.price = price;**this**.name = name;}**var**
    chair = new Product(24.99, ''Garden chair'');**var** purchased = false;**function**
    setPrice(article, price) {article.price = price;}**function** purchase(purchaseStatus)
    {purchaseStatus = true;}在这个示例中，我们再次使用了对象类型 **Product**，其构造函数首先被调用来创建一个名为 **chair**
    的 **Product** 对象，并初始化一些属性，包括价格，设置为 **24.99**。我们还创建了一个 **boolean** 变量 **purchased**，表示某物是否已售出，初始值为
    **false**。以下是两个函数的定义：**setPrice(article, price)**，它修改传递给它的产品的价格（作为第一个参数），以及 **purchase(purchaseStatus)**，它接受一个
    **boolean** 类型的变量作为销售指示符，并将其设置为 **true**（或者不设置，正如我们将看到的）。让我们在控制台中尝试这两个函数：**>**
    **setPrice(chair, 50.89)** **>** **purchase(purchased)** **>** **chair.price 50.89**
    **>** **purchased false**'
- en: As you can see, the price of the chair changes, but the status indicator **puchased**
    keeps its old value. **purchased** is a *primitive value*, it cannot be changed
    as an argument of the function (**purchaseStatus**); the object **chair**, on
    the other hand, can very well be changed in the code of the function if it is
    passed to the function as argument **article**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，椅子的价格发生了变化，但状态指示符 **purchased** 保持了其原始值。**purchased** 是一个 *原始值*，它不能作为函数（**purchaseStatus**）的参数进行更改；而对象
    **chair** 则可以在函数的代码中被修改，如果它作为参数 **article** 传递给函数的话。
- en: Calling Functions with Arguments
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 带参数调用函数
- en: Function arguments can also be passed with their parameter name when calling
    the function; for example, we could call our Kelvin to Celsius conversion as **kelvinToCelsius(kelvin=54)**.
    By passing the arguments with their parameter name makes the assignment of the
    arguments to the parameters clear, this procedure also allows the arguments to
    be passed in a different order than the parameter sequence specified in the function
    definition.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数时，也可以通过参数名来传递参数；例如，我们可以将开尔文到摄氏度的转换函数调用为 **kelvinToCelsius(kelvin=54)**。通过参数名传递实参可以使参数与实参之间的赋值关系更加清晰，并且这一方式也允许按照不同于函数定义中参数顺序的顺序传递实参。
- en: 'JavaScript is very flexible about the number of parameters: if *too many* arguments
    are given to the function, the “excess” arguments are simply ignored. The question
    of what happens in the case of *too few* arguments leads us to the topic of default
    values and optional parameters.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在参数数量方面非常灵活：如果给函数传递了*过多*的参数，“多余”的参数会被简单地忽略。关于*过少*参数的处理，我们进入了默认值和可选参数的主题。
- en: Working with Default Values and Optional Parameters
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 处理默认值和可选参数
- en: Parameters can be given a default value, as in most other programming languages,
    which is always used if no argument, i.e., no concrete value, is given for this
    parameter when the function is called.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以像大多数其他编程语言一样被赋予默认值，当调用函数时如果没有提供该参数的具体值，即没有传递实际的参数值，则始终使用默认值。
- en: Unlike many other programming languages, however, it is not this default value
    that makes a parameter optional in the first place. Instead, *all* parameters
    are optional in JavaScript. If parameters do not have a default value and yet
    are not specified in the function call, they are automatically assigned the value
    **undefined**. In our example, a call to the temperature conversion function from
    above as **kelvinToCelsius()** would be perfectly valid, but would result in the
    return value **NaN** (*not a number*), because in this case JavaScript assumes
    the value **undefined** for the parameter **kelvin**, and this cannot be used
    for arithmetic calculations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与许多其他编程语言不同，这个默认值并不是使参数可选的原因。实际上，*所有*参数在JavaScript中都是可选的。如果参数没有默认值，且在函数调用中没有被指定，则自动赋值为**undefined**。在我们的示例中，调用上面提到的温度转换函数**kelvinToCelsius()**是完全有效的，但会返回**NaN**（*非数字*），因为在这种情况下，JavaScript将**kelvin**参数的值假定为**undefined**，而**undefined**不能用于数学计算。
- en: Using Functions as Arguments of Functions
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数作为函数的参数
- en: The arguments of functions can be of any object type. They can also be function
    objects themselves. This should not really surprise you after what we have discussed
    before. However, we want to illustrate this fact here with an example to show
    that this is a very useful feature of JavaScript.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数可以是任何对象类型。它们甚至可以是函数对象本身。通过我们之前讨论的内容，这不应该让你感到惊讶。然而，我们希望通过一个示例来说明这一点，展示它是JavaScript的一个非常有用的特性。
- en: 'Consider the following two functions, each of which concatenates a student’s
    first name and last name in different ways:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个函数，它们分别以不同方式将学生的名字和姓氏连接起来：
- en: '**function** lastFirst(firstname, lastName) {**return** lastName + '', '' +
    firstName;}**function** firstLast(firstName, lastName) {**return** firstName +
    '' '' + lastName;}'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**function** lastFirst(firstname, lastName) {**return** lastName + '', '' +
    firstName;}**function** firstLast(firstName, lastName) {**return** firstName +
    '' '' + lastName;}'
- en: 'We could now develop a function **showMark()** that, in addition to showing
    the student’s name, also takes care of showing an exam grade:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开发一个**showMark()**函数，除了显示学生的名字外，还负责显示考试成绩：
- en: 'function showMark(firstName, lastName, mark, displayName) {console.log(displayName(firstName,
    lastName) + '': '' + mark);}'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 'function showMark(firstName, lastName, mark, displayName) {console.log(displayName(firstName,
    lastName) + '': '' + mark);}'
- en: 'We could now call **showMark()** as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以如下调用**showMark()**：
- en: '**>** showNote(''Beth'', ''Hathaway'', ''A+'', lastFirst);Hathaway, Bath: A+**>**
    showNote(''Beth'', ''Hathaway'', ''A+'', firstLast);Beth Hathaway: 1.0'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**>** showNote(''Beth'', ''Hathaway'', ''A+'', lastFirst);Hathaway, Bath: A+**>**
    showNote(''Beth'', ''Hathaway'', ''A+'', firstLast);Beth Hathaway: 1.0'
- en: Thus, **showMark()** uses the **displayName** function passed to it as an argument.
    This makes **showMark()** extremely flexible. Because as long as the passed function
    takes first and last names in that order, it can be used to display names in various
    ways.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**showMark()**使用作为参数传入的**displayName**函数。这使得**showMark()**非常灵活。只要传入的函数按照名字和姓氏的顺序处理，它就可以以不同的方式显示名字。
- en: Working with a Variable Number of Arguments
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 处理可变数量的参数
- en: 'JavaScript provides an easy way to access the arguments of a function without
    using the name of the parameters. This is especially helpful when you don’t know
    in advance exactly how many arguments the user will be passing. In the following
    simple example, we have a function that can be passed several strings as arguments,
    and that combines those strings as a news ticker with **+++** as the separator:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript提供了一种方便的方法来访问函数的参数，而无需使用参数的名称。这在你无法预先知道用户会传递多少参数的情况下尤其有用。在以下简单的示例中，我们有一个可以接受多个字符串作为参数的函数，它将这些字符串组合成一个新闻滚动条，并使用**+++**作为分隔符：
- en: '**function** newsTicker() {**var** ticker = Array.from(arguments).join('' +++
    '');console.log(ticker)}'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**function** newsTicker() {**var** ticker = Array.from(arguments).join('' +++
    '');console.log(ticker)}'
- en: 'It can now be called like this, for example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以像这样调用，例如：
- en: '**>** newsTicker(''Eagles at 49ers 35:38'', ''Chiefs at Bengals 23:20'')Eagles
    at 49ers 35:38 +++ Chiefs at Bengals 23:20'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**>** newsTicker(''Eagles at 49ers 35:38'', ''Chiefs at Bengals 23:20'')Eagles
    at 49ers 35:38 +++ Chiefs at Bengals 23:20'
- en: Instead of two match results, we could have returned *any other number* of pairings.
    Our **newsTicker()** function would be able to cope with this, even though at
    first glance it receives no arguments at all! However, since JavaScript allows
    the function to be passed more arguments than it has parameters in its definition,
    we can just feed our news ticker as many football results as we want to our heart’s
    content.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以返回*任何其他数量*的配对，而不是仅仅两个比赛结果。我们的**newsTicker()**函数能够应对这种情况，尽管乍一看它根本没有接收任何参数！然而，由于
    JavaScript 允许传递比函数定义中参数更多的参数，我们可以根据需要随心所欲地将任何数量的足球比赛结果传递给我们的新闻播报器。
- en: Arguments behaves like an array in some respects. For example, you can access
    the individual arguments passed to the function with **arguments[0]**, **arguments[1]**,
    and so on. However, **arguments** is not a true array. Other than the **length**
    property, which returns the number of arguments passed, **arguments** has none
    of the usual array properties and methods. For our purposes, we must first convert
    it to the **Array** type, which then provides us with the **join()** function
    to concatenate the individual elements. Here we use the **from()** function of
    the **Array object**, which converts an array-like object (like **arguments**)
    into a real array.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Arguments 在某些方面表现得像一个数组。例如，你可以通过**arguments[0]**、**arguments[1]**等访问传递给函数的单个参数。然而，**arguments**并不是真正的数组。除了**length**属性（返回传递的参数数量）之外，**arguments**没有其他常见的数组属性和方法。为了我们的目的，我们必须先将它转换为**Array**类型，这样我们就可以使用**join()**函数来连接单个元素。这里我们使用**Array对象**的**from()**函数，它将类数组对象（如**arguments**）转换为真正的数组。
- en: 33.1 [5 min]
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 33.1 [5 分钟]
- en: Define an object **Product** with product name and price as properties and develop
    a method for this object that applies a price discount to the product, which the
    caller of the method can specify as a parameter. If he does not specify a price
    discount, it should be assumed that the price is to be reduced by 20%.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个**Product**对象，包含产品名称和价格作为属性，并为该对象开发一个方法，应用一个价格折扣，这个折扣由调用者作为参数指定。如果调用者没有指定折扣，则假定价格应该减少
    20%。
- en: 33.2 [5 min]
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 33.2 [5 分钟]
- en: Write a function that can be passed a **Product** object like in previous task
    and then applies the discount given as a parameter. The function should not be
    a method of the object. In what two ways can the “return” of the modified product
    object be done, and why?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个可以传入**Product**对象（如前一个任务中的对象）的函数，并应用作为参数传递的折扣。该函数不应是对象的方法。修改后的产品对象的“返回”可以通过哪两种方式完成，为什么？
- en: 33.3 [5 min]
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 33.3 [5 分钟]
- en: Develop a function that takes an unspecified number of arguments and returns
    them as an alphabetically sorted array.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个函数，接受不定数量的参数，并返回按字母顺序排序的数组。
- en: 33.4 [5 min]
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 33.4 [5 分钟]
- en: Write a function that does an output to the console. Assign the resulting function
    object to another variable. Then call the function using this other variable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，向控制台输出。将结果函数对象分配给另一个变量。然后使用这个其他变量调用该函数。
- en: 33.1.4 Scope of Variables in Functions
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.1.4 函数中的变量作用域
- en: Especially in connection with functions, the range of validity of variables
    plays an important role. Variables declared with **var** *within* a function are
    *local* variables that exist only in the code block of that function. They cannot
    be accessed outside the function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是与函数相关时，变量的有效范围起着重要作用。使用**var**在函数内声明的变量是*局部*变量，仅存在于该函数的代码块中。它们不能在函数外部访问。
- en: However, if a variable is accessed within a function *without* **var**, it is
    only created as a new local variable if there is no global variable of the same
    name, i.e., declared outside the function (“one level higher”, so to speak).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果在函数内访问一个变量*没有*使用**var**，那么只有在不存在同名的全局变量（即在函数外声明的变量，“高一级”）时，才会创建一个新的局部变量。
- en: 'Consider the following simple example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下简单示例：
- en: '**var** factor1 = 3, factor2 = 5;**function** multiply() {**var** factor2 =
    7;result = factor1 * factor2;factor1 = 11;factor3 = 200;**return** result;}console.log(multiply());console.log(factor1);console.log(factor2);console.log(factor3);'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**var** factor1 = 3, factor2 = 5;**function** multiply() {**var** factor2 =
    7;result = factor1 * factor2;factor1 = 11;factor3 = 200;**return** result;}console.log(multiply());console.log(factor1);console.log(factor2);console.log(factor3);'
- en: 'This little program makes four outputs:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小程序产生了四个输出：
- en: '21115200'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '21115200'
- en: Within the function **multiply()** a *local* variable **factor2** is created
    with **var**, whose value (7) differs from the value of the global variable with
    the same name, which was declared and initialized outside the function (5).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数**multiply()**中创建了一个*局部*变量**factor2**，它使用**var**声明，其值（7）与在函数外部声明并初始化的同名全局变量（5）不同。
- en: After calling the function, we output the value of the variable **factor2**
    to the console. In doing so, we automatically access the *global* variable **factor2**,
    because the local variable of the same name ceased to exist at the end of the
    **multiply()** function. However, it is the local variable with the value 7 that
    is used to calculate the multiplication within the function. In a sense, it shields
    the global variable **factor2**; as a result, it is not visible. When the variable
    **factor2** is accessed in the statement **result = factor1 * factor2**, the local
    variable is therefore automatically used. Only if no local variable exists, a
    global variable is searched for, and in the case of **factor1**, one is found.
    A new value is then assigned to this variable. Since the keyword **var** is not
    used, the assignment is made to the global variable. This change of the variable
    value is therefore also visible outside the function, as the second output in
    the console shows. If the assignment had been prefaced with **var**, instead of
    assigning a value to a global variable, we would have created a *new local* variable
    with the identifier **factor1**. The assignment of the value 11 would then have
    gone to this local variable, leaving the global variable **factor1** unaffected,
    shielded in its visibility by the local variable, and retaining its value after
    the **multiply()** function had been executed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数后，我们将变量**factor2**的值输出到控制台。这样做时，我们自动访问了*全局*变量**factor2**，因为同名的局部变量在**multiply()**函数结束时不再存在。然而，在函数内进行乘法计算时，使用的是值为7的局部变量。在某种意义上，它屏蔽了全局变量**factor2**；因此它不可见。当在语句**result
    = factor1 * factor2**中访问变量**factor2**时，局部变量会自动被使用。只有当没有局部变量时，才会查找全局变量，并且在**factor1**的情况下，找到了一个。然后给这个变量赋了一个新值。由于没有使用**var**关键字，赋值发生在全局变量上。因此，这个变量值的变化在函数外部也是可见的，正如控制台中的第二个输出所示。如果赋值前使用了**var**，我们就不是给全局变量赋值，而是创建了一个*新的局部*变量**factor1**。然后，值11会被赋给这个局部变量，而不影响全局变量**factor1**，它会在局部变量的作用下保持不可见，并在**multiply()**函数执行完毕后保留原有值。
- en: This is exactly what happens, as you can see in the third output, with the variable
    **factor2**, which is only apparently assigned a new value within the function;
    this new value goes to the new *local* variable **factor2**, so that the global
    variable is not changed in its value by the assignment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是发生的情况，正如你在第三个输出中看到的，变量**factor2**仅在函数内部看似被赋予了一个新值；这个新值被赋给了新的*局部*变量**factor2**，因此全局变量的值并没有因为赋值而发生改变。
- en: 'Output number four is interesting. It accesses the variable **factor3**, which
    is used for the first time in our **multiply()** function. We already said that
    variables accessed within a function without the **var** keyword are global variables.
    And that’s exactly how it is with **factor3**: by assigning **factor3 = 200**,
    we create a global variable, even though the assignment happens *inside* the function.
    And because **factor3** is a global variable, we can access the value stored in
    it outside the function without any problems.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个输出很有趣。它访问了变量**factor3**，这个变量首次在我们的**multiply()**函数中使用。我们已经说过，函数内没有使用**var**关键字访问的变量是全局变量。正是这种情况发生在**factor3**上：通过赋值**factor3
    = 200**，我们创建了一个全局变量，尽管赋值发生在*函数内*。而且由于**factor3**是一个全局变量，我们可以在函数外部毫无问题地访问它存储的值。
- en: By the way, the arguments that are passed to functions are always local variables.
    If a global variable of the same name exists, it is practically masked by the
    function, it is invisible. If you access the variable with its identifier, you
    work with the local variable of the same name, i.e., the argument of the function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，传递给函数的参数始终是局部变量。如果存在同名的全局变量，它将被函数“遮蔽”，即不可见。如果你通过标识符访问该变量，你实际上是在操作同名的局部变量，即函数的参数。
- en: 33.5 [10 min]
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 33.5 [10 分钟]
- en: What values do the variables **x**, **y**, **y1**, **y2**, and **z** have after
    executing the following program, and why?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下程序后，变量**x**、**y**、**y1**、**y2**和**z**的值分别是多少？为什么？
- en: x = 5;z = 3;**function** allOthers(x, y) {y1 = x;x = null;var y2 = y;z = 1;}allOthers(6,2);
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: x = 5;z = 3;**function** allOthers(x, y) {y1 = x;x = null;var y2 = y;z = 1;}allOthers(6,2);
- en: 33.2 Working with Modules/Libraries
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 33.2 使用模块/库
- en: 33.2.1 Developing and Using Your Own Modules
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.2.1 开发和使用自有模块
- en: Using modules means including code that is sourced out. Outsourcing code makes
    sense especially if you want to use the code in different programs. For example,
    if you have developed a practical function and want to use it not only in the
    program for which you originally designed it, but also in other programs, the
    easiest thing to do is to outsource this function to its own module and then include
    this module in all programs that are to access the function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块意味着包含外部的代码。外包代码尤其有意义，如果你希望在不同的程序中使用该代码。例如，如果你开发了一个实用函数，并希望不仅在原始设计它的程序中使用，还希望在其他程序中使用，最简单的做法是将这个函数外包到它自己的模块中，然后在所有需要访问该函数的程序中包含这个模块。
- en: The easiest way to include another JavaScript file is to include it in the web
    page using the **script** element. Let’s take a look at exactly that with an example.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 包含另一个JavaScript文件最简单的方法是使用**script**元素将其包含在网页中。让我们通过一个例子来具体看看。
- en: 'In ► Sect. [33.1.2](#Sec3) we developed a function **getRandomNumber()** which
    returns a random number between 0 and 10\. Let’s assume that because this function
    is convenient and we want to use it in different scripts, we want to put it in
    its own module. To do this, we first create a new JavaScript file **mymodule.js**,
    in which we place the function. In addition, we define a variable called **fixedNumber**
    in our module. This will make our file **mymodule.js** look like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在► 第[33.1.2节](#Sec3)中，我们开发了一个返回0到10之间随机数的函数**getRandomNumber()**。假设由于这个函数很方便，我们希望在不同的脚本中使用它，我们想将它放入自己的模块中。为此，我们首先创建一个新的JavaScript文件**mymodule.js**，并将函数放在其中。此外，我们在模块中定义一个名为**fixedNumber**的变量。这将使我们的文件**mymodule.js**看起来像这样：
- en: '**function** getRandomNumber() {**var** randomNumber;randomNumber = Math.round(Math.random()*10,
    0);**return** randomNumber;}fixedNumber = 4;'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**function** getRandomNumber() {**var** randomNumber;randomNumber = Math.round(Math.random()*10,
    0);**return** randomNumber;}fixedNumber = 4;'
- en: 'The function **getRandomNumber()** and the variable **fixedNumber** are accessed
    from another JavaScript program called **moduleapplication.js**:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 函数**getRandomNumber()**和变量**fixedNumber**是从另一个名为**moduleapplication.js**的JavaScript程序中访问的：
- en: 'document.write(''A random number: '', getRandomNumber());document.write(''<p></p>'');document.write(''A
    fixed number: '', fixedNumber);'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: document.write('随机数：', getRandomNumber());document.write('<p></p>');document.write('固定数值：',
    fixedNumber);
- en: 'This script in turn is embedded in a simple web page:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本又被嵌入到一个简单的网页中：
- en: '**<!DOCTYPE html>**<**html>****<head>****<title>**Script with its own module**</title>****<noscript>**Please
    enable JavaScript!**</noscript>****</head>****<body>****<script** src="mymodule.js"**></script>****<script**
    src="moduleapplication.js"**></script>****</body>****</html>**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**<!DOCTYPE html>**<**html>****<head>****<title>**带有自有模块的脚本**</title>****<noscript>**请启用JavaScript！**</noscript>****</head>****<body>****<script**
    src="mymodule.js"**></script>****<script** src="moduleapplication.js"**></script>****</body>****</html>**'
- en: In order for the function and variable we defined in **mymodule.js** to be available
    in our actual program, which is in the **moduleapplication.js** file, we need
    to include the module in the web page as well, *before* **moduleapplication.js**.
    Since the scripts are processed in order, if we included the module later, its
    contents would not be known at the time we access it from **moduleapplication.js**.
    So, pay attention to the order!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们在**mymodule.js**中定义的函数和变量可以在实际的程序中使用（该程序位于**moduleapplication.js**文件中），我们需要在网页中包含该模块，并且必须在**moduleapplication.js**之前包含它。由于脚本是按顺序处理的，如果我们在后面才包含该模块，在从**moduleapplication.js**访问时，模块内容将不可用。所以，请注意顺序！
- en: 'Now, when we open the web page, we get an output like the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们打开网页时，得到的输出如下所示：
- en: 'A random number: 2A fixed number: 4'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数：2固定数：4
- en: In exactly the same way, you could now include the module **mymodule.js** in
    other projects and access the function **getRandomNumber()** there without having
    to repeat the code of the function in your new project in the main code file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，你现在可以在其他项目中包含模块**mymodule.js**，并在那里访问函数**getRandomNumber()**，而不必在新项目的主代码文件中重复该函数的代码。
- en: JavaScript’s ability to work with modules has expanded more and more over time.
    While in the beginning this ability was limited to including source several files
    in the web page (as we just did), with newer language standards true modularization
    became possible. This, along with other things, allows more precise control over
    which objects are exported by modules and can then be imported again for use by
    other modules (and thus also by the JavaScript applications themselves). When
    importing, various options are also available to deal with naming conflicts that
    can arise when modules provide objects (for example, functions) whose identifiers
    are identical to the identifiers of objects already present in the importing code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript处理模块的能力随着时间的推移不断扩展。虽然最初这一能力仅限于将几个源文件包含到网页中（就像我们刚刚做的那样），但随着新语言标准的推出，真正的模块化成为可能。这使得更加精确地控制模块导出哪些对象并可以再次被其他模块（以及JavaScript应用程序本身）导入变得可能。导入时，还提供了各种选项来处理命名冲突，防止模块提供的对象（例如函数）与导入代码中已存在的对象的标识符冲突。
- en: However, these considerations go well beyond the scope of an introduction to
    JavaScript development. For us it is sufficient to know that we can modularize
    our code by splitting it into individual script files and then embedding them
    into our HTML page.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些考虑因素超出了JavaScript开发入门的范围。对我们来说，知道如何通过将代码拆分成单独的脚本文件，然后将它们嵌入到HTML页面中来实现代码模块化就足够了。
- en: 33.2.2 Finding and Integrating External Modules/Libraries
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.2.2 查找和集成外部模块/库
- en: Unlike for some other programming languages (such as Python with the *Python
    Package Index*, see ► Sect. [23.​3.​3](474412_1_En_23_Chapter.xhtml#Sec10)), there
    is no central or quasi-official platform for JavaScript where you can find useful
    code to use when developing your own applications. Nevertheless, there are of
    course some “hotspots” of the very active JavaScript community; first and foremost
    *GitHub*, which we already had a look at in ► Sect. [13.​2](474412_1_En_13_Chapter.xhtml#Sec2)
    and which is a platform for exchange and collaboration among developers based
    on the versioning tool *git* developed by Linux inventor *Linus Torvalds*. Here
    you will find a plethora of *repositories*, or code archives, with countless useful
    functions and classes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与某些其他编程语言（例如Python通过*Python包索引*，见► 第[23.3.3节](474412_1_En_23_Chapter.xhtml#Sec10)）不同，JavaScript没有一个中央或准官方平台，你可以在上面找到在开发自己应用程序时有用的代码。然而，当然也有一些非常活跃的JavaScript社区“热点”；首先是*GitHub*，我们已经在►
    第[13.2节](474412_1_En_13_Chapter.xhtml#Sec2)中查看过，它是一个基于Linux发明者*Linus Torvalds*开发的版本控制工具*git*的开发者交流和协作平台。在这里，你将找到大量的*仓库*，即代码档案，包含无数有用的函数和类。
- en: Find out about the licensing situation from the **LICENSE** file in the repository
    before using third-party code! Most developers who make their work available on
    *GitHub* use one of the well-known standard licenses such as *GNU General Public
    License* or *Creative Commons* or *MIT*, each of which usually comes in various
    variants and versions. Conveniently, *GitHub* always provides you with a summary
    of these standard licenses, showing what you are allowed to do with the code and
    what you are not. So, you don’t have to read long legal texts on a regular basis
    at all to understand how you’re allowed to make use of other developers’ prior
    work. *GitHub* has already done that work for you.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用第三方代码之前，请通过仓库中的**LICENSE**文件了解许可情况！大多数将作品公开在*GitHub*上的开发者都会使用一些知名的标准许可证，例如*GNU通用公共许可证*、*创意共享许可证*或*MIT许可证*，每种许可证通常都有多个变种和版本。方便的是，*GitHub*总是为你提供这些标准许可证的摘要，显示你可以对代码做什么，不能做什么。因此，你完全不需要经常阅读冗长的法律文本就能理解你被允许如何使用其他开发者的先前作品。*GitHub*已经为你完成了这项工作。
- en: A *GitHub repository* usually contains a large number of files. Don’t be surprised
    if the supposed descriptions of these files (in the middle column of a repository
    code view) seem strange to you. This column does not contain a description of
    the files at all, but comments that explain the last change to the file. In practice,
    the most important files are regularly located in the repository’s **\dist** directory;
    they are the *distributable* files, i.e., those code files that are intended for
    distribution and production use. If you want to read the code, it is recommended
    to look at the **\src** directory. This is because the code in **\dist** is usually
    stripped of unnecessary characters (for example, spaces and comments) in order
    to keep the file size as small as possible and to improve the performance of the
    web page that uses this code. Sometimes the code has been obfuscated (scroll back
    a few pages to ► Sect. [29.​1.​2](474412_1_En_29_Chapter.xhtml#Sec3), where we
    discussed obfuscation). You can, of course, also work with the code in the **\src**
    directory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*GitHub 仓库* 通常包含大量文件。如果你发现这些文件的描述（仓库代码视图中的中间列）看起来很奇怪，不要感到惊讶。这个列并不包含文件的描述，而是解释文件最后一次更改的注释。实际上，最重要的文件通常位于仓库的**\dist**目录；它们是*可分发*文件，即那些用于分发和生产环境的代码文件。如果你想阅读代码，建议查看**\src**目录。这是因为**\dist**中的代码通常会去除不必要的字符（例如空格和注释），以尽可能减小文件大小并提高使用这些代码的网页的性能。有时代码会被混淆（请回到几页前的►第29.1.2节，我们讨论了混淆）。当然，你也可以直接使用**\src**目录中的代码。'
- en: The easiest way to make the code usable for you is to download a ZIP file via
    the “Close or download” button and then unzip it on your computer. It contains
    the entire repository. While having the code available is necessary, it is also
    important to understand how to use it. The **README** file of the respective project
    and possibly other files in the **\doc** folder regularly provide information
    on this.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让代码对你可用的最简单方法是通过“关闭或下载”按钮下载 ZIP 文件，然后在你的计算机上解压。它包含了整个仓库。虽然拥有代码是必要的，但理解如何使用它也同样重要。各个项目的**README**文件以及**\doc**文件夹中的其他文件通常会提供相关信息。
- en: Besides *GitHub*, there are of course numerous other sources from which you
    can obtain JavaScript modules, such as ► [*javascripting.com*](http://javascripting.com).
    Also, a targeted internet search in which you follow the pattern “How can I...”
    quite often brings you to answers that point to modules that you can download
    from somewhere. Alternatively, you can ask ChatGPT something like “Which JavaScript
    modules are available to *implement a running news ticker on a website?*” (Replace
    the text in italics with your own topic of interest).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*GitHub*，当然还有许多其他来源可以获取 JavaScript 模块，例如► [*javascripting.com*](http://javascripting.com)。此外，通过模式为“我怎么做...”的定向互联网搜索，通常也能找到指向可以下载模块的答案。或者，你可以向
    ChatGPT 提问类似“哪些 JavaScript 模块可以*在网站上实现滚动新闻跑马灯*？”（将斜体部分替换为你自己的兴趣主题）。
- en: By the way, one of the most popular JavaScript libraries is *jQuery*, which
    especially simplifies working with the browser’s object model (i.e., selecting
    and modifying HTML elements, for example).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一句，最流行的 JavaScript 库之一是*jQuery*，它特别简化了与浏览器对象模型的交互（例如，选择和修改 HTML 元素）。
- en: 33.3 Frameworks
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 33.3 框架
- en: '*Frameworks* play a big role in professional application development with JavaScript
    today. Frameworks differ from normal program libraries/modules in that they provide
    a wireframe for the application that calls the code written by the developer whenever
    that is necessary. When using libraries, it is the developer’s code that calls
    the library when it is needed. Therefore, in the context of frameworks, one speaks
    of an *inversion of control*. Frameworks play a major role in practice because
    they allow the programmer to concentrate on the core functionality of his application
    and to hand off other, more standard tasks such as handling logins and session
    management or retrieving data from databases and displaying it in template-based
    pages to the framework.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*框架*在如今使用 JavaScript 进行专业应用开发中起着重要作用。框架与普通的程序库/模块的不同之处在于，它们为应用程序提供了一个框架，当需要时会调用开发者编写的代码。而在使用库时，是开发者的代码在需要时调用库。因此，在框架的背景下，人们谈论的是*控制反转*。框架在实践中扮演着重要角色，因为它们使程序员能够集中精力开发应用程序的核心功能，其他更加标准的任务，如处理登录和会话管理，或者从数据库中检索数据并在基于模板的页面中显示这些数据，则交由框架来处理。'
- en: Some well-known JavaScript frameworks are *Angular*, *React*, and *Vue*. Looking
    at their structure and usage is far beyond the scope of this book. However, a
    prerequisite for using frameworks is knowledge of JavaScript basics, and these
    are exactly what we cover in this part of the book. So, after studying this part,
    you’ll have a solid foundation on which to venture into working with frameworks
    as well, should you so desire. In fact, for most purposes in the “private user
    area” (hobby programmer is not a nice phrase!) the use of standard JavaScript
    (perhaps enhanced by some libraries from GitHub) without the use of frameworks
    is sufficient, which although they are extremely powerful, also bring a certain
    “overhead” of work and enforce a structure that is not necessary for smaller projects.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一些著名的 JavaScript 框架包括*Angular*、*React*和*Vue*。深入研究它们的结构和用法超出了本书的范围。然而，使用框架的前提是掌握
    JavaScript 基础，这正是本书这一部分的内容。所以，学习完这一部分后，你将具备坚实的基础，以便在需要时进入框架的使用领域。实际上，对于大多数“私人用户区”（爱好编程者这个说法并不太好！）的用途而言，使用标准的
    JavaScript（可能通过一些 GitHub 上的库增强）而不使用框架就足够了，因为虽然框架功能强大，但也带来了某种程度的“额外开销”，并且强制要求一种结构，对于较小的项目来说，这种结构并不必要。
- en: 33.4 Summary
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 33.4 总结
- en: In this chapter we have looked at functions and seen how functions are defined
    and used. In addition, we have looked at extending the scope of functions with
    external libraries and explored the question of what frameworks are and how they
    differ from “conventional” libraries.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们研究了函数，了解了函数是如何定义和使用的。此外，我们还探讨了如何通过外部库扩展函数的作用域，并探讨了框架是什么，以及它们与“传统”库的区别。
- en: 'Be sure to take the following points from this chapter:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要从本章中记住以下几点：
- en: Functions are usually defined with the keyword **function**.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数通常使用关键字**function**定义。
- en: You can take parameters (whose concrete values are called arguments when called)
    that can be given a default value.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用参数（当被调用时，具体值被称为参数值），这些参数可以设置默认值。
- en: JavaScript is very flexible about passing arguments when calling functions;
    for example, a function can be called with more or fewer arguments than it has
    parameters; accordingly, practically every parameter to a function is optional.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 在调用函数时对传递参数非常灵活；例如，函数可以使用比它的参数更多或更少的参数来调用；因此，几乎每个函数的参数都是可选的。
- en: Arguments can be passed both as position arguments, that is, based on their
    position in the order of the parameters list, and as keyword arguments, that is,
    specifying the identifier of their parameter.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数可以通过位置参数传递，即根据它们在参数列表中的位置，或者通过关键字参数传递，即指定它们参数的标识符。
- en: Functions can return values with the **return** statement (or the **return()**
    function). Functions that do not explicitly return a value return **undefined**.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以使用**return**语句（或**return()**函数）返回值。如果函数没有显式地返回值，则返回**undefined**。
- en: In JavaScript, functions are objects of the type **function**.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，函数是**function**类型的对象。
- en: They can therefore also be assigned to variables. In particular, methods can
    be defined for objects in this way; the method of a JavaScript object is ultimately
    nothing more than an attribute of the object, namely a (callable) attribute of
    type **function**.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，它们也可以被赋值给变量。特别是，方法可以通过这种方式为对象定义；JavaScript对象的方法本质上不过是对象的一个属性，即一种（可调用的）**function**类型属性。
- en: Because functions are objects, they can be passed as arguments to other functions.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于函数是对象，因此它们可以作为参数传递给其他函数。
- en: Variables defined within a function with keyword **var** are local variables
    that cease to exist as soon as the execution of the function is finished; accordingly,
    they are not visible from the main program. Function arguments are also considered
    local variables. Any global variables with the same name are “shielded” from access
    by these local variables.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内用关键字**var**定义的变量是局部变量，一旦函数执行完毕，它们就会消失；因此，它们在主程序中不可见。函数参数也被视为局部变量。任何具有相同名称的全局变量都被这些局部变量“屏蔽”，无法访问。
- en: If a variable is created within a function without using the keyword **var**,
    a global variable is created that is also visible outside the function body. If
    a global variable of this name already exists, this variable is accessed.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在函数内部创建变量时没有使用关键字**var**，则会创建一个全局变量，该变量在函数外部也可见。如果已存在同名的全局变量，则会访问该变量。
- en: Beyond JavaScript’s standard feature set, you can work with extension libraries;
    while there is no official source for these, as there is for many programming
    languages, there are platforms, such as ► [javascripting.​com](http://javascripting.com),
    where developers provide a large set of libraries for a variety of purposes.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了JavaScript的标准功能外，你还可以使用扩展库；虽然这些库没有像许多编程语言那样的官方来源，但有一些平台，例如► [javascripting.​com](http://javascripting.com)，在这些平台上，开发者提供了大量用于各种用途的库。
- en: Frameworks play a major role in practical (at least professional) JavaScript
    development because they lead to a significant reduction in workload when developing
    complex applications and allow the developer to focus on the essentials. They
    provide a wireframe in which the developer can embed his code. The framework organizes
    the flow of the application, and the developer’s code is invoked by the framework
    where necessary. Because here—unlike “normally”—the control of the application
    does not lie with the developer, but with the framework, one also speaks of an
    “inversion of control”.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架在实际（至少是专业的）JavaScript开发中起着重要作用，因为它们大大减少了开发复杂应用时的工作量，使开发者可以集中精力处理核心内容。它们提供了一个框架，开发者可以在其中嵌入自己的代码。框架组织应用的流程，在必要时调用开发者的代码。因为在这里——与“通常”不同——应用的控制权不在开发者手中，而在于框架，所以也称为“控制反转”。
- en: 33.5 Solutions to the Exercises
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 33.5 练习的解决方案
- en: 'Exercise 33.1Product = {name: ''Garden chair'', price: 24.99 };Product.dicount
    = function(discountPercent = 20) {**this**.price = **this**.price * (1-discountPercent/100);}'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '练习33.1Product = {name: ''花园椅'', price: 24.99 };Product.discount = function(discountPercent
    = 20) {**this**.price = **this**.price * (1-discountPercent/100);}'
- en: First, we create the object with its attributes **name** and **price**. We then
    add the function **discount()** to the object; more precisely, we assign a function
    object to the property **discount** that is to have the specified code. From now
    on, the function object can be called under the identifier **discount**, namely
    as the method **discount()**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个具有属性**name**和**price**的对象。然后，我们将函数**discount()**添加到该对象；更准确地说，我们将一个函数对象赋值给属性**discount**，这个属性将包含指定的代码。从此以后，可以通过标识符**discount**调用该函数对象，即作为方法**discount()**调用。
- en: Similarly, we could of course have created our **Product** object with a constructor
    function, as we saw in ► Sect. [33.1.3](#Sec4). We could then have included the
    definition of the **discount** property in the constructor and simply assigned
    the function object to **this.discount** instead of **product.discount**.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们当然也可以通过构造函数创建我们的**Product**对象，就像我们在►第33.1.3节中看到的那样。我们可以在构造函数中包含**discount**属性的定义，并直接将函数对象赋值给**this.discount**，而不是**product.discount**。
- en: Exercise 33.2**function** discount(prod, discountPercent = 20) {prod.price =
    prod.price * (1-discountPercent/100);*// return prod;*}
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 练习33.2**function** discount(prod, discountPercent = 20) {prod.price = prod.price
    * (1-discountPercent/100);*// return prod;*}
- en: This function is not a method of the **Product** object. It simply takes a **Product**
    object and adjusts its price. This is possible because in JavaScript, objects
    are passed as function arguments *by reference*, which means that we have direct
    access to the passed object with the **prod** parameter. The case would be different
    if the argument was a *primitive*, such as a number or a string. In this case,
    the argument value would be passed *by value*; changes that we would make to these
    arguments would accordingly have no effect on the variable passed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不是**Product**对象的方法。它只是接受一个**Product**对象并调整其价格。这是可能的，因为在 JavaScript 中，对象作为函数参数是*按引用传递*的，这意味着我们可以直接通过**prod**参数访问传递的对象。如果参数是*原始类型*，比如数字或字符串，情况就不同了。在这种情况下，参数值是*按值传递*的；我们对这些参数做的修改将不会影响传递的变量。
- en: Instead of using the arguments passing *by reference*, we could also return
    the modified **Product** object to the caller using a **return** statement (commented
    out in the solution suggestion above). By the way, this possibility would also
    exist if the argument was a primitive and passed *by value*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不使用*按引用传递*的方式，而是通过**return**语句将修改后的**Product**对象返回给调用者（在上面的解决方案建议中已被注释掉）。顺便提一下，如果参数是原始值并*按值传递*，这种可能性也同样存在。
- en: Exercise 33.3
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 33.3
- en: 'The function could look like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可能如下所示：
- en: '**function** arrayCreateAndSort() {**return** Array.from(arguments).sort();}'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**function** arrayCreateAndSort() {**return** Array.from(arguments).sort();}'
- en: Here we use the **arguments** object, which contains the argument values passed
    for each function. Although it is not a real array itself, it can be converted
    into an array with the function **Array.from()** and then sorted.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用**arguments**对象，它包含传递给每个函数的参数值。尽管它本身并不是一个真正的数组，但可以通过**Array.from()**函数将其转换为数组，然后进行排序。
- en: 'After that, we could call the function like this, for example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以像这样调用该函数，例如：
- en: '**>** arrayCreateAndSort(''Hello'', '', '', ''I'', ''will'', ''be'', ''a'',
    ''sorted'', ''array'')[",", "array", "be", "hello", "I", "one", "sorted", "to",
    "will"]Exercise 33.4**va**r myFunction = **function**() {console.log(''This is
    the function that is actually called.'');}**var** myFunction2 = myFunction;myFunction2();'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**>** arrayCreateAndSort(''Hello'', '', '', ''I'', ''will'', ''be'', ''a'',
    ''sorted'', ''array'')[",", "array", "be", "hello", "I", "one", "sorted", "to",
    "will"]练习 33.4**va**r myFunction = **function**() {console.log(''这是实际被调用的函数。'');}**var**
    myFunction2 = myFunction;myFunction2();'
- en: Here we first assign a function expression to the variable **myFunction**; the
    variable **myFunction** is thus an object of the type **function**. Like any other
    object, we can now assign this object to another variable, in our example to the
    variable **myFunction2**. With this variable we can call the function. As with
    every function call, the round brackets must be specified, even if the function
    does not take any parameters.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们首先将一个函数表达式赋值给变量**myFunction**；因此，变量**myFunction**是一个**function**类型的对象。像任何其他对象一样，我们现在可以将这个对象赋值给另一个变量，在我们的例子中是变量**myFunction2**。通过这个变量，我们可以调用该函数。与每个函数调用一样，即使函数不接受任何参数，也必须指定圆括号。
- en: 'Exercise 33.5Our program results in the following values of the variables:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 33.5我们的程序结果是以下变量值：
- en: '**x = 5**: **x** is initialized as a global variable with the value 5\. Within
    the function, the argument with the same name is then set to zero. However, the
    argument of the function are *local variables*. So, if we access **x** within
    the function, we do not work with the global variable **x**, but with the local
    variable of the same name, namely the argument **x** with which the function was
    called (and which ceases to exist at the end of the function body). Therefore,
    the value of the global variable remains unchanged.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**x = 5**：**x**作为全局变量被初始化为值5。在函数内部，具有相同名称的参数被设置为零。然而，函数的参数是*局部变量*。因此，如果我们在函数内部访问**x**，我们访问的并不是全局变量**x**，而是与调用函数时传入的参数**x**同名的局部变量（它在函数体结束时会消失）。因此，全局变量的值保持不变。'
- en: '**y** does not exist: The variable **y** is also a *local variable* within
    the function. It ceases to exist after the function is fully executed. Since no
    global variable of the same name exists, we can no longer access a variable with
    the identifier **y** after the execution of our function is complete.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**y**不存在：变量**y**也是函数内部的*局部变量*。当函数完全执行完毕后，它就不再存在了。由于没有同名的全局变量存在，我们在函数执行完毕后无法再访问名为**y**的变量。'
- en: '**y1 = 6**: The variable **y1** is created within the function, but without
    the keyword **var**. Therefore, when **y1 = x** is assigned, a new *global* variable
    is created that is still available after the function has finished.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**y1 = 6**：变量 **y1** 在函数内部创建，但没有使用关键字 **var**。因此，当 **y1 = x** 被赋值时，会创建一个新的
    *全局* 变量，且在函数执行完毕后该变量仍然存在。'
- en: '**y2** does not exist: Similar to **y1**, **y2** is also created within the
    function by assignment, but using the keyword **var**. Thus, the assignment does
    not create a global variable, as was the case with **y1**, but a *local* variable.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**y2** 不存在：与 **y1** 类似，**y2** 也是通过赋值在函数内部创建的，但使用了关键字 **var**。因此，这个赋值操作并不会创建一个全局变量，如同
    **y1** 的情况，而是创建了一个 *局部* 变量。'
- en: '**z = 1**: **z** is a global variable that has the value 3 when the function
    is called. Within the function, **z** is then set to the value 1\. Since the assignment
    is made without the keyword **var** (which would have created a new local variable
    with this identifier), we are therefore manipulating the *global* variable here.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**z = 1**：**z** 是一个全局变量，在函数被调用时它的值为 3。在函数内部，**z** 被赋值为 1。由于赋值操作没有使用关键字 **var**（否则会创建一个新的局部变量），因此我们实际上是在操作
    *全局* 变量。'
