- en: Chapter 12
  id: totrans-0
  prefs:
  - PREF_H1
  stylish: true
  type: TYPE_NORMAL
  zh: 第12章
- en: Dynamic Programming
  id: totrans-1
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 动态规划
- en: In the previous chapter, you learned how to write recursively and how to use
    recursion to solve some rather complex problems.
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何编写递归代码，以及如何使用递归解决一些相当复杂的问题。
- en: While recursion can certainly solve some problems, it can also create new ones
    if not used properly. In fact, recursion is often the culprit behind some of the
    slowest categories of Big O, such as `O(2^N)`.
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 虽然递归确实可以解决一些问题，但如果使用不当，它也可能带来新的问题。事实上，递归通常是导致某些最慢的大O类别（如`O(2^N)`）的罪魁祸首。
- en: The good news, though, is that many of these problems can be avoided. In this
    chapter, you’ll learn how to identify some of the most common speed traps found
    in recursive code and how to express such algorithms in terms of Big O. More important,
    you’ll learn the techniques to fix these problems.
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 不过好消息是，许多这些问题是可以避免的。在本章中，你将学习如何识别递归代码中一些最常见的性能陷阱，以及如何用大O符号表达这些算法。更重要的是，你将学习解决这些问题的技巧。
- en: 'Here’s some more good news: the techniques found in this chapter are pretty
    simple. Let’s take a look at how to use these easy but effective methods for turning
    our recursive nightmares into recursive bliss.'
  id: totrans-5
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里还有一些好消息：本章中的技巧相当简单。让我们看看如何使用这些简单但有效的方法将我们的递归噩梦变成递归的快乐。
