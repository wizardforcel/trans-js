- en: Exercises
  id: totrans-0
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 练习
- en: The following exercises provide you with the opportunity to practice with linked
    lists. The solutions to these exercises are found in the section [`Chapter 14`](f_0219.xhtml#pitting.linked.lists.against.arrays.solutions).
  id: totrans-1
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下练习为您提供了练习链表的机会。这些练习的解决方案可以在章节 [`第14章`](f_0219.xhtml#pitting.linked.lists.against.arrays.solutions)
    中找到。
- en: Add a method to the `classic LinkedList` class that prints all the values of
    the `list`.
  id: totrans-2
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 为 `classic LinkedList` 类添加一个方法，该方法打印 `list` 中的所有值。
- en: Add a method to the `DoublyLinkedList` class that prints all the values of the
    list in reverse order.
  id: totrans-3
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 为 `DoublyLinkedList` 类添加一个方法，该方法按逆序打印列表中的所有值。
- en: Add a method to the `classic LinkedList` class that returns the last value from
    the `list`. Assume you don’t know how many elements are in the `list`.
  id: totrans-4
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 为 `classic LinkedList` 类添加一个方法，该方法返回 `list` 中的最后一个值。假设您不知道 `list` 中有多少元素。
- en: Here’s a tricky one. Add a method to the `classic LinkedList` class that reverses
    the `list`; that is, if the original `list` is `A -> B -> C`, all of the `list`’s
    links should change so that `C -> B -> A`.
  id: totrans-5
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 这是一个棘手的问题。为 `classic LinkedList` 类添加一个方法，反转 `list`；也就是说，如果原始 `list` 为 `A ->
    B -> C`，则所有的 `list` 链接应更改为 `C -> B -> A`。
- en: Here’s a brilliant little linked list puzzle for you. Let’s say you have access
    to a `node` from somewhere in the middle of a `classic linked list` but not to
    the `linked list` itself; that is, you have a variable that points to an instance
    of `Node`, but you don’t have access to the `LinkedList` instance. In this situation,
    if you follow this `node`’s link, you can find all the values from this middle
    `node` until the end, but you have no way to find the nodes that precede this
    `node` in the `list`.
  id: totrans-6
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 这是一个精彩的链表难题。假设您可以访问 `classic linked list` 中某个节点，但无法访问整个 `linked list`；也就是说，您有一个指向
    `Node` 实例的变量，但无法访问 `LinkedList` 实例。在这种情况下，如果您跟随此 `node` 的链接，您可以找到从这个中间 `node`
    到末尾的所有值，但无法找到在 `list` 中该 `node` 之前的节点。
- en: Write code that will effectively delete this node from the list. The entire
    remaining list should remain complete, with only this node removed.
  id: totrans-7
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 编写代码以有效地从列表中删除此节点。剩余的整个列表应保持完整，仅删除此节点。
- en: Copyright © 2024, The Pragmatic Bookshelf.
  id: totrans-8
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 版权 © 2024, The Pragmatic Bookshelf。
