- en: '`Coercion`'
  id: totrans-0
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`强制转换`'
- en: '`Coercion` in JavaScript is the conversion of one type of value into another
    type of value.'
  id: totrans-1
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: JavaScript 中的`强制转换`是将一种类型的值转换为另一种类型的值。
- en: '[MDN defines coercion](https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion)
    as:'
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '[MDN 对强制转换的定义](https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion)是：'
- en: '`Type coercion` is the automatic or implicit conversion of values from one
    data type to another (such as strings to numbers).'
  id: totrans-3
  prefs:
  - PREF_BQ
  stylish: true
  type: TYPE_NORMAL
  zh: '`类型强制转换`是值从一种数据类型自动或隐式转换为另一种数据类型（例如字符串转换为数字）。'
- en: According to MDN’s definition, if the conversion of values is `implicit`, then
    it is `coercion`, whereas `type conversion` can either be `implicit` or `explicit`.
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 根据 MDN 的定义，如果值的转换是`隐式的`，那么这就是`强制转换`，而`类型转换`可以是`隐式`的也可以是`显式`的。
- en: 'So, if the developer expresses the intention to convert one type of value into
    another, it is just `type conversion`. The following code example is an example
    of an `explicit` type conversion:'
  id: totrans-5
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 因此，如果开发者表达了将一种类型的值转换为另一种类型的意图，那就是`类型转换`。以下代码示例是一个`显式`类型转换的例子：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And if the type conversion is `implicit`, where the developer expressed no
    intention to convert any value into another value, then it is `implicit type conversion`
    or `coercion`. The following code is an example of `coercion`:'
  id: totrans-7
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果类型转换是`隐式的`，也就是说开发者并没有表达任何将某个值转换为另一个值的意图，那么这就是`隐式类型转换`或`强制转换`。以下代码是`强制转换`的一个示例：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Whenever JavaScript sees a value of one type in a context that expects a value
    of a different type, it tries to coerce or convert the value into the expected
    type. In the above code example, `"50"` is the unexpected value type because the
    operation is subtraction. The subtraction is between numbers, not between a string
    and a number. So `"50"`, being an unexpected value, gets converted into a number,
    i.e. `50`.
  id: totrans-9
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 每当 JavaScript 在一个期望不同类型值的上下文中看到一种类型的值时，它都会尝试将该值强制转换或转换为预期类型。在上面的代码示例中，`"50"`是意外的值类型，因为操作是减法。减法是在数字之间，而不是在字符串和数字之间。因此，作为意外值的`"50"`被转换为数字，即`50`。
- en: However, some might argue that any type of conversion in a dynamically typed
    language can be considered `coercion`. Moreover, the difference between `implicit`
    and `explicit` type conversion depends on how one views `implicit` and `explicit`
    type conversion.
  id: totrans-10
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，有些人可能会争辩说，在动态类型语言中，任何类型的转换都可以被视为`强制转换`。此外，`隐式`和`显式`类型转换之间的区别取决于人们如何看待`隐式`和`显式`类型转换。
- en: Having said that, what’s important is that we understand the process of `type
    conversion` in JavaScript. The goal of this module is to help you understand how
    JavaScript converts one type of value into another and make `type conversion`
    (implicit or explicit) less scary.
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 话虽如此，重要的是我们要理解 JavaScript 中的`类型转换`过程。本模块的目标是帮助你理解 JavaScript 如何将一种类型的值转换为另一种类型，并使`类型转换`（无论是隐式还是显式）变得不那么可怕。
- en: '`Coercion` is one of those topics that many JavaScript developers generally
    misunderstand, and this is because most online resources advise staying away from
    `coercion` and presenting it as a topic that should be avoided instead of taking
    the time to understand it and take advantage of it where possible.'
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`强制转换`是许多 JavaScript 开发者普遍误解的主题，这主要是因为大多数在线资源建议远离`强制转换`，并将其呈现为一个应该避免的话题，而不是花时间去理解并在可能的情况下加以利用。'
- en: What makes `coercion` scary for many JavaScript developers, especially beginners,
    is the need for more understanding of this topic. `Coercion` is presented as a
    feature of JavaScript that is better avoided than understood.
  id: totrans-13
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让许多 JavaScript 开发者，尤其是初学者，感到`强制转换`可怕的原因在于缺乏对这一主题的理解。`强制转换`被视为 JavaScript 的一种特性，通常更应该避免而不是理解。
- en: '`Coercion` is one of the core topics of JavaScript, and its understanding is
    key to understanding JavaScript in depth. No matter how many online resources
    tell you to avoid this topic, it is unavoidable if you work with JavaScript. Instead
    of avoiding it, why not make an effort to understand it? With this in mind, in
    this module, we will take a deeper look at this topic, and hopefully, by the end
    of this module, you will have a solid understanding of `type coercion`.'
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`强制转换`是 JavaScript 的核心主题之一，其理解对深入理解 JavaScript 至关重要。无论多少在线资源告诉你要避免这个主题，只要你使用
    JavaScript，就无法避免。与其回避，不如努力去理解它。考虑到这一点，在本模块中，我们将深入探讨这一主题，希望到模块结束时，你能对`类型强制转换`有一个扎实的理解。'
- en: 强制类型转换是JavaScript的核心主题之一，其理解是深入理解JavaScript的关键。无论有多少在线资源告诉你避免这个主题，如果你使用JavaScript，这个主题是不可避免的。因此，与其避免它，不如试着去理解它？考虑到这一点，在本模块中，我们将更深入地探讨这个主题，希望到模块结束时，你能对类型强制转换有一个扎实的理解。
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 强制类型转换是JavaScript的核心主题之一，其理解是深入理解JavaScript的关键。无论有多少在线资源告诉你避免这个主题，如果你使用JavaScript，这个主题是不可避免的。因此，与其避免它，不如试着去理解它？考虑到这一点，在本模块中，我们将更深入地探讨这个主题，希望到模块结束时，你能对类型强制转换有一个扎实的理解。
- en: 要深入理解强制类型转换，我们需要了解JavaScript如何将一个值转换为另一种类型的值。我们需要理解JavaScript执行类型转换时所采取的算法或步骤。
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 要深入理解强制类型转换，我们需要了解JavaScript如何将一个值转换为另一种类型的值。我们需要理解JavaScript执行类型转换时所采取的算法或步骤。
- en: 为了深入了解强制类型转换，让我们理解以下内容：
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为了深入了解强制类型转换，让我们理解以下内容：
- en: 抽象操作
  id: totrans-18
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 抽象操作
- en: 抽象相等运算符（`==`）
  id: totrans-19
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 抽象相等运算符（`==`）
- en: 加法运算符（`+`）
  id: totrans-20
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 加法运算符（`+`）
- en: 关系运算符（`<`，`>`，`<=`，`>=`）
  id: totrans-21
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 关系运算符（`<`，`>`，`<=`，`>=`）
- en: 理解上述主题将帮助我们奠定理解JavaScript中类型转换过程的基础。因此，事不宜迟，让我们开始理解我们列表中的第一个项目，即抽象操作。
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 理解上述主题将帮助我们奠定理解JavaScript中类型转换过程的基础。因此，事不宜迟，让我们开始理解我们列表中的第一个项目，即抽象操作。
- en: ECMAScript规范记录了几种机制，JavaScript语言用于将一种类型的值转换为另一种类型的值。这些机制被称为“**抽象操作**”；抽象的意思是这些并不是可以被JavaScript代码引用或调用的真实函数；相反，它们只是语言内部用于执行类型转换的算法步骤。
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: ECMAScript规范记录了几种机制，JavaScript语言用于将一种类型的值转换为另一种类型的值。这些机制被称为“**抽象操作**”；抽象的意思是这些并不是可以被JavaScript代码引用或调用的真实函数；相反，它们只是语言内部用于执行类型转换的算法步骤。
- en: 这些抽象操作在规范中写成似乎是实际函数的样子。例如，`operationName(arg1, arg2, ...)`，但规范明确指出，抽象操作是算法而不是可以被调用的实际函数。
  id: totrans-24
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这些抽象操作在规范中写成似乎是实际函数的样子。例如，`operationName(arg1, arg2, ...)`，但规范明确指出，抽象操作是算法而不是可以被调用的实际函数。
- en: ECMAScript规范中提到了许多[抽象操作](https://262.ecma-international.org/13.0/#sec-abstract-operations)，但在处理强制转换时，以下一些常见操作也被提及：
  id: totrans-25
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: ECMAScript规范中提到了许多[抽象操作](https://262.ecma-international.org/13.0/#sec-abstract-operations)，但在处理强制转换时，以下一些常见操作也被提及：
- en: '`ToPrimitive`'
  id: totrans-26
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`ToPrimitive`'
- en: '`ToNumber`'
  id: totrans-27
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`ToNumber`'
- en: '`ToString`'
  id: totrans-28
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`ToString`'
- en: '`ToBoolean`'
  id: totrans-29
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`ToBoolean`'
- en: 尽管上述提到的抽象操作名称自我描述，但让我们理解它们是如何在类型转换中发挥作用的。
  id: totrans-30
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 尽管上述提到的抽象操作名称自我描述，但让我们理解它们是如何在类型转换中发挥作用的。
- en: '`ToPrimitive`'
  id: totrans-31
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`ToPrimitive`'
- en: '`[ToPrimitive](https://262.ecma-international.org/13.0/#sec-toprimitive)`抽象操作用于将对象转换为原始值。该操作接受两个参数：'
  id: totrans-32
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`[ToPrimitive](https://262.ecma-international.org/13.0/#sec-toprimitive)` 抽象操作用于将对象转换为原始值。该操作接受两个参数：'
- en: '`input`：一个应该被转换为原始值的对象'
  id: totrans-33
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`input`：一个应该被转换为原始值的对象'
- en: '`preferredType`：一个可选的第二个参数，指定在将对象转换为原始值时应优先考虑的类型'
  id: totrans-34
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`preferredType`：一个可选的第二个参数，指定在将对象转换为原始值时应优先考虑的类型'
- en: '`OrdinaryToPrimitive`'
  id: totrans-35
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`OrdinaryToPrimitive`'
- en: 该操作调用另一个抽象操作，称为`OrdinaryToPrimitive`，以执行实际转换，并且它还接受两个参数：
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 该操作调用另一个抽象操作，称为 `OrdinaryToPrimitive`，以执行实际转换，并且它还接受两个参数：
- en: '`O`：一个应该被转换为原始值的对象'
  id: totrans-37
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`O`：一个应该被转换为原始值的对象'
- en: '``hint``: a type that should be favored when converting an object to a primitive
    value.'
  id: totrans-38
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '``hint``：在将对象转换为原始值时应优先考虑的类型。'
- en: '``ToPrimitive`` abstract operation invokes the ``OrdinaryToPrimitive`` abstract
    operation, passing in the object, that is to be converted into a primitive value,
    as the first argument, and the second argument ``hint`` is set based on the value
    of ``preferredType`` argument as described below:'
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '``ToPrimitive`` 抽象操作调用 ``OrdinaryToPrimitive`` 抽象操作，将要转换为原始值的对象作为第一个参数传入，第二个参数
    ``hint`` 的值根据下面描述的 ``preferredType`` 参数来设定：'
- en: If the ``preferredType`` is “string”, set ``hint`` to string.
  id: totrans-40
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果 ``preferredType`` 为“string”，则将 ``hint`` 设置为字符串。
- en: If the ``preferredType`` is a “number”, set ``hint`` to the number.
  id: totrans-41
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果 ``preferredType`` 为“number”，则将 ``hint`` 设置为数字。
- en: If ``preferredType`` is not specified, set ``hint`` to the number.
  id: totrans-42
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果未指定 ``preferredType``，则将 ``hint`` 设置为数字。
- en: 'Each object in JavaScript inherits the following two methods from the object
    that sits at the top of the inheritance hierarchy, i.e., the ``Object.prototype``
    object:'
  id: totrans-43
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: JavaScript中的每个对象都从继承层次结构顶端的对象，即 ``Object.prototype`` 对象，继承以下两个方法：
- en: '``toString()``'
  id: totrans-44
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '``toString()``'
- en: '``valueOf()``'
  id: totrans-45
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '``valueOf()``'
- en: '``toString()``'
  id: totrans-46
  prefs:
  - PREF_H5
  stylish: true
  type: TYPE_NORMAL
  zh: '``toString()``'
- en: 'The ``toString`` method is used to convert an object into its string representation.
    The default behavior of the ``toString`` method is to convert objects in the following
    (not so-useful) form:'
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '``toString`` 方法用于将对象转换为其字符串表示。``toString`` 方法的默认行为是将对象转换为以下（不太有用）形式：'
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s the above code in action:'
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 下面是上述代码的实际应用：
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example1”
    />
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example1”
    />
- en: 'As the default implementation of the ``toString`` method is not useful at all,
    different objects override this method to make its output more useful. The built-in
    ``Date`` object, for example, when converted to a string, outputs a human-readable
    string representation of the date:'
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 由于 ``toString`` 方法的默认实现完全没有用，因此不同的对象会重写此方法，使其输出更有用。例如，内置的 ``Date`` 对象在转换为字符串时，会输出可读性强的日期字符串：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here’s the above code in action:'
  id: totrans-53
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 下面是上述代码的实际应用：
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example2”
    />
  id: totrans-54
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example2”
    />
- en: '``valueOf()``'
  id: totrans-55
  prefs:
  - PREF_H5
  stylish: true
  type: TYPE_NORMAL
  zh: '``valueOf()``'
- en: The ``valueOf`` method is used to convert an object into a primitive value.
    The default implementation of this method, like the ``toString`` method, is useless,
    as it just returns the object on which this method is called.
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '``valueOf`` 方法用于将对象转换为原始值。此方法的默认实现与 ``toString`` 方法类似，基本无用，因为它只返回调用该方法的对象。'
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s the above code in action:'
  id: totrans-58
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 下面是上述代码的实际应用：
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example3”
    />
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example3”
    />
- en: It is meant to be overridden by other objects. Many built-in objects override
    this method. For example, for the ``Date`` objects, this method returns the number
    of milliseconds since midnight 01 January 1, 1970 UTC.
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这意味着可以被其他对象重写。许多内置对象重写了这个方法。例如，对于``Date``对象，该方法返回自1970年1月1日00:00:00 UTC以来的毫秒数。
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here’s the above code in action:'
  id: totrans-62
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上面的代码执行效果如下：
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example4”
    />
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example4”
    />
- en: The ``OrdinaryToPrimitive`` abstract operation invokes the ``toString`` and
    the ``valueOf`` methods to convert an object into a primitive value. Among these
    two methods, in some cases, only one of them is called; in other cases, both of
    them are called.
  id: totrans-64
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '``OrdinaryToPrimitive``抽象操作调用``toString``和``valueOf``方法将对象转换为原始值。在这两种方法中，在某些情况下，仅调用其中一种；在其他情况下，都会调用它们。'
- en: The ``hint`` argument received by the ``OrdinaryToPrimitive`` abstract operation
    determines which of these two methods is called first.
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '``hint``参数由``OrdinaryToPrimitive``抽象操作接收，决定先调用这两种方法中的哪一种。'
- en: Prefer string.
  id: totrans-66
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 优先选择字符串。
- en: If the ``hint`` argument is “string”, then the ``OrdinaryToPrimitive`` abstract
    operation first invokes the ``toString`` method on the object. If the ``toString``
    method returns a primitive value, ``even if that primitive value is not of the
    string type``, then that primitive value is used as a primitive representation
    of the object.
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果``hint``参数是“string”，那么``OrdinaryToPrimitive``抽象操作会首先调用对象上的``toString``方法。如果``toString``方法返回原始值，``即使该原始值不是字符串类型``，那么该原始值将被用作对象的原始表示。
- en: If the `toString` method doesn’t exist or doesn’t return a primitive value,
    then the `valueOf` method is invoked. If the `valueOf` method returns a primitive
    value, then that value is used; otherwise, a `TypeError` is thrown, indicating
    that the object couldn’t be converted to a primitive value.
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果`toString`方法不存在或未返回原始值，则调用`valueOf`方法。如果`valueOf`方法返回原始值，则使用该值；否则，抛出`TypeError`，表示对象无法转换为原始值。
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s the above code in action:'
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上面的代码执行效果如下：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example5”
    />`'
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example5”
    />`'
- en: In the above code example, we have an object containing overridden implementations
    of the `toString` and the `valueOf` method. At the end of the code example, we
    are trying to log `obj`, embedded in a [template literal](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals),
    to the console. In this case, the `obj` will be converted into a string.
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上面的代码示例中，我们有一个包含重写的`toString`和`valueOf`方法的对象。在代码示例的末尾，我们尝试将`obj`记录在一个嵌入的[模板字面量](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)中输出到控制台。在这种情况下，`obj`将被转换为字符串。
- en: As discussed above, when the `hint` argument of the `OrdinaryToPrimitive` abstract
    operation is “string”, the `toString` method is invoked to convert an object into
    a primitive value, preferably into a value of string type.
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如上所述，当`OrdinaryToPrimitive`抽象操作的`hint`参数为“string”时，会调用`toString`方法将对象转换为原始值，优先转换为字符串类型的值。
- en: As the `toString` implementation of the `obj` object is returning a string primitive
    value, the `valueOf` method is not invoked, and the object-to-primitive conversion
    process for the `obj` object is complete at this point. The primitive value returned
    by the `toString` method of the `obj` object is used by the template literal.
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 由于`obj`对象的`toString`实现返回的是字符串原始值，因此`valueOf`方法未被调用，`obj`对象的对象到原始值的转换过程在此时完成。`obj`对象的`toString`方法返回的原始值被模板字面量使用。
- en: 'But it was mentioned above that the value returned by the `toString` method
    can be of non-string primitive type. The following code example verifies this
    claim:'
  id: totrans-75
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 但是上面提到过，`toString`方法返回的值可以是非字符串原始类型。以下代码示例验证了这一说法：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here’s the above code in action:'
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上面的代码执行效果如下：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example6”
    />`'
  id: totrans-78
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example6”
    />`'
- en: The `toString` method in the above code example returns a boolean (non-string)
    primitive value. Instead of invoking the `valueOf` method or converting the non-string
    return value of the `toString` method into a string value, the boolean value is
    accepted as the primitive representation of the `obj` object.
  id: totrans-79
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上述代码示例中的`toString`方法返回一个布尔（非字符串）原始值。与调用`valueOf`方法或将`toString`方法的非字符串返回值转换为字符串值不同，布尔值被接受为`obj`对象的原始表示。
- en: 'The next case we need to verify is what happens if the `toString` method doesn’t
    return a primitive value. The following code example demonstrates this case:'
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们需要验证的下一个案例是，如果`toString`方法没有返回原始值会发生什么。以下代码示例演示了这种情况：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here’s the above code in action:'
  id: totrans-82
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是上述代码的实际运行：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example7”
    />`'
  id: totrans-83
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example7”
    />`'
- en: As explained earlier, if the `toString` method doesn’t return a primitive value,
    the `valueOf` method will be invoked to get a primitive representation of the
    object. In the code example above, the `toString` method returns an empty array
    of an object type; as a result, the `valueOf` method is invoked.
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如前所述，如果`toString`方法没有返回原始值，则会调用`valueOf`方法以获取对象的原始表示。在上面的代码示例中，`toString`方法返回一个空的对象类型数组；因此，调用了`valueOf`方法。
- en: 'The `valueOf` method is invoked even if the `toString` is not defined for an
    object. The following code example shows this behavior:'
  id: totrans-85
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 即使对象没有定义`toString`，也会调用`valueOf`方法。以下代码示例展示了这种行为：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s the above code in action:'
  id: totrans-87
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是上述代码的实际运行：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example8”
    />`'
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example8”
    />`'
- en: The last case we need to verify is what happens when JavaScript can’t get a
    primitive value, even after invoking the `toString` and the `valueOf` method.
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们需要验证的最后一个案例是，当JavaScript在调用`toString`和`valueOf`方法后仍无法获取原始值时会发生什么。
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s the above code in action:'
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是上述代码的实际运行：
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/abstract-operations-example9"
    />`'
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/abstract-operations-example9"
    />`'
- en: 当JavaScript在调用了两个方法后仍无法获取原始值时，会抛出`TypeError`，指示对象无法转换为原始值。因此，重要的是要记住在重写这些方法时，至少其中一个方法应返回一个原始值。
  id: totrans-93
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当JavaScript在调用了两个方法后仍无法获取原始值时，会抛出`TypeError`，指示对象无法转换为原始值。因此，重要的是要记住在重写这些方法时，至少其中一个方法应返回一个原始值。
- en: 我们已经讨论了当首选类型为字符串时在对象到原始值转换过程中的情况。接下来，让我们讨论当首选类型为数字时会发生什么。
  id: totrans-94
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们已经讨论了当首选类型为字符串时在对象到原始值转换过程中的情况。接下来，让我们讨论当首选类型为数字时会发生什么。
- en: 优先考虑数字
  id: totrans-95
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 优先考虑数字
- en: 如果提示参数为“number”，那么`OrdinaryToPrimitive`抽象操作会首先调用`valueOf`方法，然后在需要时调用`toString`方法。
  id: totrans-96
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果提示参数为“number”，那么`OrdinaryToPrimitive`抽象操作会首先调用`valueOf`方法，然后在需要时调用`toString`方法。
- en: 这类似于上面讨论的“优先考虑字符串”案例，不同之处在于调用`valueOf`和`toString`方法的顺序是相反的。
  id: totrans-97
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这类似于上面讨论的“优先考虑字符串”案例，不同之处在于调用`valueOf`和`toString`方法的顺序是相反的。
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 下面是上述代码的实际运行：
  id: totrans-99
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 下面是上述代码的实际运行：
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/abstract-operations-example10"
    />`'
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/abstract-operations-example10"
    />`'
- en: 上面的代码示例与上面部分中显示的示例相同，除了我们不是将`obj`嵌入模板字面量并记录到控制台，而是将1加到`obj`。我们将`obj`视为数字。
  id: totrans-101
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上面的代码示例与上面部分中显示的示例相同，除了我们不是将`obj`嵌入模板字面量并记录到控制台，而是将1加到`obj`。我们将`obj`视为数字。
- en: 因此，当JavaScript在期望数字的上下文中获取对象时，它会尝试将对象强制转换为原始类型，优先转换为数字类型。
  id: totrans-102
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 因此，当JavaScript在期望数字的上下文中获取对象时，它会尝试将对象强制转换为原始类型，优先转换为数字类型。
- en: 在这种情况下，传递给`OrdinaryToPrimitive`抽象操作的`hint`参数是“number”；因此，首先调用`valueOf`方法。由于它返回了一个原始值，因此无需调用`toString`方法。
  id: totrans-103
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这种情况下，传递给`OrdinaryToPrimitive`抽象操作的`hint`参数是“number”；因此，首先调用`valueOf`方法。由于它返回了一个原始值，因此无需调用`toString`方法。
- en: 剩下的情况与“优先考虑字符串”部分中讨论的相同。唯一的区别是，当首选类型为“number”时，首先调用`valueOf`方法。
  id: totrans-104
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 剩下的情况与“优先考虑字符串”部分中讨论的相同。唯一的区别是，当首选类型为“number”时，首先调用`valueOf`方法。
- en: 如果`valueOf`方法返回布尔值，会发生什么？这是一个原始值。它不是数字，但仍然是一个原始值。因此，JavaScript应该将其视为`obj`对象的原始表示，对吗？
  id: totrans-105
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果`valueOf`方法返回布尔值，会发生什么？这是一个原始值。它不是数字，但仍然是一个原始值。因此，JavaScript应该将其视为`obj`对象的原始表示，对吗？
- en: 考虑以下代码示例：
  id: totrans-106
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 考虑以下代码示例：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 下面是上述代码的实际运行：
  id: totrans-108
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 下面是上述代码的实际运行：
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/abstract-operations-example11"
    />`'
  id: totrans-109
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/abstract-operations-example11"
    />`'
- en: 我们为什么会得到2作为输出？答案是`true`被视为`obj`对象的原始表示，但我们无法将`true`与`1`相加。JavaScript在这个上下文中期望的是一个数字。因此，它会尝试将`true`强制转换为期望的值类型，在这种情况下为`1`。如果`valueOf`方法返回`false`，它将被强制转换为`0`。
  id: totrans-110
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们为什么会得到2作为输出？答案是`true`被视为`obj`对象的原始表示，但我们无法将`true`与`1`相加。JavaScript在这个上下文中期望的是一个数字。因此，它会尝试将`true`强制转换为期望的值类型，在这种情况下为`1`。如果`valueOf`方法返回`false`，它将被强制转换为`0`。
- en: 无偏好
  id: totrans-111
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 无偏好
- en: 当调用`ToPrimitive`抽象操作而没有指定首选类型或提示，或者如果提示被设置为“default”，那么该操作通常表现得好像提示是“number”。因此，默认情况下，`ToPrimitive`更倾向于转换为数字类型。
  id: totrans-112
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当调用`ToPrimitive`抽象操作而没有指定首选类型或提示，或者如果提示被设置为“default”，那么该操作通常表现得好像提示是“number”。因此，默认情况下，`ToPrimitive`更倾向于转换为数字类型。
- en: 然而，对象可以通过实现[`Symbol.toPrimitive`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)函数来覆盖这种默认的`ToPrimitive`行为。该函数接受一个首选类型作为参数，并返回对象的原始表示。
  id: totrans-113
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，对象可以通过实现[`Symbol.toPrimitive`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)函数来覆盖这种默认的`ToPrimitive`行为。该函数接受一个首选类型作为参数，并返回对象的原始表示。
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 以上代码的实际效果如下：
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以上代码的实际效果如下：
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example12”
    />
  id: totrans-116
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example12”
    />
- en: 在内置对象中，只有`Date`和`Symbol`对象覆盖了`ToPrimitive`抽象操作的默认行为。`Date`对象将默认行为实现为首选类型或提示为“string”时的效果。
  id: totrans-117
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在内置对象中，只有`Date`和`Symbol`对象覆盖了`ToPrimitive`抽象操作的默认行为。`Date`对象将默认行为实现为首选类型或提示为“string”时的效果。
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 以上代码的实际效果如下：
  id: totrans-119
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以上代码的实际效果如下：
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example13”
    />
  id: totrans-120
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example13”
    />
- en: :::note
  id: totrans-121
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: :::note
- en: 我们很少需要显式调用`Symbol.toPrimitive`函数。JavaScript在需要将对象转换为原始值时会自动调用此函数。
  id: totrans-122
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们很少需要显式调用`Symbol.toPrimitive`函数。JavaScript在需要将对象转换为原始值时会自动调用此函数。
- en: ':::'
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: ':::'
- en: '`ToPrimitive`抽象操作在下面的图像中进行了总结：'
  id: totrans-124
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`ToPrimitive`抽象操作在下面的图像中进行了总结：'
- en: '![Object to primitive conversion summarized](images/module_04----lesson_04.03----public----assets----ToPrimitive.png)'
  id: totrans-125
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![对象到原始值转换总结](images/module_04----lesson_04.03----public----assets----ToPrimitive.png)'
- en: 对象到原始值转换的总结
  id: totrans-126
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 对象到原始值转换的总结
- en: '`ToNumber`'
  id: totrans-127
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`ToNumber`'
- en: '[`ToNumber`](https://262.ecma-international.org/13.0/#sec-tonumber)抽象操作在JavaScript需要将任何非数字值转换为数字时使用。'
  id: totrans-128
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '[`ToNumber`](https://262.ecma-international.org/13.0/#sec-tonumber)抽象操作在JavaScript需要将任何非数字值转换为数字时使用。'
- en: 以下表格显示了此抽象操作应用于一些非数字值的结果：
  id: totrans-129
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下表格显示了此抽象操作应用于一些非数字值的结果：
- en: '| Value | ToNumber(value) |'
  id: totrans-130
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| 值 | ToNumber(value) |'
- en: '| --- | --- |'
  id: totrans-131
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ”” | 0 |'
  id: totrans-132
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ”” | 0 |'
- en: '| “0” | 0 |'
  id: totrans-133
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| “0” | 0 |'
- en: '| “-0” | -0 |'
  id: totrans-134
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| “-0” | -0 |'
- en: '| ” 123 “ | 123 |'
  id: totrans-135
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| ” 123 “ | 123 |'
- en: '| “45” | 45 |'
  id: totrans-136
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| “45” | 45 |'
- en: '| “abc” | NaN |'
  id: totrans-137
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| “abc” | NaN |'
- en: '| false | 0 |'
  id: totrans-138
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| false | 0 |'
- en: '| true | 1 |'
  id: totrans-139
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| true | 1 |'
- en: '| undefined | NaN |'
  id: totrans-140
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| undefined | NaN |'
- en: '| null | 0 |'
  id: totrans-141
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| null | 0 |'
- en: 就对象而言，`ToNumber`抽象操作首先使用`ToPrimitive`抽象操作将对象转换为原始值，首选类型为“number”，然后将结果值转换为数字。
  id: totrans-142
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 就对象而言，`ToNumber`抽象操作首先使用`ToPrimitive`抽象操作将对象转换为原始值，首选类型为“number”，然后将结果值转换为数字。
- en: '[`BigInt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)值允许*显式*转换为数字类型，但*隐式*转换是不允许的；隐式转换会抛出`TypeError`。'
  id: totrans-143
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '[`BigInt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)值允许*显式*转换为数字类型，但*隐式*转换是不允许的；隐式转换会抛出`TypeError`。'
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 以上代码的实际效果如下：
  id: totrans-145
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以上代码的实际效果如下：
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example14”
    />
  id: totrans-146
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example14”
    />
- en: '`ToString`'
  id: totrans-147
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`ToString`'
- en: '[`ToString`](https://262.ecma-international.org/13.0/#sec-tostring)抽象操作用于将任何值转换为字符串。'
  id: totrans-148
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '[`ToString`](https://262.ecma-international.org/13.0/#sec-tostring)抽象操作用于将任何值转换为字符串。'
- en: 以下表格显示了此抽象操作应用于一些非字符串值的结果：
  id: totrans-149
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下表格显示了此抽象操作应用于一些非字符串值的结果：
- en: '| Value | ToNumber(value) |'
  id: totrans-150
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| 值 | ToNumber(value) |'
- en: '| --- | --- |'
  id: totrans-151
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| null | “null” |'
  id: totrans-152
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| null | “null” |'
- en: '| undefined | “undefined” |'
  id: totrans-153
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| undefined | “undefined” |'
- en: '| 0 | “0” |'
  id: totrans-154
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| 0 | “0” |'
- en: '| -0 | “0” |'
  id: totrans-155
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| -0 | “0” |'
- en: '| true | “true” |'
  id: totrans-156
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| true | “true” |'
- en: '| false | “false” |'
  id: totrans-157
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| false | “false” |'
- en: '| 123 | “123” |'
  id: totrans-158
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| 123 | “123” |'
- en: '| NaN | “NaN” |'
  id: totrans-159
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| NaN | “NaN” |'
- en: 在对象的情况下，`ToString`抽象操作首先使用`ToPrimitive`抽象操作将对象转换为原始值，首选类型为“string”，然后将结果值转换为字符串。
  id: totrans-160
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在对象的情况下，`ToString`抽象操作首先使用`ToPrimitive`抽象操作将对象转换为原始值，首选类型为“string”，然后将结果值转换为字符串。
- en: '`ToBoolean`'
  id: totrans-161
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`ToBoolean`'
- en: The [ToBoolean](https://262.ecma-international.org/13.0/#sec-toboolean) abstract
    operation is used to convert a value into a boolean value.
  id: totrans-162
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '[ToBoolean](https://262.ecma-international.org/13.0/#sec-toboolean)抽象操作用于将值转换为布尔值。'
- en: Unlike the above-mentioned abstract operations, this operation is simply a lookup
    of whether a value is a [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)
    value. If it is, we get `false` as a return value; for all other values, this
    operation returns `true`.
  id: totrans-163
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与上述抽象操作不同，此操作仅仅是检查一个值是否为[falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)值。如果是，我们返回`false`；对于所有其他值，此操作返回`true`。
- en: 'The following is a list of falsy values:'
  id: totrans-164
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下是虚假值的列表：
- en: '`false`'
  id: totrans-165
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`0`, `-0`, `0n`'
  id: totrans-166
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`0`, `-0`, `0n`'
- en: '`undefined`'
  id: totrans-167
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`undefined`'
- en: '`null`'
  id: totrans-168
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`null`'
- en: '`NaN`'
  id: totrans-169
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`NaN`'
- en: '`""`'
  id: totrans-170
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`""`'
- en: As mentioned earlier, there are many [abstract operations](https://262.ecma-international.org/13.0/#sec-abstract-operations)
    mentioned in the ECMAScript specification that are used for type conversion; in
    this lesson, we have only discussed the common ones.
  id: totrans-171
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 正如前面提到的，ECMAScript规范中提到了许多用于类型转换的[抽象操作](https://262.ecma-international.org/13.0/#sec-abstract-operations)；在本课中，我们只讨论了常见的操作。
- en: Further reading
  id: totrans-172
  prefs:
  - PREF_H5
  stylish: true
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[Number coercion - (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number#number_coercion)'
  id: totrans-173
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[数字强制转换 - (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number#number_coercion)'
- en: '[String coercion - (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#string_coercion)'
  id: totrans-174
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[字符串强制转换 - (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#string_coercion)'
- en: '[Boolean coercion - (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean#boolean_coercion)'
  id: totrans-175
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[布尔强制转换 - (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean#boolean_coercion)'
- en: '[Coercing values - (You Don’t Know JS Yet )](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/types-grammar/ch4.md)'
  id: totrans-176
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[强制转换值 - (你还不知道的 JS)](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/types-grammar/ch4.md)'
- en: Let’s discuss the infamous `double equal` operator that is used for `loosely`
    comparing two values. It is also known as the `abstract equality` operator.
  id: totrans-177
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们讨论臭名昭著的`双等号`运算符，它用于`松散`比较两个值。它也被称为`抽象相等`运算符。
- en: This operator is infamous because many resources online, and JavaScript developers,
    in general, discourage its use because of its coercive behavior. Instead of blindly
    ignoring the `double equality` operator, we should try to understand how it behaves,
    and then we can decide for ourselves whether we want to not use it at all in our
    code or use it where it is safe to use.
  id: totrans-178
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这个运算符臭名昭著，因为许多在线资源以及一般的JavaScript开发者都不鼓励使用它，原因在于其强制类型转换行为。我们不应该盲目忽视`双等于`运算符，而是应该尝试理解它的行为，然后我们可以自行决定是否在我们的代码中完全不使用它，或者在安全的情况下使用它。
- en: Despite what you hear about this operator, it behaves according to some predefined
    algorithmic steps, and if we understand how it works, this operator won’t scare
    us, and we might even prefer this operator in some cases over its cousin, the
    strict equality operator (`===`).
  id: totrans-179
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 尽管你听说过这个运算符的种种，但它的行为遵循一些预定义的算法步骤，如果我们理解它的工作原理，这个运算符就不会让我们感到恐惧，在某些情况下，我们甚至可能更喜欢这个运算符而非它的“表亲”严格相等运算符（`===`）。
- en: When two values are compared using the `double equals` operator, the steps taken
    by JavaScript to compare the two values are described by an abstract operation
    known as [IsLooselyEqual](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-islooselyequal).
  id: totrans-180
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当使用`双等于`运算符比较两个值时，JavaScript进行比较的步骤由一种称为[IsLooselyEqual](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-islooselyequal)的抽象操作描述。
- en: Summary of abstract equality operator
  id: totrans-181
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 抽象相等运算符总结
- en: 'The working of the `double equals` operator is roughly summarized in the steps
    below:'
  id: totrans-182
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`双等于`运算符的工作过程大致总结如下：'
- en: If the values being compared are of the same type, then perform the [strict
    equality comparison](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-isstrictlyequal).
  id: totrans-183
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果比较的值是同一类型，则执行[严格相等比较](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-isstrictlyequal)。
- en: If one value is `undefined` or `null` and the other value is also `undefined`
    or `null`, return true.
  id: totrans-184
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果一个值是`undefined`或`null`，而另一个值也为`undefined`或`null`，则返回真。
- en: If one or both values are objects, they are converted into primitive types,
    preferring the number type.
  id: totrans-185
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果一个或两个值是对象，则将它们转换为原始类型，优先考虑数字类型。
- en: If both values are primitives but are of different types, convert the types
    until they match, preferring the number type for coercing values.
  id: totrans-186
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果两个值都是原始类型但类型不同，则转换类型直到匹配，优先考虑数字类型进行强制转换。
- en: Delegating to strict equality comparison
  id: totrans-187
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 委托给严格相等比较
- en: Think about the first point mentioned above. If the types of values being compared
    using this operator are the same, under the hood, the two values get compared
    using the triple equals or the strict equality operator. So, if we know that only
    the same type of values will get compared in some piece of code, it doesn’t make
    any difference whether we use the double equals or the triple equals operator;
    in this case, we will always have the strict equality operator.
  id: totrans-188
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 想想上面提到的第一点。如果使用该运算符比较的值类型相同，那么在底层，这两个值将使用三重等于或严格相等运算符进行比较。因此，如果我们知道在某段代码中只会比较相同类型的值，那么使用双等于或三重等于运算符没有区别；在这种情况下，我们将始终使用严格相等运算符。
- en: '`null` vs `undefined`'
  id: totrans-189
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`null` 与 `undefined`'
- en: The second point is also worth pondering over. Unlike the strict equality operator,
    the abstract or loose equality operator considers `null == undefined` comparison
    to be true.
  id: totrans-190
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第二点也值得深思。与严格相等运算符不同，抽象或宽松相等运算符认为`null == undefined`的比较为真。
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can see the code above in action below:'
  id: totrans-192
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面看到上面的代码的实际运行：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-equality-operator-example1”
    />`'
  id: totrans-193
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/abstract-equality-operator-example1"
    />`'
- en: The fact that `null` and `undefined` are equal to each other according to the
    abstract equality operator makes for an interesting use case of the abstract equality
    operator. When writing JavaScript code, it is common to check if a value is neither
    `null` nor `undefined`.
  id: totrans-194
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 根据抽象相等运算符，`null`和`undefined`彼此相等，这为抽象相等运算符提供了一个有趣的用例。在编写JavaScript代码时，常常需要检查一个值既不是`null`也不是`undefined`。
- en: 'With the strict equality operator, we will have a check that looks something
    like the following:'
  id: totrans-195
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用严格相等运算符时，我们会有一个类似于以下的检查：
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Whereas with the abstract equality operator, we can shorten this check to just
    one condition:'
  id: totrans-197
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 而使用抽象相等运算符时，我们可以将此检查简化为一个条件：
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Considering how often we need to guard against `null` and `undefined` in our
    JavaScript code, I feel the abstract equality operator is ideal for this case.
    Having said that, you won’t be wrong if you use the strict equality operator in
    this case.
  id: totrans-199
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 考虑到我们在JavaScript代码中多么频繁地需要防止`null`和`undefined`，我觉得抽象相等运算符在这种情况下是理想的。尽管如此，如果你在这种情况下使用严格相等运算符也不会错。
- en: “if” conditions
  id: totrans-200
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: “if”条件
- en: 'Although the coercive behavior of the abstract equality operator is predictable,
    as explained above, people often fall into a trap because of how they use this
    operator in the `if` statement conditions. Consider the following code example:'
  id: totrans-201
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 尽管抽象相等运算符的强制行为是可预测的，但正如上面所解释的，人们常常因为如何在`if`语句条件中使用该运算符而陷入陷阱。考虑以下代码示例：
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can see the code above in action below:'
  id: totrans-203
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面看到上面的代码在实际中的效果：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-equality-operator-example4”
    />`'
  id: totrans-204
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/abstract-equality-operator-example4"
    />`'
- en: We know from an earlier lesson that objects are [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)
    values. So, in the above code example, it seems reasonable to assume that the
    `if` condition would be evaluated as `true`, leading to the execution of the `if`
    block. But, if you execute the above code, you might be surprised to know that
    instead of the `if` block, the `else` would execute because the `someVal == true`
    check would evaluate to `false`.
  id: totrans-205
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们从之前的课程中知道，对象是[真值](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)值。因此，在上述代码示例中，假设`if`条件会被评估为`true`似乎是合理的，这将导致执行`if`块。但是，如果你执行上述代码，你可能会惊讶地发现，执行的是`else`，因为`someVal
    == true`检查会评估为`false`。
- en: 'If either operand of the abstract equality operator is a boolean value, it
    is first converted to a number - `false` into `0` and `true` into `1`. So the
    `if` condition in the above code example would be evaluated as follows:'
  id: totrans-206
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果抽象相等运算符的任一操作数是布尔值，它会首先被转换为数字——`false`变为`0`，`true`变为`1`。因此，上述代码示例中的`if`条件将被评估如下：
- en: 'One operand is an object, and the other one is a boolean, so according to `step
    10` of the [isLooselyEqual](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-islooselyequal)
    abstract operation, if one operand is a boolean value, convert it into a number
    using the `ToNumber` abstract operation. So our condition would become:'
  id: totrans-207
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 一个操作数是对象，另一个是布尔值，因此根据[isLooselyEqual](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-islooselyequal)抽象操作的**第10步**，如果一个操作数是布尔值，则使用`ToNumber`抽象操作将其转换为数字。所以我们的条件将变为：
- en: '[PRE20]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 在将布尔值转换为数字后，我们有一个对象与数字之间的比较。根据`isLooselyEqual`抽象操作的**第12步**，对象`someVal`将使用`ToPrimitive`抽象操作转换为原始值，优先类型为“数字”。对象字面量的默认原始表示为`"[object
    Object]"`，因此经过强制转换后的条件将变为：`js "[object Object]" == 1;`
  id: totrans-209
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 在将布尔值转换为数字后，我们有一个对象与数字之间的比较。根据`isLooselyEqual`抽象操作的**第12步**，对象`someVal`将使用`ToPrimitive`抽象操作转换为原始值，优先类型为“数字”。对象字面量的默认原始表示为`"[object
    Object]"`，因此经过强制转换后的条件将变为：`js "[object Object]" == 1;`
- en: 现在，我们有一个字符串与数字之间的比较。根据`isLooselyEqual`抽象操作的**第6步**，如果一个操作数是字符串，另一个是数字，则将字符串转换为数字。将`"[object
    Object]"`转换为数字将给我们`[NaN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN)`。所以我们的条件将变为：
  id: totrans-210
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 现在，我们有一个字符串与数字之间的比较。根据`isLooselyEqual`抽象操作的**第6步**，如果一个操作数是字符串，另一个是数字，则将字符串转换为数字。将`"[object
    Object]"`转换为数字将给我们`[NaN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN)`。所以我们的条件将变为：
- en: '[PRE21]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 在进行三次强制转换后，我们有一个`NaN`值与一个数字之间的比较。它们彼此不相等。(`NaN`值与任何其他值（包括它自身）都不相等。)因此我们的条件未能评估为`true`。
  id: totrans-212
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 在进行三次强制转换后，我们有一个`NaN`值与一个数字之间的比较。它们彼此不相等。（`NaN`值与任何其他值（包括它自身）都不相等。）因此我们的条件未能评估为`true`。
- en: 上述讨论的目的在于理解，使用抽象相等运算符检查一个值是`true`还是`false`并不总是如预期那样有效。在这种情况下，很容易指责抽象相等运算符。但事实是，编写这种代码的人需要帮助，以理解或记住抽象相等运算符的工作原理。
  id: totrans-213
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上述讨论的目的在于理解，使用抽象相等运算符检查一个值是`true`还是`false`并不总是如预期那样有效。在这种情况下，很容易指责抽象相等运算符。但事实是，编写这种代码的人需要帮助，以理解或记住抽象相等运算符的工作原理。
- en: 在这种情况下，如果我们想要检查一个值是真值还是假值，不需要使用抽象相等运算符，利用`if`语句的强制行为就足够了。我所说的是，上述代码中的`if`条件应该写为：
  id: totrans-214
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们想要检查一个值是真值还是假值，不需要使用抽象相等运算符，利用`if`语句的强制行为就足够了。我所说的是，上述代码中的`if`条件应该写为：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 在上述条件下，我们将获得预期结果，因为`someVal`会被检查是否为真值；如果是，条件将评估为真，从而执行`if`块。
  id: totrans-216
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上述条件下，我们将获得预期结果，因为`someVal`会被检查是否为真值；如果是，条件将评估为真，从而执行`if`块。
- en: 所以，作为建议，避免进行如`someVal == true`的检查，其中一个操作数是布尔值。在这种情况下，利用`if`语句的隐式强制特性将检查值是否有效。
  id: totrans-217
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 所以，作为建议，避免进行如`someVal == true`的检查，其中一个操作数是布尔值。在这种情况下，利用`if`语句的隐式强制特性将检查值是否有效。
- en: 深入阅读
  id: totrans-218
  prefs:
  - PREF_H5
  stylish: true
  type: TYPE_NORMAL
  zh: 深入阅读
- en: '[布尔陷阱 - 你还不知道JS](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/types-grammar/ch4.md#-boolean-gotcha)'
  id: totrans-219
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[布尔陷阱 - 你还不知道JS](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/types-grammar/ch4.md#-boolean-gotcha)'
- en: '[“if”语句的运行时语义（ECMAScript规范）](https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-if-statement)'
  id: totrans-220
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[“if”语句的运行时语义（ECMAScript规范）](https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-if-statement)'
- en: 加法运算符
  id: totrans-221
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 加法运算符
- en: 加法运算符可以用来对两个数字进行加法运算，也可以用来连接两个字符串，这被称为字符串连接。
  id: totrans-222
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 加法运算符可以用来对两个数字进行加法运算，也可以用来连接两个字符串，这被称为字符串连接。
- en: 该运算符的工作原理基于[ApplyStringOrNumericBinaryOperator](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-applystringornumericbinaryoperator)。其工作方式是，如果任一或两个操作数是非原始值，则使用`ToPrimitive`抽象操作将它们转换为原始值，并且未指定首选类型。因此，“number”在这种情况下是首选类型，因为这是`ToPrimitive`抽象操作的默认行为。
  id: totrans-223
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 该运算符的工作原理基于[ApplyStringOrNumericBinaryOperator](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-applystringornumericbinaryoperator)。其工作方式是，如果任一或两个操作数是非原始值，则使用`ToPrimitive`抽象操作将它们转换为原始值，并且未指定首选类型。因此，“number”在这种情况下是首选类型，因为这是`ToPrimitive`抽象操作的默认行为。
- en: 在检查非原始操作数并将它们（如果有的话）强制转换为原始值后，下一步是检查一个或两个操作数是否为字符串。如果是这种情况，则将非字符串操作数（如果有的话）强制转换为字符串，并执行字符串连接。
  id: totrans-224
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在检查非原始操作数并将它们（如果有的话）强制转换为原始值后，下一步是检查一个或两个操作数是否为字符串。如果是这种情况，则将非字符串操作数（如果有的话）强制转换为字符串，并执行字符串连接。
- en: 如果两个操作数都不是字符串，则在将非数字操作数强制转换为数字后执行加法。
  id: totrans-225
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果两个操作数都不是字符串，则在将非数字操作数强制转换为数字后执行加法。
- en: 关系运算符
  id: totrans-226
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 关系运算符
- en: 关系运算符（`<`，`>`，`<=`，`>=`）用于比较字符串和数字。在关系运算符的情况下调用的抽象操作是[IsLessThan](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-islessthan)抽象操作。尽管其名称如此，但该操作也处理“<=”、“>”和“>=”比较。
  id: totrans-227
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 关系运算符（`<`，`>`，`<=`，`>=`）用于比较字符串和数字。在关系运算符的情况下调用的抽象操作是[IsLessThan](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-islessthan)抽象操作。尽管其名称如此，但该操作也处理“<=”、“>”和“>=”比较。
- en: 如果任一操作数是对象，则将其转换为原始值，首选类型为“number”。如果两个操作数都是字符串，则使用它们的Unicode码点进行比较。如果不是字符串，则操作数通常会转换为数字，然后进行比较。
  id: totrans-228
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果任一操作数是对象，则将其转换为原始值，首选类型为“number”。如果两个操作数都是字符串，则使用它们的Unicode码点进行比较。如果不是字符串，则操作数通常会转换为数字，然后进行比较。
- en: 我们还可以使用关系运算符比较`Date`对象。请记住，当使用`ToPrimitive`操作将`Date`对象转换为原始值时，它们会被转换为字符串，但在关系运算符的情况下，`Date`对象在转换为原始值时会以数字表示，因为在关系运算符的情况下，`ToPrimitive`抽象操作被传递了“number”作为首选类型。
  id: totrans-229
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们还可以使用关系运算符比较`Date`对象。请记住，当使用`ToPrimitive`操作将`Date`对象转换为原始值时，它们会被转换为字符串，但在关系运算符的情况下，`Date`对象在转换为原始值时会以数字表示，因为在关系运算符的情况下，`ToPrimitive`抽象操作被传递了“number”作为首选类型。
- en: '[PRE23]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 这是上述代码的实际效果的Replit：
  id: totrans-231
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是上述代码的实际效果的Replit：
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/relational-operators-example1"
    />`'
  id: totrans-232
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/relational-operators-example1"
    />`'
- en: 现在我们已经更深入地了解了强制转换以及一些常见抽象操作如何工作以使强制转换生效，让我们测试一下我们在本模块中所学到的知识。以下练习将使我们巩固对强制转换主题的理解。
  id: totrans-233
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在我们已经更深入地了解了强制转换以及一些常见抽象操作如何工作以使强制转换生效，让我们测试一下我们在本模块中所学到的知识。以下练习将使我们巩固对强制转换主题的理解。
- en: 以下是一些涉及强制转换的表达式。根据您在本模块中获得的知识，尝试猜测输出。如果您不理解所有内容，请不要担心。它们的解释也在下面提供。您显然可以参考规范以及本模块中的早期课程，以理解和猜测下面表达式的输出。
  id: totrans-234
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下是一些涉及强制转换的表达式。根据您在本模块中获得的知识，尝试猜测输出。如果您不理解所有内容，请不要担心。它们的解释也在下面提供。您显然可以参考规范以及本模块中的早期课程，以理解和猜测下面表达式的输出。
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 下面是对上述每个表达式输出的解释。
  id: totrans-236
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 下面是对上述每个表达式输出的解释。
- en: '`0 == false`'
  id: totrans-237
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`0 == false`'
- en: Let’s start with an easy one, and most people will probably get it right, even
    without reading this module. Now that we know how the abstract equality operator
    works let us understand the steps taken to evaluate this expression as `true`.
  id: totrans-238
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们从一个简单的开始，大多数人可能会正确理解，即使不阅读此模块。现在我们知道抽象相等运算符的工作原理，让我们理解评估该表达式为`true`时所采取的步骤。
- en: 'As the types are not equal and one of the operands is a boolean, the boolean
    operand is converted into a number using the `ToNumber` abstract operation. So,
    the first coercive step is to convert `false` into a number, i.e., `0`. The expression
    becomes:'
  id: totrans-239
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 由于类型不相等且其中一个操作数是布尔值，因此布尔操作数使用`ToNumber`抽象操作转换为数字。因此，第一次强制转换步骤是将`false`转换为数字，即`0`。表达式变为：
- en: '[PRE25]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now the types are equal, so the strict equality comparison is performed, i.e.,
    `0 === 0`, giving us `true` as an output.
  id: totrans-241
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 现在类型相等，因此执行严格相等比较，即`0 === 0`，输出为`true`。
- en: '`"" == false`'
  id: totrans-242
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`"" == false`'
- en: 'As the types are not equal and one of the operands is a boolean, the boolean
    operand is converted into a number using the `ToNumber` abstract operation. So,
    the first coercive step is to convert `false` into a number, i.e., `0`. The expression
    becomes:'
  id: totrans-243
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 由于类型不相等且其中一个操作数是布尔值，因此布尔操作数使用`ToNumber`抽象操作转换为数字。因此，第一次强制转换步骤是将`false`转换为数字，即`0`。表达式变为：
- en: '[PRE26]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we have a string and a number. Recall that the abstract equality operator
    prefers number comparison, so the string operand is converted into a number using
    the `ToNumber` abstract operation. An empty string, when converted into a number,
    outputs `0`. So the expression becomes:'
  id: totrans-245
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 现在，我们有一个字符串和一个数字。请记住，抽象相等运算符优先考虑数字比较，因此字符串操作数使用`ToNumber`抽象操作转换为数字。空字符串在转换为数字时输出为`0`。因此，表达式变为：
- en: '[PRE27]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The types are equal, so the strict equality comparison is performed, i.e., `0
    === 0`, giving us `true` as an output.
  id: totrans-247
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 类型相等，因此执行严格相等比较，即`0 === 0`，输出为`true`。
- en: '`0 == []`'
  id: totrans-248
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`0 == []`'
- en: 'The array is converted into a primitive value using the `ToPrimitive` abstract
    operation. As the abstract equality operator prefers number comparison, the array
    is converted into a primitive value with a number as the preferred type. An empty
    array, when converted into a primitive value, outputs an empty string. So the
    expression becomes:'
  id: totrans-249
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 数组使用`ToPrimitive`抽象操作转换为原始值。由于抽象相等运算符优先考虑数字比较，因此数组转换为数字作为首选类型的原始值。空数组在转换为原始值时输出为空字符串。因此，表达式变为：
- en: '[PRE28]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, the string will be converted into a number. An empty string converted
    into a number outputs `0`. So the expression becomes:'
  id: totrans-251
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，字符串将被转换为数字。将空字符串转换为数字时输出为`0`。因此，表达式变为：
- en: '[PRE29]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The types are equal, so the strict equality comparison is performed, i.e., `0
    === 0`, giving us `true` as an output.
  id: totrans-253
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 类型相等，因此执行严格相等比较，即`0 === 0`，输出结果为`true`。
- en: '`[123] == 123`'
  id: totrans-254
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`[123] == 123`'
- en: We have a comparison between an array and a number. So, the array is converted
    into a primitive value using the `ToPrimitive` abstract operation, with number
    as the preferred type. The `valueOf` method will be invoked first, as the preferred
    type is a number. But we know that the default implementation of the `valueOf`
    method simply returns the object on which it is called. So, the `toString` is
    invoked next. For Arrays, the `toString` method returns an empty string for empty
    arrays; for an array like `[1, 2, 3]`, it returns the contents of the array as
    a string, joined by commas, i.e., `"1,2,3"`. Each array element is coerced into
    a string and then joined by comma(s).
  id: totrans-255
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 我们有一个数组和一个数字之间的比较。因此，数组将使用`ToPrimitive`抽象操作转换为原始值，以数字为首选类型。`valueOf`方法将首先被调用，因为首选类型是数字。但我们知道，`valueOf`方法的默认实现只是返回调用它的对象。因此，接下来调用`toString`。对于数组，`toString`方法对空数组返回一个空字符串；对于像`[1,
    2, 3]`这样的数组，它返回数组的内容，以字符串形式用逗号连接，即`"1,2,3"`。每个数组元素被强制转换为字符串，然后用逗号连接。
- en: 'In our case, we have a single element in an array, i.e., `[123]`, so it will
    be coerced into `"123"`. So the expression becomes:'
  id: totrans-256
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 在我们的例子中，数组中有一个元素，即`[123]`，因此它将被强制转换为`"123"`。所以表达式变为：
- en: '[PRE30]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, the string will be converted into a number. So the expression becomes:'
  id: totrans-258
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，字符串将被转换为数字。因此表达式变为：
- en: '[PRE31]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The types are equal, so the strict equality comparison is performed, i.e., `123
    === 123`, giving us `true` as an output.
  id: totrans-260
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 类型相等，因此执行严格相等比较，即`123 === 123`，输出结果为`true`。
- en: ':::info 关于数组转换为原始值的奇怪事实：包含`null`或`undefined`的数组会被强制转换为一个空字符串，即`[null]` —> `""`
    和 `[undefined]` —> `""`。类似地，包含两者的数组会被强制转换为包含单个逗号的字符串，即`[null, undefined]` —> `","`。为什么我们不会得到`"null"`、`"undefined"`和`"null,undefined"`这样的数组呢？这只是强制转换的一个边缘情况。:::'
  id: totrans-261
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: ':::info 关于数组转换为原始值的奇怪事实：包含`null`或`undefined`的数组会被强制转换为一个空字符串，即`[null]` —> `""`
    和 `[undefined]` —> `""`。类似地，包含两者的数组会被强制转换为包含单个逗号的字符串，即`[null, undefined]` —> `","`。为什么我们不会得到`"null"`、`"undefined"`和`"null,undefined"`这样的数组呢？这只是强制转换的一个边缘情况。:::'
- en: '`[1] < [2]`'
  id: totrans-262
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`[1] < [2]`'
- en: 这是两个对象之间的比较。两个数组都使用`ToPrimitive`抽象操作被转换为原始值，以数字为首选类型。如前面的示例所述，`toString`最终会被调用，将两个数组转换为原始值，分别输出为`"1"`和`"2"`。因此表达式变为：
  id: totrans-263
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 这是两个对象之间的比较。两个数组都使用`ToPrimitive`抽象操作被转换为原始值，以数字为首选类型。如前面的示例所述，`toString`最终会被调用，将两个数组转换为原始值，分别输出为`"1"`和`"2"`。因此表达式变为：
- en: '[PRE32]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 现在，我们有两个字符串。类型相等，因此执行严格相等比较，即`"1" < "2"`，输出结果为`true`，因为字符串是根据它们的Unicode代码点进行比较的。
  id: totrans-265
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 现在，我们有两个字符串。类型相等，因此执行严格相等比较，即`"1" < "2"`，输出结果为`true`，因为字符串是根据它们的Unicode代码点进行比较的。
- en: '`[] == ![]`'
  id: totrans-266
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`[] == ![]`'
- en: 在这个比较中，我们有两个运算符：抽象相等运算符和[Not (!)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_NOT)运算符。Not运算符的优先级高于相等运算符，因此子表达式`![]`会被首先计算。
  id: totrans-267
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 在这个比较中，我们有两个运算符：抽象相等运算符和[Not (!)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_NOT)运算符。Not运算符的优先级高于相等运算符，因此子表达式`![]`会被首先计算。
- en: Not运算符将`true`转换为`false`，反之亦然。但在这里它与非布尔值一起使用。那么，当JavaScript在期望不同类型值的上下文中看到某个类型的值时会发生什么？强制转换！所以`[]`会被强制转换为布尔值，因为布尔值是期望的类型，使用`ToBoolean`抽象操作。由于`[]`是一个真值，它被强制转换为`true`，然后Not运算符否定它，将`true`转换为`false`。因此表达式变为：
  id: totrans-268
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: Not运算符将`true`转换为`false`，反之亦然。但在这里它与非布尔值一起使用。那么，当JavaScript在期望不同类型值的上下文中看到某个类型的值时会发生什么？强制转换！所以`[]`会被强制转换为布尔值，因为布尔值是期望的类型，使用`ToBoolean`抽象操作。由于`[]`是一个真值，它被强制转换为`true`，然后Not运算符否定它，将`true`转换为`false`。因此表达式变为：
- en: '[PRE33]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 接下来，布尔操作数，即`false`被转换为数字，即`0`。表达式现在是：
  id: totrans-270
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，布尔操作数，即`false`被转换为数字，即`0`。表达式现在是：
- en: '[PRE34]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 现在我们在对象和数字之间进行比较。回忆一下抽象相等运算符的工作方式，对象将被转换为原始值，优先考虑数字类型。如前面的一个示例所述，空数组被转换为一个空字符串，因此表达式变为：
  id: totrans-272
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 现在我们在对象和数字之间进行比较。回忆一下抽象相等运算符的工作方式，对象将被转换为原始值，优先考虑数字类型。如前面的一个示例所述，空数组被转换为一个空字符串，因此表达式变为：
- en: '[PRE35]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 接下来，空字符串被转换为数字，即`0`，使用`ToNumber`抽象操作。
  id: totrans-274
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，空字符串被转换为数字，即`0`，使用`ToNumber`抽象操作。
- en: '[PRE36]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 类型相等，因此执行严格相等比较，即`0 === 0`，输出结果为`true`。
  id: totrans-276
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 类型相等，因此执行严格相等比较，即`0 === 0`，输出结果为`true`。
- en: :::note If you are wondering how I know which operand, either left or right,
    is coerced first and what coercion is performed, I am simply referring to the
    steps mentioned in the ECMAScript specification. For example, for an expression
    involving a comparison using the abstract equality operator, I am referring to
    the steps of the [`IsLooselyEqual`](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-islooselyequal)
    abstract operation.
  id: totrans-277
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: :::note 如果你想知道我是如何知道哪个操作数（左侧或右侧）首先被强制转换，以及执行了什么强制转换，我只是参考了ECMAScript规范中提到的步骤。例如，对于涉及使用抽象相等运算符的比较的表达式，我是参考[`IsLooselyEqual`](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-islooselyequal)抽象操作的步骤。
- en: 'This is what you should do as well. There is no need to memorize every step.
    Just understand the basics of how coercion is performed, which abstract operations
    are involved, and just refer to the specification. :::'
  id: totrans-278
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '这就是你应该做的。同样没有必要记住每一个步骤。只需理解强制转换的基本原理，涉及哪些抽象操作，并参考规范即可。:::'
- en: '`!!"true" == !!"false"`'
  id: totrans-279
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`!!"true" == !!"false"`'
- en: Again, we have two operators in an expression. As mentioned before, the precedence
    of the logical `Not` operator is higher, so the sub-expressions `!!"true"` and
    `!!"false"` will be evaluated first.
  id: totrans-280
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 再次，我们在一个表达式中有两个操作符。如前所述，逻辑 `Not` 运算符的优先级较高，因此子表达式 `!!"true"` 和 `!!"false"` 将首先被计算。
- en: The string `"true"` in the expression `!!"true"` is a truthy value, so it will
    be coerced to the boolean value `true`. So the expression will become `!!true`.
    Next, we have two occurrences of the `Not` operator. Applying it twice to `true`
    will first convert it to `false` and then back to `true`.
  id: totrans-281
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 表达式 `!!"true"` 中的字符串 `"true"` 是一个真值，因此它将被强制转换为布尔值 `true`。因此，表达式将变为 `!!true`。接下来，我们有两次
    `Not` 运算符的出现。将其应用于 `true` 两次将首先将其转换为 `false`，然后再转换回 `true`。
- en: 'The second sub-expression `!!"false"` will also evaluate to `true` because
    the string `"false"` is a truthy value, so same as the first sub-expression, the
    expression will become `!!true` and then applying the `Not` operator twice will
    give us `true`. So after the sub-expressions have been coerced and evaluated,
    our expression will become:'
  id: totrans-282
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 第二个子表达式 `!!"false"` 也将计算为 `true`，因为字符串 `"false"` 是一个真值，所以与第一个子表达式相同，表达式将变为 `!!true`，然后应用两次
    `Not` 运算符将得到 `true`。因此，在子表达式被强制转换和计算后，我们的表达式将变为：
- en: '[PRE37]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The types are equal, so the strict equality comparison is performed, i.e., `true
    === true`, giving us `true` as an output.
  id: totrans-284
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 类型相等，因此执行严格相等比较，即 `true === true`，输出为 `true`。
- en: '[`[1, 2, 3] + [4, 5, 6]`](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-applystringornumericbinaryoperator)'
  id: totrans-285
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '[`[1, 2, 3] + [4, 5, 6]`](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-applystringornumericbinaryoperator)'
- en: Recall how the addition operator works. The abstract operation involved here
    is [`ApplyStringOrNumericBinaryOperator`](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-applystringornumericbinaryoperator).
  id: totrans-286
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 回忆一下加法运算符是如何工作的。这里涉及的抽象操作是 [`ApplyStringOrNumericBinaryOperator`](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-applystringornumericbinaryoperator)。
- en: 'As both of the operands are objects, they are first converted into primitive
    values with no preferred type specified for the `ToPrimitive` abstract operation.
    So, by default, “number” is the preferred type. Arrays, when coerced into primitive
    values, are converted into primitive values using the `toString` method. For the
    array that we have in our expression, we will get `"1,2,3"` and `"4,5,6"` respectively.
    So the expression becomes:'
  id: totrans-287
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 由于两个操作数都是对象，它们首先被转换为没有指定优先类型的原始值用于 `ToPrimitive` 抽象操作。因此，默认情况下，“数字”是优先类型。数组在强制转换为原始值时，使用
    `toString` 方法进行转换。对于我们表达式中的数组，我们将分别得到 `"1,2,3"` 和 `"4,5,6"`。所以表达式变为：
- en: '[PRE38]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As both operands, after coercion, are strings, instead of addition, concatenation
    is performed, joining both strings, giving us `"1,2,34,5,6"` as output.
  id: totrans-289
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 由于两个操作数在强制转换后都是字符串，因此不是加法，而是执行连接，将两个字符串连接在一起，输出为 `"1,2,34,5,6"`。
- en: '[`[undefined] == 0`](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-applystringornumericbinaryoperator)'
  id: totrans-290
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '[`[undefined] == 0`](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-applystringornumericbinaryoperator)'
- en: 'As we have seen many times in this lesson when there is a comparison between
    an object and a number using the abstract equality operator, the object is first
    converted into a primitive value. Recall from a note earlier in this lesson that
    `[undefined]`, when converted into a primitive value, outputs an empty string.
    So the expression becomes:'
  id: totrans-291
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 正如我们在本节课中多次看到的，当对象与数字进行比较时，使用抽象相等运算符，对象首先被转换为原始值。回忆一下本节课早些时候提到的，`[undefined]`
    转换为原始值时输出一个空字符串。因此，表达式变为：
- en: '[PRE39]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'An empty string, when converted into a number, gives us `0`. So the expression
    becomes:'
  id: totrans-293
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 空字符串在转换为数字时，给我们 `0`。所以表达式变为：
- en: '[PRE40]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 类型相等，因此执行严格相等比较，即`0 === 0`，输出为`true`。
  id: totrans-295
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 类型相等，因此执行严格相等比较，即 `0 === 0`，输出为 `true`。
- en: '`[[]] == ''''`'
  id: totrans-296
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`[[]] == ''''`'
- en: 在这个表达式中，我们有一个包含空数组和空字符串的数组。数组操作数首先被转换为原始值。回想一下数组是如何转换为原始值的。除了前面提到的一些特殊情况，数组通过将其元素强制转换为字符串并用逗号连接它们来转换为原始值。因此，嵌套的空数组将被转换为原始值。当空数组被转换为原始值时，我们得到什么？是的，一个空字符串。所以，外层数组也被转换为一个空字符串。强制转换后的表达式变为：
  id: totrans-297
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 在这个表达式中，我们有一个包含空数组和空字符串的数组。数组操作数首先被转换为原始值。回想一下数组是如何转换为原始值的。除了前面提到的一些特殊情况，数组通过将其元素强制转换为字符串并用逗号连接它们来转换为原始值。因此，嵌套的空数组将被转换为原始值。当空数组被转换为原始值时，我们得到什么？是的，一个空字符串。所以，外层数组也被转换为一个空字符串。强制转换后的表达式变为：
- en: '[PRE41]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 空字符串等于空字符串，因此输出为`true`。
  id: totrans-299
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 空字符串等于空字符串，因此输出为 `true`。
- en: '`[] + {}`'
  id: totrans-300
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`[] + {}`'
- en: 由于运算符是加法运算符，且两个操作数都是对象，因此它们都被转换为没有优先类型的原始值。因此，默认情况下，优先类型被设置为“数字”。
  id: totrans-301
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 由于运算符是加法运算符，且两个操作数都是对象，因此它们都被转换为没有优先类型的原始值。因此，默认情况下，优先类型被设置为“数字”。
- en: 空数组被转换为一个空字符串，而对象字面量的默认原始表示为字符串`"[object Object]"`。所以表达式变为：
  id: totrans-302
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 空数组被转换为一个空字符串，而对象字面量的默认原始表示为字符串 `"[object Object]"`。所以表达式变为：
- en: '[PRE42]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 两个操作数现在都是字符串，并且被连接，输出为`"[object Object]"`。
  id: totrans-304
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 两个操作数现在都是字符串，并且被连接，输出为 `"[object Object]"`。
- en: 参考文献
  id: totrans-305
  prefs:
  - PREF_H5
  stylish: true
  type: TYPE_NORMAL
  zh: 参考文献
- en: 上述一些表达式来自以下 GitHub 仓库：[wtfjs](https://github.com/denysdovhan/wtfjs)
  id: totrans-306
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上述一些表达式来自以下 GitHub 仓库：[wtfjs](https://github.com/denysdovhan/wtfjs)
