- en: Coercion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coercion in JavaScript is the conversion of one type of value into another type
    of value.
  prefs: []
  type: TYPE_NORMAL
- en: '[MDN defines coercion](https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion)
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: Type coercion is the automatic or implicit conversion of values from one data
    type to another (such as strings to numbers).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: According to MDN’s definition, if the conversion of values is *implicit*, then
    it is *coercion*, whereas *type conversion* can either be *implicit* or *explicit*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if the developer expresses the intention to convert one type of value into
    another, it is just type conversion. The following code example is an example
    of an *explicit* type conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And if the type conversion is implicit, where the developer expressed no intention
    to convert any value into another value, then it is implicit type conversion or
    coercion. The following code is an example of coercion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Whenever JavaScript sees a value of one type in a context that expects a value
    of a different type, it tries to coerce or convert the value into the expected
    type. In the above code example, `"50"` is the unexpected value type because the
    operation is subtraction. The subtraction is between numbers, not between a string
    and a number. So `"50"`, being an unexpected value, gets converted into a number,
    i.e. `50`.
  prefs: []
  type: TYPE_NORMAL
- en: However, some might argue that any type of conversion in a dynamically typed
    language can be considered coercion. Moreover, the difference between *implicit*
    and *explicit* type conversion depends on how one views *implicit* and *explicit*
    type conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, what’s important is that we understand the process of type
    conversion in JavaScript. The goal of this module is to help you understand how
    JavaScript converts one type of value into another and make type conversion (implicit
    or explicit) less scary.
  prefs: []
  type: TYPE_NORMAL
- en: Coercion is one of those topics that many JavaScript developers generally misunderstand,
    and this is because most online resources advise staying away from coercion and
    presenting it as a topic that should be avoided instead of taking the time to
    understand it and take advantage of it where possible.
  prefs: []
  type: TYPE_NORMAL
- en: What makes coercion scary for many JavaScript developers, especially beginners,
    is the need for more understanding of this topic. Coercion is presented as a feature
    of JavaScript that is better avoided than understood.
  prefs: []
  type: TYPE_NORMAL
- en: Coercion is one of the core topics of JavaScript, and its understanding is key
    to understanding JavaScript in depth. No matter how many online resources tell
    you to avoid this topic, it is unavoidable if you work with JavaScript. Instead
    of avoiding it, why not make an effort to understand it? With this in mind, in
    this module, we will take a deeper look at this topic, and hopefully, by the end
    of this module, you will have a solid understanding of type coercion.
  prefs: []
  type: TYPE_NORMAL
- en: Coercion is one of the core topics of JavaScript, and its understanding is key
    to understanding JavaScript in depth. No matter how many online resources tell
    you to avoid this topic, it is unavoidable if you work with JavaScript. So, instead
    of avoiding it, why not try to understand it? With this in mind, in this module,
    we will take a deeper look at this topic, and hopefully, by the end of this module,
    you will have a solid understanding of type coercion.
  prefs: []
  type: TYPE_NORMAL
- en: To understand coercion in-depth, we need to understand how JavaScript goes about
    converting one value into another type of value. We need to understand what algorithms
    or steps JavaScript takes to perform type conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deep dive into the world of coercion, let us understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract equality operator (==)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Addition operation (+)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational operators (<, >, <=, >=)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the above-mentioned topics will help us lay the foundation for
    understanding the process of type conversion in JavaScript. So, without further
    ado, let us begin by understanding the first item on our list, i.e., abstract
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: The ECMAScript specification has documented several mechanisms that are used
    by the JavaScript language to convert one type of value into another type of value.
    These mechanisms are known as “**abstract operations**”; abstract in the sense
    that these are not some real functions that can be referred to or called by the
    JavaScript code; instead, they are just algorithmic steps internally used by the
    language to perform type conversion.
  prefs: []
  type: TYPE_NORMAL
- en: These abstract operations are written in the specification as though they were
    actual functions. For example, `operationName(arg1, arg2, ...)`, but the specification
    clarifies that the abstract operations are algorithms rather than actual functions
    that can be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many [abstract operations](https://262.ecma-international.org/13.0/#sec-abstract-operations)
    mentioned in the ECMAScript specification, but some of the common ones that come
    into play when dealing with coercion are mentioned below:'
  prefs: []
  type: TYPE_NORMAL
- en: ToPrimitive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ToNumber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ToString
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ToBoolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the names of the above-mentioned abstract operations are self-descriptive,
    let us understand how exactly they aid in type conversion.
  prefs: []
  type: TYPE_NORMAL
- en: ToPrimitive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [ToPrimitive](https://262.ecma-international.org/13.0/#sec-toprimitive)
    abstract operation is used to convert an object to a primitive value. This operation
    takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`input`: an object that should be converted into a primitive value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preferredType`: an optional second argument that specifies the type that should
    be favored when converting an object into a primitive value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OrdinaryToPrimitive
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This operation invokes another abstract operation known as [OrdinaryToPrimitive](https://262.ecma-international.org/13.0/#sec-ordinarytoprimitive)
    to do the actual conversion, and it also takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`O`: an object that should be converted into a primitive value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hint`: a type that should be favored when converting an object to a primitive
    value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ToPrimitive` abstract operation invokes the `OrdinaryToPrimitive` abstract
    operation, passing in the object, that is to be converted into a primitive value,
    as the first argument, and the second argument hint is set based on the value
    of `preferredType` argument as described below:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `preferredType` is “string”, set `hint` to string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `preferredType` is a “number”, set `hint` to the number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `preferredType` is not specified, set `hint` to the number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each object in JavaScript inherits the following two methods from the object
    that sits at the top of the inheritance hierarchy, i.e., the Object.prototype
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`toString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valueOf()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: toString( )
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `toString` method is used to convert an object into its string representation.
    The default behavior of the `toString` method is to convert objects in the following
    (not so-useful) form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the above code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example1”
    />
  prefs: []
  type: TYPE_NORMAL
- en: 'As the default implementation of the `toString` method is not useful at all,
    different objects override this method to make its output more useful. The built-in
    `Date` object, for example, when converted to a string, outputs a human-readable
    string representation of the date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the above code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example2”
    />
  prefs: []
  type: TYPE_NORMAL
- en: valueOf( )
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `valueOf` method is used to convert an object into a primitive value. The
    default implementation of this method, like the `toString` method, is useless,
    as it just returns the object on which this method is called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the above code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example3”
    />
  prefs: []
  type: TYPE_NORMAL
- en: It is meant to be overridden by other objects. Many built-in objects override
    this method. For example, for the `Date` objects, this method returns the number
    of milliseconds since midnight 01 January 1, 1970 UTC.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the above code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example4”
    />
  prefs: []
  type: TYPE_NORMAL
- en: The `OrdinaryToPrimitive` abstract operation invokes the `toString` and the
    `valueOf` methods to convert an object into a primitive value. Among these two
    methods, in some cases, only one of them is called; in other cases, both of them
    are called.
  prefs: []
  type: TYPE_NORMAL
- en: The `hint` argument received by the `OrdinaryToPrimitive` abstract operation
    determines which of these two methods is called first.
  prefs: []
  type: TYPE_NORMAL
- en: Prefer string
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the `hint` argument is “string”, then the `OrdinaryToPrimitive` abstract
    operation first invokes the `toString` method on the object. If the `toString`
    method returns a primitive value, *even if that primitive value is not of the
    string type*, then that primitive value is used as a primitive representation
    of the object.
  prefs: []
  type: TYPE_NORMAL
- en: If the `toString` method doesn’t exist or doesn’t return a primitive value,
    then the `valueOf` method is invoked. If the `valueOf` method returns a primitive
    value, then that value is used; otherwise, a `TypeError` is thrown, indicating
    that the object couldn’t be converted to a primitive value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the above code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example5”
    />
  prefs: []
  type: TYPE_NORMAL
- en: In the above code example, we have an object containing overridden implementations
    of the `toString` and the `valueOf` method. At the end of the code example, we
    are trying to log `obj`, embedded in a [template literal](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals),
    to the console. In this case, the `obj` will be converted into a string.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed above, when the `hint` argument of the `OrdinaryToPrimitive` abstract
    operation is “string”, the `toString` method is invoked to convert an object into
    a primitive value, preferably into a value of string type.
  prefs: []
  type: TYPE_NORMAL
- en: As the `toString` implementation of the `obj` object is returning a string primitive
    value, the `valueOf` method is not invoked, and the object-to-primitive conversion
    process for the `obj` object is complete at this point. The primitive value returned
    by the `toString` method of the `obj` object is used by the template literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'But it was mentioned above that the value returned by the `toString` method
    can be of non-string primitive type. The following code example verifies this
    claim:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the above code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example6”
    />
  prefs: []
  type: TYPE_NORMAL
- en: The `toString` method in the above code example returns a boolean (non-string)
    primitive value. Instead of invoking the `valueOf` method or converting the non-string
    return value of the `toString` method into a string value, the boolean value is
    accepted as the primitive representation of the `obj` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next case we need to verify is what happens if the `toString` method doesn’t
    return a primitive value. The following code example demonstrates this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the above code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example7”
    />
  prefs: []
  type: TYPE_NORMAL
- en: As explained earlier, if the `toString` method doesn’t return a primitive value,
    the `valueOf` method will be invoked to get a primitive representation of the
    object. In the code example above, the `toString` method returns an empty array
    of an object type; as a result, the `valueOf` method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `valueOf` method is invoked even if the `toString` is not defined for an
    object. The following code example shows this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the above code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example8”
    />
  prefs: []
  type: TYPE_NORMAL
- en: The last case we need to verify is what happens when JavaScript can’t get a
    primitive value, even after invoking the `toString` and the `valueOf` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the above code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example9”
    />
  prefs: []
  type: TYPE_NORMAL
- en: When JavaScript can’t get a primitive value after invoking both methods, a `TypeError`
    is thrown, indicating that the object couldn’t be converted into a primitive value.
    So, it is important to remember when overriding these methods that at least one
    of them should return a primitive value.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed what happens when the preferred type is a string in the object-to-primitive
    conversion process. Next, let’s discuss what happens when the preferred type is
    a number.
  prefs: []
  type: TYPE_NORMAL
- en: Prefer number
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the hint argument is “number”, then the `OrdinaryToPrimitive` abstract operation
    first invokes the `valueOf` method and then the `toString` method, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to the “prefer string” case discussed above, except that the
    order in which the `valueOf` and the `toString` methods are invoked is the opposite.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the above code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example10”
    />
  prefs: []
  type: TYPE_NORMAL
- en: This code example above is the same as the one shown in the section above, except
    that instead of embedding `obj` in a template literal and logging it to the console,
    we are adding 1 to `obj`. We are using `obj` as if it were a number.
  prefs: []
  type: TYPE_NORMAL
- en: So when JavaScript gets an object in a context where it expects a number, it
    tries to coerce the object into a primitive type, preferably into a number type.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the `hint` argument passed to the `OrdinaryToPrimitive` abstract
    operation is “number”; as a result, the `valueOf` method is invoked first. Since
    it returned a primitive value, there is no need to invoke the `toString` method.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the cases are the same as discussed in the “prefer string” section.
    The only difference is that the `valueOf` method is invoked first when the preferred
    type is “number”.
  prefs: []
  type: TYPE_NORMAL
- en: What will happen if the `valueOf` method returns a boolean value? It is a primitive
    value. It is not a number but still a primitive value. So JavaScript should accept
    it as a primitive representation of the `obj` object, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the above code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example11”
    />
  prefs: []
  type: TYPE_NORMAL
- en: Why did we get two as an output? The answer is that `true` is accepted as a
    primitive representation of the `obj` object, but we cannot add `true` and `1`.
    JavaScript expects a number in this context. So, it tries to coerce `true` into
    the expected type of value, which in this case is `1`. If the `valueOf` method
    had returned `false`, it would have been coerced to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: No preference
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the `ToPrimitive` abstract operation is called without the preferred type
    or hint, or if the hint is set to “default”, then this operation generally behaves
    as if the hint were “number”. So, by default, the `ToPrimitive` prefers the conversion
    to number type.
  prefs: []
  type: TYPE_NORMAL
- en: However, the objects can override this default `ToPrimitive` behavior by implementing
    the [Symbol.toPrimitive](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)
    function. This function is passed a preferred type as an argument, and it returns
    the primitive representation of the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the above code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example12”
    />
  prefs: []
  type: TYPE_NORMAL
- en: Out of the built-in objects, only the `Date` and `Symbol` objects override the
    default behavior of the `ToPrimitive` abstract operation. The `Date` objects implement
    the default behavior as if the preferred type or hint is “string.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the above code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example13”
    />
  prefs: []
  type: TYPE_NORMAL
- en: :::note
  prefs: []
  type: TYPE_NORMAL
- en: We rarely need to call the `Symbol.toPrimitive` function explicitly. JavaScript
    calls this function automatically when it needs to convert an object into a primitive
    value.
  prefs: []
  type: TYPE_NORMAL
- en: ':::'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ToPrimitive` abstract operation is summarized in the image below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Object to primitive conversion summarized](images/module_04----lesson_04.03----public----assets----ToPrimitive.png)'
  prefs: []
  type: TYPE_IMG
- en: Object to primitive conversion summarized
  prefs: []
  type: TYPE_NORMAL
- en: ToNumber
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [ToNumber](https://262.ecma-international.org/13.0/#sec-tonumber) abstract
    operation is used whenever JavaScript needs to convert any non-number value into
    a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the results of this abstract operation applied to
    some non-number values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | ToNumber(value) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ”” | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| “0” | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| “-0” | -0 |'
  prefs: []
  type: TYPE_TB
- en: '| ” 123 “ | 123 |'
  prefs: []
  type: TYPE_TB
- en: '| “45” | 45 |'
  prefs: []
  type: TYPE_TB
- en: '| “abc” | NaN |'
  prefs: []
  type: TYPE_TB
- en: '| false | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| true | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| undefined | NaN |'
  prefs: []
  type: TYPE_TB
- en: '| null | 0 |'
  prefs: []
  type: TYPE_TB
- en: As far as objects are concerned, the `ToNumber` abstract operation first converts
    the object into a primitive value using the `ToPrimitive` abstract operation with
    “number” as the preferred type, and then the resulting value is converted into
    a number.
  prefs: []
  type: TYPE_NORMAL
- en: The [BigInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)
    values allow *explicit* conversion into a number type, but the *implicit* conversion
    is not allowed; implicit conversion throws a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the above code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-operations-example14”
    />
  prefs: []
  type: TYPE_NORMAL
- en: ToString
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [ToString](https://262.ecma-international.org/13.0/#sec-tostring) abstract
    operation is used to convert any value into a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the results of this abstract operation applied to
    some non-string values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | ToNumber(value) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| null | “null” |'
  prefs: []
  type: TYPE_TB
- en: '| undefined | “undefined” |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | “0” |'
  prefs: []
  type: TYPE_TB
- en: '| -0 | “0” |'
  prefs: []
  type: TYPE_TB
- en: '| true | “true” |'
  prefs: []
  type: TYPE_TB
- en: '| false | “false” |'
  prefs: []
  type: TYPE_TB
- en: '| 123 | “123” |'
  prefs: []
  type: TYPE_TB
- en: '| NaN | “NaN” |'
  prefs: []
  type: TYPE_TB
- en: In the case of objects, the `ToString` abstract operation first converts the
    object into a primitive value using the `ToPrimitive` abstract operation with
    “string” as the preferred type, and then the resulting value is converted into
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: ToBoolean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [ToBoolean](https://262.ecma-international.org/13.0/#sec-toboolean) abstract
    operation is used to convert a value into a boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the above-mentioned abstract operations, this operation is simply a lookup
    of whether a value is a [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)
    value. If it is, we get `false` as a return value; for all other values, this
    operation returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of falsy values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'false'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0, -0, 0n
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: undefined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NaN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ””
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned earlier, there are many [abstract operations](https://262.ecma-international.org/13.0/#sec-abstract-operations)
    mentioned in the ECMAScript specification that are used for type conversion; in
    this lesson, we have only discussed the common ones.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Number coercion - (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number#number_coercion)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[String coercion - (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#string_coercion)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Boolean coercion - (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean#boolean_coercion)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Coercing values - (You Don’t Know JS Yet )](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/types-grammar/ch4.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s discuss the infamous “double equal” operator that is used for *loosely*
    comparing two values. It is also known as the “abstract equality” operator.
  prefs: []
  type: TYPE_NORMAL
- en: This operator is infamous because many resources online, and JavaScript developers,
    in general, discourage its use because of its coercive behavior.Instead of blindly
    ignoring the double equality operator, we should try to understand how it behaves,
    and then we can decide for ourselves whether we want to not use it at all in our
    code or use it where it is safe to use.
  prefs: []
  type: TYPE_NORMAL
- en: Despite what you hear about his operator, it behaves according to some predefined
    algorithmic steps, and if we understand how it works, this operator won’t scare
    us, and we might even prefer this operator in some cases over its cousin, the
    strict equality operator (===).
  prefs: []
  type: TYPE_NORMAL
- en: When two values are compared using the double equals operator, the steps taken
    by JavaScript to compare the two values are described by an abstract operation
    known as [IsLooselyEqual](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-islooselyequal).
  prefs: []
  type: TYPE_NORMAL
- en: Summary of abstract equality operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The working of the double equals operator is roughly summarized in the steps
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: If the values being compared are of the same type, then perform the [strict
    equality comparison](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-isstrictlyequal).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one value is `undefined` or `null` and the other value is also `undefined`
    or `null`, return true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one or both values are objects, they are converted into primitive types,
    preferring the number type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If both values are primitives but are of different types, convert the types
    until they match, preferring the number type for coercing values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegating to strict equality comparison
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Think about the first point mentioned above. If the types of values being compared
    using this operator are the same, under the hood, the two values get compared
    using the triple equals or the strict equality operator. So, if we know that only
    the same type of values will get compared in some piece of code, it doesn’t make
    any difference whether we use the double equals or the triple equals operator;
    in this case, we will always have the strict equality operator.
  prefs: []
  type: TYPE_NORMAL
- en: null vs undefined
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second point is also worth pondering over. Unlike the strict equality operator,
    the abstract or loose equality operator considers `null == undefined` comparison
    to be true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the code above in action below:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-equality-operator-example1”
    />
  prefs: []
  type: TYPE_NORMAL
- en: The fact that `null` and `undefined` are equal to each other according to the
    abstract equality operator makes for an interesting use case of the abstract equality
    operator. When writing JavaScript code, it is common to check if a value is neither
    `null` nor `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the strict equality operator, we will have a check that looks something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas with the abstract equality operator, we can shorten this check to just
    one condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Considering how often we need to guard against `null` and `undefined` in our
    JavaScript code, I feel the abstract equality operator is ideal for this case.
    Having said that, you won’t be wrong if you use the strict equality operator in
    this case.
  prefs: []
  type: TYPE_NORMAL
- en: “if” conditions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although the coercive behavior of the abstract equality operator is predictable,
    as explained above, people often fall into a trap because of how they use this
    operator in the `if` statement conditions. Consider the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the code above in action below:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/abstract-equality-operator-example4”
    />
  prefs: []
  type: TYPE_NORMAL
- en: We know from an earlier lesson that objects are [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)
    values. So, in the above code example, it seems reasonable to assume that the
    `if` condition would be evaluated as `true`, leading to the execution of the `if`
    block. But, if you execute the above code, you might be surprised to know that
    instead of the `if` block, the `else` would execute because the `someVal == true`
    check would evaluate to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If either operand of the abstract equality operator is a boolean value, it
    is first converted to a number - `false` into `0` and `true` into `1`. So the
    `if` condition in the above code example would be evaluated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One operand is an object, and the other one is a boolean, so according to **step
    10** of the [isLooselyEqual](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-islooselyequal)
    abstract operation, if one operand is a boolean value, convert it into a number
    using the `ToNumber` abstract operation. So our condition would become:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After coercing a boolean value into a number, we have a comparison between
    an object and a number. According to **step 12** of the `isLooselyEqual` abstract
    operation, the object `someVal` would be converted into a primitive value using
    the `ToPrimitive` abstract operation, passing “number” as the preferred type.
    The default primitive representation of object literals is `"[object Object]"`,
    so our condition after coercion would become: `js "[object Object]" == 1;`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we have a comparison between a string and a number. According to **step
    6** of the `isLooselyEqual` abstract operation, if one operand is a string and
    the other one is a number, convert a string into a number. Converting `"[object
    Object]"` into a number will give us [NaN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN).
    So our condition would become:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After coercing three times, we have a comparison between a `NaN` value and a
    number. They are not equal to each other. *(`NaN` value is not equal to any other
    value, including itself.)*. So our condition fails to evaluate as `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The purpose of the above discussion is to understand that checking if a value
    is `true` or `false` using the abstract equality operator doesn’t always work
    as one might expect. It is easy to blame the abstract equality operator in such
    cases. Still, the fact is that those who write such code need help understanding
    or remembering how the abstract equality operator works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In such cases where we want to check if a value is truthy or falsy, instead
    of using the abstract equality operator, it is enough to take advantage of the
    coercive behavior of the `if` statement. What I mean is that the `if` condition
    in the above code should be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With the above condition, we will get the expected result because `someVal`
    will be checked if it is a truthy value; if it is, the condition will evaluate
    to true, leading to the execution of the `if` block.
  prefs: []
  type: TYPE_NORMAL
- en: So, as a piece of advice, avoid checks such as `someVal == true`, where one
    operand is a boolean value. In such cases, take advantage of the implicit coercive
    nature of the `if` statement, which will check if the value is a valid value or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Boolean gotcha - You Don’t Know JS Yet](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/types-grammar/ch4.md#-boolean-gotcha)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Runtime semantics of “if” statement (ECMAScript specification)](https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-if-statement)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Addition Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The addition operator can be used to perform the addition of two numbers, or
    it can be used to join two strings, also known as string concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: The working of this operator is based on the [ApplyStringOrNumericBinaryOperator](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-applystringornumericbinaryoperator).
    The way this works is that if any or both operands are non-primitive values, they
    are converted into primitive values using the `ToPrimitive` abstract operation,
    and no preferred type is specified. As a result, the “number” is the preferred
    type in this case because that is the default behavior of the `ToPrimitive` abstract
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: After checking for non-primitive operands and coercing them, if any, into primitive
    values, the next step is to check if either or both operands are strings. If that’s
    the case, then the non-string operands, if any, are coerced into strings, and
    string concatenation is performed.
  prefs: []
  type: TYPE_NORMAL
- en: If neither operand is a string, then the addition is performed after coercing
    non-number operands into numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Relational operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The relational operators (<, >, <=, >=) are used to compare both strings and
    numbers. The abstract operation invoked in the case of relational operators is
    [IsLessThan](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-islessthan)
    abstract operation. Despite its name, this operation handles “<=”, “>”, and “>=”
    comparisons as well.
  prefs: []
  type: TYPE_NORMAL
- en: If either operand is an object, it is converted into a primitive value with
    “number” as the preferred type. If both operands are strings, then they are compared
    using their Unicode code points. If not strings, then the operands are generally
    converted into numbers and then compared.
  prefs: []
  type: TYPE_NORMAL
- en: We can also compare date objects using relational operators. Recall that the
    `Date` objects are converted into strings when converted into primitive values
    using the `ToPrimitive` operation with no preferred type, but in the case of relational
    operators, `Date` objects, when converted into primitives, result in a number
    representation of the `Date` objects because in the case of relational operators,
    `ToPrimitive` abstract operation is passed “number” as the preferred type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a Replit of the above code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/relational-operators-example1”
    />
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have had a deeper look at coercion and how some of the common abstract
    operations work to make coercion work, let us test what we learned in this module.
    This following exercise will allow us to consolidate our understanding of the
    topic of coercion.
  prefs: []
  type: TYPE_NORMAL
- en: Following are some expressions that involve coercion. Try to guess the output
    based on the knowledge you gained in this module. Don’t worry if you don’t understand
    all of them. Their explanation is also given below. You can obviously refer to
    the specification and the earlier lessons in this module to understand and guess
    the output of the expressions below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Below is an explanation of the output of each of the above-mentioned expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '`0 == false`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start with an easy one, and most people will probably get it right, even
    without reading this module. Now that we know how the abstract equality operator
    works let us understand the steps taken to evaluate this expression as `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the types are not equal and one of the operands is a boolean, the boolean
    operand is converted into a number using the [ToNumber](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tonumber)
    abstract operation. So, the first coercive step is to convert `false` into a number,
    i.e., `0`. The expression becomes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now the types are equal, so the strict equality comparison is performed, i.e.,
    `0 === 0`, giving us `true` as an output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`"" == false`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the types are not equal and one of the operands is a boolean, the boolean
    operand is converted into a number using the `ToNumber` abstract operation. So,
    the first coercive step is to convert `false` into a number, i.e., `0`. The expression
    becomes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have a string and a number. Recall that the abstract equality operator
    prefers number comparison, so the string operand is converted into a number using
    the `ToNumber` abstract operation. An empty string, when converted into a number,
    outputs `0`. So the expression becomes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The types are equal, so the strict equality comparison is performed, i.e., `0
    === 0`, giving us `true` as an output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0 == []`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The array is converted into a primitive value using the `ToPrimitive` abstract
    operation. As the abstract equality operator prefers number comparison, the array
    is converted into a primitive value with a number as the preferred type. An empty
    array, when converted into a primitive value, outputs an empty string. So the
    expression becomes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the string will be converted into a number. An empty string converted
    into a number outputs `0`. So the expression becomes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The types are equal, so the strict equality comparison is performed, i.e., `0
    === 0`, giving us `true` as an output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[123] == 123`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have a comparison between an array and a number. So, the array is converted
    into a primitive value using the `ToPrimitive` abstract operation, with number
    as the preferred type. The `valueOf` method will be invoked first, as the preferred
    type is a number. But we know that the default implementation of the `valueOf`
    method simply returns the object on which it is called. So, the `toString` is
    invoked next. For Arrays, the `toString` method returns an empty string for empty
    arrays; for an array like `[1, 2, 3]`, it returns the contents of the array as
    a string, joined by commas, i.e., `"1,2,3"`. Each array element is coerced into
    a string and then joined by comma(s).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our case, we have a single element in an array, i.e., `[123]`, so it will
    be coerced into `"123"`. So the expression becomes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the string will be converted into a number. So the expression becomes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The types are equal, so the strict equality comparison is performed, i.e., `123
    === 123`, giving us `true` as an output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ':::info Weird fact about array conversion into a primitive value: an array
    containing `null` or `undefined` is coerced into an empty string, i.e., `[null]`
    —> `""` and `[undefined]` —> `""`. Similarly, an array containing both of them
    is coerced into a string containing a single comma, i.e., `[null, undefined]`
    —> `","`. Why don’t we get `"null"`, `"undefined"`, and `"null,undefined"` for
    such arrays, respectively? This is just one of the corner cases of coercion. :::'
  prefs: []
  type: TYPE_NORMAL
- en: '`[1] < [2]`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is a comparison between two objects. Both arrays are converted into primitive
    values using the `ToPrimitive` abstract operation, with number as the preferred
    type. As explained in the previous example, the `toString` will eventually be
    called to convert both arrays into primitive values, giving us `"1"` and `"2"`
    as output, respectively. So the expression becomes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we have two strings. The types are equal, so the strict equality comparison
    is performed, i.e., `"1" < "2"`, giving us `true` as an output because the strings
    are compared using their Unicode code points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[] == ![]`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this comparison, we have two operators: the abstract equality operator and
    the [Not (!)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_NOT)
    operator. The Not operator has a higher [precedence](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
    than the equality operator, so the sub-expression `![]` is evaluated first.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Not operator converts true into false, and vice versa. But here it is used
    with a non-boolean value. So what happens when JavaScript sees a value of one
    type in a context where it expects a value of a different type? Coercion! So `[]`
    will be coerced into a boolean value, as boolean is the expected type, using the
    `ToBoolean` abstract operation. As `[]` is a truthy value, it is coerced into
    `true` and then the Not operator negates it, converting `true` into `false`. So
    the expression becomes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the boolean operand, i.e., `false` is converted into a number, i.e.,
    `0`. The expression is now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have a comparison between an object and a number. Recalling how the
    abstract equality operator works, the object will be converted into a primitive
    value, preferring the number type. As mentioned in one of the earlier examples,
    an empty array is converted into an empty string, so the expression becomes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, the empty string is converted into a number, i.e., `0`, using the `ToNumber`
    abstract operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The types are equal, so the strict equality comparison is performed, i.e., `0
    === 0`, giving us `true` as an output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: :::note If you are wondering how I know which operand, either left or right,
    is coerced first and what coercion is performed, I am simply referring to the
    steps mentioned in the ECMAScript specification. For example, for an expression
    involving a comparison using the abstract equality operator, I am referring to
    the steps of the [IsLooselyEqual](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-islooselyequal)
    abstract operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what you should do as well. There is no need to memorize every step.
    Just understand the basics of how coercion is performed, which abstract operations
    are involved, and just refer to the specification. :::'
  prefs: []
  type: TYPE_NORMAL
- en: '`!!"true" == !!"false"`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Again, we have two operators in an expression. As mentioned before, the precedence
    of the logical Not operator is higher, so the sub-expressions `!!"true"` and `!!"false"`
    will be evaluated first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The string `"true"` in the expression `!!"true"` is a truthy value, so it will
    be coerced to the boolean value `true`. So the expression will become `!!true`.
    Next, we have two occurrences of the Not operator. Applying it twice to `true`
    will first convert it to `false` and then back to `true`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The second sub-expression `!!"false"` will also evaluate to `true` because
    the string `"false"` is a truthy value, so same as the first sub-expression, the
    expression will become `!!true` and then applying the Not operator twice will
    give us `true`. So after the sub-expressions have been coerced and evaluated,
    our expression will become:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The types are equal, so the strict equality comparison is performed, i.e., `true
    === true`, giving us `true` as an output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[1, 2, 3] + [4, 5, 6]`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall how the addition operator works. The abstract operation involved here
    is [ApplyStringOrNumericBinaryOperator](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-applystringornumericbinaryoperator).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As both of the operands are objects, they are first converted into primitive
    values with no preferred type specified for the `ToPrimitive` abstract operation.
    So, by default, “number” is the preferred type. Arrays, when coerced into primitive
    values, are converted into primitive values using the `toString` method. For the
    array that we have in our expression, we will get `"1,2,3"` and `"4,5,6"` respectively.
    So the expression becomes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As both operands, after coercion, are strings, instead of addition, concatenation
    is performed, joining both strings, giving us `"1,2,34,5,6"` as output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[undefined] == 0`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we have seen many times in this lesson when there is a comparison between
    an object and a number using the abstract equality operator, the object is first
    converted into a primitive value. Recall from a note earlier in this lesson that
    `[undefined]`, when converted into a primitive value, outputs an empty string.
    So the expression becomes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An empty string, when converted into a number, gives us `0`. So the expression
    becomes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The types are equal, so the strict equality comparison is performed, i.e., `0
    === 0`, giving us `true` as an output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[[]] == ''''`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this expression, we have an array containing an empty array and an empty
    string. The array operand is first converted into a primitive value. Recall how
    arrays are converted into primitive values. Apart from some corner cases mentioned
    earlier, arrays are converted into primitives by coercing their elements into
    strings and then joining them using commas. So, the nested empty array will be
    converted into a primitive value. What do we get when an empty array is converted
    into a primitive value? Yes, an empty string. So, the outer array is also converted
    into an empty string. The expression after coercion becomes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An empty string is equal to an empty string, so the output is `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[] + {}`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As the operator is an addition operator and both operands are objects, they
    are both converted into primitives with no preferred type. So, by default, the
    preferred type is set to “number”.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An empty array is converted into an empty string, and the default primitive
    representation of object literals is the string `"[object Object]"`. So the expression
    becomes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Both operands are now strings that are concatenated, giving us `“[object Object]”
    as an output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Some of the expressions above were taken from the following github repo: [wtfjs](https://github.com/denysdovhan/wtfjs)'
  prefs: []
  type: TYPE_NORMAL
