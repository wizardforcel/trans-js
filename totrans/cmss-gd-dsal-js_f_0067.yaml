- en: Array Sample
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next example, we create a function that takes a small sample of an array.
    We expect to have very large arrays, so our sample is just the first, middlemost,
    and last value from the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an implementation of this function. See if you can identify its efficiency
    in Big O:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ sample(array) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (array.length === 0) { ​**return**​ ​**null**​; } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**const**​ first = array[0]; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**const**​ middle = array[Math.floor(array.length / 2)]; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**const**​ last = array[array.length - 1]; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**return**​ [first, middle, last]; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: In this case again, the array passed into this function is the primary data,
    so we can say that N is the number of elements in this array.
  prefs: []
  type: TYPE_NORMAL
- en: However, our function ends up taking the same number of steps no matter what
    N is. Reading from the beginning, midpoint, and last indexes of an array each
    takes one step no matter the size of the array. Similarly, finding the array’s
    length and dividing it by 2 also takes one step.
  prefs: []
  type: TYPE_NORMAL
- en: Since the number of steps is constant—that is, it remains the same no matter
    what N is—this algorithm is considered O(1).
  prefs: []
  type: TYPE_NORMAL
