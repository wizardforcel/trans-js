- en: Hoisting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, variables and functions can be accessed *before* their actual
    declaration, and the term used to describe this in JavaScript is “**Hoisting**.”
  prefs: []
  type: TYPE_NORMAL
- en: “var” declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term “hoisting” is mostly associated with function declarations and variables
    declared with the “var” keyword. Let’s take a look at how *hoisting* is associated
    with the “var” variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the above code in the Replit below:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/hoisting-example1” />
  prefs: []
  type: TYPE_NORMAL
- en: The output of the above code shows *hoisting* in action. The first line in the
    above code outputs `undefined` on the console, but how is this possible? How are
    we able to access the `result` variable *before* it is actually declared on the
    second line?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is made possible because of the **parsing** step before the code is executed.
    The preprocessing of the JavaScript code before its execution allows the JavaScript
    engine to detect some errors early before any code is executed. The following
    code example shows this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the Replit to run the above code:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/hoisting-example2” />
  prefs: []
  type: TYPE_NORMAL
- en: Without any preprocessing of the code, the JavaScript engine cannot detect the
    syntax error inside the `print` function unless the function is invoked or called,
    and the above code should log “hello world” on the console without throwing any
    errors because the function containing the syntax error hasn’t been called. But
    the above code throws an error instead of logging “hello world” on the console.
    Why is that? The answer is the processing step before the code execution.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript engine scans the code before executing it, allowing it to detect
    some errors before any code is executed. This also enables the engine to handle
    variable declarations by registering the variables declared in the current scope.
    Before any scope starts, all the variables declared in that scope are registered
    for that scope. In other words, all the variables declared in a scope are reserved
    for that scope before the code in that scope is executed. This preprocessing of
    the code before its execution is what enables *hoisting*. This allows us to refer
    to “var” variables *before* they are actually declared in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Let us revisit the code example given above that logs `undefined` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the “var” variables are *hoisted*, and we can refer to them *before* their
    declaration, then why is `undefined` logged on the console instead of the actual
    value of the `result` variable, which should be 15?
  prefs: []
  type: TYPE_NORMAL
- en: The thing with the hoisting of the “var” variables is that only their **declaration**
    is hoisted, not their values. These variables are assigned the value of `undefined`,
    and the actual value, 15 in the above code example, is assigned when their declaration
    is executed during the step-by-step execution of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Function declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Function declarations, just like variables declared using the “var” keyword,
    are also hoisted. The following code example shows the hoisting of a function
    declaration in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the Replit to run the above code:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/hoisting-example4” />
  prefs: []
  type: TYPE_NORMAL
- en: If “var” variables are assigned a value of `undefined` before their declaration
    is executed, how are we able to call the function *before* its declaration? How
    is the hoisting of function declarations different from the hoisting of variables
    declared using the `var` keyword? The difference here is that in the case of function
    declarations, the function’s name is registered as a variable in the scope containing
    the function declaration, and it is initialized with the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: In the above code example, the `startCar` is registered as a variable in the
    global scope, and it is assigned the function. Unlike the “var” variables, there
    is no initialization with the `undefined` value in the case of function declarations.
  prefs: []
  type: TYPE_NORMAL
- en: It is hard to see how hoisting can be a useful feature for a programming language
    until we see the hoisting of function declarations. To be able to call a function
    before or after the function declaration is really useful and frees the developer
    from arranging the code in such a way that every function declaration comes *before*
    it is called. This helps in code organization, as we can declare functions together
    either at the top or at the bottom of the code file and call them from anywhere
    we want in that file.
  prefs: []
  type: TYPE_NORMAL
- en: Function declarations inside blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a long time, function declarations inside blocks weren’t part of the ECMAScript
    specification, but that changed with the introduction of ES2015\. Since the function
    declarations weren’t part of the specification before 2015 and were allowed in
    the language by the JavaScript engines, they were handled differently by different
    engines.
  prefs: []
  type: TYPE_NORMAL
- en: In ES2015, the ECMAScript specification defined **standard** and **legacy**
    rules for handling function declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Standard rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: According to the standard rules, the function declarations inside blocks are
    *hoisted* to the top of the block, converted into a function expression, and assigned
    to a variable declared with the `let` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The function hoisted inside the block is limited to the containing block and
    cannot be accessed by code outside the block containing the function.
  prefs: []
  type: TYPE_NORMAL
- en: :::note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the standard rules only come into effect in [strict
    mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  prefs: []
  type: TYPE_NORMAL
- en: ':::'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example will help you better understand the standard rules
    for function declarations inside blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the standard rules, the function inside the `if` block should
    be treated as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `fnInsideBlock` function in the above code can only be called from within
    the `if` block.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The [legacy rules](https://262.ecma-international.org/13.0/#sec-block-level-function-declarations-web-legacy-compatibility-semantics)
    are applied to the non-strict code in web browsers. According to the legacy rules,
    apart from a `let` variable for a function declaration inside a block, there is
    also a `var` variable in the containing function scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take the code example given in the above section and add the function
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the above code in the Replit below:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/hoisting-example7” />
  prefs: []
  type: TYPE_NORMAL
- en: As the above code is executed in strict mode, the standard rules apply; as a
    result, the above code throws an error because, as explained in the above section,
    the function inside the block is hoisted to the top of the containing scope and
    is only accessible inside that block. As a result, the function call outside the
    `if` block throws an error.
  prefs: []
  type: TYPE_NORMAL
- en: If the `"use strict"` directive is removed from the above code, it will execute
    without any error. Why is that? This is because, in non-strict mode, the legacy
    rules for function declarations in a block apply, and according to the legacy
    rules, the hoisted function inside the block is assigned to a `var` variable that
    is declared in the containing function scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above code, when executed in non-strict mode, is treated by the JavaScript
    engines as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a Replit demonstrating the above code:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/hoisting-example8” />
  prefs: []
  type: TYPE_NORMAL
- en: :::note
  prefs: []
  type: TYPE_NORMAL
- en: In the transformed code above, `fnInsideBlockVar` and `fnInsideBlock` are the
    same variables handled behind the scenes by the JavaScript engines. The names
    are shown to be different just for the sake of explaining how the function declarations
    in blocks are handled according to the legacy rules.
  prefs: []
  type: TYPE_NORMAL
- en: ':::'
  prefs: []
  type: TYPE_NORMAL
- en: Now, it should be clear why removing the “use strict” directive allows the code
    to be executed without any error. The hoisted function inside the block is assigned
    to a var variable defined in the function scope. As a result, the function inside
    the block is accessible outside the containing if block.
  prefs: []
  type: TYPE_NORMAL
- en: :::tip
  prefs: []
  type: TYPE_NORMAL
- en: The legacy rules are complicated and confusing; as a result, we shouldn’t rely
    on code that depends on the legacy rules for function declarations inside blocks.
    We should write code in strict mode to keep confusing complexities from entering
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: ':::'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[What are the precise semantics of block-level functions in ES6? - (stackoverflow
    post)](https://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Why does block assigned value change global variable? - (stackoverflow post)](https://stackoverflow.com/questions/61191014/why-does-block-assigned-value-change-global-variable)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Function declaration in block moving temporary value outside of block? - (stackoverflow
    post)](https://stackoverflow.com/questions/58619924/function-declaration-in-block-moving-temporary-value-outside-of-block)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like function declarations, class declarations are also hoisted, but they are
    hoisted *differently* compared to the function declarations.
  prefs: []
  type: TYPE_NORMAL
- en: While we can access a function declaration *before* its declaration, we cannot
    do the same in the case of class declarations. Doesn’t that mean that the class
    declarations aren’t hoisted? No, they are hoisted, but *differently*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first verify that class declarations are indeed hoisted with the help
    of the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a Replit demonstrating the above code:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/hoisting-example9” />
  prefs: []
  type: TYPE_NORMAL
- en: The above code throws an error that proves that the class declarations are indeed
    hoisted.
  prefs: []
  type: TYPE_NORMAL
- en: If the class declarations weren’t hoisted, then the `console.log` function call
    should have logged “Honda” to the console, but that isn’t the case, and that is
    because the class declaration inside the `if` block is hoisted and any code, before
    or after the `Car` declaration inside the block, that accesses `Car` will access
    the class declaration and not the `Car` variable declared above the `if` statement.
    The fact that the identifier `Car` inside the `if` block refers to the class declaration
    and not the `Car` variable declared before the `if` statement proves that the
    class declarations are indeed hoisted.
  prefs: []
  type: TYPE_NORMAL
- en: So, if class declarations are hoisted, then why can’t we access them *before*
    their declaration? The answer to this question is the “**Temporal Dead Zone (TDZ)**”.
  prefs: []
  type: TYPE_NORMAL
- en: Temporal Dead Zone (TDZ)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Temporal Dead Zone (TDZ)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz)
    refers to the time during which the block-scoped variables (`let`, `const`) or
    class declarations cannot be accessed. The time starts from the start of the scope
    till the declaration is executed. The following code example will help us visualize
    TDZ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: TDZ is the reason class declarations cannot be accessed before their declaration
    is executed during the step-by-step execution of the code.
  prefs: []
  type: TYPE_NORMAL
- en: let and const
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As TDZ also applies to the `let` and `const`, are the variables declared using
    `let` or constants using `const` also hoisted? Yes, they are also hoisted, but,
    like the class declarations, they are hoisted *differently* because of the TDZ.
  prefs: []
  type: TYPE_NORMAL
- en: :::info
  prefs: []
  type: TYPE_NORMAL
- en: It is a common misconception that block-scoped variables and constants are not
    hoisted, but as we discussed above, they are hoisted; it’s just that their hoisting
    is *different* as compared to the hoisting of variables declared using the `var`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: ':::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the above code example in action in the following Replit:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/hoisting-example11” />
  prefs: []
  type: TYPE_NORMAL
- en: Function and class expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function and class expression are not hoisted. Consider the following code
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the above code example in action in Replit:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/hoisting-example12” />
  prefs: []
  type: TYPE_NORMAL
- en: In the above code example, as the variables `Car` and `Person` have been declared
    using the `var` keyword, we can access them *before* their declaration, and their
    value are `undefined`. This is because only the declarations are hoisted, not
    their values. In the above code example, the values are expressions, and they
    are not hoisted.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to create an instance of the `Car` class or call the `Person` constructor,
    we will get an error. It is worth noting that the error we get in this case is
    not a reference error (an error that is thrown in the case of undeclared identifiers)
    but a type error, and this is because `Car` and `Person` are hoisted and initialized
    with the value of `undefined`, and we cannot call an `undefined` as a constructor
    function. Recall that only the declarations are hoisted in this case, not their
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Hoisting can be a confusing concept to wrap your head around, especially for
    beginners, because of the differences in which hoisting is associated with `var`
    variables, function declarations, and ES2015 changes, i.e., block-scoped variables/constants
    and ES2015 classes.
  prefs: []
  type: TYPE_NORMAL
- en: Common misconception about hoisting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many JavaScript beginners have a misconception about the concept of hoisting,
    and that is that the JavaScript engine *moves* the hoisted declarations to the
    top of the file. Although this makes it easy to understand the concept of hoisting,
    that is not the reality.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript engines don’t move the hoisted declarations to the top of the file.
    Instead, they simply process the declarations before the step-by-step execution
    of the code. In the case of `var` variables, they are assigned the value of `undefined`
    until their declaration is executed. In the case of block-scoped variables, they
    are marked as “uninitialized”.
  prefs: []
  type: TYPE_NORMAL
