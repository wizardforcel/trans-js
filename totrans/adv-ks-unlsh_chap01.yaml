- en: '`Hoisting`'
  id: totrans-0
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: In JavaScript, variables and functions can be accessed `before` their actual
    declaration, and the term used to describe this in JavaScript is `Hoisting`.
  id: totrans-1
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`var` declarations'
  id: totrans-2
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: The term “hoisting” is mostly associated with function declarations and variables
    declared with the `var` keyword. Let’s take a look at how `hoisting` is associated
    with the `var` variables.
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Consider the following code example:'
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can run the above code in the `Replit` below:'
  id: totrans-6
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/hoisting-example1" />`'
  id: totrans-7
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The output of the above code shows `hoisting` in action. The first line in the
    above code outputs `undefined` on the console, but how is this possible? How are
    we able to access the `result` variable `before` it is actually declared on the
    second line?
  id: totrans-8
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'This is made possible because of the `parsing` step before the code is executed.
    The preprocessing of the JavaScript code before its execution allows the JavaScript
    engine to detect some errors early before any code is executed. The following
    code example shows this in action:'
  id: totrans-9
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s the `Replit` to run the above code:'
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/hoisting-example2" />`'
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Without any preprocessing of the code, the JavaScript engine cannot detect the
    syntax error inside the `print` function unless the function is invoked or called,
    and the above code should log `hello world` on the console without throwing any
    errors because the function containing the syntax error hasn’t been called. But
    the above code throws an error instead of logging `hello world` on the console.
    Why is that? The answer is the processing step before the code execution.
  id: totrans-13
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The JavaScript engine scans the code before executing it, allowing it to detect
    some errors before any code is executed. This also enables the engine to handle
    variable declarations by registering the variables declared in the current scope.
    Before any scope starts, all the variables declared in that scope are registered
    for that scope. In other words, all the variables declared in a scope are reserved
    for that scope before the code in that scope is executed. This preprocessing of
    the code before its execution is what enables `hoisting`. This allows us to refer
    to `var` variables `before` they are actually declared in the code.
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Let us revisit the code example given above that logs `undefined` to the console.
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the `var` variables are `hoisted`, and we can refer to them `before` their
    declaration, then why is `undefined` logged on the console instead of the actual
    value of the `result` variable, which should be `15`?
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The thing with the hoisting of the `var` variables is that only their `declaration`
    is hoisted, not their values. These variables are assigned the value of `undefined`,
    and the actual value, `15` in the above code example, is assigned when their declaration
    is executed during the step-by-step execution of the code.
  id: totrans-18
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Function` declarations'
  id: totrans-19
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 'Function declarations, just like variables declared using the `var` keyword,
    are also hoisted. The following code example shows the hoisting of a function
    declaration in action:'
  id: totrans-20
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here’s the Replit to run the above code:'
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/hoisting-example4” />`'
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: If `var` variables are assigned a value of `undefined` before their declaration
    is executed, how are we able to call the function `before` its declaration? How
    is the hoisting of function declarations different from the hoisting of variables
    declared using the `var` keyword? The difference here is that in the case of function
    declarations, the function’s name is registered as a variable in the scope containing
    the function declaration, and it is initialized with the function itself.
  id: totrans-24
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In the above code example, the `startCar` is registered as a variable in the
    global scope, and it is assigned the function. Unlike the `var` variables, there
    is no initialization with the `undefined` value in the case of function declarations.
  id: totrans-25
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: It is hard to see how hoisting can be a useful feature for a programming language
    until we see the hoisting of function declarations. To be able to call a function
    `before` or `after` the function declaration is really useful and frees the developer
    from arranging the code in such a way that every function declaration comes `before`
    it is called. This helps in code organization, as we can declare functions together
    either at the top or at the bottom of the code file and call them from anywhere
    we want in that file.
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Function declarations inside blocks
  id: totrans-27
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: For a long time, function declarations inside blocks weren’t part of the ECMAScript
    specification, but that changed with the introduction of ES2015. Since the function
    declarations weren’t part of the specification before 2015 and were allowed in
    the language by the JavaScript engines, they were handled differently by different
    engines.
  id: totrans-28
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In ES2015, the ECMAScript specification defined `standard` and `legacy` rules
    for handling function declarations.
  id: totrans-29
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Standard rules
  id: totrans-30
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: According to the standard rules, the function declarations inside blocks are
    `hoisted` to the top of the block, converted into a function expression, and assigned
    to a variable declared with the `let` keyword.
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The function hoisted inside the block is limited to the containing block and
    cannot be accessed by code outside the block containing the function.
  id: totrans-32
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: :::note
  id: totrans-33
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: It is important to note that the standard rules only come into effect in [`strict
    mode`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: ':::'
  id: totrans-35
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The following code example will help you better understand the standard rules
    for function declarations inside blocks:'
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'According to the standard rules, the function inside the `if` block should
    be treated as shown below:'
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `fnInsideBlock` function in the above code can only be called from within
    the `if` block.
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Legacy rules
  id: totrans-41
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: The [legacy rules](https://262.ecma-international.org/13.0/#sec-block-level-function-declarations-web-legacy-compatibility-semantics)
    are applied to the non-strict code in web browsers. According to the legacy rules,
    apart from a `let` variable for a function declaration inside a block, there is
    also a `var` variable in the containing function scope.
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Let us take the code example given in the above section and add the function
    calls:'
  id: totrans-43
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can run the above code in the Replit below:'
  id: totrans-45
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: <ReplitEmbed src="https://replit.com/@newlineauthors/hoisting-example7" />
  id: totrans-46
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As the above code is executed in strict mode, the standard rules apply; as a
    result, the above code throws an error because, as explained in the above section,
    the function inside the block is hoisted to the top of the containing scope and
    is only accessible inside that block. As a result, the function call outside the
    `if` block throws an error.
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: If the `"use strict"` directive is removed from the above code, it will execute
    without any error. Why is that? This is because, in non-strict mode, the legacy
    rules for function declarations in a block apply, and according to the legacy
    rules, the hoisted function inside the block is assigned to a `var` variable that
    is declared in the containing function scope.
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The above code, when executed in non-strict mode, is treated by the JavaScript
    engines as shown below:'
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here’s a Replit demonstrating the above code:'
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: <ReplitEmbed src="https://replit.com/@newlineauthors/hoisting-example8" />
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: :::note
  id: totrans-53
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In the transformed code above, `fnInsideBlockVar` and `fnInsideBlock` are the
    same variables handled behind the scenes by the JavaScript engines. The names
    are shown to be different just for the sake of explaining how the function declarations
    in blocks are handled according to the legacy rules.
  id: totrans-54
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: ':::'
  id: totrans-55
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Now, it should be clear why removing the `"use strict"` directive allows the
    code to be executed without any error. The hoisted function inside the block is
    assigned to a `var` variable defined in the function scope. As a result, the function
    inside the block is accessible outside the containing `if` block.
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: :::tip
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The legacy rules are complicated and confusing; as a result, we shouldn’t rely
    on code that depends on the legacy rules for function declarations inside blocks.
    We should write code in strict mode to keep confusing complexities from entering
    our code.
  id: totrans-58
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: ':::'
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-60
  prefs:
  - PREF_H5
  stylish: true
  type: TYPE_NORMAL
- en: '[What are the precise semantics of block-level functions in ES6? - (stackoverflow
    post)](https://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6)'
  id: totrans-61
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '[Why does block assigned value change global variable? - (stackoverflow post)](https://stackoverflow.com/questions/61191014/why-does-block-assigned-value-change-global-variable)'
  id: totrans-62
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '[Function declaration in block moving temporary value outside of block? - (stackoverflow
    post)](https://stackoverflow.com/questions/58619924/function-declaration-in-block-moving-temporary-value-outside-of-block)'
  id: totrans-63
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Class declarations
  id: totrans-64
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 像函数声明一样，类声明也被提升，但与函数声明相比，它们是*以不同的方式*被提升的。
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 虽然我们可以在函数声明*之前*访问它，但在类声明的情况下我们不能这样做。这难道不意味着类声明没有被提升吗？不，它们是被提升的，但*以不同的方式*。
  id: totrans-66
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 让我们先通过以下代码示例验证类声明确实被提升：
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 这是一个展示上述代码的Replit：
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/hoisting-example9" />`'
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 上述代码抛出错误，证明类声明确实被提升。
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 如果类声明没有被提升，那么`console.log`函数调用应该在控制台打印“Honda”，但事实并非如此。这是因为`if`块中的类声明是被提升的，而任何在`Car`声明之前或之后访问`Car`的代码将会访问类声明，而不是在`if`语句之前声明的`Car`变量。`if`块中标识符`Car`指向类声明而不是在`if`语句之前声明的`Car`变量，这证明了类声明确实是被提升的。
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 所以，如果类声明是被提升的，为什么我们不能在其声明*之前*访问它们呢？这个问题的答案是“**Temporal Dead Zone (TDZ)**”。
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Temporal Dead Zone (TDZ)
  id: totrans-74
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: '[Temporal Dead Zone (TDZ)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz)指的是在块级作用域变量（`let`、`const`）或类声明无法被访问的时间。这个时间从作用域的开始到声明被执行的时间开始。以下代码示例将帮助我们可视化TDZ：'
  id: totrans-75
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: TDZ是类声明无法在其声明被执行之前被访问的原因，发生在代码逐步执行的过程中。
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`let`和`const`'
  id: totrans-78
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 由于TDZ也适用于`let`和`const`，那么使用`let`声明的变量或使用`const`声明的常量也被提升吗？是的，它们也是被提升的，但与类声明一样，它们的提升是*不同的*，因为TDZ的原因。
  id: totrans-79
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: :::info
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 这是一个常见的误解，认为块级作用域变量和常量没有被提升，但正如我们之前讨论的，它们是被提升的；只不过它们的提升与使用`var`关键字声明的变量相比是*不同的*。
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: ':::'
  id: totrans-82
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 你可以在以下Replit中查看上述代码示例的实际情况：
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/hoisting-example11" />`'
  id: totrans-85
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 函数和类表达式
  id: totrans-86
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 函数和类表达式没有被提升。考虑以下代码示例：
  id: totrans-87
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 这是上述代码示例在Replit中的实际情况：
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/hoisting-example12" />`'
  id: totrans-90
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在上述代码示例中，由于变量`Car`和`Person`是使用`var`关键字声明的，我们可以在它们的声明之前访问它们，并且它们的值为`undefined`。这是因为只有声明被提升，而不是它们的值。在上述代码示例中，值是表达式，并没有被提升。
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 如果我们尝试创建`Car`类的实例或调用`Person`构造函数，我们会遇到一个错误。值得注意的是，在这种情况下我们得到的错误不是引用错误（在未声明标识符的情况下抛出的错误），而是类型错误，这是因为`Car`和`Person`被提升并初始化为`undefined`，我们不能将`undefined`作为构造函数调用。请记住，在这种情况下只有声明被提升，而不是它们的值。
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 提升可能是一个让人感到困惑的概念，特别是对于初学者，因为提升与`var`变量、函数声明以及ES2015变化（即块作用域变量/常量和ES2015类）之间的差异。
  id: totrans-93
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 关于提升的常见误解
  id: totrans-94
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 许多JavaScript初学者对提升的概念有误解，认为JavaScript引擎*移动*了提升的声明到文件的顶部。虽然这使得理解提升的概念变得容易，但这并不是现实。
  id: totrans-95
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: JavaScript引擎不会将提升的声明移动到文件的顶部。相反，它们只是处理声明，然后逐步执行代码。在`var`变量的情况下，它们在声明被执行之前被赋值为`undefined`。在块作用域变量的情况下，它们被标记为“未初始化”。
  id: totrans-96
  prefs: []
  stylish: true
  type: TYPE_NORMAL
