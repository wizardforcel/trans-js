- en: An Algorithm of the Third Kind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, you learned that binary search on an ordered array
    is much faster than linear search on the same array. Let’s now look at how to
    describe binary search in terms of Big O notation.
  prefs: []
  type: TYPE_NORMAL
- en: We can’t describe binary search as being O(1), because the number of steps increases
    as the data increases. It also doesn’t fit into the category of O(N), since the
    number of steps is much fewer than the N data elements. As we have seen, binary
    search takes only seven steps for an array containing 100 elements.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search, then, seems to fall somewhere in between O(1) and O(N). So what
    is it?
  prefs: []
  type: TYPE_NORMAL
- en: In Big O terms, we describe binary search as having a time complexity of
  prefs: []
  type: TYPE_NORMAL
- en: O(log N).
  prefs: []
  type: TYPE_NORMAL
- en: I pronounce this as “Oh of log N.” This type of algorithm is also known as having
    a time complexity of log time.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, O(log N) is the Big O way of describing an algorithm that increases
    one step each time the data is doubled. As you learned in the previous chapter,
    binary search does just that. You’ll see momentarily why this is expressed as
    O(log N), but let’s first summarize what you’ve learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three types of algorithms you’ve learned about so far can be sorted from
    most efficient to least efficient as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: O(1)
  prefs: []
  type: TYPE_NORMAL
- en: O(log N)
  prefs: []
  type: TYPE_NORMAL
- en: O(N)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a graph that compares the three types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/big_o_notation/graph_three_types_fixed.png](images/big_o_notation/graph_three_types_fixed.png)'
  prefs: []
  type: TYPE_IMG
- en: Note how O(log N) curves ever so slightly upward, making it less efficient than
    O(1) but much more efficient than O(N).
  prefs: []
  type: TYPE_NORMAL
- en: To understand why this algorithm is called O(log N), you need to first understand
    what logarithms are. If you’re already familiar with this mathematical concept,
    feel free to skip the next section.
  prefs: []
  type: TYPE_NORMAL
