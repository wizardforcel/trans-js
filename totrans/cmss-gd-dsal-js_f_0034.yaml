- en: An Algorithm of the Third Kind
  id: totrans-0
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: In the previous chapter, you learned that binary search on an ordered array
    is much faster than linear search on the same array. Let’s now look at how to
    describe binary search in terms of `Big O` notation.
  id: totrans-1
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: We can’t describe binary search as being `O(1)`, because the number of steps
    increases as the data increases. It also doesn’t fit into the category of `O(N)`,
    since the number of steps is much fewer than the `N` data elements. As we have
    seen, binary search takes only seven steps for an array containing 100 elements.
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Binary search, then, seems to fall somewhere in between `O(1)` and `O(N)`. So
    what is it?
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In `Big O` terms, we describe binary search as having a time complexity of
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`O(log N)`.'
  id: totrans-5
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: I pronounce this as “Oh of log N.” This type of algorithm is also known as having
    a time complexity of `log time`.
  id: totrans-6
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Simply put, `O(log N)` is the `Big O` way of describing an algorithm that increases
    one step each time the data is doubled. As you learned in the previous chapter,
    binary search does just that. You’ll see momentarily why this is expressed as
    `O(log N)`, but let’s first summarize what you’ve learned so far.
  id: totrans-7
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The three types of algorithms you’ve learned about so far can be sorted from
    most efficient to least efficient as follows:'
  id: totrans-8
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`O(1)`'
  id: totrans-9
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`O(log N)`'
  id: totrans-10
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`O(N)`'
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Let’s look at a graph that compares the three types:'
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`![images/big_o_notation/graph_three_types_fixed.png](images/big_o_notation/graph_three_types_fixed.png)`'
  id: totrans-13
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: Note how `O(log N)` curves ever so slightly upward, making it less efficient
    than `O(1)` but much more efficient than `O(N)`.
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: To understand why this algorithm is called `O(log N)`, you need to first understand
    what logarithms are. If you’re already familiar with this mathematical concept,
    feel free to skip the next section.
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
