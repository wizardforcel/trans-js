- en: © 作者（们），独家许可给`Springer Fachmedien Wiesbaden GmbH`，`Springer Nature`的一部分 2024`J.
    L. Zuckarelli` 用`Python`和`JavaScript`学习编码 [https://doi.org/10.1007/978-3-658-42912-6_1](https://doi.org/10.1007/978-3-658-42912-6_1)
  id: totrans-0
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 1. 什么是编程？
  id: totrans-1
  prefs:
  - PREF_H1
  stylish: true
  type: TYPE_NORMAL
- en: '`Joachim L. Zuckarelli`^([1](#Aff2)  )(1)慕尼黑，德国概述'
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在本章中，我们将讨论编程是什么，以及我们为什么需要编程和程序员。我们将看到，编程是关于开发或实现逐步解决问题的策略，称为`算法`。然而，并非所有计算机能够解决的问题都适合使用严格的算法来处理；在`人工智能`（`AI`）领域，使用了其他方法，我们将在本章中也探讨这些方法。
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 1.1 神秘的力量——或：意识决定存在
  id: totrans-4
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 您的汽车、手机和洗衣机有什么共同点？它们当然是技术设备，都是工程的奇迹。但还有什么呢？
  id: totrans-5
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 它们都运行在软件上。正是软件赋予了它们生命，使您能够将这些设备用于它们被设计的目的。没有软件，这些设备只会是没有功能、没有价值的金属和塑料构造。
  id: totrans-6
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 我们看不见软件，但我们可以看到它的效果，这些效果通过其运行的物理设备，即`硬件`，来介导。如果您的汽车在滑溜的条件下开始打滑，而您能够及时拦住它并将其引导回稳定的方向，那么您就会感受到`电子稳定程序`（`ESP`）的效果。`ESP`不断检查汽车是否朝着您用方向盘设定的方向行驶，必要时进行调整，从而帮助您保持车辆的控制。这是一种您看不见但在需要时存在的强大助手。
  id: totrans-7
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 软件控制物理设备，并告诉它们该做什么。这个原则同样适用于您的汽车、洗衣机和手机。然而，运行在这些设备上的软件在功能上有两个关键的不同点：
  id: totrans-8
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`首先，`控制您的洗衣机或提供汽车辅助功能的软件功能非常有限，因为它只需用于特定目的。您可能不会想在洗衣机上写商业信函或硕士论文，因此没有软件可以让您这样做，而洗衣机缺乏必要的物理输入和输出系统。另一方面，手机、平板电脑和计算机（笔记本、台式机、服务器等）运行着更广泛的不同软件，因为这些设备的功能恰恰是运行程序。'
  id: totrans-9
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Secondly,` cars and washing machines once existed without software, functioning
    purely mechanically and electrically. A computer without software, however, would
    make no sense, because its central function is to execute programs.'
  id: totrans-10
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`The simple examples of the washing machine and the car show that software
    is capturing more and more devices that were previously operated without software.
    This increasing digitalization of the real world not only makes it possible to
    make more and more functions available on the devices or to execute previously
    existing functions more precisely, safely, quickly, or autonomously, but also
    to network different devices with each other. The Internet of Things is the modern
    buzzword here. When your refrigerator recognizes that the milk is about to run
    out and autonomously orders two cartons of milk online, because it knows that
    you need milk every morning to prepare your cereals, or when your house automatically
    raises the shutters because the weather forecast announces strong winds, then
    you get a sense the software working behind the scenes to make different devices
    work together for our benefit.`'
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Despite all the networking and all the supposed intelligence of everyday devices,
    when we think of “software” we naturally think of the classic computer and the
    software permanently installed on it, such as the operating system, the word processor
    or the web browser. In fact, however, almost everything we encounter on the Internet
    every day is ultimately software. Even static websites, as we know them from the
    early days of the World Wide Web and with which you can do nothing but look at
    them, are ultimately designed with a special, descriptive programming language
    (more on this below). Of course, there is software behind `dynamic` websites that
    respond to user input. When you post a message on Facebook or start a search query
    on Google, software is running, partly on your own computer, partly on the web
    server that provides the page.`'
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'With its increasing breadth of application and its ability to solve complex
    problems, software has undergone rapid development in recent decades. By contrast,
    things did not happen quite as rapidly in the early days of software: the first
    device on which a real program could run was the `Analytical Engine` of the English
    polymath `Charles Babbage` in the 1830s, a purely mechanical predecessor of the
    computer. The Italian mathematician `Federico Luigi Menabrea` and the British
    scholar `Augusta Ada Byron`, among others, wrote the first programs for this system.
    This activity earned `Byron` a reputation as the world’s first female programmer
    and made her a subject of pop culture. What was most remarkable about the software
    the two were developing at the time was that the hardware to go with it didn’t
    even exist at the time. The work of the two early programmers took place with
    paper and ink, for `Babbage`’s `Analytical Engine` was never built during his
    lifetime because the `British Association for the Advancement of Science`, which
    should have funded the project, found the cost too uncertain and the prospects
    for success too nebulous. In fact, a fully functional `Analytical Engine` was
    not built until the 1990s, when much more powerful computers had been available
    for decades.'
  id: totrans-13
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Punched cards were used to store the programs (and also the data with which
    they worked). This technique was first used at the beginning of the nineteenth
    century in the `Jacquard loom`, a weaving machine that could be “programmed” to
    weave certain patterns with the help of the punched cards.
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Here you can also see the parallel to our discussion about washing machines
    and computers: `Babbage`’s `Analytical Engine` was a system that was developed
    exclusively to run software, whereas the loom of the silk weaver `Joseph-Marie
    Jacquard` was, like the washing machine, a device that can basically fulfill its
    function without software, but which becomes more versatile and easier to use
    through programs.'
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 1.2 Algorithms
  id: totrans-16
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 'Software is ubiquitous these days. It controls the devices and tells them what
    to do. This is quite obvious with physical devices such as the washing machine,
    which masters a whole range of automatic washing programs, or your car, which
    maneuvers into a parking space completely independently thanks to the corresponding
    assistance function. But it’s the same with computer software: the software instructs
    the computer to display a `YouTube` video on the screen, for example, and play
    the appropriate sound through the speakers. Software allows you to use the keyboard
    to enter your `Twitter` password or click a button in word processing to put some
    words in `bold` type.'
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The software thus issues instructions to the devices. A set of several such
    instructions is called an `algorithm`.
  id: totrans-18
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: An algorithm is nothing more than a working instruction that explains how to
    achieve a certain goal step by step. We are familiar with algorithms from our
    everyday lives, even if we do not usually refer to the work rules and processes
    we encounter there as algorithms.
  id: totrans-19
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'One example of an everyday algorithm is a recipe to make a good basil pesto:'
  id: totrans-20
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-21
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: You need `80 g` of `pine nuts`, `4–5` bunches of `basil` (`pesto alla genovese`)
    and/or `rocket`, a clove of garlic, `50 g` of `Parmesan cheese`, `50 g` of `pecorino
    sardo` or `pecorino romano`, `180 mL` of `olive oil`, and `salt` (preferably coarse).
  id: totrans-22
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-23
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Wash the basil, pat dry and pluck off the leaves.
  id: totrans-24
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-25
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Peel the garlic clove, remove the germ and chop coarsely.
  id: totrans-26
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '4.'
  id: totrans-27
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Grate `parmesan` and `pecorino` (do not use cheese that has already been grated).
  id: totrans-28
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '5.'
  id: totrans-29
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Place the `pine nuts`, `garlic` and `basil leaves` in a mortar with the `salt`
    and crush finely.
  id: totrans-30
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '6.'
  id: totrans-31
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Mix in the cheese.
  id: totrans-32
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '7.'
  id: totrans-33
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Slowly add the olive oil, not too much at a time so you can work it into the
    mixture well.
  id: totrans-34
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: 'If you follow these instructions, you will end up with a good pesto made from
    the ingredients mentioned in the first step. Another example of algorithms that
    we encounter in everyday life all the time is the following:'
  id: totrans-35
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-36
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Head northwest on `W 31st St` toward `8th Ave`。
  id: totrans-37
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-38
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Go `184 ft`。
  id: totrans-39
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-40
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Turn right onto `8th Ave`。
  id: totrans-41
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '4.'
  id: totrans-42
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Go `0.7 mi`。
  id: totrans-43
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '5.'
  id: totrans-44
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Turn right on `W 44th St`。
  id: totrans-45
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '6.'
  id: totrans-46
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Go `0.2 mi`。
  id: totrans-47
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: 'This algorithm describes how to get from `Penn Station` to `Times Square` in
    `New York`。As a final example, here’s an everyday algorithm that describes getting
    up and getting ready on a normal workday: 1.  1.'
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Get up.
  id: totrans-49
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-50
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Brush teeth.
  id: totrans-51
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-52
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Shower.
  id: totrans-53
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '4.'
  id: totrans-54
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Get dressed.
  id: totrans-55
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '5.'
  id: totrans-56
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Stir instant coffee in cup.
  id: totrans-57
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '6.'
  id: totrans-58
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Drink from coffee cup until cup is empty.
  id: totrans-59
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '7.'
  id: totrans-60
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Put on shoes.
  id: totrans-61
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '8.'
  id: totrans-62
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: If it is cold, put on a jacket.
  id: totrans-63
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '9.'
  id: totrans-64
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Leave apartment.
  id: totrans-65
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '10.'
  id: totrans-66
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Lock the door.
  id: totrans-67
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: 'This algorithm differs from the previous two algorithms in that not all steps
    are always executed. Some steps (“… put on a jacket”) are only executed if certain
    conditions are met (“If it is cold …”). Other steps are repeated: step `6` says
    to drink from the coffee cup until the cup is empty. Conditions and repetitions
    (or “loops，” as the programmer would say) are important concepts of programming,
    which we will deal with in more detail later.'
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: You can see from the example of this simple instruction for getting up that
    we often use elements such as conditions and loops in our everyday algorithms,
    which are also used in programming. Basically, everyday algorithms and the algorithms
    that programmers develop are not that different. Nevertheless, there are some
    important differences.
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: But what are the differences between these everyday algorithms and the algorithms
    that are processed by computers? We have already said that everyday algorithms
    are not usually called “algorithms”—just look at the face of the chef in a restaurant
    when you compliment him after a delicious meal and let him know that “he really
    used an excellent `Tartufo` algorithm.”
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: But the differences between everyday algorithms and computer algorithms are
    even more profound. Computer algorithms run on the device `computer`; Everyday
    algorithms run on the “device human.” The “device human” is an intelligent system
    and automatically fills in gaps that the algorithm may have with what makes sense
    at that point. If, for example, the algorithm omits a trivial but obvious intermediate
    step that is vital, then we recognize this incompleteness and simply execute the
    missing step anyway, even though it is not specified in the algorithm. Computers
    don’t do that. Computers are machines that do exactly what they are told. They
    don’t think for themselves, and they don’t have any intelligence that would allow
    them to independently recognize incomplete instruction sets or errors in the algorithm
    and fill in or replace them with what makes sense at that point. That is why computer
    algorithms must be complete, with no errors. They must be incomparably more precise
    than algorithms designed to run on the “human device.” Everything must be described
    in detail so that the computer can correctly execute the algorithm.
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Although everyday algorithms and computer algorithms are fundamentally different
    in this respect, they have one thing in common: they are ultimately just a sequence
    of steps to achieve a certain goal, regardless of what that goal is—whether it’s
    to make a fabulous `pesto` or to make a `Facebook` post.'
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'This answers the basic question we ask in this chapter: Programming is nothing
    more and nothing less than the process of developing algorithms and writing them
    down so that the computer can execute them.'
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '1.3`Limits of Classical Algorithms`: The Playing Field of Artificial Intelligence'
  id: totrans-74
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 1.3.1`Only Apparently Intelligent`
  id: totrans-75
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: Computers can do many things very well that we humans find difficult or where
    we quickly reach our limits, as the German-born founder of PayPal, `Peter Thiel`,
    argues. They perform complicated calculations at breathtaking speed for hours
    on end without ever beginning to tire. Yet, `Thiel` continues, computers routinely
    fail at tasks that even toddlers can do effortlessly, such as the task of discerning
    whether or not the animal depicted in a YouTube video is a `cat`. Why is this
    seemingly simple problem so difficult for computers to master?
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Try writing down an algorithm that checks whether a picture shows a cat. You
    will probably start with the obvious features of a cat, such as the ears or whiskers.
    But you can’t just tell the computer, “See if there are pointed ears in the picture!.”
    How is it supposed to know what a pointy ear is? So you’re going to start describing
    pointy ears. You might approach the description problem with the geometric shape
    of a triangle. Color is certainly a good distinguishing characteristic as well.
    However, you will quickly discover that cat ears are not really quite triangular,
    even more so when the cat is filmed from the side. Also, your computer will very
    quickly mistake the gable of a gray and brown house with a thatched roof for a
    cat’s ear. The more you delve into describing what features a cat has and how
    they differ from similar features of other objects that are not cats, you’ll realize
    how incredibly hard it is to develop a real algorithm that can tell whether we’re
    dealing with a cat or not.
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Why is it so easy for us humans to recognize a cat? We always recognize the
    cat, even if we only see it from behind or against the light. The answer is simple:
    our brain does not work algorithmically. It does not execute a series of commands
    step by step to systematically solve the problem of “recognizing a cat.” It works
    completely differently.'
  id: totrans-78
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: An entire branch of computer science deals with the abstract reproduction of
    this functioning of the human brain in the computer. The ability of a computer
    to reproduce performances that we typically assume to require intelligence is
    consequently called `artificial intelligence` (AI).
  id: totrans-79
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Artificial intelligence` has become a buzzword, you hear about it everywhere
    and in all kinds of contexts. Many people are frightened by the idea that computers
    could be “intelligent.” An extensive range of exciting science fiction films teaches
    us that we should be careful what we develop in the field of `artificial intelligence`,
    after all, our creations could one day take control and make us redundant.'
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Recent developments provide reason not to dismiss such fears entirely as the
    pipe dreams of imaginative screenwriters. Until a few years ago, most experts
    assumed that there could only be `weak artificial intelligence` (as did the author
    when he developed an AI strategy for a company a few years ago). `Weak AI` means
    that a machine can perform only in some individual areas like a human. However,
    at the latest since developments such as `ChatGPT` by OpenAI, we have come much
    closer to a `strong` or `general artificial intelligence`，i.e., a system that
    can perform (at least) similarly to humans in practically all areas, and perhaps
    even shows creativity and has self-consciousness (whatever these two concepts
    actually mean). A `strong AI` would pass the famous `Turing Test` (named for British
    mathematician and computer scientist `Alan Turing`，1912–1954), in which human
    jurors were not able to decide if they are talking to a real person or an artificial
    intelligence. Until now, such systems, for which the android `Data` from the popular
    “Star Trek—The Next Generation” TV series is an impressive example, were indeed
    pure science fiction.
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: However, applications of `weak artificial intelligence` are still predominant
    at present. Advanced chess or Go computers beat any human player, no matter how
    brilliant, by a mile. (Semi-)autonomous driving would not be possible without
    `AI`-powered image recognition and the recognition of road conditions, road grids
    and any other current road users. Voice recognition, such as that offered by Apple’s
    `Siri` assistance system, is based on artificial intelligence, as is Google’s
    image search, or the mechanism that suggests `YouTube` videos that might interest
    you.
  id: totrans-82
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Some of these applications of artificial intelligence are quite controversial
    in the social debate, even if they do not come with the danger that world domination
    by highly intelligent machines will become a reality the day after tomorrow and
    that humans will be downgraded to useless bio-matter.
  id: totrans-83
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'There are at least five reasons for this:'
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-85
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Because artificial intelligence allows us to reproduce human performance, which
    we typically associate with intelligence, it opens up a wide field of applications
    that were previously reserved for human decision-making, evaluation and judgment.
    We do not feel comfortable delegating these decisions to basically unintelligent
    systems that only simulate the workings of human intelligence. After all, it is
    precisely the core idea of weak artificial intelligence that human intelligence
    performances are reproduced in a narrowly limited area, without causing real`thinking`
    in the machine. It is therefore not surprising that people are skeptical when
    they are suddenly expected to entrust their lives to an autonomously driven car,
    to rely on medical diagnoses made by “intelligent” software, or to accept judgments
    written by a specialized program as opposed to a human judge. However, the situation
    is put into perspective when one looks at other situations in history where technology
    suddenly took over the activities of humans. NASA’s Apollo 11 mission in 1969
    saw the first use of a control computer, initially much to the displeasure of
    the astronauts involved, who simply could not imagine putting their lives in the
    hands of the control program developed by the young mathematician, `Margaret Hamilton`
    and her team. In fact, the software did not control the spacecraft fully automatically
    as an autopilot but acted more like an assistance system for the human pilots,
    who were getting used to working with the new technology. So, habituation occurs
    when we realize that the systems are serving their purpose and we develop confidence
    in their`functioning,` even if we don’t really understand how they work.
  id: totrans-86
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-87
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: In addition to the necessary trust in their functionality, `ethical considerations`
    also pose a problem for applications of artificial intelligence. A classic, hypothetical
    example is the driverless car that, in a critical traffic situation, only has
    the choice between two situations that are, strictly speaking, morally unacceptable,
    either of which would result in the death or serious injury of another road user.
    This case can still be “solved” reasonably well by the car simply choosing the
    variant that gives the “affected” road user the highest chance of survival. In
    case of doubt, the autopilot assesses the situation considerably faster and better
    than the shocked and completely overwhelmed human driver. Nevertheless, there
    are more than a few who postulate, based on fundamental considerations, that such
    decisions should always be reserved for humans. The same is sometimes demanded
    for decisions in a social context, such as court judgments.
  id: totrans-88
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-89
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Artificial intelligence allows applications that can be used to exert `control
    over other people`, either through surveillance or by influencing our behavior.
    In the wrong hands, such technologies would be powerful tools for despots, autocrats,
    and even for democratic politicians in democratic political systems. The social
    debate about alleged vote-rigging in the `2016 presidential election` in the `United
    States` and the role of `social media` in democratic contestation are still comparatively
    benign examples of such phenomena.
  id: totrans-90
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '4.'
  id: totrans-91
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: The results that artificial intelligence produces depend heavily on the inputs
    with which it has been trained. This can lead to artificial intelligence delivering
    incorrect results or presenting facts in a distorted and biased way. The former
    is a problem that, for example, the creators of `ChatGPT` explicitly point out
    to their users. The latter has been criticized in particular in connection with
    (actually or supposedly) racist statements and connotations.
  id: totrans-92
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '5.'
  id: totrans-93
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Finally, not only since the rise of `ChatGPT` and its brethren it is likely
    that artificial intelligence will replace humans in some areas, leading to a social
    problem in that people will no longer be able to perform the work that they have
    been trained to do. This is considered a significant problem mainly because the
    first areas where artificial intelligence will replace humans completely will
    be those that are currently handled by people with rather low skills. These people,
    in turn, will find it more difficult to find alternative employment than higher-skilled
    people.
  id: totrans-94
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: So even if some applications of artificial intelligence are not without controversy,
    its spread and number of areas of application will continue to grow. The possibilities
    offered by artificial intelligence are simply too interesting and too tempting.
  id: totrans-95
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '1.3.2 `Cat or Not Cat`: That Is the Question Here'
  id: totrans-96
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 使用识别图片中猫的例子，我们已经建立了人工智能与传统算法的工作方式截然不同。实际上，许多人工智能方法并不采用算法步骤的序列，而是使用一种模仿人类大脑工作方式的模式识别形式。在这个过程中，信号通过几层人工“神经元”进行传递。由于有“神经元”，人们也称之为`neural
    network`。这些神经元像小网络节点一样相互连接。网络中任何连接的神经元都可以将信号脉冲传递给任何与之相连的其他神经元。是否发生这种传递，以及传递的强度，首先取决于相关神经元之间是否存在连接。如果存在，某个神经元传递给下一个神经元的脉冲强度则取决于这些神经元之间连接的“厚度”以及第一个神经元从其各自的“前身”接收到的信号强度。最后一层神经元是输出层。这是多层处理结果“显示”的地方。
  id: totrans-97
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在我们的猫的例子中，关于图像的信息，即每个像素的位置和颜色值，首先到达神经元的输入层。这些神经元根据连接的厚度和它们自身接收到的脉冲强度，将脉冲传递到下一层。在最后一层只有两个神经元，分别表示结果“猫”和“非猫”。因此，最终结果，即最终到达两个输出神经元的信号强度，显然取决于输入层（即我们分析的图像）中信号的分布以及神经元之间连接的厚度。但神经网络如何知道这些连接必须多厚才能最终识别出输入层中的图像是否代表一只猫呢？答案是：它不知道。我们必须告诉它。更准确地说，我们用猫的图像和不显示猫的图像“训练”网络。毕竟，我们知道最终哪个结果是正确的。借助于未训练（或至少尚未完全训练）的网络提供的结果和一个特殊的算法，可以对神经元之间的连接厚度进行最佳调整。之后，就进入下一个训练图像。经过时间的推移和数千张图像，神经网络在识别猫的图像方面变得越来越好。
  id: totrans-98
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The remarkable thing about this technique is that in the end we can’t tell why
    exactly the neural network is able to distinguish the cat images from the non-cat
    images in the first place. The network consists of a huge set of neurons and connections
    between those neurons, as well as the thicknesses of those connections (called
    `weights`). If you look at these parameters, you can’t tell from the neural network
    that it is designed to recognize a cat. In fact, we don’t have the slightest idea
    `why` the network works. The parameters simply emerged from the training sessions,
    they were determined by a very classical algorithm based on the difference between
    the result calculated by the network and the desired, that is, correct result,
    or readjusted step by step with each training image. Thus, the neural network
    is a black box. Whereas with a conventional algorithm we can understand exactly
    how it arrived at this or that result, with the neural network we see only a confusing
    set of parameters that cannot be interpreted in any meaningful way.
  id: totrans-99
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: For the sake of completeness, it should be mentioned that not all artificial
    intelligence approaches work with neural networks. For decades, there have been
    systems that provide the knowledge of an expert in a certain field on the basis
    of `if-then` rules and thus of conventional algorithms, and that practically support
    people in a question-and-answer game, for example in making a complicated medical
    diagnosis or in understanding the malfunction of an engine. These systems are
    also called `expert systems` because they have the knowledge of a human expert
    in this field documented in explicit rules.
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_NORMAL
