- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024J. L. ZuckarelliLearn coding with Python and JavaScript
    [https://doi.org/10.1007/978-3-658-42912-6_1](https://doi.org/10.1007/978-3-658-42912-6_1)
  prefs: []
  type: TYPE_NORMAL
- en: 1. What Is Programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1)München, GermanyOverview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will deal with what programming is and why we need programming
    and programmers in the first place. We will see that programming is about developing
    or implementing step-by-step problem-solving strategies called algorithms. However,
    not all types of problems that computers can solve are amenable to processing
    with strict algorithms; in the field of artificial intelligence (AI), other approaches
    are used, which we will also look at in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '1.1 The Mysterious Power—or: Consciousness Determines Being'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What do your car, your mobile phone and your washing machine have in common?
    They are, of course, technical devices and are all marvels of engineering. But
    what else?
  prefs: []
  type: TYPE_NORMAL
- en: They all run on software. It is the software that gives them life, that allows
    you to use the devices for the purpose for which they were built. Without software,
    all of these devices would simply be metal and plastic constructs with no function,
    no value.
  prefs: []
  type: TYPE_NORMAL
- en: We can’t see software, but we can see its effects, mediated by the physical
    devices, the *hardware*, on which it runs. If your car starts to slide in slippery
    conditions and you can intercept it and steer it back onto a stable course, then
    you feel the effects of the Electronic Stabilization Program (ESP). The ESP constantly
    checks whether the car is moving in the direction you have set with the steering
    wheel, readjusts it if necessary, and in this way helps you to keep the vehicle
    under control. A powerful helper that you can’t see but is there when you need
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The software controls the physical devices and tells them what to do. This
    principle applies equally to your car, your washing machine, and your mobile phone.
    Nevertheless, there are two key differences in terms of the software that runs
    on these devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '*First of all,* the software that controls your washing machine or provides
    the assistance functions of your car, for example, is very limited in functionality
    because it is only needed for a specific purpose. You probably won’t want to write
    your business letters or your master’s thesis on your washing machine, so there
    is no software that allows you to do that, and the washing machine lacks the physical
    input and output systems that would be necessary to do that. Mobile phones, tablets,
    and computers (laptops, desktops, servers, etc.), on the other hand, run a much
    wider range of different software, because the function of these devices is precisely
    to run programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Secondly,* cars and washing machines once existed without software, functioning
    purely mechanically and electrically. A computer without software, however, would
    make no sense, because its central function is to execute programs.'
  prefs: []
  type: TYPE_NORMAL
- en: The simple examples of the washing machine and the car show that software is
    capturing more and more devices that were previously operated without software.
    This increasing digitalization of the real world not only makes it possible to
    make more and more functions available on the devices or to execute previously
    existing functions more precisely, safely, quickly, or autonomously, but also
    to network different devices with each other. The Internet of Things is the modern
    buzzword here. When your refrigerator recognizes that the milk is about to run
    out and autonomously orders two cartons of milk online, because it knows that
    you need milk every morning to prepare your cereals, or when your house automatically
    raises the shutters because the weather forecast announces strong winds, then
    you get a sense the software working behind the scenes to make different devices
    work together for our benefit.
  prefs: []
  type: TYPE_NORMAL
- en: Despite all the networking and all the supposed intelligence of everyday devices,
    when we think of “software” we naturally think of the classic computer and the
    software permanently installed on it, such as the operating system, the word processor
    or the web browser. In fact, however, almost everything we encounter on the Internet
    every day is ultimately software. Even static websites, as we know them from the
    early days of the World Wide Web and with which you can do nothing but look at
    them, are ultimately designed with a special, descriptive programming language
    (more on this below). Of course, there is software behind *dynamic* websites that
    respond to user input. When you post a message on Facebook or start a search query
    on Google, software is running, partly on your own computer, partly on the web
    server that provides the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'With its increasing breadth of application and its ability to solve complex
    problems, software has undergone rapid development in recent decades. By contrast,
    things did not happen quite as rapidly in the early days of software: the first
    device on which a real program could run was the *Analytical Engine of* the English
    polymath *Charles Babbage* in the 1830s, a purely mechanical predecessor of the
    computer. The Italian mathematician *Federico Luigi Menabrea* and the British
    scholar *Augusta Ada Byron*, among others, wrote the first programs for this system.
    This activity earned Byron a reputation as the world’s first female programmer
    and made her a subject of pop culture. What was most remarkable about the software
    the two were developing at the time was that the hardware to go with it didn’t
    even exist at the time. The work of the two early programmers took place with
    paper and ink, for Babbage’s *Analytical Engine* was never built during his lifetime
    because the *British Association for the Advancement of Science*, which should
    have funded the project, found the cost too uncertain and the prospects for success
    too nebulous. In fact, a fully functional *Analytical Engine* was not built until
    the 1990s, when much more powerful computers had been available for decades.'
  prefs: []
  type: TYPE_NORMAL
- en: Punched cards were used to store the programs (and also the data with which
    they worked). This technique was first used at the beginning of the nineteenth
    century in the *Jacquard loom*, a weaving machine that could be “programmed” to
    weave certain patterns with the help of the punched cards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you can also see the parallel to our discussion about washing machines
    and computers: Babbage’s *Analytical Engine* was a system that was developed exclusively
    to run software, whereas the loom of the silk weaver *Joseph-Marie Jacquard* was,
    like the washing machine, a device that can basically fulfill its function without
    software, but which becomes more versatile and easier to use through programs.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 Algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Software is ubiquitous these days. It controls the devices and tells them what
    to do. This is quite obvious with physical devices such as the washing machine,
    which masters a whole range of automatic washing programs, or your car, which
    maneuvers into a parking space completely independently thanks to the corresponding
    assistance function. But it’s the same with computer software: the software instructs
    the computer to display a YouTube video on the screen, for example, and play the
    appropriate sound through the speakers. Software allows you to use the keyboard
    to enter your Twitter password or click a button in word processing to put some
    words in bold type.'
  prefs: []
  type: TYPE_NORMAL
- en: The software thus issues instructions to the devices. A set of several such
    instructions is called an algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm is nothing more than a working instruction that explains how to
    achieve a certain goal step by step. We are familiar with algorithms from our
    everyday lives, even if we do not usually refer to the work rules and processes
    we encounter there as algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example of an everyday algorithm is a recipe to make a good basil pesto:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need 80 g of pine nuts, 4–5 bunches of basil (pesto alla genovese) and/or
    rocket, a clove of garlic, 50 g of Parmesan cheese, 50 g of pecorino sardo or
    pecorino romano, 180 mL of olive oil, and salt (preferably coarse).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wash the basil, pat dry and pluck off the leaves.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Peel the garlic clove, remove the germ and chop coarsely.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Grate parmesan and pecorino (do not use cheese that has already been grated).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the pine nuts, garlic and basil leaves in a mortar with the salt and crush
    finely.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mix in the cheese.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '7.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Slowly add the olive oil, not too much at a time so you can work it into the
    mixture well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you follow these instructions, you will end up with a good pesto made from
    the ingredients mentioned in the first step.Another example of algorithms that
    we encounter in everyday life all the time is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Head northwest on W 31st St toward 8th Ave.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go 184 ft.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn right onto 8th Ave.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go 0.7 mi.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn right on W 44th St.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go 0.2 mi.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This algorithm describes how to get from Penn Station to Times Square in New
    York.As a final example, here’s an everyday algorithm that describes getting up
    and getting ready on a normal workday: 1.  1.'
  prefs: []
  type: TYPE_NORMAL
- en: Get up.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Brush teeth.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shower.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get dressed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stir instant coffee in cup.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drink from coffee cup until cup is empty.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '7.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put on shoes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '8.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is cold, put on a jacket.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '9.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave apartment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lock the door.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This algorithm differs from the previous two algorithms in that not all steps
    are always executed. Some steps (“… put on a jacket”) are only executed if certain
    conditions are met (“If it is cold …”). Other steps are repeated: step 6 says
    to drink from the coffee cup until the cup is empty. Conditions and repetitions
    (or “loops,” as the programmer would say) are important concepts of programming,
    which we will deal with in more detail later.'
  prefs: []
  type: TYPE_NORMAL
- en: You can see from the example of this simple instruction for getting up that
    we often use elements such as conditions and loops in our everyday algorithms,
    which are also used in programming. Basically, everyday algorithms and the algorithms
    that programmers develop are not that different. Nevertheless, there are some
    important differences.
  prefs: []
  type: TYPE_NORMAL
- en: But what are the differences between these everyday algorithms and the algorithms
    that are processed by computers? We have already said that everyday algorithms
    are not usually called “algorithms”—just look at the face of the chef in a restaurant
    when you compliment him after a delicious meal and let him know that “he really
    used an excellent Tartufo algorithm.”
  prefs: []
  type: TYPE_NORMAL
- en: But the differences between everyday algorithms and computer algorithms are
    even more profound. Computer algorithms run on the device computer; Everyday algorithms
    run on the “device human.” The “device human” is an intelligent system and automatically
    fills in gaps that the algorithm may have with what makes sense at that point.
    If, for example, the algorithm omits a trivial but obvious intermediate step that
    is vital, then we recognize this incompleteness and simply execute the missing
    step anyway, even though it is not specified in the algorithm. Computers don’t
    do that. Computers are machines that do exactly what they are told. They don’t
    think for themselves, and they don’t have any intelligence that would allow them
    to independently recognize incomplete instruction sets or errors in the algorithm
    and fill in or replace them with what makes sense at that point. That is why computer
    algorithms must be complete, with no errors. They must be incomparably more precise
    than algorithms designed to run on the “human device.” Everything must be described
    in detail so that the computer can correctly execute the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although everyday algorithms and computer algorithms are fundamentally different
    in this respect, they have one thing in common: they are ultimately just a sequence
    of steps to achieve a certain goal, regardless of what that goal is—whether it’s
    to make a fabulous pesto or to make a Facebook post.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This answers the basic question we ask in this chapter: Programming is nothing
    more and nothing less than the process of developing algorithms and writing them
    down so that the computer can execute them.'
  prefs: []
  type: TYPE_NORMAL
- en: '1.3 Limits of Classical Algorithms: The Playing Field of Artificial Intelligence'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1.3.1 Only Apparently Intelligent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computers can do many things very well that we humans find difficult or where
    we quickly reach our limits, as the German-born founder of PayPal, Peter Thiel,
    argues. They perform complicated calculations at breathtaking speed for hours
    on end without ever beginning to tire. Yet, Thiel continues, computers routinely
    fail at tasks that even toddlers can do effortlessly, such as the task of discerning
    whether or not the animal depicted in a YouTube video is a cat. Why is this seemingly
    simple problem so difficult for computers to master?
  prefs: []
  type: TYPE_NORMAL
- en: Try writing down an algorithm that checks whether a picture shows a cat. You
    will probably start with the obvious features of a cat, such as the ears or whiskers.
    But you can’t just tell the computer, “See if there are pointed ears in the picture!.”
    How is it supposed to know what a pointy ear is? So you’re going to start describing
    pointy ears. You might approach the description problem with the geometric shape
    of a triangle. Color is certainly a good distinguishing characteristic as well.
    However, you will quickly discover that cat ears are not really quite triangular,
    even more so when the cat is filmed from the side. Also, your computer will very
    quickly mistake the gable of a gray and brown house with a thatched roof for a
    cat’s ear. The more you delve into describing what features a cat has and how
    they differ from similar features of other objects that are not cats, you’ll realize
    how incredibly hard it is to develop a real algorithm that can tell whether we’re
    dealing with a cat or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is it so easy for us humans to recognize a cat? We always recognize the
    cat, even if we only see it from behind or against the light. The answer is simple:
    our brain does not work algorithmically. It does not execute a series of commands
    step by step to systematically solve the problem of “recognizing a cat.” It works
    completely differently.'
  prefs: []
  type: TYPE_NORMAL
- en: An entire branch of computer science deals with the abstract reproduction of
    this functioning of the human brain in the computer. The ability of a computer
    to reproduce performances that we typically assume to require intelligence is
    consequently called *artificial intelligence* (AI).
  prefs: []
  type: TYPE_NORMAL
- en: Artificial intelligence has become a buzzword, you hear about it everywhere
    and in all kinds of contexts. Many people are frightened by the idea that computers
    could be “intelligent.” An extensive range of exciting science fiction films teaches
    us that we should be careful what we develop in the field of artificial intelligence,
    after all, our creations could one day take control and make us redundant.
  prefs: []
  type: TYPE_NORMAL
- en: Recent developments provide reason not to dismiss such fears entirely as the
    pipe dreams of imaginative screenwriters. Until a few years ago, most experts
    assumed that there could only be *weak artificial intelligence* (as did the author
    when he developed an AI strategy for a company a few years ago). Weak AI means
    that a machine can perform only in some individual areas like a human. However,
    at the latest since developments such as *ChatGPT* by OpenAI, we have come much
    closer to a *strong* or *general artificial intelligence*, i.e., a system that
    can perform (at least) similarly to humans in practically all areas, and perhaps
    even shows creativity and has self-consciousness (whatever these two concepts
    actually mean). A strong AI would pass the famous *Turing Test* (named for British
    mathematician and computer scientist *Alan Turing*, 1912–1954), in which human
    jurors were not able to decide if they are talking to a real person or an artificial
    intelligence. Until now, such systems, for which the android *Data* from the popular
    “Star Trek—The Next Generation” TV series is an impressive example, were indeed
    pure science fiction.
  prefs: []
  type: TYPE_NORMAL
- en: However, applications of weak artificial intelligence are still predominant
    at present. Advanced chess or Go computers beat any human player, no matter how
    brilliant, by a mile. (Semi-)autonomous driving would not be possible without
    AI-powered image recognition and the recognition of road conditions, road grids
    and any other current road users. Voice recognition, such as that offered by Apple’s
    Siri assistance system, is based on artificial intelligence, as is Google’s image
    search, or the mechanism that suggests YouTube videos that might interest you.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these applications of artificial intelligence are quite controversial
    in the social debate, even if they do not come with the danger that world domination
    by highly intelligent machines will become a reality the day after tomorrow and
    that humans will be downgraded to useless bio-matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are at least five reasons for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because artificial intelligence allows us to reproduce human performance, which
    we typically associate with intelligence, it opens up a wide field of applications
    that were previously reserved for human decision-making, evaluation and judgment.
    We do not feel comfortable delegating these decisions to basically unintelligent
    systems that only simulate the workings of human intelligence. After all, it is
    precisely the core idea of weak artificial intelligence that human intelligence
    performances are reproduced in a narrowly limited area, without causing real *thinking
    in* the machine. It is therefore not surprising that people are skeptical when
    they are suddenly expected to entrust their lives to an autonomously driven car,
    to rely on medical diagnoses made by “intelligent” software, or to accept judgments
    written by a specialized program as opposed to a human judge. However, the situation
    is put into perspective when one looks at other situations in history where technology
    suddenly took over the activities of humans. NASA’s Apollo 11 mission in 1969
    saw the first use of a control computer, initially much to the displeasure of
    the astronauts involved, who simply could not imagine putting their lives in the
    hands of the control program developed by the young mathematician, *Margaret Hamilton*
    and her team. In fact, the software did not control the spacecraft fully automatically
    as an autopilot but acted more like an assistance system for the human pilots,
    who were getting used to working with the new technology. So, habituation occurs
    when we realize that the systems are serving their purpose and we develop confidence
    in their *functioning,* even if we don’t really understand how they work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition to the necessary trust in their functionality, *ethical considerations*
    also pose a problem for applications of artificial intelligence. A classic, hypothetical
    example is the driverless car that, in a critical traffic situation, only has
    the choice between two situations that are, strictly speaking, morally unacceptable,
    either of which would result in the death or serious injury of another road user.
    This case can still be “solved” reasonably well by the car simply choosing the
    variant that gives the “affected” road user the highest chance of survival. In
    case of doubt, the autopilot assesses the situation considerably faster and better
    than the shocked and completely overwhelmed human driver. Nevertheless, there
    are more than a few who postulate, based on fundamental considerations, that such
    decisions should always be reserved for humans. The same is sometimes demanded
    for decisions in a social context, such as court judgments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Artificial intelligence allows applications that can be used to exert *control
    over other people*, either through surveillance or by influencing our behavior.
    In the wrong hands, such technologies would be powerful tools for despots, autocrats,
    and even for democratic politicians in democratic political systems. The social
    debate about alleged vote-rigging in the 2016 presidential election in the United
    States and the role of social media in democratic contestation are still comparatively
    benign examples of such phenomena.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The results that artificial intelligence produces depend heavily on the inputs
    with which it has been trained. This can lead to artificial intelligence delivering
    incorrect results or presenting facts in a distorted and biased way. The former
    is a problem that, for example, the creators of *ChatGPT* explicitly point out
    to their users. The latter has been criticized in particular in connection with
    (actually or supposedly) racist statements and connotations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, not only since the rise of *ChatGPT* and its brethren it is likely
    that artificial intelligence will replace humans in some areas, leading to a social
    problem in that people will no longer be able to perform the work that they have
    been trained to do. This is considered a significant problem mainly because the
    first areas where artificial intelligence will replace humans completely will
    be those that are currently handled by people with rather low skills. These people,
    in turn, will find it more difficult to find alternative employment than higher-skilled
    people.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So even if some applications of artificial intelligence are not without controversy,
    its spread and number of areas of application will continue to grow. The possibilities
    offered by artificial intelligence are simply too interesting and too tempting.
  prefs: []
  type: TYPE_NORMAL
- en: '1.3.2 Cat or Not Cat: That Is the Question Here'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the example of recognizing a cat in a picture, we have established that
    artificial intelligence works in a completely different way to conventional algorithms.
    And indeed, many AI approaches do not work with an algorithmic sequence of steps,
    but with a form of pattern recognition that is modeled on the way the human brain
    works. In this process, signals are routed through several layers of artificial
    “neurons.” Because of the “neurons,” one also speaks of a *neural network*. These
    neurons are connected to other neurons like small network nodes. Any neuron connected
    in the network can pass on a signal impulse to any other neuron they are connected
    to. Whether this happens or not, and if so, how strongly, depends first of all
    on whether there is a connection at all between the neurons in question. If there
    is, the strength of the impulse that one neuron passes on to the next neuron depends
    on how “thick” the connection between the neurons is and how strong the signal
    is that the first neuron received from its respective “predecessor.” The final
    layer of neurons is the output layer. This is where the result of this multi-layer
    processing is “displayed.”
  prefs: []
  type: TYPE_NORMAL
- en: 'In our cat example, the information about the image, i.e., the individual pixels
    with their position in the image and their color values, hits the input layer
    of neurons. These pass the impulses on to the next layer, according to the thickness
    of the connections and the strength of the impulse they themselves received. In
    the last layer there are only two neurons, representing the results “cat” and
    “not cat.” So, the outcome, the strength of the signal that ends up with the two
    output neurons, obviously depends on the distribution of the signals in the input
    layer (that is, the image we are analyzing) and the thickness of the connections
    between the neurons. But how does the neural network know how thick these connections
    must be so that in the end it can recognize whether the image we feed into the
    input layer represents a cat or not? Answer: It doesn’t. We have to tell it. More
    precisely, we “train” the network with cat images and images that don’t show cats.
    After all, we know which result is the correct one in the end. With the help of
    the result, which the untrained (or at least not yet fully trained) network delivers,
    and a special algorithm, the connection thicknesses between the neurons can be
    optimally adjusted. After that, it’s on to the next training image. Over time
    and thousands of images, the neural network becomes better and better at recognizing
    the cat images.'
  prefs: []
  type: TYPE_NORMAL
- en: The remarkable thing about this technique is that in the end we can’t tell why
    exactly the neural network is able to distinguish the cat images from the non-cat
    images in the first place. The network consists of a huge set of neurons and connections
    between those neurons, as well as the thicknesses of those connections (called
    weights). If you look at these parameters, you can’t tell from the neural network
    that it is designed to recognize a cat. In fact, we don’t have the slightest idea
    *why* the network works. The parameters simply emerged from the training sessions,
    they were determined by a very classical algorithm based on the difference between
    the result calculated by the network and the desired, that is, correct result,
    or readjusted step by step with each training image. Thus, the neural network
    is a black box. Whereas with a conventional algorithm we can understand exactly
    how it arrived at this or that result, with the neural network we see only a confusing
    set of parameters that cannot be interpreted in any meaningful way.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of completeness, it should be mentioned that not all artificial
    intelligence approaches work with neural networks. For decades, there have been
    systems that provide the knowledge of an expert in a certain field on the basis
    of if-then rules and thus of conventional algorithms, and that practically support
    people in a question-and-answer game, for example in making a complicated medical
    diagnosis or in understanding the malfunction of an engine. These systems are
    also called *expert systems* because they have the knowledge of a human expert
    in this field documented in explicit rules.
  prefs: []
  type: TYPE_NORMAL
