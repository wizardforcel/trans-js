- en: What is JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Course Overview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript is arguably the most widely used programming language on the planet,
    and there is a vast amount of content available for learning JavaScript. The problem
    is that not all the content on the internet does a good job of explaining the
    complex or confusing concepts of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: This course aims to teach different concepts in JavaScript that are not easy
    to grasp, especially for beginners. Topics like closures, coercion, the asynchronous
    nature of JavaScript, etc., are examples of topics that most beginners struggle
    with because they are not easy to understand. The goal of this course is to provide
    in-depth, easy-to-understand explanations of such confusing topics.
  prefs: []
  type: TYPE_NORMAL
- en: Even those who have been working with JavaScript for a few years might need
    help understanding some of the concepts covered in this course or might have some
    gaps in their understanding. The goal of this course is to fill those gaps.
  prefs: []
  type: TYPE_NORMAL
- en: This course will not only provide easy-to-understand explanations of fundamental
    JavaScript topics like hoisting, coercion, event loop, etc., but will also cover
    advanced topics like promises and async-await syntax in a way that will be easy
    for the students to understand.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this course, students will have a deep understanding of the concepts
    covered in this course. They will become better at JavaScript by having a solid
    understanding of the topics that most JavaScript beginners struggle with. Students
    will be able to debug JavaScript code better and avoid common pitfalls by having
    a deep understanding of fundamental but confusing JavaScript topics.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This course assumes that students have a basic understanding of JavaScript and
    programming in general. Understanding of topics like variables, loops, objects,
    arrays, functions, etc., is assumed.
  prefs: []
  type: TYPE_NORMAL
- en: Running code examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can download code examples from the same place where you purchased this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: If you have any trouble finding or downloading the code examples, email us at
    [us@fullstack.io](mailto:us@fullstack.io).
  prefs: []
  type: TYPE_NORMAL
- en: Who is this course for?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The course is for those who:'
  prefs: []
  type: TYPE_NORMAL
- en: are struggling to have a deep understanding of JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: understand fundamental to advanced JavaScript concepts but want to fill gaps
    in their understanding of different JavaScript topics that are key to becoming
    a good JavaScript developer (topics like closures, coercion, event loop, asynchronous
    JavaScript, promises, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: want to understand JavaScript in-depth and get better at working with JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: want to get better at debugging JavaScript and preparing for job interviews,
    as this course will provide a deeper understanding of the JavaScript language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: want to solidify their understanding of JavaScript’s fundamental topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: want to avoid frustration due to a lack of understanding of JavaScript’s confusing
    topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: want to excel in working with JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This course is unlike online articles/blogs and many JavaScript video courses
    that either fail to provide in-depth, easy-to-understand explanations of JavaScript
    topics that are not easy for beginners to understand or do not cover all the necessary
    topics (fundamental to advanced) that a good JavaScript developer must understand.
  prefs: []
  type: TYPE_NORMAL
- en: This course combines fundamental but confusing JavaScript topics in a single
    course that aims to provide a solid understanding to the students and cover all
    the topics that are key to understanding JavaScript in depth.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is currently the most widely used programming language. With the
    rise of modern front-end frameworks and platforms like Node.js, it seems that
    JavaScript will be the most used programming language for the foreseeable future.
  prefs: []
  type: TYPE_NORMAL
- en: It is the programming language of the web, most commonly used to add interactivity
    to web pages. With the help of technologies like Node.js, which allow us to write
    JavaScript outside the browser environment, software developers can now write
    full-stack applications by learning just one programming language.
  prefs: []
  type: TYPE_NORMAL
- en: So, how did this programming language that we know today come into existence?
    Let’s take a brief tour of its history.
  prefs: []
  type: TYPE_NORMAL
- en: History of JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the early days of web browsers, web pages could only be static, without any
    dynamic behavior or interactivity. A server was needed for simple things like
    form input validations. With limited internet speeds in those days, requiring
    a roundtrip to the server just for input validation was highly undesirable.
  prefs: []
  type: TYPE_NORMAL
- en: There was a need for a client-side scripting language that allowed us to add
    interactivity to web pages. In 1995, a software developer at Netscape began working
    on such a language, initially called “mocha,” which was later changed to “LiveScript.”
  prefs: []
  type: TYPE_NORMAL
- en: This language was supposed to be part of the Netscape Navigator 2 browser, but
    just before the release of the browser, LiveScript was renamed to “JavaScript.”
  prefs: []
  type: TYPE_NORMAL
- en: When Netscape released its Netscape Navigator 3 browser, Microsoft came up with
    its web browser known as Internet Explorer 3, which included Microsoft’s implementation
    of the JavaScript language.
  prefs: []
  type: TYPE_NORMAL
- en: 'This presented a problem: there were now two separate implementations of the
    JavaScript language. There was a need for a standards body that was responsible
    for the advancement of the JavaScript language.'
  prefs: []
  type: TYPE_NORMAL
- en: Standardization of the JavaScript language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem of multiple versions of JavaScript led Netscape to submit the JavaScript
    language as a proposal to Ecma International, a standards organization.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is standardized as “ECMAScript” and its standard is [ECMA-262](https://www.ecma-international.org/publications-and-standards/standards/ecma-262/).
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the previous lesson, the initial name for JavaScript was Mocha,
    which was later changed to LiveScript, and just before the release of the Netscape
    Navigator 2 browser, the name was changed to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: So what’s the reason behind using the word “Java” inside the name “JavaScript”
    when there was already a popular programming language named “Java”?
  prefs: []
  type: TYPE_NORMAL
- en: This question of whether these two languages are related to each other arises
    in the mind of almost every person who is already familiar with one of these two
    languages and comes across the other language.
  prefs: []
  type: TYPE_NORMAL
- en: It was just a **marketing move**. Java was popular at that time, and Netscape
    wanted to cash in on the popularity of the Java language. That is why Netscape
    renamed the language from LiveScript to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from some similarities in the syntax and, of course, in the name of both
    languages, the two languages are very different from each other.
  prefs: []
  type: TYPE_NORMAL
- en: Ecma International, TC39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript is standardized as **ECMAScript** by **Ecma International**, a standards
    organization.
  prefs: []
  type: TYPE_NORMAL
- en: Within Ecma International, people responsible for developing the JavaScript
    language are part of the **Technical Committee 39** (TC39). This committee consists
    of different stakeholders from the JavaScript community. Mostly people from big
    companies like Google, Microsoft, etc. are part of this group.
  prefs: []
  type: TYPE_NORMAL
- en: Other people can become part of TC39 as well and make their contribution in
    the development of the JavaScript language. Details of how anyone can either contribute
    or be part of TC39 meetings as a member can be found on the [TC39 website](https://tc39.es/).
  prefs: []
  type: TYPE_NORMAL
- en: TC39 also has a [GitHub account](https://github.com/tc39) which hosts multiple
    repositories related to their work. Repositories include notes from TC39 meetings,
    different proposals for the JavaScript language, details of how TC39 works, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Proposals process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TC39 has a well-defined process through which proposals are passed before they
    can be added to the ECMAScript specification and ultimately be part of the JavaScript
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each proposal is passed through five stages which are mentioned below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![process stages](images/module_01----lesson_01.04----public----assets----proposal-stages.png)'
  prefs: []
  type: TYPE_IMG
- en: process stages
  prefs: []
  type: TYPE_NORMAL
- en: Stage 0
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first stage represents someone’s idea that they think is worthy of being
    part of the JavaScript language.
  prefs: []
  type: TYPE_NORMAL
- en: Not all proposals at this stage move to the next stage, but the ones that do
    are the ones that gain enough interest and have a TC39 committee member who is
    willing to work on the idea. Proposals at this stage that gain enough interest
    are discussed in the TC39 meeting. If the discussion goes well, the proposal is
    moved to the next stage.
  prefs: []
  type: TYPE_NORMAL
- en: Stage 1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Proposals at this stage are discussed and developed by the community (including
    non-committee members), and if the proposal still has enough interest and is thought
    to have potential benefit if added to the specification, initial specification
    language and API are developed and discussed in the TC39 meeting. Provided everything
    goes well, the proposal is moved to the next stage.
  prefs: []
  type: TYPE_NORMAL
- en: Stage 2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At this stage, the API, syntax, and so on are refined and described in greater
    detail using the formal specification language. Polyfills and Babel plugins may
    be developed at this stage for real-world experimentation with the solution of
    the proposal.
  prefs: []
  type: TYPE_NORMAL
- en: Once the proposal has been described in enough detail, it can be considered
    for the next stage.
  prefs: []
  type: TYPE_NORMAL
- en: Stage 3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Proposals at this stage are almost ready to be included in the ECMAScript specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'For proposals to be moved to the final stage, they need to meet the following
    two criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: a suite of tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: two compatible implementations of the proposal that passed the tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the conditions mentioned above are met, and the committee has a consensus
    that the proposal is ready to be part of the ECMAScript specification, it is moved
    to the next stage.
  prefs: []
  type: TYPE_NORMAL
- en: Stage 4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At this stage, the proposal is complete and is ready to be included in the ECMAScript
    specification and ultimately be added to the JavaScript language.
  prefs: []
  type: TYPE_NORMAL
- en: A pull request is generated to the ecma262 GitHub repository to include it in
    the specification. Once the pull request is approved, the proposal is part of
    the specification and ready to be implemented in the JavaScript engines that still
    need to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: For further details of this process, refer to a [process document](https://tc39.es/process-document/)
    on TC39’s website, which explains the various stages through which proposals pass
    through.
  prefs: []
  type: TYPE_NORMAL
- en: Track upcoming features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Additions to the JavaScript language in recent years have completely transformed
    JavaScript into a programming language, and sometimes, it can be hard to stay
    updated with the new additions to the language.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping ourselves updated with new changes is one thing, but how can we track
    changes that could potentially be part of JavaScript in the future?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this question lies in [TC39’s GitHub repository](https://github.com/tc39),
    which contains [meeting notes](https://github.com/tc39/notes) and [proposals](https://github.com/tc39/proposals)
    that are at various stages of the proposal process described in the earlier lesson.
  prefs: []
  type: TYPE_NORMAL
- en: Notes and proposal repositories are a great place to keep track of upcoming
    changes, and in general, the TC39 GitHub repository is useful for tracking the
    work that the TC39 committee is doing.
  prefs: []
  type: TYPE_NORMAL
- en: How is ECMAScript versioned?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ECMAScript version 5, also known as “ES5”, came out in 2009, and until that
    point, the ECMAScript specification was referred to by its **edition** number,
    but with the introduction of ECMAScript’s 6th edition, also known as “ES6”, TC39
    added the **year** number in the language’s name.
  prefs: []
  type: TYPE_NORMAL
- en: As the 6th edition came out in the year 2015, it was “ECMAScript 2015”, “ES2015”
    for short. The later editions were also named using the year number in which they
    came out, e.g., “ES2016”, etc.
  prefs: []
  type: TYPE_NORMAL
- en: You will also see these editions referred to as “ES6”, “ES7”, etc., and this
    naming convention is also fine to use. Which one you choose is up to your preference.
    Most of the time, you will see both types of names used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this writing, **ECMAScript 2023** is the latest edition of ECMAScript.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is thought of as an “interpreted” language by many because of the
    nature of how it is executed, but calling JavaScript just an “interpreted” language
    is not entirely true.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of compiled languages, compilers usually compile the source code
    and produce a binary executable file, which can then be distributed and executed.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in the case of interpreted languages, interpreters do not
    produce an executable output file; unlike compilers, which compile the source
    code ahead of time, interpreters read and execute code on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of JavaScript, the JavaScript engines do not output an executable
    file, which is one of the reasons it is thought of as an interpreted language.
  prefs: []
  type: TYPE_NORMAL
- en: However, the JavaScript code is *compiled* into an intermediary form known as
    **byte code**, which is then executed by the virtual machine. The virtual machine
    **interprets** byte code, but modern JavaScript engines don’t just interpret the
    byte code; they include what’s known as the “**Just-in-time (JIT) compiler**”
    to compile the byte code into native machine code, which is executed at a faster
    speed than the byte code.
  prefs: []
  type: TYPE_NORMAL
- en: JIT Compiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just-in-time (JIT) compilation is a technique used by many modern JavaScript
    engines to increase the execution speed of the JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript code is converted into byte code, and the JavaScript engine then
    executes this byte code. However, modern JavaScript engines perform many optimizations
    to increase the performance of JavaScript code. These optimizations are performed
    based on the information collected by the engine while it is executing the code.
  prefs: []
  type: TYPE_NORMAL
- en: One way to optimize performance is to compile byte code into machine code, which
    executes faster than the byte code. The JavaScript engine identifies the “hot”
    parts of the code to do this - parts that are being executed frequently.
  prefs: []
  type: TYPE_NORMAL
- en: These “hot” parts of the code are then compiled into native machine code, and
    this machine code is then executed instead of the corresponding byte code.
  prefs: []
  type: TYPE_NORMAL
- en: So how is the JIT compiler different from a traditional compiler used by languages
    like C++? Unlike traditional compilers, which compile the code ahead of time,
    the JIT compiler compiles the code at runtime while the code is being executed.
  prefs: []
  type: TYPE_NORMAL
- en: While Javascript code is still distributed in source code format rather than
    executable format, it is compiled into byte code and possibly native machine code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, coming back to the question: is JavaScript a compiled or interpreted language?
    It is safe to say that it is both - **compiled as well as an interpreted language**.'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t necessarily need to understand the nitty-gritty details of how exactly
    the JavaScript code that we write is executed, but to develop a good understanding
    of the language; it is important to have a basic understanding of how our JavaScript
    code gets transformed into something that a machine can understand and execute.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to understand what different things come into play while
    our code is executing; concepts like “**execution context**,” “**call stack**,”
    etc. are crucial to understanding the JavaScript language’s runtime behavior and
    being able to work with it and debug it efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To execute JavaScript code, we need another software known as a **JavaScript
    engine**. This engine contains all the necessary components to transform the code
    into something the machine can execute.
  prefs: []
  type: TYPE_NORMAL
- en: Different browser vendors typically create JavaScript engines; each major vendor
    has developed a JavaScript engine that executes the JavaScript code in their browser.
  prefs: []
  type: TYPE_NORMAL
- en: The following table shows some major browsers and their JavaScript engines.
  prefs: []
  type: TYPE_NORMAL
- en: '| Browser | Engine |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Google Chrome | V8 |'
  prefs: []
  type: TYPE_TB
- en: '| Edge | Chakra |'
  prefs: []
  type: TYPE_TB
- en: '| Mozilla Firefox | Spider Monkey |'
  prefs: []
  type: TYPE_TB
- en: '| Safari | JavaScriptCore |'
  prefs: []
  type: TYPE_TB
- en: While there are differences in the steps taken by each JavaScript engine to
    execute the JavaScript code, the major steps taken by each engine are more or
    less the same and we will try to have a high-level overview of how our code gets
    transformed and executed by the JavaScript engines by understanding the Google
    Chrome’s **V8** engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the high-level overview of the execution pipeline
    of the V8 engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![process stages](images/module_01----lesson_01.08----public----assets----v8-execution-pipeline.png)'
  prefs: []
  type: TYPE_IMG
- en: process stages
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript engine is complicated software that contains lots of steps and
    components that are used to transform and execute the JavaScript code, but the
    above image shows a simplified version of the execution pipeline of the V8 engine.
  prefs: []
  type: TYPE_NORMAL
- en: ':::note Please note that the team working on the V8 engine is continuously
    improving it; as a result, the simplified execution pipeline shown in the image
    above may change in the future. :::'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get a better understanding of how the execution pipeline shown above works
    by understanding what happens at each step of this pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Source Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before the JavaScript engine can begin its work, the source code needs to be
    downloaded from some source. This can either be from the network, a cache, or
    a service worker that pre-fetched the code.
  prefs: []
  type: TYPE_NORMAL
- en: The engine itself doesn’t have the capability to download the code. The browser
    does it and then passes it to the engine, which can then begin transforming it
    and eventually execute it.
  prefs: []
  type: TYPE_NORMAL
- en: Parser
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After downloading the source code, the next step is to transform it into **tokens**.
    Think of this step as identifying different parts of the code; for example, the
    word “function” is one token that is identified as a “keyword.” Other tokens may
    include a string, an operator, etc. This process of dividing the code into tokens
    is done by a “scanner,” and this process is known as “**tokenization**.”
  prefs: []
  type: TYPE_NORMAL
- en: 'The following JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be tokenized as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once the tokens have been generated, the parser uses them to generate an [Abstract
    Syntax Tree (AST)](https://en.wikipedia.org/wiki/Abstract_syntax_tree), a set
    of objects that represent the structure of the source code.
  prefs: []
  type: TYPE_NORMAL
- en: '[AST Explorer](https://astexplorer.net/) is a cool website that you can use
    to visualize the AST. Go ahead and paste the code above in the AST explorer and
    explore the generated AST.'
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **Bytecode Generator** uses the AST produced by the parser to generate the
    bytecode. This generated bytecode is taken by the **Bytecode Interpreter**, which
    then interprets it.
  prefs: []
  type: TYPE_NORMAL
- en: V8 also passes the generated bytecode through some optimizers, which perform
    some optimizations to ensure efficient execution of the bytecode by the Bytecode
    Interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While the bytecode is executed, the JavaScript engine collects information about
    the code being executed. The engine then uses this information to optimize the
    code further.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the JavaScript engine can identify the parts of code that are being
    executed frequently, also known as the “hot” parts of the code. The “hot” parts
    of the code are then compiled into native machine code to ensure that these parts
    get executed as fast as possible.
  prefs: []
  type: TYPE_NORMAL
- en: However, the optimized native machine code sometimes has to be deoptimized back
    to the bytecode generated by the Bytecode Generator because of the way the code
    was written.
  prefs: []
  type: TYPE_NORMAL
- en: The need for falling back to the bytecode arises from the fact that JavaScript
    is a [dynamically typed](https://developer.mozilla.org/en-US/docs/Glossary/Dynamic_typing)
    language. The dynamic nature means that we can call a particular JavaScript function
    with different kinds of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The above function can be called with different “shapes” of objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that if the `print` function is called multiple times with objects
    with the following shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: and if it is compiled to native machine code, but then if the same function
    is called with an object with a *different* shape, the JavaScript engine cannot
    use the optimized machine code and has to fall back to the bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: The optimized native machine code is generated using the information collected
    during the execution of the JavaScript code. The native machine code requires
    certain checks to ensure that the assumptions made during the generation of the
    native machine code are not violated. If the checks fail, the JavaScript engine
    has to execute the bytecode instead of the native machine code. This process is
    called **deoptimization**.
  prefs: []
  type: TYPE_NORMAL
- en: 'References:'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following resources can be used to learn more about how the JavaScript
    code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Understanding the V8 JavaScript Engine - (freeCodeCamp talk by Lydia Hallie)](https://www.youtube.com/watch?v=xckH5s3UuX4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How JavaScript Works: Under the Hood of the V8 Engine - (freeCodeCamp blog)](https://www.freecodecamp.org/news/javascript-under-the-hood-v8/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What does V8’s ignition really do? - (stackoverflow post)](https://stackoverflow.com/questions/54957946/what-does-v8s-ignition-really-do)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ignition - an interpreter for V8 - (youtube video)](https://www.youtube.com/watch?v=r5OWCtuKiAk)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blazingly fast parsing, part 1: optimizing the scanner - (V8 blog)](https://v8.dev/blog/scanner)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Overhead of Deoptimization Checks in the V8 JavaScript Engine - (paper by
    Dept. of Computer Engineering, University of California)](https://masc.soe.ucsc.edu/docs/iiswc16.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever any JavaScript code is executed, it is executed inside an environment.
    By “environment”, I mean everything that is accessible by the code that aids in
    its execution. For example, the value of `this`, variables in the current scope,
    function arguments, etc. This environment is known as the “**Execution Context**”.
    Every time any JavaScript code is executed, an execution context is created before
    its execution.
  prefs: []
  type: TYPE_NORMAL
- en: :::note
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the concept of execution context lays the foundation for understanding
    other JavaScript concepts like *hoisting*, *closures*, etc. These topics will
    be covered in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: ':::'
  prefs: []
  type: TYPE_NORMAL
- en: Types of execution contexts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are two main types of execution contexts that we will discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: Global execution context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function execution context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: :::info
  prefs: []
  type: TYPE_NORMAL
- en: There is a third type of execution context that is created for the execution
    of code inside the [eval](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)
    function. Still, as the use of the `eval` function is discouraged due to security
    concerns, we will only discuss the types of execution context mentioned above.
  prefs: []
  type: TYPE_NORMAL
- en: ':::'
  prefs: []
  type: TYPE_NORMAL
- en: Global execution context
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The global execution context is the base context created whenever JavaScript
    code is loaded for execution. Global code, i.e., the code that is not inside a
    function, is executed inside a global execution context.
  prefs: []
  type: TYPE_NORMAL
- en: The global context contains the global variables, functions, etc. It also contains
    the value for `this` and a reference to the outer environment, which, in the case
    of a global execution context, is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Function execution context
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every time a JavaScript function is called, a new execution context is created
    for the execution of that function. Just like the global execution context, the
    function execution context contains:'
  prefs: []
  type: TYPE_NORMAL
- en: The variables and functions are declared inside the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of `this` inside the function for the current function call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reference to the outer environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function execution context also contains the arguments passed to the function.
  prefs: []
  type: TYPE_NORMAL
- en: Execution context phases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Execution contexts have following two phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Creation phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation phase
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As the name suggests, the execution contexts (global and function) are created
    during the creation phase.
  prefs: []
  type: TYPE_NORMAL
- en: During this phase, the variable declarations and references to functions are
    saved as key-value pairs inside the execution context. The value of `this` and
    a reference to the outer environment are also set during this phase.
  prefs: []
  type: TYPE_NORMAL
- en: The values for variables are not assigned during the creation phase. However,
    variables that refer to functions do refer to functions during this phase. Variables
    declared using `var` are assigned `undefined` as their value during this phase,
    while variables declared using `let` or constants declared using `const` are left
    uninitialized.
  prefs: []
  type: TYPE_NORMAL
- en: :::info
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a global context, there is no outer environment, so reference
    to the outer environment is set to `null`, but in the case of a function context,
    the value of `this` depends on how the function is called, so the value of `this`
    is set appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: ':::'
  prefs: []
  type: TYPE_NORMAL
- en: Lexical and Variable environments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'During the creation phase, the following two components are created:'
  prefs: []
  type: TYPE_NORMAL
- en: Lexical environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lexical and Variable environments are structures that are used internally to
    hold key-value mappings of variables, functions, reference to the outer environment,
    and the value of `this`.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the lexical and variable environments is that the variable
    environment only holds the key-value mappings of variables declared with the `var`
    keyword, while function declarations and variables declared with `let` or constants
    declared using `const` are inside the lexical environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution context for the above code during the creation phase can be conceptually
    visualized as shown in the image below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![global execution context](images/module_01----lesson_01.09----public----assets----gec-creation-phase.png)'
  prefs: []
  type: TYPE_IMG
- en: global execution context
  prefs: []
  type: TYPE_NORMAL
- en: Execution phase
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned earlier, after the creation phase, different variables in the execution
    context are yet to be assigned their respective values. Assignments are done during
    the execution phase, and the code is finally executed.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Following resources can be used to learn more about the execution context in
    JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Understanding Execution Context and Execution Stack in Javascript - (blog)](https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JavaScript Execution Context – How JS Works Behind The Scenes - (freeCodeCamp
    blog)](https://www.freecodecamp.org/news/execution-context-how-javascript-works-behind-the-scenes/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JavaScript Under The Hood - Execution Context - (youtube video)](https://www.youtube.com/watch?v=Fd9VaW0M7K4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A call stack is a structure that is used internally by the JavaScript engine
    to keep track of the piece of code that is currently executing. The call stack
    is simply a [stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))
    data structure that aids in the execution of the JavaScript code by keeping track
    of currently executing code. You can also think of a call stack in JavaScript
    as a collection of execution contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Before executing any JavaScript code, a global execution context is created
    and pushed on the call stack. This can be easily visualized using the debugger
    in the browser developer tools.
  prefs: []
  type: TYPE_NORMAL
- en: '![global execution context pushed on the callstack](images/module_01----lesson_01.10----public----assets----global-execution-context.png)'
  prefs: []
  type: TYPE_IMG
- en: global execution context pushed on the callstack
  prefs: []
  type: TYPE_NORMAL
- en: :::note
  prefs: []
  type: TYPE_NORMAL
- en: The `debugger` keyword simply creates a breakpoint, forcing the debugger to
    stop at the line containing the `debugger` keyword. We will cover debugging in
    a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ':::'
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the above image, before the execution of the `console.log` statement,
    there is something named “global” in the call stack. This is a global execution
    context that is created and pushed on the call stack before executing the code.
  prefs: []
  type: TYPE_NORMAL
- en: :::note
  prefs: []
  type: TYPE_NORMAL
- en: The label “global” is not important, and different browsers may use different
    labels to represent the global execution context in the call stack. For example,
    the debugger in the Google Chrome browser shows “(anonymous)” instead of “global.”
    The above screenshot was taken using the Firefox browser.
  prefs: []
  type: TYPE_NORMAL
- en: ':::'
  prefs: []
  type: TYPE_NORMAL
- en: 'After pushing the global execution context on the call stack, any function
    calls encountered during the execution of the code will lead to more entries in
    the call stack. For every function call, a new entry is added to the call stack
    before that function starts executing, and as soon as the function execution ends,
    that entry is popped off the stack. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Before the execution of the above code, the global execution context is pushed
    on the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: '![callstack](images/module_01----lesson_01.10----public----assets----callstack-1.png)'
  prefs: []
  type: TYPE_IMG
- en: callstack
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the `foo` function is called, a new entry is added to the call stack
    for the execution of the `foo` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![callstack](images/module_01----lesson_01.10----public----assets----callstack-2.png)'
  prefs: []
  type: TYPE_IMG
- en: callstack
  prefs: []
  type: TYPE_NORMAL
- en: The `foo` function contains a call to the `baz` function. So, another entry
    is pushed on the call stack for the `baz` function call.
  prefs: []
  type: TYPE_NORMAL
- en: '![callstack](images/module_01----lesson_01.10----public----assets----callstack-3.png)'
  prefs: []
  type: TYPE_IMG
- en: callstack
  prefs: []
  type: TYPE_NORMAL
- en: The `baz` function contains a call to the `bar` function. So, another entry
    is pushed on the call stack for the `bar` function call.
  prefs: []
  type: TYPE_NORMAL
- en: '![callstack](images/module_01----lesson_01.10----public----assets----callstack-4.png)'
  prefs: []
  type: TYPE_IMG
- en: callstack
  prefs: []
  type: TYPE_NORMAL
- en: Note that the top element in the call stack represents the currently executing
    piece of code. As soon as the `bar` function execution ends, its entry in the
    call stack is removed. Ultimately, the code execution completes, and the call
    stack becomes empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the code above in the Replit below to see the call stack in action:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/Lesson-9-callstack” />
  prefs: []
  type: TYPE_NORMAL
- en: Stack overflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term “stack overflow” is a familiar term for every software developer, either
    because of every software developer’s favorite website [stackoverflow](https://stackoverflow.com/)
    or because of the stack overflow error due to infinite recursion.
  prefs: []
  type: TYPE_NORMAL
- en: We will be discussing the term “stack overflow” in the context of the call stack.
    The call stack has a fixed size and can contain a limited number of entries.
  prefs: []
  type: TYPE_NORMAL
- en: So what happens if we create a function that just calls itself?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Remember what happens when a function is called? A new entry is added to the
    call stack. In the case of the above function that just calls itself and never
    finishes executing, we are just adding the new entries in the call stack without
    ever removing any entries. This is infinite recursion, and this leads to an error
    known as **stack overflow**. This error is thrown when the call stack gets filled
    up to its limit and can no longer hold more entries.
  prefs: []
  type: TYPE_NORMAL
- en: There are many resources on the internet that claim that primitives are allocated
    on the stack and objects are allocated on the heap, but the reality is not that
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: The official ECMAScript specification doesn’t state anything about how JavaScript
    engines should allocate memory for different types of values or how they should
    free up memory once it is no longer needed by the program. As a result, different
    JavaScript implementations are free to choose how they want to handle memory management
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: So instead of simply believing that the primitive values are stored on the stack,
    and the objects are stored on the heap, we should understand that memory allocation
    in JavaScript is an implementation detail, and different JavaScript engines might
    handle memory differently because the language specification doesn’t mandate how
    memory should be handled in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: In the V8 engine, for example, almost everything is stored on the heap. The
    following quote from the [official V8 blog](https://v8.dev/blog/pointer-compression#value-tagging-in-v8)
    invalidates the common misconception regarding memory allocation in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript values in V8 are represented as objects and allocated on the V8 heap,
    no matter if they are objects, arrays, numbers, or strings. This allows us to
    represent any value as a pointer to an object.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This doesn’t mean that we should assume that everything is allocated on the
    heap. JavaScript engines may allocate *most* values on the heap but could use
    the stack for optimization and store temporary values that might not last longer
    than a function call.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript engines are complicated softwares that are heavily optimized. It
    is unreasonable to assume that they all just follow the simple rule of *primitives
    go on the stack and objects on the heap*.
  prefs: []
  type: TYPE_NORMAL
- en: The most important point you should take away from this lesson is that different
    JavaScript engines may handle memory differently, and “primitives in javaScript
    simply go on the stack” is a **misconception**.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[JavaScript memory model demystified - (blog)](https://www.zhenghao.io/posts/javascript-memory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What are JavaScript variables made of - (blog)](https://www.zhenghao.io/posts/javascript-variables)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Where does Javascript allocate memory for the result of a function call? Stack
    or heap? - (stackoverflow post)](https://stackoverflow.com/questions/67356107/where-does-javascript-allocate-memory-for-the-result-of-a-function-call-stack-o)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic garbage collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike other languages like C, where the programmer is responsible for freeing
    up the memory when it is no longer needed, JavaScript makes the job of the programmer
    easier by automatically handling the memory.
  prefs: []
  type: TYPE_NORMAL
- en: Memory that is no longer needed is automatically freed by the JavaScript engine,
    and this process is known as **garbage collection**. Modern JavaScript engines
    include a garbage collector that is responsible for determining which parts of
    the memory are no longer needed and can be freed. Once such blocks of memory have
    been determined, those blocks are freed by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: Different algorithms are used to determine which blocks of memory are no longer
    needed and are eligible for garbage collection. Currently, modern JavaScript engines
    use a [Mark-and-sweep algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#mark-and-sweep_algorithm).
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm determines which blocks of memory are “unreachable”; such blocks
    of memory are considered eligible for garbage collection. This algorithm is an
    improvement over the [reference counting algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#reference-counting_garbage_collection),
    which has its limitations.
  prefs: []
  type: TYPE_NORMAL
- en: The Java language also has the mechanism of automatic garbage collection, but
    in Java, programmers can manually trigger the garbage collection process, whereas
    JavaScript programmers don’t have this level of control over garbage collection.
    Some might see this as a limitation, but there is no doubt that automatic garbage
    collection is really helpful for programmers to avoid memory leaks that are often
    encountered in languages that don’t handle this automatically.
  prefs: []
  type: TYPE_NORMAL
