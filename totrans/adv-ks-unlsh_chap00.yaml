- en: '`What is JavaScript`'
  id: totrans-0
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: '`Course Overview`'
  id: totrans-1
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: '`JavaScript is arguably the most widely used programming language on the planet,
    and there is a vast amount of content available for learning JavaScript. The problem
    is that not all the content on the internet does a good job of explaining the
    complex or confusing concepts of JavaScript.`'
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`This course aims to teach different concepts in JavaScript that are not easy
    to grasp, especially for beginners. Topics like closures, coercion, the asynchronous
    nature of JavaScript, etc., are examples of topics that most beginners struggle
    with because they are not easy to understand. The goal of this course is to provide
    in-depth, easy-to-understand explanations of such confusing topics.`'
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Even those who have been working with JavaScript for a few years might need
    help understanding some of the concepts covered in this course or might have some
    gaps in their understanding. The goal of this course is to fill those gaps.`'
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`This course will not only provide easy-to-understand explanations of fundamental
    JavaScript topics like hoisting, coercion, event loop, etc., but will also cover
    advanced topics like promises and async-await syntax in a way that will be easy
    for the students to understand.`'
  id: totrans-5
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`By the end of this course, students will have a deep understanding of the
    concepts covered in this course. They will become better at JavaScript by having
    a solid understanding of the topics that most JavaScript beginners struggle with.
    Students will be able to debug JavaScript code better and avoid common pitfalls
    by having a deep understanding of fundamental but confusing JavaScript topics.`'
  id: totrans-6
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Prerequisites`'
  id: totrans-7
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: '`This course assumes that students have a basic understanding of JavaScript
    and programming in general. Understanding of topics like variables, loops, objects,
    arrays, functions, etc., is assumed.`'
  id: totrans-8
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Running code examples`'
  id: totrans-9
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: '`You can download code examples from the same place where you purchased this
    book.`'
  id: totrans-10
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`If you have any trouble finding or downloading the code examples, email us
    at [us@fullstack.io](mailto:us@fullstack.io).`'
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Who is this course for?`'
  id: totrans-12
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: '`The course is for those who:`'
  id: totrans-13
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`are struggling to have a deep understanding of JavaScript`'
  id: totrans-14
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`understand fundamental to advanced JavaScript concepts but want to fill gaps
    in their understanding of different JavaScript topics that are key to becoming
    a good JavaScript developer (topics like closures, coercion, event loop, asynchronous
    JavaScript, promises, etc.)`'
  id: totrans-15
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`want to understand JavaScript in-depth and get better at working with JavaScript`'
  id: totrans-16
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`want to get better at debugging JavaScript and preparing for job interviews,
    as this course will provide a deeper understanding of the JavaScript language`'
  id: totrans-17
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`want to solidify their understanding of JavaScript’s fundamental topics`'
  id: totrans-18
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`want to avoid frustration due to a lack of understanding of JavaScript’s confusing
    topics`'
  id: totrans-19
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`want to excel in working with JavaScript`'
  id: totrans-20
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: This course is unlike online articles/blogs and many `JavaScript` video courses
    that either fail to provide in-depth, easy-to-understand explanations of `JavaScript`
    topics that are not easy for beginners to understand or do not cover all the necessary
    topics (fundamental to advanced) that a good `JavaScript` developer must understand.
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: This course combines fundamental but confusing `JavaScript` topics in a single
    course that aims to provide a solid understanding to the students and cover all
    the topics that are key to understanding `JavaScript` in depth.
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`JavaScript` is currently the most widely used programming language. With the
    rise of modern front-end frameworks and platforms like `Node.js`, it seems that
    `JavaScript` will be the most used programming language for the foreseeable future.'
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: It is the programming language of the web, most commonly used to add interactivity
    to web pages. With the help of technologies like `Node.js`, which allow us to
    write `JavaScript` outside the browser environment, software developers can now
    write full-stack applications by learning just one programming language.
  id: totrans-24
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: So, how did this programming language that we know today come into existence?
    Let’s take a brief tour of its history.
  id: totrans-25
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: History of `JavaScript`
  id: totrans-26
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: In the early days of web browsers, web pages could only be static, without any
    dynamic behavior or interactivity. A server was needed for simple things like
    form input validations. With limited internet speeds in those days, requiring
    a roundtrip to the server just for input validation was highly undesirable.
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: There was a need for a client-side scripting language that allowed us to add
    interactivity to web pages. In 1995, a software developer at `Netscape` began
    working on such a language, initially called “`mocha`,” which was later changed
    to “`LiveScript`.”
  id: totrans-28
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: This language was supposed to be part of the `Netscape Navigator 2` browser,
    but just before the release of the browser, `LiveScript` was renamed to “`JavaScript`.”
  id: totrans-29
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: When `Netscape` released its `Netscape Navigator 3` browser, `Microsoft` came
    up with its web browser known as `Internet Explorer 3`, which included `Microsoft`’s
    implementation of the `JavaScript` language.
  id: totrans-30
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'This presented a problem: there were now two separate implementations of the
    `JavaScript` language. There was a need for a standards body that was responsible
    for the advancement of the `JavaScript` language.'
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Standardization of the `JavaScript` language
  id: totrans-32
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: The problem of multiple versions of `JavaScript` led `Netscape` to submit the
    `JavaScript` language as a proposal to `Ecma International`, a standards organization.
  id: totrans-33
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`JavaScript` is standardized as “`ECMAScript`” and its standard is [`ECMA-262`](https://www.ecma-international.org/publications-and-standards/standards/ecma-262/).'
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As mentioned in the previous lesson, the initial name for `JavaScript` was `Mocha`,
    which was later changed to `LiveScript`, and just before the release of the `Netscape
    Navigator 2` browser, the name was changed to `JavaScript`.
  id: totrans-35
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: So what’s the reason behind using the word `Java` inside the name `JavaScript`
    when there was already a popular programming language named `Java`?
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: This question of whether these two languages are related to each other arises
    in the mind of almost every person who is already familiar with one of these two
    languages and comes across the other language.
  id: totrans-37
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: It was just a `marketing move`. Java was popular at that time, and `Netscape`
    wanted to cash in on the popularity of the `Java` language. That is why `Netscape`
    renamed the language from `LiveScript` to `JavaScript`.
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Apart from some similarities in the syntax and, of course, in the name of both
    languages, the two languages are very different from each other.
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Ecma International`, `TC39`'
  id: totrans-40
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: '`JavaScript` is standardized as `ECMAScript` by `Ecma International`, a standards
    organization.'
  id: totrans-41
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Within `Ecma International`, people responsible for developing the `JavaScript`
    language are part of the `Technical Committee 39` (`TC39`). This committee consists
    of different stakeholders from the `JavaScript` community. Mostly people from
    big companies like `Google`, `Microsoft`, etc. are part of this group.
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Other people can become part of `TC39` as well and make their contribution in
    the development of the JavaScript language. Details of how anyone can either contribute
    or be part of `TC39` meetings as a member can be found on the [`TC39 website`](https://tc39.es/).
  id: totrans-43
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`TC39` also has a [`GitHub account`](https://github.com/tc39) which hosts multiple
    repositories related to their work. Repositories include notes from `TC39` meetings,
    different proposals for the `JavaScript` language, details of how `TC39` works,
    etc.'
  id: totrans-44
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Proposals process`'
  id: totrans-45
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: '`TC39` has a well-defined process through which proposals are passed before
    they can be added to the `ECMAScript` specification and ultimately be part of
    the `JavaScript` language.'
  id: totrans-46
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Each proposal is passed through five stages which are mentioned below:'
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '![process stages](images/module_01----lesson_01.04----public----assets----proposal-stages.png)'
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: '`process stages`'
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Stage 0`'
  id: totrans-50
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: The first stage represents someone’s idea that they think is worthy of being
    part of the `JavaScript` language.
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Not all proposals at this stage move to the next stage, but the ones that do
    are the ones that gain enough interest and have a `TC39` committee member who
    is willing to work on the idea. Proposals at this stage that gain enough interest
    are discussed in the `TC39` meeting. If the discussion goes well, the proposal
    is moved to the next stage.
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Stage 1`'
  id: totrans-53
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: Proposals at this stage are discussed and developed by the community (including
    non-committee members), and if the proposal still has enough interest and is thought
    to have potential benefit if added to the specification, initial specification
    language and `API` are developed and discussed in the `TC39` meeting. Provided
    everything goes well, the proposal is moved to the next stage.
  id: totrans-54
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Stage 2`'
  id: totrans-55
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: At this stage, the API, syntax, and so on are refined and described in greater
    detail using the formal specification language. Polyfills and Babel plugins may
    be developed at this stage for real-world experimentation with the solution of
    the proposal.
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Once the proposal has been described in enough detail, it can be considered
    for the next stage.
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Stage 3`'
  id: totrans-58
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: Proposals at this stage are almost ready to be included in the ECMAScript specification.
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'For proposals to be moved to the final stage, they need to meet the following
    two criteria:'
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`a suite of tests`'
  id: totrans-61
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`two compatible implementations of the proposal that passed the tests`'
  id: totrans-62
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Once the conditions mentioned above are met, and the committee has a consensus
    that the proposal is ready to be part of the ECMAScript specification, it is moved
    to the next stage.
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Stage 4`'
  id: totrans-64
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: At this stage, the proposal is complete and is ready to be included in the ECMAScript
    specification and ultimately be added to the JavaScript language.
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A pull request is generated to the `ecma262` GitHub repository to include it
    in the specification. Once the pull request is approved, the proposal is part
    of the specification and ready to be implemented in the JavaScript engines that
    still need to implement it.
  id: totrans-66
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: For further details of this process, refer to a [`process document`](https://tc39.es/process-document/)
    on TC39’s website, which explains the various stages through which proposals pass
    through.
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Track upcoming features.
  id: totrans-68
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: Additions to the JavaScript language in recent years have completely transformed
    JavaScript into a programming language, and sometimes, it can be hard to stay
    updated with the new additions to the language.
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Keeping ourselves updated with new changes is one thing, but how can we track
    changes that could potentially be part of JavaScript in the future?
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The answer to this question lies in [`TC39’s GitHub repository`](https://github.com/tc39),
    which contains [`meeting notes`](https://github.com/tc39/notes) and [`proposals`](https://github.com/tc39/proposals)
    that are at various stages of the proposal process described in the earlier lesson.
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Notes and proposal repositories are a great place to keep track of upcoming
    changes, and in general, the `TC39` GitHub repository is useful for tracking the
    work that the TC39 committee is doing.
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: How is ECMAScript versioned?
  id: totrans-73
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: ECMAScript version 5, also known as “ES5”, came out in 2009, and until that
    point, the ECMAScript specification was referred to by its `edition` number, but
    with the introduction of ECMAScript’s 6th edition, also known as “ES6”, TC39 added
    the `year` number in the language’s name.
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As the 6th edition came out in the year 2015, it was “ECMAScript 2015”, “ES2015”
    for short. The later editions were also named using the year number in which they
    came out, e.g., “ES2016”, etc.
  id: totrans-75
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 你还会看到这些版本被称为“`ES6`”、“`ES7`”等，这种命名方式也是可以使用的。你选择哪一种取决于你的偏好。在大多数情况下，你会看到两种类型的名称可以互换使用。
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在撰写本文时，`ECMAScript 2023`是最新的`ECMAScript`版本。
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 由于`JavaScript`的执行方式，许多人将其视为一种“解释”语言，但仅将`JavaScript`称为“解释”语言并不完全正确。
  id: totrans-78
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 对于编译语言，编译器通常会编译源代码并生成一个二进制可执行文件，这个文件可以被分发和执行。
  id: totrans-79
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 另一方面，对于解释语言，解释器不会产生可执行输出文件；与编译器不同，编译器提前编译源代码，解释器则是实时读取并执行代码。
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 对于`JavaScript`而言，`JavaScript`引擎不会输出可执行文件，这也是它被视为解释语言的原因之一。
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 然而，`JavaScript`代码被*编译*成一种称为`byte code`的中间形式，然后由虚拟机执行。虚拟机`解释`字节码，但现代`JavaScript`引擎不仅仅是解释字节码；它们包括被称为“`Just-in-time
    (JIT) compiler`”的组件，将字节码编译成本地机器码，这种机器码的执行速度快于字节码。
  id: totrans-82
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`JIT Compiler`'
  id: totrans-83
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: “`Just-in-time (JIT)`”编译是一种被许多现代`JavaScript`引擎使用的技术，以提高`JavaScript`代码的执行速度。
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`JavaScript`代码被转换成字节码，然后`JavaScript`引擎执行这些字节码。然而，现代`JavaScript`引擎进行许多优化以提高`JavaScript`代码的性能。这些优化是在引擎执行代码时收集的信息基础上进行的。'
  id: totrans-85
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 优化性能的一种方法是将字节码编译成机器码，机器码执行速度快于字节码。`JavaScript`引擎识别代码中的“热”部分来实现这一点——即频繁执行的部分。
  id: totrans-86
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 这些“热”代码部分随后被编译成本地机器码，并且这段机器码在执行时会替代相应的字节码。
  id: totrans-87
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 那么，`JIT`编译器与像`C++`这样的传统编译器有何不同？与传统编译器提前编译代码不同，`JIT`编译器在代码执行时实时编译代码。
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 尽管`JavaScript`代码仍以源代码格式分发而非可执行格式，但它会被编译成字节码，并可能编译成本地机器码。
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 所以，回到问题上：`JavaScript`是编译语言还是解释语言？可以安全地说它既是*编译的*也是*解释的语言*。
  id: totrans-90
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`We don’t necessarily need to understand the nitty-gritty details of how exactly
    the JavaScript code that we write is executed, but to develop a good understanding
    of the language; it is important to have a basic understanding of how our JavaScript
    code gets transformed into something that a machine can understand and execute.`'
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`It is also important to understand what different things come into play while
    our code is executing; concepts like “` **execution context** `,” “` **call stack**
    `,” etc. are crucial to understanding the JavaScript language’s runtime behavior
    and being able to work with it and debug it efficiently.`'
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`JavaScript Engine`'
  id: totrans-93
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: '`To execute JavaScript code, we need another software known as a` **JavaScript
    engine** `. This engine contains all the necessary components to transform the
    code into something the machine can execute.`'
  id: totrans-94
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Different browser vendors typically create JavaScript engines; each major
    vendor has developed a JavaScript engine that executes the JavaScript code in
    their browser.`'
  id: totrans-95
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`The following table shows some major browsers and their JavaScript engines.`'
  id: totrans-96
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '| `Browser` | `Engine` |'
  id: totrans-97
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `---` | `---` |'
  id: totrans-98
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `Google Chrome` | `V8` |'
  id: totrans-99
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `Edge` | `Chakra` |'
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `Mozilla Firefox` | `Spider Monkey` |'
  id: totrans-101
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `Safari` | `JavaScriptCore` |'
  id: totrans-102
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '`While there are differences in the steps taken by each JavaScript engine to
    execute the JavaScript code, the major steps taken by each engine are more or
    less the same and we will try to have a high-level overview of how our code gets
    transformed and executed by the JavaScript engines by understanding the Google
    Chrome’s` `V8` `engine.`'
  id: totrans-103
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`The following image shows the high-level overview of the execution pipeline
    of the V8 engine:`'
  id: totrans-104
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '![process stages](images/module_01----lesson_01.08----public----assets----v8-execution-pipeline.png)'
  id: totrans-105
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: '`process stages`'
  id: totrans-106
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`The JavaScript engine is complicated software that contains lots of steps
    and components that are used to transform and execute the JavaScript code, but
    the above image shows a simplified version of the execution pipeline of the V8
    engine.`'
  id: totrans-107
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`:::note Please note that the team working on the V8 engine is continuously
    improving it; as a result, the simplified execution pipeline shown in the image
    above may change in the future. :::`'
  id: totrans-108
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Let’s get a better understanding of how the execution pipeline shown above
    works by understanding what happens at each step of this pipeline.`'
  id: totrans-109
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Source Code`'
  id: totrans-110
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: '`Before the JavaScript engine can begin its work, the source code needs to
    be downloaded from some source. This can either be from the network, a cache,
    or a service worker that pre-fetched the code.`'
  id: totrans-111
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`The engine itself doesn’t have the capability to download the code. The browser
    does it and then passes it to the engine, which can then begin transforming it
    and eventually execute it.`'
  id: totrans-112
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Parser`'
  id: totrans-113
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 下载源代码后，下一步是将其转化为`tokens`。将此步骤视为识别代码的不同部分；例如，单词“function”是一个被识别为“关键字”的`token`。其他的`tokens`可能包括字符串、运算符等。将代码划分为`tokens`的过程由“扫描器”完成，这个过程被称为“`tokenization`”。
  id: totrans-114
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 以下的`JavaScript`代码：
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 它可以如下进行标记：
  id: totrans-117
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 一旦生成了`tokens`，解析器使用它们生成一个[抽象语法树（AST）](https://en.wikipedia.org/wiki/Abstract_syntax_tree)，一组表示源代码结构的对象。
  id: totrans-119
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[AST Explorer](https://astexplorer.net/)是一个很酷的网站，你可以用它来可视化`AST`。请将上面的代码粘贴到`AST
    Explorer`中，探索生成的`AST`。'
  id: totrans-120
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Interpreter`'
  id: totrans-121
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: '`Bytecode Generator`使用解析器生成的`AST`来生成字节码。这个生成的字节码由`Bytecode Interpreter`接收，然后进行解释。'
  id: totrans-122
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`V8`也会将生成的字节码通过一些优化器，这些优化器执行一些优化以确保字节码在`Bytecode Interpreter`中高效执行。'
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Compiler`'
  id: totrans-124
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 在字节码被执行时，`JavaScript`引擎收集关于正在执行的代码的信息。引擎随后使用这些信息进一步优化代码。
  id: totrans-125
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 例如，`JavaScript`引擎可以识别正在频繁执行的代码部分，也称为代码的“热点”部分。这些“热点”部分的代码随后被编译为本地机器代码，以确保这些部分尽可能快地执行。
  id: totrans-126
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 然而，优化后的本地机器代码有时必须被去优化回由`Bytecode Generator`生成的字节码，因为代码的编写方式。
  id: totrans-127
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 回退到字节码的需求源于`JavaScript`是一种[动态类型](https://developer.mozilla.org/en-US/docs/Glossary/Dynamic_typing)语言。动态特性意味着我们可以用不同类型的值调用特定的`JavaScript`函数。
  id: totrans-128
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 考虑以下代码：
  id: totrans-129
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 上述函数可以与不同“形状”的对象调用。
  id: totrans-131
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 这意味着如果`print`函数多次被调用，且对象具有以下形状：
  id: totrans-133
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 如果它被编译为本地机器代码，但如果同一个函数与一个*不同*形状的对象被调用，`JavaScript`引擎就不能使用优化过的机器代码，而必须回退到字节码。
  id: totrans-135
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The optimized native machine code is generated using the information collected
    during the execution of the JavaScript code. The native machine code requires
    certain checks to ensure that the assumptions made during the generation of the
    native machine code are not violated. If the checks fail, the JavaScript engine
    has to execute the bytecode instead of the native machine code. This process is
    called `deoptimization`.
  id: totrans-136
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'References:'
  id: totrans-137
  prefs:
  - PREF_H5
  stylish: true
  type: TYPE_NORMAL
- en: 'The following resources can be used to learn more about how the JavaScript
    code is executed:'
  id: totrans-138
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[Understanding the V8 JavaScript Engine - (freeCodeCamp talk by Lydia Hallie)](https://www.youtube.com/watch?v=xckH5s3UuX4)'
  id: totrans-139
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '[How JavaScript Works: Under the Hood of the V8 Engine - (freeCodeCamp blog)](https://www.freecodecamp.org/news/javascript-under-the-hood-v8/)'
  id: totrans-140
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '[What does V8’s ignition really do? - (stackoverflow post)](https://stackoverflow.com/questions/54957946/what-does-v8s-ignition-really-do)'
  id: totrans-141
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '[Ignition - an interpreter for V8 - (youtube video)](https://www.youtube.com/watch?v=r5OWCtuKiAk)'
  id: totrans-142
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '[Blazingly fast parsing, part 1: optimizing the scanner - (V8 blog)](https://v8.dev/blog/scanner)'
  id: totrans-143
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '[Overhead of Deoptimization Checks in the V8 JavaScript Engine - (paper by
    Dept. of Computer Engineering, University of California)](https://masc.soe.ucsc.edu/docs/iiswc16.pdf)'
  id: totrans-144
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Whenever any JavaScript code is executed, it is executed inside an environment.
    By “environment”, I mean everything that is accessible by the code that aids in
    its execution. For example, the value of `this`, variables in the current scope,
    function arguments, etc. This environment is known as the `Execution Context`.
    Every time any JavaScript code is executed, an execution context is created before
    its execution.
  id: totrans-145
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: :::note
  id: totrans-146
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Understanding the concept of execution context lays the foundation for understanding
    other JavaScript concepts like `hoisting`, `closures`, etc. These topics will
    be covered in later chapters.
  id: totrans-147
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: ':::'
  id: totrans-148
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Types of execution contexts
  id: totrans-149
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 'The following are two main types of execution contexts that we will discuss:'
  id: totrans-150
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Global execution context
  id: totrans-151
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Function execution context
  id: totrans-152
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: :::info
  id: totrans-153
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: There is a third type of execution context that is created for the execution
    of code inside the [`eval`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)
    function. Still, as the use of the `eval` function is discouraged due to security
    concerns, we will only discuss the types of execution context mentioned above.
  id: totrans-154
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: ':::'
  id: totrans-155
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Global execution context
  id: totrans-156
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: The global execution context is the base context created whenever JavaScript
    code is loaded for execution. Global code, i.e., the code that is not inside a
    function, is executed inside a global execution context.
  id: totrans-157
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The global context contains the global variables, functions, etc. It also contains
    the value for `this` and a reference to the outer environment, which, in the case
    of a global execution context, is `null`.
  id: totrans-158
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Function execution context
  id: totrans-159
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 每次调用JavaScript函数时，都会为该函数的执行创建一个新的执行上下文。与全局执行上下文类似，函数执行上下文包含：
  id: totrans-160
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 变量和函数在函数内部声明。
  id: totrans-161
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 当前函数调用中`this`的值。
  id: totrans-162
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 对外部环境的引用。
  id: totrans-163
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 函数执行上下文还包含传递给函数的参数。
  id: totrans-164
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 执行上下文阶段
  id: totrans-165
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 执行上下文有以下两个阶段：
  id: totrans-166
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 创建阶段
  id: totrans-167
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 执行阶段
  id: totrans-168
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 创建阶段
  id: totrans-169
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 正如名称所示，执行上下文（全局和函数）是在创建阶段创建的。
  id: totrans-170
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在这个阶段，变量声明和对函数的引用被保存为键值对，存放在执行上下文中。`this`的值和对外部环境的引用也在此阶段设置。
  id: totrans-171
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在创建阶段，变量的值并未被赋值。然而，引用函数的变量在此阶段确实会引用函数。用`var`声明的变量在此阶段被赋值为`undefined`，而用`let`声明的变量或用`const`声明的常量则保持未初始化状态。
  id: totrans-172
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: :::info
  id: totrans-173
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在全局上下文中，没有外部环境，因此对外部环境的引用被设置为`null`；而在函数上下文中，`this`的值取决于函数的调用方式，因此`this`的值被适当地设置。
  id: totrans-174
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: ':::'
  id: totrans-175
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 词法和变量环境
  id: totrans-176
  prefs:
  - PREF_H5
  stylish: true
  type: TYPE_NORMAL
- en: 在创建阶段，将创建以下两个组件：
  id: totrans-177
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 词法环境
  id: totrans-178
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 变量环境
  id: totrans-179
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 词法和变量环境是用于内部存储变量、函数、对外部环境的引用以及`this`的值的结构。
  id: totrans-180
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 词法环境和变量环境之间的区别在于，变量环境仅包含用`var`关键字声明的变量的键值映射，而函数声明和用`let`或`const`声明的变量则位于词法环境内。
  id: totrans-181
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 考虑以下代码：
  id: totrans-182
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 上述代码在创建阶段的执行上下文可以概念上可视化为下图所示：
  id: totrans-184
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '![global execution context](images/module_01----lesson_01.09----public----assets----gec-creation-phase.png)'
  id: totrans-185
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: 全局执行上下文
  id: totrans-186
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 执行阶段
  id: totrans-187
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 正如前面提到的，在创建阶段之后，执行上下文中的不同变量尚未被赋予各自的值。赋值将在执行阶段进行，代码最终被执行。
  id: totrans-188
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 参考文献
  id: totrans-189
  prefs:
  - PREF_H5
  stylish: true
  type: TYPE_NORMAL
- en: 以下资源可用于进一步了解JavaScript中的执行上下文：
  id: totrans-190
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[Understanding Execution Context and Execution Stack in Javascript - (blog)](https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0)'
  id: totrans-191
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '[JavaScript执行上下文 – JS背后的工作原理 - (freeCodeCamp博客)](https://www.freecodecamp.org/news/execution-context-how-javascript-works-behind-the-scenes/)'
  id: totrans-192
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '[JavaScript幕后揭秘 - 执行上下文 - (youtube视频)](https://www.youtube.com/watch?v=Fd9VaW0M7K4)'
  id: totrans-193
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 调用栈是JavaScript引擎内部用于跟踪当前正在执行的代码片段的结构。调用栈只是一个[栈](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))数据结构，通过跟踪当前执行的代码来帮助执行JavaScript代码。你也可以将JavaScript中的调用栈视为执行上下文的集合。
  id: totrans-194
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在执行任何JavaScript代码之前，创建一个全局执行上下文并将其压入调用栈。可以通过浏览器开发者工具中的调试器轻松可视化。
  id: totrans-195
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '![global execution context pushed on the callstack](images/module_01----lesson_01.10----public----assets----global-execution-context.png)'
  id: totrans-196
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: 全局执行上下文被压入调用栈
  id: totrans-197
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: :::note
  id: totrans-198
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`debugger`关键字简单地创建一个断点，强制调试器在包含`debugger`关键字的行上停止。我们将在后面的章节中讨论调试。'
  id: totrans-199
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '::::'
  id: totrans-200
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 请注意，在上述图像中，在执行`console.log`语句之前，调用栈中有一个名为“global”的东西。这是一个全局执行上下文，在执行代码之前创建并压入调用栈。
  id: totrans-201
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: :::note
  id: totrans-202
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 标签“global”并不重要，不同的浏览器可能使用不同的标签来表示调用栈中的全局执行上下文。例如，Google Chrome浏览器中的调试器显示“(anonymous)”而不是“global”。上述屏幕截图是在Firefox浏览器中拍摄的。
  id: totrans-203
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '::::'
  id: totrans-204
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在将全局执行上下文压入调用栈后，在执行代码期间遇到的任何函数调用都会导致调用栈中更多条目的添加。对于每个函数调用，在该函数开始执行之前都会向调用栈添加一个新的条目，一旦函数执行结束，该条目就会从栈中弹出。考虑以下代码：
  id: totrans-205
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 考虑以下代码：
  id: totrans-206
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 在执行上述代码之前，全球执行上下文被压入调用栈。
  id: totrans-208
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '![callstack](images/module_01----lesson_01.10----public----assets----callstack-1.png)'
  id: totrans-209
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: callstack
  id: totrans-210
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 一旦调用`foo`函数，一个新的条目被添加到调用栈中以执行`foo`函数。
  id: totrans-211
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '![callstack](images/module_01----lesson_01.10----public----assets----callstack-2.png)'
  id: totrans-212
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: callstack
  id: totrans-213
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`foo`函数包含对`baz`函数的调用。因此，另一个条目被压入调用栈以进行`baz`函数调用。'
  id: totrans-214
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '![callstack](images/module_01----lesson_01.10----public----assets----callstack-3.png)'
  id: totrans-215
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: callstack
  id: totrans-216
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`baz`函数包含对`bar`函数的调用。因此，另一个条目被推入`bar`函数调用的调用栈。'
  id: totrans-217
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '![callstack](images/module_01----lesson_01.10----public----assets----callstack-4.png)'
  id: totrans-218
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: '`callstack`'
  id: totrans-219
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 请注意，调用栈中的顶部元素代表当前正在执行的代码片段。一旦`bar`函数执行结束，它在调用栈中的条目将被移除。最终，代码执行完成，调用栈变为空。
  id: totrans-220
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 您可以在下面的`Replit`中运行上述代码，以查看调用栈的实际效果：
  id: totrans-221
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/Lesson-9-callstack” />`'
  id: totrans-222
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Stack overflow`'
  id: totrans-223
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: “`stack overflow`”是每个软件开发人员都熟悉的术语，无论是因为每个软件开发人员最喜欢的网站[stackoverflow](https://stackoverflow.com/)，还是因为无限递归导致的堆栈溢出错误。
  id: totrans-224
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 我们将在调用栈的上下文中讨论“`stack overflow`”这个术语。调用栈的大小是固定的，并且可以包含有限数量的条目。
  id: totrans-225
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 那么，如果我们创建一个只是调用自己的函数，会发生什么呢？
  id: totrans-226
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 还记得调用函数时会发生什么吗？一个新条目被添加到调用栈中。在上述仅调用自身且永不完成执行的函数的情况下，我们只是不断在调用栈中添加新条目，而从未移除任何条目。这就是无限递归，这会导致一个称为`stack
    overflow`的错误。当调用栈填满到其限制，并且无法再容纳更多条目时，就会抛出此错误。
  id: totrans-228
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 网络上有很多资源声称原始值在栈上分配，而对象在堆上分配，但现实并非如此简单。
  id: totrans-229
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 官方的`ECMAScript`规范没有说明JavaScript引擎应该如何为不同类型的值分配内存，或者在程序不再需要内存时如何释放内存。因此，不同的JavaScript实现可以自由选择如何处理JavaScript中的内存管理。
  id: totrans-230
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 因此，我们不应该简单地相信原始值存储在栈上，而对象存储在堆上，而应该理解，JavaScript中的内存分配是一个实现细节，不同的JavaScript引擎可能以不同的方式处理内存，因为语言规范并未规定JavaScript中的内存应该如何处理。
  id: totrans-231
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在`V8`引擎中，几乎所有内容都是存储在堆上的。以下引用来自[官方V8博客](https://v8.dev/blog/pointer-compression#value-tagging-in-v8)，它揭示了关于JavaScript中内存分配的常见误解。
  id: totrans-232
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在`V8`中，JavaScript值被表示为对象并分配在`V8`堆上，无论它们是对象、数组、数字还是字符串。这使我们能够将任何值表示为指向对象的指针。
  id: totrans-233
  prefs:
  - PREF_BQ
  stylish: true
  type: TYPE_NORMAL
- en: 这并不意味着我们应该假设所有东西都在堆上分配。JavaScript引擎可能会在堆上分配*大部分*值，但也可能利用栈进行优化，存储可能不会持续超过函数调用的临时值。
  id: totrans-234
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: JavaScript引擎是复杂的软件，经过了大量优化。假设它们都仅仅遵循*原始值在栈上而对象在堆上*的简单规则是不合理的。
  id: totrans-235
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 你应该从这节课中得到的最重要的观点是，不同的JavaScript引擎可能会以不同的方式处理内存，而“原始值在JavaScript中简单地在栈上”是一种`misconception`。
  id: totrans-236
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 进一步阅读
  id: totrans-237
  prefs:
  - PREF_H5
  stylish: true
  type: TYPE_NORMAL
- en: '[JavaScript memory model demystified - (blog)](https://www.zhenghao.io/posts/javascript-memory)'
  id: totrans-238
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '[What are JavaScript variables made of - (blog)](https://www.zhenghao.io/posts/javascript-variables)'
  id: totrans-239
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '[Where does Javascript allocate memory for the result of a function call? Stack
    or heap? - (stackoverflow post)](https://stackoverflow.com/questions/67356107/where-does-javascript-allocate-memory-for-the-result-of-a-function-call-stack-o)'
  id: totrans-240
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 自动垃圾收集
  id: totrans-241
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 与C等其他语言不同，在这些语言中，程序员负责在不再需要时释放内存，JavaScript通过自动处理内存使程序员的工作变得更轻松。
  id: totrans-242
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 不再需要的内存会被JavaScript引擎自动释放，这个过程称为`garbage collection`。现代JavaScript引擎包括一个垃圾收集器，负责确定哪些内存部分不再需要并可以释放。一旦确定了这些内存块，这些块就会被垃圾收集器释放。
  id: totrans-243
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 不同的算法用于确定哪些内存块不再需要并符合垃圾收集的条件。目前，现代JavaScript引擎使用[标记-清除算法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#mark-and-sweep_algorithm)。
  id: totrans-244
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 该算法确定哪些内存块是“不可达”的；这些内存块被认为符合垃圾收集的条件。这个算法是对[引用计数算法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#reference-counting_garbage_collection)的改进，但它有其局限性。
  id: totrans-245
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Java语言也有自动垃圾收集的机制，但在Java中，程序员可以手动触发垃圾收集过程，而JavaScript程序员对垃圾收集没有这样的控制级别。有些人可能会把这视为一种限制，但毫无疑问，自动垃圾收集确实对程序员避免在不自动处理内存的语言中经常遇到的内存泄漏非常有帮助。
  id: totrans-246
  prefs: []
  stylish: true
  type: TYPE_NORMAL
