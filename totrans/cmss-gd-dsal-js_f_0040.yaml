- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Speeding Up Your Code with Big O
  prefs: []
  type: TYPE_NORMAL
- en: Big O notation is a great tool for expressing the efficiency of an algorithm.
    We’ve already been able to use it to quantify the difference between binary search
    vs. linear search, as binary search is O(log N)—a much faster algorithm than linear
    search, which is O(N).
  prefs: []
  type: TYPE_NORMAL
- en: With Big O, you also have the opportunity to compare your algorithm to general
    algorithms out there in the world, and you can say to yourself, “Is this a fast
    or slow algorithm as far as algorithms generally go?”
  prefs: []
  type: TYPE_NORMAL
- en: If you find that Big O labels your algorithm as a slow one, you can now take
    a step back and try to figure out if there’s a way to optimize it by trying to
    get it to fall under a faster category of Big O. This may not always be possible,
    of course, but it’s certainly worth thinking about.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll write some code to solve a practical problem and then
    measure our algorithm using Big O. We’ll then see if we might be able to modify
    the algorithm to give it a nice efficiency bump. (Spoiler: we will.)'
  prefs: []
  type: TYPE_NORMAL
