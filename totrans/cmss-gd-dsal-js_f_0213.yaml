- en: Chapter 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are the solutions to the exercises found in the section [​*Exercises*​](f_0086.xhtml#blazing.fast.lookup.with.hashes.exercises).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following implementation first stores the values of the first array in
    a hash table and then checks each value of the second array against that hash
    table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ getIntersection(array1, array2) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**const**​ intersection = []; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**const**​ hashTable = {}; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | array1.forEach((value) => { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | hashTable[value] = ​**true**​; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | }); |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | array2.forEach((value) => { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**if**​ (hashTable[value]) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | intersection.push(value); |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | }); |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**return**​ intersection; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: This algorithm has an efficiency of O(N).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following implementation checks each string in the array. If the string
    isn’t yet in the hash table, the string gets added. If the string is in the hash
    table, that means it’s been added before, which means it’s a duplicate! This algorithm
    has a time complexity of O(N):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ findDuplicate(array) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**const**​ hashTable = {}; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**for**​ (​**const**​ value ​**of**​ array) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**if**​ (hashTable[value]) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**return**​ value; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } ​**else**​ { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | hashTable[value] = ​**true**​; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**return**​ ​**null**​; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'The following implementation begins by creating a hash table out of all the
    characters we encounter in the string. Next, we iterate over each character of
    the alphabet and check to see whether the character is contained within our hash
    table. If it isn’t, it means the character is missing from the string, so we return
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ findMissingLetter(string) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**const**​ hashTable = {}; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**for**​ (​**const**​ ​**char**​ ​**of**​ string) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | hashTable[​**char**​] = ​**true**​; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**const**​ alphabet = ​*''abcdefghijklmnopqrstuvwxyz''*​; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**for**​ (​**const**​ ​**char**​ ​**of**​ alphabet) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**if**​ (!hashTable[​**char**​]) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**return**​ ​**char**​; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**return**​ ​**null**​; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: The following implementation begins by iterating over each character in the
    string. If the character doesn’t yet exist in the hash table, the character is
    added to the hash table as a key with the value of 1, indicating the character
    has been found once so far. If the character is already in the hash table, we
    simply increment the value by 1\. So if the character "e" has the value of 3,
    it means the "e" exists three times within the string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then we iterate over the characters again and return the first character that
    only exists once within the string. This algorithm is O(N):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ firstNonDuplicate(string) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**const**​ hashTable = {}; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**for**​ (​**const**​ ​**char**​ ​**of**​ string) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**if**​ (hashTable[​**char**​]) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | hashTable[​**char**​] += 1; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } ​**else**​ { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | hashTable[​**char**​] = 1; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**for**​ (​**const**​ ​**char**​ ​**of**​ string) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**if**​ (hashTable[​**char**​] === 1) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**return**​ ​**char**​; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**return**​ ​**null**​; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
