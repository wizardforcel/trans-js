- en: Deletion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deletion is the least straightforward operation within a binary search tree
    and requires some careful maneuvering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we want to delete the 4 from this binary search tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/binary_trees/bst_4.png](images/binary_trees/bst_4.png)'
  prefs: []
  type: TYPE_IMG
- en: First, we perform a search to find the 4\. We won’t visualize this search again,
    since you’ve already got that down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we find the 4, we can delete it in one step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/binary_trees/bst_16.png](images/binary_trees/bst_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Well, that was simple. But let’s see what happens when we try to delete the
    10:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/binary_trees/bst_17.png](images/binary_trees/bst_17.png)'
  prefs: []
  type: TYPE_IMG
- en: We end up with an 11 that isn’t connected to the tree anymore. And we can’t
    have that, because we’d lose the 11 forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, to solve this problem, we can plug the 11 into where the 10 used to
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/binary_trees/bst_18.png](images/binary_trees/bst_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, our deletion algorithm follows these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If the node being deleted has no children, simply delete it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the node being deleted has one child, delete the node and plug the child
    into the spot where the deleted node was.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a Node with Two Children
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Deleting a node that has two children is the most complex scenario. Let’s say
    we want to delete the 56 in this tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/binary_trees/bst_19.png](images/binary_trees/bst_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What are we going to do with its former children, 52 and 61? We can’t move
    both of them to where the 56 was. This is where the next rule of the deletion
    algorithm comes into play:'
  prefs: []
  type: TYPE_NORMAL
- en: When deleting a node with two children, replace the deleted node with the successor
    node. The successor node is the child node whose value is the least of all values
    that are greater than the deleted node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That was a tricky sentence. To put it in other words: if we were to put the
    deleted node and all of its descendants in ascending order, the successor node
    would be the next number after the one we just deleted.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, it’s easy to figure out which node is the successor since the
    deleted node had only two descendants. If we put the numbers 52-56-61 in ascending
    order, the next number after 56 is 61.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we find the successor node, we plug it into where the deleted node was.
    So we replace the 56 with the 61:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/binary_trees/bst_20.png](images/binary_trees/bst_20.png)'
  prefs: []
  type: TYPE_IMG
- en: Finding the Successor Node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How does the computer find the successor node? This can be tricky when we delete
    a node high up in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the algorithm for finding the successor node:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit the right child of the deleted value, and then keep on visiting the left
    child of each subsequent child until there are no more left children. The bottom
    value is the successor node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see this again in action in a more complex example. Let’s delete the
    root node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/binary_trees/delete_root_node.png](images/binary_trees/delete_root_node.png)'
  prefs: []
  type: TYPE_IMG
- en: We now need to plug the successor node into where the 50 was and turn it into
    the root node. So let’s find the successor node.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we first visit the right child of the deleted node, and then keep
    descending leftward until we reach a node that doesn’t have a left child:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/binary_trees/bst_21.png](images/binary_trees/bst_21.png)'
  prefs: []
  type: TYPE_IMG
- en: It turns out that the 52 is the successor node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve found the successor node, we plug it into the node we deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/binary_trees/bst_22.png](images/binary_trees/bst_22.png)'
  prefs: []
  type: TYPE_IMG
- en: And we’re done!
  prefs: []
  type: TYPE_NORMAL
- en: Successor Node with a Right Child
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We haven’t accounted for one case yet, though, and that’s where the successor
    node has a right child of its own. Let’s re-create the preceding tree but add
    a right child to the 52:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/binary_trees/bst_23.png](images/binary_trees/bst_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, we can’t simply plug the successor node—the 52—into the root,
    since we’d leave its child of 55 hanging. This leads us to one more rule for our
    deletion algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: If the successor node has a right child, after plugging the successor node into
    the spot of the deleted node, take the former right child of the successor node
    and place it where the successor node used to be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That was another tricky sentence, so let’s walk through the steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we plug the successor node (52) into the root. This leaves the 55 dangling
    without a parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/binary_trees/bst_24.png](images/binary_trees/bst_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we place the 55 in the spot where the successor node used to be, which
    is the left child of the 61:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/binary_trees/bst_25.png](images/binary_trees/bst_25.png)'
  prefs: []
  type: TYPE_IMG
- en: Successor Node is a Right Child
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It can sometimes happen that the successor node is itself a right child. And
    sometimes this successor node can have a right child of its own. For example,
    in the following tree, if we delete the 3, the 4 becomes the successor node, since
    the 4 has no left children:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/binary_trees/bst_15.png](images/binary_trees/bst_15.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, when we plug the successor node into the spot where the deleted 3 was,
    we don’t make the 5 dangling and reattach it elsewhere. Instead, we simply keep
    the 5 as the 4’s right child.
  prefs: []
  type: TYPE_NORMAL
- en: And now we’re really done.
  prefs: []
  type: TYPE_NORMAL
- en: The Complete Deletion Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Putting all the steps together, here is the algorithm for deletion from a binary
    search tree:'
  prefs: []
  type: TYPE_NORMAL
- en: If the node being deleted has no children, simply delete it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the node being deleted has one child, delete the node and plug the child
    into the spot where the deleted node was.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When deleting a node with two children, replace the deleted node with the successor
    node. The successor node is the child node whose value is the least of all values
    that are greater than the deleted node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To find the successor node: visit the right child of the deleted node, and
    then keep on visiting the left child of each subsequent child until there are
    no more left children. The bottom node is the successor node. If the deleted node’s
    right child has no left children, the deleted node’s right child itself becomes
    the successor node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the successor node has a right child (and the successor node was itself a
    left child of its parent), after plugging the successor node into the spot of
    the deleted node, take the former right child of the successor node and turn it
    into the left child of the former parent of the successor node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Code Implementation: Binary Search Tree Deletion'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s a JavaScript implementation of deletion from a binary search tree. The
    primary method here is delete, which in turn relies on a helper method called
    replaceWithSuccessorNode:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ deleteNode(valueToDelete, node) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**let**​ currentNode = node; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**let**​ parentOfCurrentNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**let**​ childOfDeletedNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**let**​ nodeToDelete; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**while**​ (currentNode) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (currentNode.value === valueToDelete) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | nodeToDelete = currentNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**break**​; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | parentOfCurrentNode = currentNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (valueToDelete < currentNode.value) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | currentNode = currentNode.leftChild; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } ​**else**​ ​**if**​ (valueToDelete > currentNode.value) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | currentNode = currentNode.rightChild; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (!nodeToDelete) { ​**return**​ ​**null**​; } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (nodeToDelete.leftChild && nodeToDelete.rightChild) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | replaceWithSuccessorNode(nodeToDelete); |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } ​**else**​ { ​*// deleted node has 0 or 1 children*​ |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | childOfDeletedNode = (nodeToDelete.leftChild &#124;&#124; nodeToDelete.rightChild);
    |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (!parentOfCurrentNode) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | nodeToDelete.value = childOfDeletedNode.value; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | nodeToDelete.leftChild = childOfDeletedNode.leftChild; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | nodeToDelete.rightChild = childOfDeletedNode.rightChild; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } ​**else**​ ​**if**​ (nodeToDelete === parentOfCurrentNode.leftChild)
    { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | parentOfCurrentNode.leftChild = childOfDeletedNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } ​**else**​ ​**if**​ (nodeToDelete === parentOfCurrentNode.rightChild)
    { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | parentOfCurrentNode.rightChild = childOfDeletedNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**return**​ nodeToDelete; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**function**​ replaceWithSuccessorNode(node) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**let**​ successorNode = node.rightChild; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**let**​ parentOfSuccessorNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (!successorNode.leftChild) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | node.value = successorNode.value; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | node.rightChild = successorNode.rightChild; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**return**​; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**while**​ (successorNode.leftChild) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | parentOfSuccessorNode = successorNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | successorNode = successorNode.leftChild; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (successorNode.rightChild) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | parentOfSuccessorNode.leftChild = successorNode.rightChild; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } ​**else**​ { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | parentOfSuccessorNode.leftChild = ​**null**​; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | node.value = successorNode.value; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**return**​ successorNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: That’s a decent amount of code, but we’ll walk through it step by step.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast with search and insertion, we wrote the deletion code without recursion.
    While we could have written the deletion method recursively, I find that the recursive
    code for deletion is considerably more difficult to grasp. Instead, we use a loop
    to move about the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by walking through the delete method.
  prefs: []
  type: TYPE_NORMAL
- en: When we call this method, we pass in the value we’d like to delete (valueToDelete)
    as well as the root node of the tree (node).
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, we create a few variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**let**​ currentNode = node; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**let**​ parentOfCurrentNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**let**​ childOfDeletedNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**let**​ nodeToDelete; |'
  prefs: []
  type: TYPE_TB
- en: The currentNode initially points to the root but will be updated as we move
    down the tree looking for the value we are to delete. The parentOfCurrentNode,
    as the name implies, will track the parent of the currentNode. The same goes for
    the variable childOfDeletedNode. The reason we need to track these will become
    apparent later on. Finally, the nodeToDelete will eventually point to the node
    we’ll be deleting.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then begin a loop that searches for the valueToDelete within the tree. This
    is essentially a search operation, but again, this time we use iteration instead
    of recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**while**​ (currentNode) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (currentNode.value === valueToDelete) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | nodeToDelete = currentNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**break**​; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | parentOfCurrentNode = currentNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (valueToDelete < currentNode.value) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | currentNode = currentNode.leftChild; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } ​**else**​ ​**if**​ (valueToDelete > currentNode.value) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | currentNode = currentNode.rightChild; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: This snippet moves down through the tree, updating currentNode as we go, searching
    for the valueToDelete. If we don’t find it, which will be the case if the value
    is not present in the tree, the loop will terminate on its own because currentNode
    will be null.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, we do find the valueToDelete, we declare the currentNode to be
    the nodeToDelete and break out of the loop. Note that we also keep track of the
    parentOfCurrentNode, which is now the parent of the node we’ll be deleting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**if**​ (!nodeToDelete) { ​**return**​ ​**null**​; } |'
  prefs: []
  type: TYPE_TB
- en: This returns null if the value we’d like to delete isn’t even in our tree to
    begin with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of this method performs the actual deletion. We first handle
    the most complex case, where the node we’re deleting has two children:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**if**​ (nodeToDelete.leftChild && nodeToDelete.rightChild) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | replaceWithSuccessorNode(nodeToDelete); |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: Here, we outsource the heavy lifting to the replaceWithSuccessorNode helper
    method, which we’ll analyze soon. In the meantime, though, let’s move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we handle the case in which the deleted node has 0 or 1 children:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**else**​ { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | childOfDeletedNode = (nodeToDelete.leftChild &#124;&#124; nodeToDelete.rightChild);
    |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (!parentOfCurrentNode) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | nodeToDelete.value = childOfDeletedNode.value; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | nodeToDelete.leftChild = childOfDeletedNode.leftChild; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | nodeToDelete.rightChild = childOfDeletedNode.rightChild; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } ​**else**​ ​**if**​ (nodeToDelete === parentOfCurrentNode.leftChild)
    { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | parentOfCurrentNode.leftChild = childOfDeletedNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } ​**else**​ ​**if**​ (nodeToDelete === parentOfCurrentNode.rightChild)
    { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | parentOfCurrentNode.rightChild = childOfDeletedNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: Here, we first set a new variable called childOfDeletedNode, which will represent
    the deleted node’s child. In a case where the deleted node has no children, this
    variable will be set to null. This variable is crucial, for when we delete our
    nodeToDelete, we need to place its child in the spot where the deleted node used
    to be.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s exactly what the code above does in the two else if clauses. It determines
    whether the deleted node was a left or right child of its parent, and attaches
    the childOfDeletedNode to the deleted node’s parent accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The first clause in the if statement handles the case where we’re deleting the
    root node. To ensure that we mark the deleted root’s child as the new root, we
    overwrite the root with its child.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to the final line of our method, which simply returns the deleted
    node in case we may want to use it for some other purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**return**​ nodeToDelete; |'
  prefs: []
  type: TYPE_TB
- en: Let’s now return to the case where the deleted node had two children. Our previous
    code called the helper method replaceWithSuccessorNode, so let’s walk through
    that now.
  prefs: []
  type: TYPE_NORMAL
- en: When calling this method, we pass in the node that we’ll be deleting, which
    will be called node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we identify the successor node using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**let**​ successorNode = node.rightChild; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**let**​ parentOfSuccessorNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (!successorNode.leftChild) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | node.value = successorNode.value; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | node.rightChild = successorNode.rightChild; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**return**​; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**while**​ (successorNode.leftChild) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | parentOfSuccessorNode = successorNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | successorNode = successorNode.leftChild; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: Here, we begin at the deleted node’s right child, and then move down the tree
    following left children until we can’t go any further. That bottom node is our
    successor node. We also keep track of the successor node’s parent.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the case that the successor node happens to be the deleted node’s
    right child (which occurs when the deleted node’s right child has no left children),
    we simply plug the successor node into the spot where the deleted node was. If
    this is the case, this is all we need to do. But if the successor node is a left
    child of its parent, we move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we remove the successor node from its spot:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**if**​ (successorNode.rightChild) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | parentOfSuccessorNode.leftChild = successorNode.rightChild; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } ​**else**​ { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | parentOfSuccessorNode.leftChild = ​**null**​; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: Our code deals with two possible cases. The second case (in the else clause)
    is the simpler case, which is when the successor node has no children. In that
    case, we wipe away the successor node by replacing it with null.
  prefs: []
  type: TYPE_NORMAL
- en: In the more complex case, where the successor node has a right child, we place
    that right child in the spot where the successor node used to be.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve successfully removed the successor node from the tree, but there’s one
    more critical step. Remember we didn’t initially set out to delete the successor
    node. Our entire goal was to delete the node from higher up in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we plug the successor node into the spot of the node we’re deleting:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | node.value = successorNode.value; |'
  prefs: []
  type: TYPE_TB
- en: Note that we don’t plug in the actual successor node; instead, we simply use
    its value to overwrite the value of node, effectively deleting node.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! It was a journey, but we did it.
  prefs: []
  type: TYPE_NORMAL
- en: The Efficiency of Binary Search Tree Deletion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like search and insertion, deleting from trees is also typically O(log N). This
    is because deletion requires a search plus a few extra steps to deal with any
    hanging children. Contrast this with deleting a value from an ordered array, which
    is O(N) due to shifting elements to the left to close the gap of the deleted value.
  prefs: []
  type: TYPE_NORMAL
