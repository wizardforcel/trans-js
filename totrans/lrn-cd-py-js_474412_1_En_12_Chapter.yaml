- en: © The Author(s), under exclusive license to `Springer Fachmedien Wiesbaden GmbH`,
    part of `Springer Nature` `2024J. L. Zuckarelli`Learn coding with `Python` and
    `JavaScript` [`https://doi.org/10.1007/978-3-658-42912-6_12`](https://doi.org/10.1007/978-3-658-42912-6_12)
  id: totrans-0
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`12. How Do I Input and Output Data?`'
  id: totrans-1
  prefs:
  - PREF_H1
  stylish: true
  type: TYPE_NORMAL
- en: '`Joachim L. Zuckarelli`^([1](#Aff2)  )(1)`München, Germany`Overview'
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In the last chapter we dealt with the question of how data can be stored with
    the help of variables in such a way that we can work with them in the program.
    We now turn to the question of how we can bring data into the program from the
    outside (in this context we speak in a broader sense of “data input”) and also
    get it out of the program again (“data output”). This involves both data input
    and data output directly from/to the user, as well as input and output in the
    context of files and databases. In this chapter, we deal with how a program communicates
    with its “outside world”。
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'You will learn the following:'
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: What distinguishes the two key basic modes of direct user input and output,
    graphical user interfaces and console applications, and when which form is preferable
  id: totrans-5
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Which the most important control elements on graphical user interfaces are
  id: totrans-6
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: How to design graphical user interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: How to read data from and write data to files
  id: totrans-8
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: How to work with databases in the basics.
  id: totrans-9
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`12.1 Forms of Data Input and Output`'
  id: totrans-10
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: Most programs communicate in one way or another with their “environment”。 The
    “environment” includes, of course, first and foremost the user of the program,
    who provides information and makes decisions. But part of the environment are
    also other objects and phenomena whose properties and states have an influence
    on the program flow. For example, if we are talking about software that is supposed
    to proactively turn up your heating when it starts to get cold, the current (and
    possibly predicted) temperatures are part of the program’s relevant environment.
    Of course, the program can only process information about this environment if
    it is made known to it in the form of data. In this chapter we want to take a
    closer look at this “making known”。 It is therefore a question of how information
    can be “entered” into the program in the form of data.
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: When the term “input” is used, the first thing that comes to mind is probably
    direct input by the user, and especially input with the aid of a `keyboard`. But
    of course, this is not the only way that the user can provide data to the program.
    Other input devices, of which `microphone`, `webcam`, `mouse`, `joystick`, or
    `touchscreen` are only a few examples, allow you to input very different kinds
    of data—for example sound, video, position, direction and speed data. But not
    all input comes directly from the user. `Files` and `databases` are also possible
    sources of data input that a program works with. The program for heating control,
    for example, will perhaps query data from the `database` of a `meteorological
    service` via a web interface to determine whether the heating needs to be turned
    on, and if so, when, and how much.
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Conversely, a wide range of options are available for `outputting` data. Examples
    of this are, above all, the output on the screen and the writing of data to files
    and databases.
  id: totrans-13
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In this chapter, we will deal with three types of data input and output in programs—input
    or output by or to the user via a `user interface` of some kind, as well as working
    with `files` and `databases`. Since the latter is not a trivial matter and usually
    requires knowledge of a separate programming language (a query language) developed
    specifically for this purpose, we will only cover this subject area here in an
    overview, but at least in such a way that you develop a solid understanding of
    this enormously important field in the practice of modern software development.
    Of course, there are other ways in which data can get into your program or be
    made available from your program, for example via `APIs` (Application Programming
    Interfaces). As an introductory book, however, we will concentrate on the three
    mentioned above.
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`12.2 Graphical or Non-Graphical: That Is the Question Here`'
  id: totrans-15
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: Since the advent of operating systems with graphical user interfaces and the
    triumph of the World Wide Web, we have become accustomed to entering and viewing
    data on attractively designed `graphical user interfaces` (GUIs, or, because `graphical`
    is the standard today anyway, simply UIs). What “attractive” means in this context
    depends on taste and the technical possibilities of the respective time and technological
    environment.
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: What GUIs of all times and all technical varieties have in common is that they
    try to make the input of data as convenient as possible for the user by means
    of suitable `control elements`. For example, by not having to enter numbers from
    a given range of values via the keyboard, but by allowing them to be conveniently
    defined by means of sliders.
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Especially in the course of the increasing importance of mobile and web applications,
    completely new job descriptions have developed, those of the `user interface designer`
    (`UI designer`) and the `user experience designer` (`UX designer`). While the
    `UI designer` technically designs the interface and “wires” it to the program
    code behind it, the `UX designer` is intensively concerned with the end users
    and their behavior. In a sense, he is the `UI designer`’s market researcher and
    tries to find the optimal way for end users to interact with the application.
    The `UI designer` can then implement the `UX designer`'s findings in the user
    interface. While the `UI designer` is more concerned with the “inside”, with technical
    design, the work of the `UX designer` is more concerned with the “outside” and
    consists mainly of understanding the end users and their way of working.
  id: totrans-18
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: If you’re not professionally involved in programming, you’ll usually be a `developer`,
    `UX designer` and `UI designer` all rolled into one. This is more work, but it
    also means that you can let your creativity run wild when designing your interfaces.
    However, you will also have to consider the needs and desires of your users, unless
    you are developing the software exclusively for yourself.
  id: totrans-19
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: With the triumph of graphical user interfaces, `console applications` have almost
    completely gone out of fashion in the end-user area. Those who worked with operating
    systems such as `MS-DOS` in their early computer days, or who today operate a
    `Linux` system and do so not exclusively via one of the graphical front-ends for
    `Linux`, may still remember with a pleasant shiver. `Console applications` offer
    only one form of direct input by the user, namely via the keyboard.
  id: totrans-20
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'A central difference, however, is not only in how the interface appears visually
    and in terms of ease of use. The program flow of `console applications` is usually
    quite different from that of applications with `GUIs`. Based on Karl Marx’s famous
    dictum that being determines consciousness, one could say: “The interface determines
    programming”. This is because `console applications` are usually `linear programs`,
    they run step by step. For example, first something is displayed (such as: “Please
    enter your username”); then the program waits for user input. Once the user has
    made his input and confirmed it with `<ENTER>` or `<RETURN>`, the program’s next
    output follows (“Please enter your password”); the program waits again until the
    user has made his input and confirmed it. Then the program processes the input
    (checks `username` and `password` for validity, for example) and responds again
    with an output (“Access granted.”), and so on.'
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 这与图形用户界面不同。在这里，程序通常不会指定用户操作的确切顺序。在我们的示例中，用户也可以先输入密码，然后再输入用户名。只有点击登录按钮才会触发程序检查用户输入。考虑到诸如文字处理程序的图形用户界面时，这一差异变得更加明显，在此界面中，用户可以使用按钮访问各种功能，或者直接开始处理文档文本。这种与程序的交互方式是`非线性的`。相反，程序观察用户的行为并对`事件`做出响应，例如点击按钮或从菜单中选择功能。因此，具有图形用户界面的程序通常是`事件驱动的`。如果用户触发了某个事件，程序会跳转到描述在此事件发生时应做什么的代码位置。如果用户随后触发了另一个事件，程序再次跳转到正确的位置，无论该段代码在程序的源代码中的具体位置在哪里。与控制台应用程序严格按顺序执行一行代码、构成线性语句序列不同，在事件驱动编程中，处理“跳跃”于一组语句到另一组语句，具体取决于用户的行为。
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在►`Chap. [14](474412_1_En_14_Chapter.xhtml)`中，当我们讨论如何使程序响应用户输入时，我们将更详细地研究事件驱动程序。在本章中，我们将首先处理数据输入的可能性，即接口本身。
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`12.2.1` 图形用户界面'
  id: totrans-24
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: '`12.2.1.1` 重要控件'
  id: totrans-25
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 图形用户界面上使用的控件可能因操作系统（例如，`Windows`、`macOS`、`Android`、`iOS`）和平台（计算机、平板电脑、智能手机）而异。然而，几乎所有操作系统和平台上都存在许多元素。
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在接下来的部分中，我们将简要查看最重要的控件元素及其核心属性。除了此处提到的属性外，这些控件还具有许多其他特征。它们中的一些是特定于各自的控件元素，其他则是所有控件或至少绝大多数控件所共有的。后者包括在表面上的位置、尺寸（高度和宽度）、可见性（控件元素当前是否可见或是否被隐藏？）、可用性（用户当前能否使用该控件元素？它是激活状态，还是非激活状态，从而被锁定且“灰显”？）、名称（以便在程序中进行引用）和颜色。
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Edit`字段`图形用户界面`提供`edit`字段用于经典键盘输入。根据类型或设置，这些字段允许在一行或多行中输入信息（◘ 图[12.1](#Fig1)、[12.2](#Fig2)和[12.3](#Fig3)）。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig1_HTML.jpg)'
  id: totrans-28
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 一个输入字段的屏幕截图显示文本输入。
  id: totrans-29
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 图`12.1`
  id: totrans-30
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 输入字段的示例
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig2_HTML.jpg)'
  id: totrans-32
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: 一个输入字段的屏幕截图上有十个点。
  id: totrans-33
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 图`12.2`
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 输入字段的示例
  id: totrans-35
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig3_HTML.jpg)'
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: 一个输入字段的屏幕截图显示了右侧带有垂直滚动条的外语文本。
  id: totrans-37
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 图`12.3`
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 输入字段的示例
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`edit`字段通常可以进行广泛配置，或者提供不同属性的不同`edit`字段。例如，用户的密码输入可以通过简单地不显示任何内容或显示特定字符来进行掩码处理。此外，输入的信息通常可以在输入时进行验证。例如，这可以用于强制用户输入数字输入；如果用户输入字母，则该文本根本不会被`edit`字段接受为输入。有时，不同输入的不同部分需要进行不同格式的处理（例如，当输入需要显示语法高亮的程序代码时）；这时需要一个能够处理不同文本格式的输入字段。'
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`按钮`按钮是屏幕上定义的可单击区域，用户通常通过它触发操作，例如保存文档或发送消息（◘ 图[12.4](#Fig4)）。按钮的最重要特征是其标签和在单击按钮时执行的程序部分的链接。视觉外观通常也由一个符号图像主导，该图像风格化了按钮触发的操作。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig4_HTML.jpg)'
  id: totrans-41
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 一个按钮的屏幕截图显示，`Say, hello world`在双引号中。
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 图`12.4`
  id: totrans-43
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 按钮的示例
  id: totrans-44
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`菜单`像按钮一样，菜单用于让用户触发操作。重点是从各种选项中选择菜单项。这也解释了控件元素的名称，用户以类似于餐厅菜单的方式使用它。此外，菜单及其项的名称、用户通过单击项可以触发的操作等重要属性，再次类似于按钮（◘
    图[12.5](#Fig5)）。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig5_HTML.jpg)'
  id: totrans-45
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 一个屏幕截图显示了带有标签`menu 1`和`menu 2`的菜单栏。`menu 1`标签下的下拉菜单显示了`menu item 1.1`、`menu
    item 1.2`和`menu item 1.3`。`menu item 1.2`被高亮显示。
  id: totrans-46
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 图`12.5`
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 菜单的示例
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Checkboxes and Radio Buttons` `Checkboxes` and `radio buttons` are control
    elements that allow the user to make a selection between several options. Unlike
    buttons and menus, clicking on one of these elements does not usually trigger
    an immediate action. Instead, `checkboxes` and `radio buttons` are usually used
    to specify settings that control the exact behavior of actions that the user later
    triggers elsewhere, such as by clicking on a button or menu item. For example,
    the user could use a `radio button` to choose whether to open a file read-only
    or not. The actual action, the opening of the file, is triggered later by clicking
    on a button `“Open file”`. What exactly a click on this button does (whether the
    file is opened in read-only mode or in such a way that it can also be modified)
    is determined by the setting previously made with the help of the `radio button`
    (◘ Figs. [`12.6`](#Fig6) and [`12.7`](#Fig7)).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig6_HTML.jpg)'
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of a list reading `checkbox 1` and `checkbox 2`。 Both have square-shaped
    checkboxes in front of them, where `checkbox 1` is selected.
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fig. 12.6
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Examples of `checkboxes`
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig7_HTML.jpg)'
  id: totrans-53
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: A screenshot of a list reading `radio button 1` and `radio button 2`。 Both have
    circular buttons in front of them, where `radio button 2` is selected.
  id: totrans-54
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fig. 12.7
  id: totrans-55
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Examples of `radio buttons`
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Checkboxes` often appear in multiples, `radio buttons` always. The difference
    between the usually square `checkboxes` and the round `radio buttons` is that
    *only one option* can be selected from a group of such control elements in the
    case of `radio buttons`, but *several can* be clicked on in the case of `checkboxes`.'
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Toggle Buttons` Similar to `checkboxes`, `toggle` buttons allow you to toggle
    an option on or off. Unlike `checkboxes`, however, there are no checkmarks to
    indicate whether the option is currently selected or not. Instead, the appearance
    is modeled after a slide switch. `Toggle buttons` have become popular with the
    triumph of the mobile operating systems `iOS` and `Android` but are now also available
    on other platforms (◘ Fig. [`12.8`](#Fig8)).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig8_HTML.jpg)'
  id: totrans-58
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of a `toggle button` resembles a horizontally oriented bright cylindrical
    structure with a sphere at the right.
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fig. 12.8
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Example of a `toggle button`
  id: totrans-61
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Sliders` `Sliders` are control elements that allow you to make a selection
    along a scale, i.e., between options that can be arranged in an order based on
    some criterion. Like `radio buttons` and `checkbox/toggle buttons`, a change in
    the current selection by the user does not usually trigger an immediate action.
    In most cases they are used to make a setting that takes effect later when the
    user triggers an action, such as clicking on a button or menu item (though sometimes
    changes made by the user have a direct effect, such as when the slider is used
    to scale a graphic that automatically updates when the slider control is moved).
    Its most important setting is the scale, the gradation in which the user can adjust
    the slider control, particularly the number and designation of the expressions
    (◘ Figs. [`12.9`](#Fig9) and [`12.10`](#Fig10)).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig9_HTML.jpg)'
  id: totrans-62
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of a slider with a rectangular scale reading measurements at the
    bottom. A bright shaded block moves on the scale.
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fig. `12.9`
  id: totrans-64
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Example of a slider
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig10_HTML.jpg)'
  id: totrans-66
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: A screenshot of a slider resembles a horizontal bar with a small spherical structure
    surrounded by rays at the left, and a big spherical structure surrounded by rays
    at the right. A dot moves on the bar.
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fig. `12.10`
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Example of a slider
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`List Views`/`List Boxes` `List views` or `list boxes` are “flat”, non-hierarchical
    lists of items that allow the user to select one or more of these items. An example
    of the use of `list views` are `file managers` that list the files contained in
    a folder. In this case, the elements shown in the list view can be provided with
    icons. Sometimes, in addition to the name of the element, other properties of
    the elements are displayed in extra columns of the list view, for example, their
    size or the date of their last modification. In addition to the type of display
    (icons, additional columns for supplementary element properties), an important
    property that can be specified when using `list views` is whether the user should
    be able to select only a single element at a time or several elements at once
    (◘ Fig. [`12.11`](#Fig11)).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig11_HTML.jpg)'
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of a list with three columns. The column headers are `element`,
    `property 1`, and `property 2`。`Element` has items `1` to `4`。`Property 1` has
    `property 1.1`, `2.1`, `3.1`, and `4.1`。`Property 2` has `1.2`, `2.2`, `3.2`,
    and `4.2`。
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fig. `12.11`
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Example of a list view
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Tree Views` are similar to lists in the sense that they allow multiple elements
    to be displayed. Unlike lists, however, they have a tree-like structure, i.e.,
    they display hierarchical relationships between the elements. A classic example
    for the use of `tree views` are the `folder views` in file managers, where the
    hierarchy of the folders is typically displayed as a tree structure. This is a
    very good way to represent hierarchical relationships of any kind, such as the
    structure of an organization or a hierarchy of products, ranging from broad product
    categories down to individual products. Unlike `list views`，`tree views` typically
    have no additional columns for displaying further properties of the hierarchically
    arranged elements (◘ `Fig. [12.12](#Fig12)`)。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig12_HTML.jpg)'
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of a menu displays the expanded view of a list under `node 1` and
    `node 2`。`Node 1` has `element 1.1` and `element 1.2`。`Node 2` has `element 3`。
  id: totrans-75
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Fig. 12.12`'
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Example of a `tree view`
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Pickers` are control elements that allow you to make a selection from several
    predefined options, usually without immediately triggering any action. In this
    respect, they are similar to `radio buttons`，which also allow a selection of settings
    from several predefined alternatives. However, the types and forms in which pickers
    appear are very different. Sometimes they allow the selection from a predefined,
    but large and complex set of possibilities. A good example of such a choice is
    the `date picker` that has become commonplace on mobile and non-mobile platforms.
    Two very different examples of such `date pickers` are shown in ◘ `Figs. [12.13](#Fig13)`
    and `Figs. [12.14](#Fig14)`。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig13_HTML.jpg)'
  id: totrans-78
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of the list of dates in three columns in the format of `date`，`month`，and
    `year`。`7` dates are listed from year `2021` to `2027`。A tick mark and a cross
    mark are at the bottom. The date `07 05 2024` is highlighted。
  id: totrans-79
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Fig. 12.13`'
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Examples of `date pickers`
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig14_HTML.jpg)'
  id: totrans-82
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: A screenshot of a `calendar` displays `May 2023` with up and down arrows to
    the right. The date `1` starts on a `Monday` and the last date `30` is on a `Sunday`。The
    date `27` is highlighted which falls on a `Saturday`。
  id: totrans-83
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Fig. 12.14`'
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Examples of `date pickers`
  id: totrans-85
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Of course, `pickers` do not necessarily have to be based on such a complex selection
    situation as the date. `Pickers` are often used to select from a manageable list
    of simple text options. In this sense, `pickers` also include the good old `combo
    box` as shown in ◘ `Fig. [12.15](#Fig15)`，which presents a list of selection options
    that expands downwards。![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig15_HTML.jpg)
  id: totrans-86
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of a dropdown under the `combo box 1` field. It lists `Entry 1`,
    `Entry 2`, `Entry 3`, `Entry 4`, and `Entry 5`。
  id: totrans-87
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Fig. 12.15`'
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Example of a `combo box`
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`12.2.1.2 Developing Graphical User Interfaces`'
  id: totrans-90
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: Now that we have looked at some popular controls for graphical user interfaces,
    the question naturally arises as to how exactly one technically develops an interface.
    Somehow the arrangement of controls and their properties have to be defined. The
    best interface design you have thought up and perhaps sketched out on paper or
    with the help of a graphics or presentation program won’t help you if you can’t
    turn it into a truly usable program interface, a real GUI.
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: This is often done with the help of the `Integrated Development Environments`
    (`IDE`s), which we already learned about in ► Sect. `[8.​1.​3](474412_1_En_8_Chapter.xhtml#Sec4)`.
    These often allow you to “click” together graphical user interfaces without programming
    by selecting the different controls and placing them where you want them. ◘ Fig.
    `[12.16](#Fig16)` shows the integrated development environment of `Delphi`. Here
    you can see how a graphical user interface is being created. On the right (the
    “Palette” area), different control elements can be selected, which can then be
    placed in the program window using drag & drop. Their size can also be adjusted
    using the mouse. In the “Object Inspector” on the left, you can see the properties
    of the currently selected control element, in this case the selected button. The
    selected property you can see here is the “Caption”, the label of the button.
    Other properties are, for example, the shape the cursor should take when you move
    the mouse over the button (`Cursor`), the font of the button caption (`Font`)
    or the height of the control (`Height`). Obviously, even with a simple button
    you can make quite a few settings to define the appearance and behavior in detail.![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig16_HTML.jpg)
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of the test project - `Delphi 11 community edition` - `unit 2`
    window with three panels. Panel 1 lists the tools under the structure and object
    inspector. Panel 2 is the workspace displays the `button 1` under the `unit 2`.
    Panel 3 lists the options under `test projects` and `palette`.
  id: totrans-93
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fig. `12.16`
  id: totrans-94
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Designing a graphical user interface with `Delphi`
  id: totrans-95
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: On the “Events” tab of the object explorer you would get an overview of the
    `events` that this control can trigger. In addition to the click, you can also
    move the mouse over the button. For more information, see ► Sect. `[14.​7](474412_1_En_14_Chapter.xhtml#Sec7)`,
    where we will look at events in more detail.
  id: totrans-96
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: By the way, `Delphi` stores the graphical user interface internally (called
    “form” there) as a code file. You can see this in ◘ Fig. `[12.17](#Fig17)`. You
    could also edit the interface by adding or deleting elements in this text file
    or by changing the characteristics of their properties. More convenient, of course,
    is editing by drag & drop in `WYSIWYG` mode (`what you see is what you get`),
    as seen in ◘ Fig. `[12.16](#Fig16)`.![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig17_HTML.jpg)
  id: totrans-97
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of test project - `Delphi 11 community edition` - `unit 2` window
    with 3 panels. Panel 1 has the structure and object inspector. Panel 2 is the
    workspace that displays a program under `unit 2`. Panel 3 lists the options under
    test projects and palette.
  id: totrans-98
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fig. `12.17`
  id: totrans-99
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Graphical user interface as `Delphi` stores it internally
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Some programming languages are designed to define graphical user interfaces
    directly in the program code, similar to the way `Delphi` does it in the background.
    The individual elements of the interface are then usually objects in the sense
    of object-oriented programming. They are created by program statements, placed,
    adjusted with respect to their properties, and “wired” to the rest of the program
    code. You will learn more about this procedure using `Python` as an example in
    ► Sect. `[22.​2](474412_1_En_22_Chapter.xhtml#Sec2)`. In ► Sect. `[32.​4](474412_1_En_32_Chapter.xhtml#Sec4)`,
    we will see how, in the case of `JavaScript`, the interface is designed with program
    code, but in a different language (namely `HTML`) than the one in which the actual
    program is written.
  id: totrans-101
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`12.2.2 Console Applications`'
  id: totrans-102
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: How Console Applications Work
  id: totrans-103
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Console applications do not have a graphical user interface, only a text interface.
    They run either in the operating system’s console or terminal (for example, `Linux
    Bash`, `Mac Terminal`, or `MS-DOS prompt`) or in an integrated development environment.
    In the former case, they are programs that the operating system can execute directly
    (i.e., programs already in machine code) or programs in an interpreted language
    that are executed by calling the interpreter in the operating system’s console
    and having it execute the program code. When executing in an `Integrated Development
    Environment`, the program is called from the development environment, i.e., a
    graphical user interface, but it only has a text interface itself, so it practically
    runs like a console application. Again, the programming language interpreter is
    called and executes the program, except that the console in which it runs is hard-coded
    into the `IDE`. In Part III of the book, we will develop console applications
    with `Python` and call them from a graphical `IDE`.
  id: totrans-104
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The special feature of console applications is that they usually run in a strictly
    linear fashion. Whereas the user can decide for himself via the event-driven graphical
    user interface which functions he calls in which order, in the console application
    he follows the sequence that is permanently built into the program. Here is a
    simple example (where `>` shows something entered by the user):'
  id: totrans-105
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Please enter the temperature in degrees Celsius:`>` 23 Conversion to Kelvin
    or degrees Fahrenheit (`K/F`)? `>` `K` 23 degrees Celsius in degrees Kelvin is:
    `296.15`.'
  id: totrans-106
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'In a graphical user interface, you might be able to use a radio button to select
    which temperature system to convert your input to. And most importantly, you probably
    could have made this selection `before` you entered the temperature to be converted
    in degrees Celsius. Not so with the console application with its text interface:
    it dictates what you have to enter and when. In this case, the program does not
    run event-driven, but linear.'
  id: totrans-107
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Here are two examples of how the first part of the above program might look
    in two programming languages, Pascal and Python; first in Python:'
  id: totrans-108
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`temp_celsius = input(''Please enter the temperature in degrees Celsius:'')target_scale
    = input(''Conversion to Kelvin or degrees Fahrenheit (K/F)?'')`'
  id: totrans-109
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As you can see, it’s quite simple to query an input from the user. Since you
    don’t have to declare variables in Python, each input is ultimately just a single
    line of code.
  id: totrans-110
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Now the whole thing in Pascal:'
  id: totrans-111
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`program temp var temp_celsius : real; target_scale : char; begin write("Please
    enter the temperature in degrees Celsius:"); readln(temp_scale); write("Conversion
    to Kelvin or degrees Fahrenheit (K/F)?"); readln(target_scale); end.`'
  id: totrans-112
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In Pascal, the variables we use must be declared, a floating-point number variable
    (`real`) and a variable that takes only a single character (`char`). The input
    as such is done here using the `readln()` function, which stands for `read line`,
    which means that after the input, a line break is automatically done so that the
    next output starts on a new line. Without the `ln`, the cursor would simply stop
    after the input. So, the next output would start exactly at that point. There
    is an analogous distinction in output, where a distinction is made between `write()`
    and `writeln()`.
  id: totrans-113
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Why Console Applications at All?
  id: totrans-114
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'There is one important question we haven’t answered yet: Why would anyone develop
    a console application at all, today, when there are so many fascinating options
    for graphical interfaces available? The most obvious reason is that it’s easier
    and faster. For example, if you want to try something out, like a new function
    library or a certain algorithm, it would be a waste of time to put a lot of work
    into designing a perfect graphical interface. Most of the time, a very simple
    console application that allows only rudimentary text interaction with the user
    is enough. Concentrate your work on the essentials and not on visual attractiveness
    and good usability, which is not necessary for your actual purpose!'
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`To understand even better why console applications have not yet gone out of
    fashion, it is worth taking a look at professional or at least ambitious software
    developers. They greatly appreciate command line tools that run in the console.
    And this for several reasons: For one, working with command-line programs is more
    ergonomic, because you can perform all tasks with just one input instrument, the
    keyboard, and you don’t have to laboriously use the mouse to call up the corresponding
    buttons or menu items in a graphical development environment. In addition, command
    line parameters, special control options that are passed directly to the console
    program when it is called, allow the program behavior to be controlled effortlessly
    and very precisely, which would be incomparably more tedious with a whole series
    of clicks on a graphical interface. Also, console applications are regularly less
    demanding in terms of system resource consumption (especially memory and processing
    power), which can mean they run faster. It is therefore not surprising that many
    developer tools come as console applications, for example the well-known versioning
    tool *git* or the text editor *vi*. As a rule, these tools have the same parameters
    and control options on all operating system platforms, making it easy for the
    developer to switch back and forth between different platforms. And finally, although
    no developer would ever openly admit it, it’s also kind of cooler, nerdier to
    work on the console command line than to click together your commands on a graphical
    user interface, just like any “normal” user.`'
  id: totrans-116
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Many professional developers use a computer with *MacOS* or *Linux* as the operating
    system instead of a Windows-based system. Asked about the reasons, many say that
    these two operating systems offer the better console, so they can work more comfortably
    on these systems. It’s no wonder then that Microsoft, whose strategic thrust is
    explicitly to cater especially to the needs of developers, has released a modern
    console app in the summer of 2019 that aims to put Windows operating systems back
    into the competition for developers’ favor.
  id: totrans-117
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`12.1`'
  id: totrans-118
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Explain two ways in which graphical user interfaces can be developed.`'
  id: totrans-119
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`12.2`'
  id: totrans-120
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Explain the basic difference in program flow between console applications
    and those with a graphical user interface.`'
  id: totrans-121
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`12.3`'
  id: totrans-122
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`List two advantages of console applications over graphical user interface
    applications.`'
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`12.3 Working with Files`'
  id: totrans-124
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 'The Fastest Way: Immediate Reading and Writing of FilesData can not only be
    entered by the user but can also come from files. Working with files is basically
    always the same and very simply structured:'
  id: totrans-125
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`The file in question is opened`'
  id: totrans-126
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`Their content is read out (or content is written into them)`'
  id: totrans-127
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`The file is closed.`'
  id: totrans-128
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 一些编程语言具有允许您直接编辑文件的函数，而无需明确担心打开和关闭它们。以下是三个示例。首先是来自 F#（“F Sharp”）的示例：`File.WriteAllText("test.txt",
    "A sample text written directly")`
  id: totrans-129
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: PHP 中的相同内容：
  id: totrans-130
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`file_put_contents("test.txt", "A sample text written directly")`'
  id: totrans-131
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 最后，在 R 中：
  id: totrans-132
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`cat("A sample text, written directly ", file = "test.txt", append = TRUE)`'
  id: totrans-133
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在所有这三种情况下，文本“A sample text, written directly”会写入名为`test.txt`的文件。该文件不必明确打开或关闭；所使用的函数会在我们干预之前处理这些。
  id: totrans-134
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Modes of File Processing
  id: totrans-135
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 然而，所有这些语言也具有独立执行上述三步的函数。如果，例如，您想多次从同一个文件中写入或读取数据，那么每次打开和关闭文件都是低效的。在这种情况下，您肯定不会使用刚才考虑的函数，而是首先打开文件，然后多次写入或读取数据，并在所有工作完成后再关闭文件。
  id: totrans-136
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 我们在 F#、PHP 和 R 中看到的写入操作，如果名为`test.txt`的文件不存在，将创建一个新文件，然后将我们的示例文本写入该新文件。但如果文件已经存在，其内容将被简单地覆盖，而不会提示或确认。仅在第三个示例，即统计语言
    R 中，使用了选项`append=TRUE`来控制现有文件内容不会被覆盖，而是将我们的文本附加到现有内容上。
  id: totrans-137
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 因此，写入与写入并不相同。实际上，文件可以打开的模式基本上有三种：
  id: totrans-138
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Read（通常是`read`或`r`）
  id: totrans-139
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Writing（通常是`write`或`w`）
  id: totrans-140
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Append（通常是`append`或`a`）
  id: totrans-141
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 模式“Write”和“Append”在所需名称的文件尚不存在时会定期创建一个新文件。它们在处理现有文件内容的方式上有所不同。在“Write”模式下，这些内容通常会被完全替换。在许多编程语言中，混合模式也是可能的，例如`ra`（读取
    = `r` 和追加 = `a`）。
  id: totrans-142
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Incidentally, for historical reasons and the way file systems have always worked,
    there is no `insert` mode. So, you normally can’t just open a file, go to a specific
    location within the file, and then just insert additional content there. Instead,
    although it’s awkward, you have to rebuild the contents of the file in a variable
    in your program, that is, read the existing first part of the file into a variable
    (such as a `string variable`), then append the contents to be inserted to that
    variable, and finally read the back part of the file and append that to the new
    contents variable as well. Afterwards you can open the file in `write` mode and
    write the content of the variable into the file. This way you have completely
    overwritten the old file content, but in fact, you have only inserted something.
  id: totrans-143
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The situation is different when reading: Here you can regularly move the `file
    pointer`，which indicates where the next operation in the file should take place,
    to any position in the file. When opening a file in `write` mode, on the other
    hand, the `file pointer` is automatically set to the beginning of the file (and
    cannot be moved away from there, at least not without actually writing something),
    and when opening it in `append` mode, it is set to the end of the file.'
  id: totrans-144
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Besides the type of editing operation to be performed on the file, the modes
    for opening files also differ with respect to another characteristic, namely whether
    the edited files are `text` or `binary files`. The difference between the two
    is most obvious with numbers. The number `32,000` is `0111110100000000` in binary
    terms, i.e., a 16-bit sequence of zeros and ones. Two bytes (8 bits each) are
    sufficient to store this value. In a `text file`, however, the number `32,000`
    would be considered text. So, if it is stored, the individual characters, “3”,
    “2”, “0”, “0” and again “0” are stored. The resulting file would then be 5 bytes
    in size. Differences between `text` and `binary files` also exist in the encoding
    of line breaks and the signaling of the end of the file, for which `text files`
    have a special character, the `EOF` character (end of file). `Text files` are
    usually such that you see letters and numbers when you open them. For example,
    program code that you write is stored in a `text file`. On the other hand, if
    you open, say, a `PDF` file or an executable program file with a `text editor`,
    all you will see is a seemingly random pattern of strange special characters;
    these are `binary files` that your `text editor` is trying to represent as `text`.
    To deal with the two different basic types of files, many programming languages
    have separate modes for writing, appending, and reading `text files` and `binary
    files`.
  id: totrans-145
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Now let’s take a closer look at opening, editing and closing files. In general,
    these operations can be represented in our pseudo-code like this:'
  id: totrans-146
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`my_file = open("test.txt", "w")` `write(my_file, "First sample text written
    to the file.")` `write(my_file, "Another sample text.")` `close(my_file)`'
  id: totrans-147
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In most languages, when a file is opened, a variable of a special type is returned.
    In our pseudo-code, we get back a variable `my_file` from the `open()` function
    we use to open the file `text.txt` in write mode (`w`)。From now on, we work with
    this variable so that the functions we use to edit the file know which file our
    instructions refer to; after all, we could have a whole series of different files
    open in parallel.
  id: totrans-148
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'In object-oriented programming languages, the file variable will regularly
    be an object, which then has special methods that can be used to manipulate the
    file (flip back a few pages to the last chapter if the topic of objects and methods
    seems unfamiliar). Then writing and closing the file might look something like
    this:'
  id: totrans-149
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`my_file = open("test.txt", "w")` `my_file.write("Another sample text.")` `my_file.close()`
    Examples in Different Programming Languages'
  id: totrans-150
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Let’s look at this in some actual existing programming languages.
  id: totrans-151
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Here is an example in C:'
  id: totrans-152
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`#include <stdio.h>` `int main() {FILE *my_file; my_file = fopen("test.txt",
    "w"); fprintf(my_file, "First sample text written to file."); fprintf(my_file,
    "Another sample text."); fclose(my_file);}`'
  id: totrans-153
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The code looks considerably more complicated than it actually is. To make it
    work, the first statement must include a special standard program library called
    `stdio.h`，which provides the functions for input and output. The main program
    in C is itself a function, `main()`，which is called automatically when the program
    is executed. What should happen then is inside the function and is what we are
    actually interested in here. In C, variables must be registered before they are
    used for the first time. Here, a variable of type `FILE` is declared, and the
    asterisk is used to create a `pointer` to such a variable, but we won’t concern
    ourselves with the implications at this point. The variable just created then
    takes the return value of the function `fopen()` (for `file open`), which we use
    to open file `test.txt` in write mode (`w`)。If this file does not exist yet, it
    will be created. After that we write with the function `fprintf()` (for `file
    print formatted`) into the just opened file, which we reference with the help
    of our variable `my_file`。Afterwards we close the file with `fclose()`。
  id: totrans-154
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The same process would look like this in Pascal:'
  id: totrans-155
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`program FileWrite; var my_file: TextFile; begin AssignFile(my_file, ''test.txt'');
    rewrite(my_file); write(my_file, ''First sample text to be written to the file.'');
    write(my_file, ''Another sample text.''); CloseFile(my_file); end.`'
  id: totrans-156
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Here we first declare a variable `my_file`. This variable is then assigned the
    reference to our file `test.txt` with a special function called `AssignFile()`.
    Up to this point, it is not at all clear in which mode the file is to be opened.
    That is not determined until the `rewrite()` function is called, which opens the
    file for writing. After writing, the file is closed at the end of the program
    with `CloseFile()`.
  id: totrans-157
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: So Pascal differs from C in that here the special function `rewrite()` is used
    when opening the file in write mode, whereas in C the general function `fopen()`
    is used, where a function argument, i.e. a setting we pass to the function when
    calling it, determines in which mode the file should be opened.
  id: totrans-158
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Analogously, there is a special function in Pascal for opening files in read
    mode: `reset()`. If the first line from file `test.txt` is to be read, the corresponding
    Pascal code would look like this:'
  id: totrans-159
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`program FileWrite; var my_file: TextFile; first_line: string; begin AssignFile(my_file,
    ''test.txt''); reset(my_file); readln(my_file, first_line); CloseFile(my_file);
    end.`'
  id: totrans-160
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The function `readln()` (*read line*) is used, which reads a line from the file
    opened in read mode (first argument of the function) and stores it in the variable
    `first_line` (second argument). After that, the file pointer is automatically
    advanced to the next line, even without our intervention. If we were to read in
    a line again, this time it would be the second line.
  id: totrans-161
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Work with Files Beyond Reading and Writing Local Files
  id: totrans-162
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The files that are read do not necessarily have to be located on your local
    system. Provided that the files are not subject to any conflicting access protection,
    an Internet address (or `URL`, a `Uniform Resource Locator`) can regularly be
    specified as the file name in most programming languages. Files that are located
    on a web server, and that your browser reads and displays as a web page, can be
    read using a program you have written yourself just as if it were a file on your
    local computer.
  id: totrans-163
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In addition to the functions for opening, reading, writing and closing files,
    many programming languages offer functions for working with the file system, such
    as creating or reading directories in the file system, or copying, moving, deleting
    or renaming files and directories. Functions for determining the file size or
    for checking whether a file exists at a certain path are also part of the standard
    scope of programming languages. Checking whether a file exists is useful to avoid
    an error or even uncontrolled program crash if your code tries to access a file
    that does not exist.
  id: totrans-164
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 当然，这里讨论的方法仅代表几乎所有编程语言具有的基本功能，尽管它们在各自设计上可能略有不同。此外，许多编程语言提供——无论是开箱即用还是通过扩展库——许多其他功能，用于处理文件。例如，读取或写入特殊文件格式（如图像文件或某些流行软件应用程序（如Microsoft
    Office）的专有格式的文件），或通过适当的网络协议（如`FTP`（`File Transfer Protocol`））与服务器交换文件。
  id: totrans-165
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`12.4`'
  id: totrans-166
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Explain the differences between the various options available when opening
    a file.`'
  id: totrans-167
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`12.4 Working with Databases`'
  id: totrans-168
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 在专业软件开发实践中，`working with databases`扮演着重要角色。我们今天所知的大多数web服务基本上是一个数据库（`"backend"`）和一个允许用户与存储在数据库中的数据交互的web用户界面（`"frontend"`）的结合。这对于web商店和社交网络都是如此。在专业环境中，读取和写入数据库因此成为数据输入和输出的常态，而不是例外。在非专业软件开发领域，`working
    with databases`的角色当然没有那么重要。因此，由于这个主题并不简单，我们将在本节中仅覆盖一些基础知识，以便给你提供一个主题的概述，并将细节留给更高级的编程课程。
  id: totrans-169
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Most databases are collections of data tables that can be related to each other.
    They are called `relational` because the tables ultimately describe relations
    (relationships) between certain objects and their properties. As a stylized example,
    look at ◘ `Tables [12.1](#Tab1)`, `[12.2](#Tab2)`, and `[12.3](#Tab3)`. ◘ `Table
    [12.1](#Tab1)` contains the data of customers. The individual customers in the
    rows (in the context of the database, we speak of `data records`) can be uniquely
    identified via the column (in database language: the `field`) **CUSTOMERID**.
    ◘ `Table [12.2](#Tab2)` shows the products. These also have some descriptive fields
    as well as a unique ID, the field **PRODUCTID**. ◘ `Table [12.3](#Tab3)` represents
    the orders that the customers have placed. In this table, an order is identified
    by its own ID (**ORDERID**), the customer, the products that the customer ordered,
    and the order date. You can see that customers and products are represented by
    their IDs, and thus by `references to` the **CUSTOMER** and **PRODUCT** tables,
    respectively. Each row represents a combination of customer and ordered product.
    For example, you can see from purchase order **B0002** that customer **C00003**
    (Mason Thomas) ordered `two` products (namely **P001—**the garden shovel, and
    **P002—**the balcony table). Accordingly, in the **ORDER** assignment table, this
    order is described by `two` records. `Table 12.1`'
  id: totrans-170
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Example data for table `CUSTOMER`
  id: totrans-171
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '| `Customerid` | `Name` | `First name` | `Email` | `Street` | `City` | `Zipcode`
    |'
  id: totrans-172
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `---` | `---` | `---` | `---` | `---` | `---` | `---` |'
  id: totrans-173
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `C00001` | `Collins` | `Ethan` | `ecollins@my-emails.com` | `123 Oak Street,
    Apt 4B` | `New York, NY` | `10001` |'
  id: totrans-174
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `C00002` | `Rodriguez` | `Olivia` | `me@oliviarodriguez.com` | `456 Pine
    Avenue, Suite 9C` | `Chicago, IL` | `90001` |'
  id: totrans-175
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `C00003` | `Thomas` | `Mason` | `mason.thomas@thomas-winery.com` | `789 Maple
    Drive` | `Los Angeles, CA` | `60601` |'
  id: totrans-176
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `C00004` | `Wilson` | `Anna` | `anna@thewilsonfamily.com` | `321 Elm Street,
    Apartment 7D` | `Houston, TX` | `77002` |'
  id: totrans-177
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '`Table 12.2`'
  id: totrans-178
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Example data for table `PRODUCT`
  id: totrans-179
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '| `Product ID` | `Description` | `Price` |'
  id: totrans-180
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `---` | `---` |'
  id: totrans-181
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `P001` | `Garden shovel, stainless steel` | `10.99` |'
  id: totrans-182
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `P002` | `Balcony table, plastic, green` | `24.99` |'
  id: totrans-183
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '`Table 12.3`'
  id: totrans-184
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Example data for table `ORDER`
  id: totrans-185
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '| `Order ID` | `Customer ID` | `Product ID` | `Date` |'
  id: totrans-186
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `---` | `---` | `---` | `---` |'
  id: totrans-187
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `B0001` | `C00001` | `P001` | `2019-06-01 0:08 AM` |'
  id: totrans-188
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `B0002` | `C00003` | `P001` | `2018-12-05 7:49 AM` |'
  id: totrans-189
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `B0002` | `C00003` | `P002` | `2018-12-05 7:49 AM` |'
  id: totrans-190
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `B0003` | `C00002` | `P001` | `2019-05-16 9:58 PM` |'
  id: totrans-191
  prefs: []
  stylish: true
  type: TYPE_TB
- en: Of course, we could have repeated all the customer and product data in the **ORDER**
    table; however, this would not only make the table unnecessarily large, but would
    also make data maintenance much more difficult, because changes to a customer’s
    master data (for example, his address) would then have to be made in two places
    in the database, the **CUSTOMER** table and the **ORDER** table. This would increase
    the risk of inconsistent data. These problems are avoided by the reference technique
    used here.
  id: totrans-192
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 定义基本对象仅一次并通过引用它们的ID或键来映射它们之间关系的过程被称为`规范化`。数据库系统确保这些引用始终有效，因此在`ORDER`表中被引用的客户不能从`CUSTOMER`表中删除，因为那样会使其现有的订单数据不一致。
  id: totrans-193
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: By the way, our example tables here are not yet perfectly normalized。`订单`的日期实际上附加在`订单`本身上，而不是属于一个订单的客户和产品的单独组合，这些组合存储在`ORDER`表中。完整的规范化可以通过从`ORDER`表中移除产品（仅保留`订单`的ID、客户和日期在`ORDER`中）来实现，并通过它们的键在一个单独的表中存储订单与所订购产品之间的分配关系。
  id: totrans-194
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Data stored in databases in this way can be queried。用于此目的的特殊编程语言是`SQL`，或`结构化查询语言`。可以用这种语言来制定查询，并由数据库系统处理，然后返回查询的数据作为结果。最重要的`SQL`语句是`SELECT`。`SELECT`的语法基本上相当简单（尽管可以在许多地方扩展以创建更复杂的查询）：`SELECT`***fields***
    `FROM`***table*** `WHERE`***condition***。
  id: totrans-195
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The statement
  id: totrans-196
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`SELECT` FIRSTNAME, NAME `FROM` CUSTOMER `WHERE` `LOCATION = ''New York, NY''`查询所有来自`CUSTOMER`表的数据记录，其中字段`CITY`的值为`"New
    York, NY"`。然而，并非所有字段都要显示，而是仅显示字段`FIRSTNAME`和`NAME`。因此，此语句的结果是一个仅包含这些字段的表，对于相关的数据记录，在示例中如◘表[12.4](#Tab4)所示。在我们的`SELECT`语句的情况下，结果表仅由一条记录组成，即Ethan
    Collins的记录。表12.4'
  id: totrans-197
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Result of our `SQL` sample query with `SELECT`
  id: totrans-198
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '| First name | Name |'
  id: totrans-199
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-200
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| Ethan | Collins |'
  id: totrans-201
  prefs: []
  stylish: true
  type: TYPE_TB
- en: 然而，`SQL`不仅可以用于从数据库中查询数据，还可以向数据库写入数据。为此，使用`INSERT`和`UPDATE`语句，分别用于将`新`记录插入到表中（`INSERT`）或更新`现有`记录（`UPDATE`），即更改记录（或同时更改多个记录）的一个或多个字段的值。
  id: totrans-202
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: From most programming languages, databases can be addressed (often with the
    help of extension libraries, covered in the following chapter), fed with SQL statements
    and their results received and processed.
  id: totrans-203
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 12.5 Your Roadmap to Learning a New Programming Language
  id: totrans-204
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: If you are learning a new programming language …
  id: totrans-205
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'you’ll discover:'
  id: totrans-206
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: which types of user interfaces (GUIs, console) you can equip your programs with,
  id: totrans-207
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: if console applications are supported, which functions are available for the
    output of data as well as for the input of data by the user,
  id: totrans-208
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: if graphical interfaces are supported, how they are designed (`graphical WYSIWYG`
    development in `IDE`, description of the interface in the code) and which controls
    are available to you for the design of your graphical user interface and which
    essential properties/configuration options they offer,
  id: totrans-209
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: how to open (and close) files for reading, writing or appending data, in particular
    what different editing modes are available when opening and how to distinguish
    between opening text and binary files,
  id: totrans-210
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: what functions are available to write data into or read data from open files,
  id: totrans-211
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`if` you plan to work with databases, how to connect to databases as well as
    send `SQL` statements to the database and process the returned results.'
  id: totrans-212
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`12.6 Solutions to the Exercises`'
  id: totrans-213
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: '`Exercise 12.1`'
  id: totrans-214
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Graphical user interfaces can be designed via an `Integrated Development Environment
    (IDE)` in `WYSIWYG` mode, where the individual control elements are selected and
    placed on the program interface with the mouse. Typically, the properties of the
    controls can be conveniently accessed. The user interface is thus created without
    having to “program” it. But many programming languages also allow the user interface
    to be created as part of the program code. The individual controls are then mostly
    objects that can be created from within the program—just like other objects—and
    placed on the interface. The properties of the controls can be accessed via the
    attributes of the objects representing them.
  id: totrans-215
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Task 12.2`'
  id: totrans-216
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Console` applications usually run in a completely linear fashion where the
    user is guided through the program, and the program determines the sequence of
    the user’s work. In applications with graphical interfaces, the user usually has
    more control over the order in which he or she executes which steps. For example,
    the user can click on buttons in any order. In this sense, the program does not
    determine user behavior; instead, it responds to `events` that the user triggers.
    For example, if the user clicks on a button, the associated event is triggered,
    and the program code intended for that event is executed. Although this type of
    event-oriented program control can, in principle, be reproduced in console applications,
    it is much less common there than in applications with graphical user interfaces.'
  id: totrans-217
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Exercise 12.3`'
  id: totrans-218
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 控制台应用程序通常快速且易于使用，前提是你熟悉它。当从控制台调用时，程序的行为通常可以通过命令行参数进行控制。所有控制操作都可以用键盘执行，这也便利了可用性，而图形用户界面通常需要指点工具（通常是鼠标），因此需要在输入设备之间切换手或双手。控制台应用程序在开发上也有优势，因为它们通常比图形用户界面应用程序的编程工作量更少。此外，开发控制台应用程序所需的编程语言知识水平通常低于开发图形用户界面的要求。
  id: totrans-219
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 练习 12.4
  id: totrans-220
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在大多数编程语言中，打开文件的模式首先根据每种情况允许的编辑操作有所不同。文件可以以常规方式打开以进行读取（`read` / `r`）、写入（`write`
    / `w`）或追加（`append` / `a`）。以写入模式打开时，现有文件会被完全覆盖。如果要向现有文件追加数据，则必须以追加模式打开。第二个区别是文件是作为文本文件还是二进制文件打开，这主要影响写入数据的编码方式。
  id: totrans-221
  prefs: []
  stylish: true
  type: TYPE_NORMAL
