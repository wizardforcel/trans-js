- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024J. L. ZuckarelliLearn coding with Python and JavaScript
    [https://doi.org/10.1007/978-3-658-42912-6_12](https://doi.org/10.1007/978-3-658-42912-6_12)
  prefs: []
  type: TYPE_NORMAL
- en: 12. How Do I Input and Output Data?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1)München, GermanyOverview
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter we dealt with the question of how data can be stored with
    the help of variables in such a way that we can work with them in the program.
    We now turn to the question of how we can bring data into the program from the
    outside (in this context we speak in a broader sense of “data input”) and also
    get it out of the program again (“data output”). This involves both data input
    and data output directly from/to the user, as well as input and output in the
    context of files and databases. In this chapter, we deal with how a program communicates
    with its “outside world”.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What distinguishes the two key basic modes of direct user input and output,
    graphical user interfaces and console applications, and when which form is preferable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which the most important control elements on graphical user interfaces are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to design graphical user interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to read data from and write data to files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with databases in the basics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.1 Forms of Data Input and Output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most programs communicate in one way or another with their “environment”. The
    “environment” includes, of course, first and foremost the user of the program,
    who provides information and makes decisions. But part of the environment are
    also other objects and phenomena whose properties and states have an influence
    on the program flow. For example, if we are talking about software that is supposed
    to proactively turn up your heating when it starts to get cold, the current (and
    possibly predicted) temperatures are part of the program’s relevant environment.
    Of course, the program can only process information about this environment if
    it is made known to it in the form of data. In this chapter we want to take a
    closer look at this “making known”. It is therefore a question of how information
    can be “entered” into the program in the form of data.
  prefs: []
  type: TYPE_NORMAL
- en: When the term “input” is used, the first thing that comes to mind is probably
    direct input by the user, and especially input with the aid of a keyboard. But
    of course, this is not the only way that the user can provide data to the program.
    Other input devices, of which microphone, webcam, mouse, joystick, or touchscreen
    are only a few examples, allow you to input very different kinds of data—for example
    sound, video, position, direction and speed data. But not all input comes directly
    from the user. Files and databases are also possible sources of data input that
    a program works with. The program for heating control, for example, will perhaps
    query data from the database of a meteorological service via a web interface to
    determine whether the heating needs to be turned on, and if so, when, and how
    much.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, a wide range of options are available for *outputting* data. Examples
    of this are, above all, the output on the screen and the writing of data to files
    and databases.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will deal with three types of data input and output in programs—input
    or output by or to the user via a *user interface* of some kind, as well as working
    with *files* and *databases*. Since the latter is not a trivial matter and usually
    requires knowledge of a separate programming language (a query language) developed
    specifically for this purpose, we will only cover this subject area here in an
    overview, but at least in such a way that you develop a solid understanding of
    this enormously important field in the practice of modern software development.
    Of course, there are other ways in which data can get into your program or be
    made available from your program, for example via APIs (Application Programming
    Interfaces). As an introductory book, however, we will concentrate on the three
    mentioned above.
  prefs: []
  type: TYPE_NORMAL
- en: '12.2 Graphical or Non-Graphical: That Is the Question Here'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the advent of operating systems with graphical user interfaces and the
    triumph of the World Wide Web, we have become accustomed to entering and viewing
    data on attractively designed *graphical user interfaces* (GUIs, or, because graphical
    is the standard today anyway, simply UIs). What “attractive” means in this context
    depends on taste and the technical possibilities of the respective time and technological
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: What GUIs of all times and all technical varieties have in common is that they
    try to make the input of data as convenient as possible for the user by means
    of suitable *control elements*. For example, by not having to enter numbers from
    a given range of values via the keyboard, but by allowing them to be conveniently
    defined by means of sliders.
  prefs: []
  type: TYPE_NORMAL
- en: Especially in the course of the increasing importance of mobile and web applications,
    completely new job descriptions have developed, those of the *user interface designer*
    (UI designer) and the *user experience designer* (UX designer). While the UI designer
    technically designs the interface and “wires” it to the program code behind it,
    the UX designer is intensively concerned with the end users and their behavior.
    In a sense, he is the UI designer’s market researcher and tries to find the optimal
    way for end users to interact with the application. The UI designer can then implement
    the UX designer's findings in the user interface. While the UI designer is more
    concerned with the “inside”, with technical design, the work of the UX designer
    is more concerned with the “outside” and consists mainly of understanding the
    end users and their way of working.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not professionally involved in programming, you’ll usually be a developer,
    UX designer and UI designer all rolled into one. This is more work, but it also
    means that you can let your creativity run wild when designing your interfaces.
    However, you will also have to consider the needs and desires of your users, unless
    you are developing the software exclusively for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: With the triumph of graphical user interfaces, *console applications* have almost
    completely gone out of fashion in the end-user area. Those who worked with operating
    systems such as MS-DOS in their early computer days, or who today operate a Linux
    system and do so not exclusively via one of the graphical front-ends for Linux,
    may still remember with a pleasant shiver. Console applications offer only one
    form of direct input by the user, namely via the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'A central difference, however, is not only in how the interface appears visually
    and in terms of ease of use. The program flow of console applications is usually
    quite different from that of applications with GUIs. Based on Karl Marx’s famous
    dictum that being determines consciousness, one could say: “The interface determines
    programming”. This is because console applications are usually *linear programs*,
    they run step by step. For example, first something is displayed (such as: “Please
    enter your username”); then the program waits for user input. Once the user has
    made his input and confirmed it with <ENTER> or <RETURN>, the program’s next output
    follows (“Please enter your password”); the program waits again until the user
    has made his input and confirmed it. Then the program processes the input (checks
    username and password for validity, for example) and responds again with an output
    (“Access granted.”), and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: This is different with a graphical user interface. Here, the program usually
    does not specify an exact sequence of user actions. In our example, the user could
    also first enter the password and only then the username. Only a click on the
    login button triggers the program to check the user input. The difference becomes
    even clearer when you consider a graphical user interface such as that of a word
    processing program, where the user can use buttons to access a variety of functions
    or just start working on the document text. This way of working with the program
    is *not linear*. Instead, the program observes what the user is doing and responds
    to *events*, such as clicking a button or selecting a function from a menu. Programs
    with graphical user interfaces are thus typically *event-driven*. If the user
    triggers a certain event, the program jumps to the place in the program code that
    describes what to do when this event occurs. If the user then triggers another
    event, the program again jumps to the right place, no matter where exactly in
    the program’s source code that section of code might be found. Unlike the console
    application, which strictly executes one line of code after another and consists
    of a linear sequence of statements, in event-driven programming the processing
    “jumps” from one block of statements to another block somewhere else, depending
    on what the user is doing.
  prefs: []
  type: TYPE_NORMAL
- en: In ► Chap. [14](474412_1_En_14_Chapter.xhtml), when we talk about how to make
    programs respond to the user’s input, we will look at event-driven programs in
    a bit more detail. In this chapter, we will first deal with the possibilities
    of data input, that is, the interface as such.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.1 Graphical User Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 12.2.1.1 Important Controls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The controls used on graphical user interfaces may look different depending
    on the operating system (for example, *Windows, macOS*, *Android*, *iOS*) and
    platform (computer, tablet, smartphone). However, many elements exist in virtually
    all operating systems and on virtually all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will take a brief look at the most important control
    elements and their central properties. In addition to the properties mentioned
    here, the controls have a number of other characteristics. Some of them are specific
    to the respective control element, others are common to all or at least to the
    vast majority of controls. The latter include the position on the surface, the
    dimensions (height and width), the visibility (is the control element currently
    visible or is it hidden?), the usability (can the user currently use the control
    element? Is it active, or is it inactive and thus locked and “grayed out”?), its
    name (so that it can be addressed in the program), and its color.
  prefs: []
  type: TYPE_NORMAL
- en: Edit fieldsGraphical user interfaces provide edit fields for classic keyboard
    input. Depending on the type or setting, these allow information to be entered
    in one or more lines (◘ Figs. [12.1](#Fig1), [12.2](#Fig2), and [12.3](#Fig3)).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig1_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of an input field reads text input.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.1
  prefs: []
  type: TYPE_NORMAL
- en: Example of an input field
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig2_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of an input field has ten dots.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.2
  prefs: []
  type: TYPE_NORMAL
- en: Example of an input field
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig3_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of an input field reads the text in a foreign language with a vertical
    scrolling bar at the right.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.3
  prefs: []
  type: TYPE_NORMAL
- en: Example of an input field
  prefs: []
  type: TYPE_NORMAL
- en: Edit fields can typically be configured extensively, or different edit fields
    with different properties are available. For example, the user’s password entry
    can be masked by simply displaying nothing or a specific character instead of
    the characters entered. Also, the information entered can often be validated as
    it is entered. For example, this can be used to force the user to enter a numeric
    input; if the user were to enter letters instead, that text would not be accepted
    as input by the edit field at all. Sometimes it is important that different parts
    of the input are formatted differently (for example, when entering program code
    that is to be displayed with syntax highlighting); then you need an input field
    that can handle different text formatting.
  prefs: []
  type: TYPE_NORMAL
- en: ButtonsButtons are defined clickable places on the screen through which the
    user usually triggers an action, for example saving a document or sending a message
    (◘ Fig. [12.4](#Fig4)). The most important feature of the button is its label
    and the link to the program part that is executed when the button is clicked.
    The visual appearance is also often dominated by a symbol image that stylizes
    the action triggered by the button.![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig4_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a button reads, Say, hello world, in double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.4
  prefs: []
  type: TYPE_NORMAL
- en: Example of a button
  prefs: []
  type: TYPE_NORMAL
- en: MenusLike buttons, menus are used to let the user trigger actions. The focus
    is on the selection among various options in the form of the menu items. This
    also explains the name of the control element, which the user uses in a similar
    way to the menu in a restaurant. In addition to the names of the menu and its
    items, important properties—again analogous to the button—are the actions that
    the user can trigger by clicking on the items (◘ Fig. [12.5](#Fig5)).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig5_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot menu bar with tabs menu 1 and menu 2\. A dropdown under menu 1
    tab reads menu item 1.1, menu item 1.2, and menu item 1.3\. Menu item 1.2 is highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.5
  prefs: []
  type: TYPE_NORMAL
- en: Example of a menu
  prefs: []
  type: TYPE_NORMAL
- en: Checkboxes and Radio ButtonsCheckboxes and radio buttons are control elements
    that allow the user to make a selection between several options. Unlike buttons
    and menus, clicking on one of these elements does not usually trigger an immediate
    action. Instead, checkboxes and radio buttons are usually used to specify settings
    that control the exact behavior of actions that the user later triggers elsewhere,
    such as by clicking on a button or menu item. For example, the user could use
    a radio button to choose whether to open a file read-only or not. The actual action,
    the opening of the file, is triggered later by clicking on a button “Open file”.
    What exactly a click on this button does (whether the file is opened in read-only
    mode or in such a way that it can also be modified) is determined by the setting
    previously made with the help of the radio button (◘ Figs. [12.6](#Fig6) and [12.7](#Fig7)).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig6_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a list reading checkbox 1 and checkbox 2\. Both have square-shaped
    checkboxes in front of them, where checkbox 1 is selected.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.6
  prefs: []
  type: TYPE_NORMAL
- en: Examples of checkboxes
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig7_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of a list reading radio button 1 and radio button 2\. Both have
    circular buttons in front of them, where radio button 2 is selected.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.7
  prefs: []
  type: TYPE_NORMAL
- en: Examples of radio buttons
  prefs: []
  type: TYPE_NORMAL
- en: Checkboxes often appear in multiples, radio buttons always. The difference between
    the usually square checkboxes and the round radio buttons is that *only one option*
    can be selected from a group of such control elements in the case of radio buttons,
    but *several can* be clicked on in the case of checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: Toggle ButtonsSimilar to checkboxes, *toggle* buttons allow you to toggle an
    option on or off. Unlike checkboxes, however, there are no checkmarks to indicate
    whether the option is currently selected or not. Instead, the appearance is modeled
    after a slide switch. Toggle buttons have become popular with the triumph of the
    mobile operating systems iOS and Android but are now also available on other platforms
    (◘ Fig. [12.8](#Fig8)).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig8_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a toggle button resembles a horizontally oriented bright cylindrical
    structure with a sphere at the right.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.8
  prefs: []
  type: TYPE_NORMAL
- en: Example of a toggle button
  prefs: []
  type: TYPE_NORMAL
- en: SlidersSliders are control elements that allow you to make a selection along
    a scale, i.e., between options that can be arranged in an order based on some
    criterion. Like radio buttons and checkbox/toggle buttons, a change in the current
    selection by the user does not usually trigger an immediate action. In most cases
    they are used to make a setting that takes effect later when the user triggers
    an action, such as clicking on a button or menu item (though sometimes changes
    made by the user have a direct effect, such as when the slider is used to scale
    a graphic that automatically updates when the slider control is moved). Its most
    important setting is the scale, the gradation in which the user can adjust the
    slider control, particularly the number and designation of the expressions (◘
    Figs. [12.9](#Fig9) and [12.10](#Fig10)).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig9_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a slider with a rectangular scale reading measurements at the
    bottom. A bright shaded block moves on the scale.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.9
  prefs: []
  type: TYPE_NORMAL
- en: Example of a slider
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig10_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of a slider resembles a horizontal bar with a small spherical structure
    surrounded by rays at the left, and a big spherical structure surrounded by rays
    at the right. A dot moves on the bar.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.10
  prefs: []
  type: TYPE_NORMAL
- en: Example of a slider
  prefs: []
  type: TYPE_NORMAL
- en: List Views/List BoxesList views or list boxes are “flat”, non-hierarchical lists
    of items that allow the user to select one or more of these items. An example
    of the use of list views are file managers that list the files contained in a
    folder. In this case, the elements shown in the list view can be provided with
    icons. Sometimes, in addition to the name of the element, other properties of
    the elements are displayed in extra columns of the list view, for example, their
    size or the date of their last modification. In addition to the type of display
    (icons, additional columns for supplementary element properties), an important
    property that can be specified when using list views is whether the user should
    be able to select only a single element at a time or several elements at once
    (◘ Fig. [12.11](#Fig11)).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig11_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a list with three columns. The column headers are element, property
    1, and property 2\. Element has items 1 to 4\. Property 1 has property 1.1, 2.1,
    3.1, and 4.1\. Property 2 has 1.2, 2.2, 3.2, and 4.2.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.11
  prefs: []
  type: TYPE_NORMAL
- en: Example of a list view
  prefs: []
  type: TYPE_NORMAL
- en: Tree ViewsTree views are similar to lists in the sense that they allow multiple
    elements to be displayed. Unlike lists, however, they have a tree-like structure,
    i.e., they display hierarchical relationships between the elements. A classic
    example for the use of tree views are the folder views in file managers, where
    the hierarchy of the folders is typically displayed as a tree structure. This
    is a very good way to represent hierarchical relationships of any kind, such as
    the structure of an organization or a hierarchy of products, ranging from broad
    product categories down to individual products. Unlike list views, tree views
    typically have no additional columns for displaying further properties of the
    hierarchically arranged elements (◘ Fig. [12.12](#Fig12)).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig12_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a menu displays the expanded view of a list under node 1 and
    node 2\. Node 1 has element 1.1 and element 1.2\. Node 2 has element 3.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.12
  prefs: []
  type: TYPE_NORMAL
- en: Example of a tree view
  prefs: []
  type: TYPE_NORMAL
- en: PickersPickers are control elements that allow you to make a selection from
    several predefined options, usually without immediately triggering any action.
    In this respect, they are similar to radio buttons, which also allow a selection
    of settings from several predefined alternatives. However, the types and forms
    in which pickers appear are very different. Sometimes they allow the selection
    from a predefined, but large and complex set of possibilities. A good example
    of such a choice is the date picker that has become commonplace on mobile and
    non-mobile platforms. Two very different examples of such date pickers are shown
    in ◘ Figs. [12.13](#Fig13) and [12.14](#Fig14).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig13_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of the list of dates in three columns in the format of date, month,
    and year. 7 dates are listed from year 2021 to 2027\. A tick mark and a cross
    mark are at the bottom. The date 07 05 2024 is highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.13
  prefs: []
  type: TYPE_NORMAL
- en: Examples of date pickers
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig14_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of a calendar displays May 2023 with up and down arrows to the
    right. The date 1 starts on a Monday and the last date 30 is on a Sunday. The
    date 27 is highlighted which falls on a Saturday.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.14
  prefs: []
  type: TYPE_NORMAL
- en: Examples of date pickers
  prefs: []
  type: TYPE_NORMAL
- en: Of course, pickers do not necessarily have to be based on such a complex selection
    situation as the date. Pickers are often used to select from a manageable list
    of simple text options. In this sense, pickers also include the good old combo
    box as shown in ◘ Fig. [12.15](#Fig15), which presents a list of selection options
    that expands downwards.![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig15_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a dropdown under the combo box 1 field. It lists Entry 1, Entry
    2, Entry 3, Entry 4, and Entry 5.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.15
  prefs: []
  type: TYPE_NORMAL
- en: Example of a combo box
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.1.2 Developing Graphical User Interfaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have looked at some popular controls for graphical user interfaces,
    the question naturally arises as to how exactly one technically develops an interface.
    Somehow the arrangement of controls and their properties have to be defined. The
    best interface design you have thought up and perhaps sketched out on paper or
    with the help of a graphics or presentation program won’t help you if you can’t
    turn it into a truly usable program interface, a real GUI.
  prefs: []
  type: TYPE_NORMAL
- en: This is often done with the help of the *Integrated Development Environments*
    (*IDE*s), which we already learned about in ► Sect. [8.​1.​3](474412_1_En_8_Chapter.xhtml#Sec4).
    These often allow you to “click” together graphical user interfaces without programming
    by selecting the different controls and placing them where you want them. ◘ Fig.
    [12.16](#Fig16) shows the integrated development environment of Delphi. Here you
    can see how a graphical user interface is being created. On the right (the “Palette”
    area), different control elements can be selected, which can then be placed in
    the program window using drag & drop. Their size can also be adjusted using the
    mouse. In the “Object Inspector” on the left, you can see the properties of the
    currently selected control element, in this case the selected button. The selected
    property you can see here is the “Caption”, the label of the button. Other properties
    are, for example, the shape the cursor should take when you move the mouse over
    the button (“Cursor”), the font of the button caption (“Font”) or the height of
    the control (“Height”). Obviously, even with a simple button you can make quite
    a few settings to define the appearance and behavior in detail.![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig16_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of the test project- Delphi 11 community edition-unit 2 window
    with three panels. Panel 1 lists the tools under the structure and object inspector.
    Panel 2 is the workspace displays the button 1 under the unit 2\. Panel 3 lists
    the options under test projects and palette.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.16
  prefs: []
  type: TYPE_NORMAL
- en: Designing a graphical user interface with Delphi
  prefs: []
  type: TYPE_NORMAL
- en: On the “Events” tab of the object explorer you would get an overview of the
    *events* that this control can trigger. In addition to the click, you can also
    move the mouse over the button. For more information, see ► Sect. [14.​7](474412_1_En_14_Chapter.xhtml#Sec7),
    where we will look at events in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, Delphi stores the graphical user interface internally (called “form”
    there) as a code file. You can see this in ◘ Fig. [12.17](#Fig17). You could also
    edit the interface by adding or deleting elements in this text file or by changing
    the characteristics of their properties. More convenient, of course, is editing
    by drag & drop in *WYSIWYG* mode (*what you see is what you get*), as seen in
    ◘ Fig. [12.16](#Fig16).![](../images/474412_1_En_12_Chapter/474412_1_En_12_Fig17_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of test project- Delphi 11 community edition-unit 2 window with
    3 panels. Panel 1 has the structure and object inspector. Panel 2 is the workspace
    that displays a program under unit 2\. Panel 3 lists the options under test projects
    and palette.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 12.17
  prefs: []
  type: TYPE_NORMAL
- en: Graphical user interface as Delphi stores it internally
  prefs: []
  type: TYPE_NORMAL
- en: Some programming languages are designed to define graphical user interfaces
    directly in the program code, similar to the way Delphi does it in the background.
    The individual elements of the interface are then usually objects in the sense
    of object-oriented programming. They are created by program statements, placed,
    adjusted with respect to their properties, and “wired” to the rest of the program
    code. You will learn more about this procedure using Python as an example in ►
    Sect. [22.​2](474412_1_En_22_Chapter.xhtml#Sec2). In ► Sect. [32.​4](474412_1_En_32_Chapter.xhtml#Sec4),
    we will see how, in the case of JavaScript, the interface is designed with program
    code, but in a different language (namely HTML) than the one in which the actual
    program is written.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.2 Console Applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How Console Applications Work
  prefs: []
  type: TYPE_NORMAL
- en: Console applications do not have a graphical user interface, only a text interface.
    They run either in the operating system’s console or terminal (for example, Linux
    Bash, Mac Terminal, or MS-DOS prompt) or in an integrated development environment.
    In the former case, they are programs that the operating system can execute directly
    (i.e., programs already in machine code) or programs in an interpreted language
    that are executed by calling the interpreter in the operating system’s console
    and having it execute the program code. When executing in an Integrated Development
    Environment, the program is called from the development environment, i.e., a graphical
    user interface, but it only has a text interface itself, so it practically runs
    like a console application. Again, the programming language interpreter is called
    and executes the program, except that the console in which it runs is hard-coded
    into the IDE. In Part III of the book, we will develop console applications with
    Python and call them from a graphical IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'The special feature of console applications is that they usually run in a strictly
    linear fashion. Whereas the user can decide for himself via the event-driven graphical
    user interface which functions he calls in which order, in the console application
    he follows the sequence that is permanently built into the program. Here is a
    simple example (where > shows something entered by the user):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please enter the temperature in degrees Celsius:**>** 23Conversion to Kelvin
    or degrees Fahrenheit (K/F)?**>** K23 degrees Celsius in degrees Kelvin is: 296.15.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a graphical user interface, you might be able to use a radio button to select
    which temperature system to convert your input to. And most importantly, you probably
    could have made this selection *before* you entered the temperature to be converted
    in degrees Celsius. Not so with the console application with its text interface:
    it dictates what you have to enter and when. In this case, the program does not
    run event-driven, but linear.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two examples of how the first part of the above program might look
    in two programming languages, Pascal and Python; first in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: temp_celsius = input('Please enter the temperature in degrees Celsius:')target_scale
    = input('Conversion to Kelvin or degrees Fahrenheit (K/F)?')
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it’s quite simple to query an input from the user. Since you
    don’t have to declare variables in Python, each input is ultimately just a single
    line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the whole thing in Pascal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**program** temp**var**temp_celsius : real;target_scale : char;**begin**write("Please
    enter the temperature in degrees Celsius:");readln(temp_scale);write("Conversion
    to Kelvin or degrees Fahrenheit (K/F)?");readln(target_scale);**end.**'
  prefs: []
  type: TYPE_NORMAL
- en: In Pascal, the variables we use must be declared, a floating-point number variable
    (**real**) and a variable that takes only a single character (**char**). The input
    as such is done here using the **readln()** function, which stands for *read line,
    which* means that after the input, a line break is automatically done so that
    the next output starts on a new line. Without the **ln,** the cursor would simply
    stop after the input. So, the next output would start exactly at that point. There
    is an analogous distinction in output, where a distinction is made between **write()**
    and **writeln()**.
  prefs: []
  type: TYPE_NORMAL
- en: Why Console Applications at All?
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important question we haven’t answered yet: Why would anyone develop
    a console application at all, today, when there are so many fascinating options
    for graphical interfaces available? The most obvious reason is that it’s easier
    and faster. For example, if you want to try something out, like a new function
    library or a certain algorithm, it would be a waste of time to put a lot of work
    into designing a perfect graphical interface. Most of the time, a very simple
    console application that allows only rudimentary text interaction with the user
    is enough. Concentrate your work on the essentials and not on visual attractiveness
    and good usability, which is not necessary for your actual purpose!'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand even better why console applications have not yet gone out of
    fashion, it is worth taking a look at professional or at least ambitious software
    developers. They greatly appreciate command line tools that run in the console.
    And this for several reasons: For one, working with command-line programs is more
    ergonomic, because you can perform all tasks with just one input instrument, the
    keyboard, and you don’t have to laboriously use the mouse to call up the corresponding
    buttons or menu items in a graphical development environment. In addition, command
    line parameters, special control options that are passed directly to the console
    program when it is called, allow the program behavior to be controlled effortlessly
    and very precisely, which would be incomparably more tedious with a whole series
    of clicks on a graphical interface. Also, console applications are regularly less
    demanding in terms of system resource consumption (especially memory and processing
    power), which can mean they run faster. It is therefore not surprising that many
    developer tools come as console applications, for example the well-known versioning
    tool *git* or the text editor *vi*. As a rule, these tools have the same parameters
    and control options on all operating system platforms, making it easy for the
    developer to switch back and forth between different platforms. And finally, although
    no developer would ever openly admit it, it’s also kind of cooler, nerdier to
    work on the console command line than to click together your commands on a graphical
    user interface, just like any “normal” user.'
  prefs: []
  type: TYPE_NORMAL
- en: Many professional developers use a computer with *MacOS* or *Linux* as the operating
    system instead of a Windows-based system. Asked about the reasons, many say that
    these two operating systems offer the better console, so they can work more comfortably
    on these systems. It’s no wonder then that Microsoft, whose strategic thrust is
    explicitly to cater especially to the needs of developers, has released a modern
    console app in the summer of 2019 that aims to put Windows operating systems back
    into the competition for developers’ favor.
  prefs: []
  type: TYPE_NORMAL
- en: '12.1'
  prefs: []
  type: TYPE_NORMAL
- en: Explain two ways in which graphical user interfaces can be developed.
  prefs: []
  type: TYPE_NORMAL
- en: '12.2'
  prefs: []
  type: TYPE_NORMAL
- en: Explain the basic difference in program flow between console applications and
    those with a graphical user interface.
  prefs: []
  type: TYPE_NORMAL
- en: '12.3'
  prefs: []
  type: TYPE_NORMAL
- en: List two advantages of console applications over graphical user interface applications.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3 Working with Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Fastest Way: Immediate Reading and Writing of FilesData can not only be
    entered by the user but can also come from files. Working with files is basically
    always the same and very simply structured:'
  prefs: []
  type: TYPE_NORMAL
- en: The file in question is opened
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Their content is read out (or content is written into them)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file is closed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some programming languages have functions that allow you to edit files directly
    without having to explicitly worry about opening and closing them. Here are three
    examples. First an example from F# (“F Sharp”):File.WriteAllText("test.txt", "A
    sample text written directly")
  prefs: []
  type: TYPE_NORMAL
- en: 'The same in PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: file_put_contents("test.txt", "A sample text written directly")
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, in R:'
  prefs: []
  type: TYPE_NORMAL
- en: cat("A sample text, written directly ", file = "test.txt", append = TRUE)
  prefs: []
  type: TYPE_NORMAL
- en: In all three cases, the text “A sample text, written directly” is written to
    a file named **test.txt**. The file does not have to be explicitly opened or closed;
    the functions used take care of that without our intervention.
  prefs: []
  type: TYPE_NORMAL
- en: Modes of File Processing
  prefs: []
  type: TYPE_NORMAL
- en: However, all of these languages also have functions for executing the above-mentioned
    three steps in working with files independently of each other. If, for example,
    you want to write data to or read data from the same file several times in a row,
    it would be inefficient to open and close the file each time. In this case, one
    would certainly not work with the functions just considered, but would first open
    the file, then write to or read from it several times, and only close the file
    again after all work has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: The write operations we saw in the examples above in F#, PHP, and R create a
    new file if the file named **test.txt** does not exist, and then write our sample
    text to that new file. But if the file already exists, its contents are simply
    overwritten, without prompting or confirmation. Only in the third example, the
    example in the statistics language R, is the option **append=TRUE** used to control
    that existing file content is not overwritten, but that our text is appended to
    the existing content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, writing is not the same as writing either. In fact, there are basically
    three modes in which files can be opened:'
  prefs: []
  type: TYPE_NORMAL
- en: Read (mostly **read** or **r**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing (mostly **write** or **w**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Append (mostly **append** or **a**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modes “Write” and “Append” regularly create a new file if no file with the
    desired name exists yet. They differ, however, in the way they handle existing
    file contents. In “Write” mode, these are usually replaced completely. In many
    programming languages, mixed modes are also possible, such as **ra** (read = **r**
    and append = **a**).
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, for historical reasons and the way file systems have always worked,
    there is no “insert” mode. So, you normally can’t just open a file, go to a specific
    location within the file, and then just insert additional content there. Instead,
    although it’s awkward, you have to rebuild the contents of the file in a variable
    in your program, that is, read the existing first part of the file into a variable
    (such as a string variable), then append the contents to be inserted to that variable,
    and finally read the back part of the file and append that to the new contents
    variable as well. Afterwards you can open the file in write mode and write the
    content of the variable into the file. This way you have completely overwritten
    the old file content, but in fact, you have only inserted something.
  prefs: []
  type: TYPE_NORMAL
- en: 'The situation is different when reading: Here you can regularly move the “file
    pointer”, which indicates where the next operation in the file should take place,
    to any position in the file. When opening a file in write mode, on the other hand,
    the file pointer is automatically set to the beginning of the file (and cannot
    be moved away from there, at least not without actually writing something), and
    when opening it in append mode, it is set to the end of the file.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides the type of editing operation to be performed on the file, the modes
    for opening files also differ with respect to another characteristic, namely whether
    the edited files are *text* or *binary files.* The difference between the two
    is most obvious with numbers. The number 32,000 is 0111110100000000 in binary
    terms, i.e., a 16-bit sequence of zeros and ones. Two bytes (8 bits each) are
    sufficient to store this value. In a text file, however, the number 32,000 would
    be considered text. So, if it is stored, the individual characters, “3”, “2”,
    “0”, “0” and again “0” are stored. The resulting file would then be 5 bytes in
    size. Differences between text and binary files also exist in the encoding of
    line breaks and the signaling of the end of the file, for which text files have
    a special character, the *EOF* character (end of file). Text files are usually
    such that you see letters and numbers when you open them. For example, program
    code that you write is stored in a text file. On the other hand, if you open,
    say, a PDF file or an executable program file with a text editor, all you will
    see is a seemingly random pattern of strange special characters; these are binary
    files that your text editor is trying to represent as text. To deal with the two
    different basic types of files, many programming languages have separate modes
    for writing, appending, and reading text files and binary files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s take a closer look at opening, editing and closing files. In general,
    these operations can be represented in our pseudo-code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: my_file = open("test.txt", "w")write(my_file, "First sample text written to
    the file.")write(my_file, "Another sample text.")close(my_file)
  prefs: []
  type: TYPE_NORMAL
- en: In most languages, when a file is opened, a variable of a special type is returned.
    In our pseudo-code, we get back a variable **my_file** from the **open()** function
    we use to open the file **text.txt** in write mode (**w**). From now on, we work
    with this variable so that the functions we use to edit the file know which file
    our instructions refer to; after all, we could have a whole series of different
    files open in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'In object-oriented programming languages, the file variable will regularly
    be an object, which then has special methods that can be used to manipulate the
    file (flip back a few pages to the last chapter if the topic of objects and methods
    seems unfamiliar). Then writing and closing the file might look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: my_file = open("test.txt", "w")my_file.write("Another sample text.")my_file.close()Examples
    in Different Programming Languages
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at this in some actual existing programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '**#include** <stdio.h>**int** main() {FILE *my_file;my_file = fopen("test.txt",
    "w");fprintf(my_file, "First sample text written to file.");fprintf(my_file, "Another
    sample text.");fclose(my_file);}'
  prefs: []
  type: TYPE_NORMAL
- en: The code looks considerably more complicated than it actually is. To make it
    work, the first statement must include a special standard program library called
    **stdio.h**, which provides the functions for input and output. The main program
    in C is itself a function, **main()**, which is called automatically when the
    program is executed. What should happen then is inside the function and is what
    we are actually interested in here. In C, variables must be registered before
    they are used for the first time. Here, a variable of type **FILE** is declared,
    and the asterisk is used to create a *pointer* to such a variable, but we won’t
    concern ourselves with the implications at this point. The variable just created
    then takes the return value of the function **fopen()** (for *file open*), which
    we use to open file **test.txt** in write mode (**w**). If this file does not
    exist yet, it will be created. After that we write with the function **fprintf()**
    (for *file print formatted*) into the just opened file, which we reference with
    the help of our variable **my_file.** Afterwards we close the file with **fclose()**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same process would look like this in Pascal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**program** FileWrite;**var**my_file: TextFile;**begin**AssignFile(my_file,
    ''test.txt'');rewrite(my_file);write(my_file, ''First sample text to be written
    to the file.'');write(my_file, ''Another sample text.'');CloseFile(my_file);**end.**'
  prefs: []
  type: TYPE_NORMAL
- en: Here we first declare a variable **my_file**. This variable is then assigned
    the reference to our file **test.txt** with a special function called **AssignFile()**.
    Up to this point, it is not at all clear in which mode the file is to be opened.
    That is not determined until the **rewrite()** function is called, which opens
    the file for writing. After writing, the file is closed at the end of the program
    with **CloseFile()**.
  prefs: []
  type: TYPE_NORMAL
- en: So Pascal differs from C in that here the special function **rewrite()** is
    used when opening the file in write mode, whereas in C the general function **fopen()**
    is used, where a function argument, i.e. a setting we pass to the function when
    calling it, determines in which mode the file should be opened.
  prefs: []
  type: TYPE_NORMAL
- en: 'Analogously, there is a special function in Pascal for opening files in read
    mode: **reset()**. If the first line from file **test.txt** is to be read, the
    corresponding Pascal code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**program** FileWrite;**var**my_file: TextFile;first_line: string;**begin**AssignFile(my_file,
    ''test.txt'');reset(my_file);readln(my_file, first_line);CloseFile(my_file);**end.**'
  prefs: []
  type: TYPE_NORMAL
- en: The function **readln()** (*read line*) is used, which reads a line from the
    file opened in read mode (first argument of the function) and stores it in the
    variable **first_line** (second argument). After that, the file pointer is automatically
    advanced to the next line, even without our intervention. If we were to read in
    a line again, this time it would be the second line.
  prefs: []
  type: TYPE_NORMAL
- en: Work with Files Beyond Reading and Writing Local Files
  prefs: []
  type: TYPE_NORMAL
- en: The files that are read do not necessarily have to be located on your local
    system. Provided that the files are not subject to any conflicting access protection,
    an Internet address (or *URL*, a *Uniform Resource Locator*) can regularly be
    specified as the file name in most programming languages. Files that are located
    on a web server, and that your browser reads and displays as a web page, can be
    read using a program you have written yourself just as if it were a file on your
    local computer.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the functions for opening, reading, writing and closing files,
    many programming languages offer functions for working with the file system, such
    as creating or reading directories in the file system, or copying, moving, deleting
    or renaming files and directories. Functions for determining the file size or
    for checking whether a file exists at a certain path are also part of the standard
    scope of programming languages. Checking whether a file exists is useful to avoid
    an error or even uncontrolled program crash if your code tries to access a file
    that does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the approaches discussed here represent only the basic functionality
    that practically all programming languages have, even if they may differ slightly
    from each other in the individual design. In addition, many programming languages
    offer—either out-of-the-box or through extension libraries—many other functions
    with which files can be processed. For example, to write or read files in special
    file formats (such as, image files or files in the proprietary formats of certain
    popular software applications like Microsoft Office), or to exchange files with
    servers via appropriate network protocols such as FTP (File Transfer Protocol).
  prefs: []
  type: TYPE_NORMAL
- en: '12.4'
  prefs: []
  type: TYPE_NORMAL
- en: Explain the differences between the various options available when opening a
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4 Working with Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the practice of professional software development, working with databases
    plays a major role. Most web services as we know them today are basically the
    combination of a database ("backend") and a web user interface ("frontend") that
    allows the user to interact with the data stored in the database. This is as true
    for web shops as it is for social networks. In the professional environment, reading
    from and writing to databases is therefore the rule rather than the exception
    when it comes to data input and output. In the field of non-professional software
    development, working with databases certainly does not play quite such a large
    role. Therefore, and because the subject is not a simple one, we will only cover
    some basics in this section, which will give you an overview of the subject, and
    leave the details to more advanced programming courses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most databases are collections of data tables that can be related to each other.
    They are called *relational* because the tables ultimately describe relations
    (relationships) between certain objects and their properties. As a stylized example,
    look at ◘ Tables [12.1](#Tab1), [12.2](#Tab2), and [12.3](#Tab3). ◘ Table [12.1](#Tab1)
    contains the data of customers. The individual customers in the rows (in the context
    of the database, we speak of *data records*) can be uniquely identified via the
    column (in database language: the *field*) **CUSTOMERID**. ◘ Table [12.2](#Tab2)
    shows the products. These also have some descriptive fields as well as a unique
    ID, the field **PRODUCTID**. ◘ Table [12.3](#Tab3) represents the orders that
    the customers have placed. In this table, an order is identified by its own ID
    (**ORDERID**), the customer, the products that the customer ordered, and the order
    date. You can see that customers and products are represented by their IDs, and
    thus by *references to* the **CUSTOMER** and **PRODUCT** tables, respectively.
    Each row represents a combination of customer and ordered product. For example,
    you can see from purchase order **B0002** that customer **C00003** (Mason Thomas)
    ordered *two* products (namely **P001—**the garden shovel, and **P002—**the balcony
    table). Accordingly, in the **ORDER** assignment table, this order is described
    by *two* records.Table 12.1'
  prefs: []
  type: TYPE_NORMAL
- en: Example data for table CUSTOMER
  prefs: []
  type: TYPE_NORMAL
- en: '| Customerid | Name | First name | Email | Street | City | Zipcode |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| C00001 | Collins | Ethan | ecollins@my-emails.com | 123 Oak Street, Apt 4B
    | New York, NY | 10001 |'
  prefs: []
  type: TYPE_TB
- en: '| C00002 | Rodriguez | Olivia | me@oliviarodriguez.com | 456 Pine Avenue, Suite
    9C, | Chicago, IL | 90001 |'
  prefs: []
  type: TYPE_TB
- en: '| C00003 | Thomas | Mason | mason.thomas@thomas-winery.com | 789 Maple Drive
    | Los Angeles, CA | 60601 |'
  prefs: []
  type: TYPE_TB
- en: '| C00004 | Wilson | Anna | anna@thewilsonfamily.com | 321 Elm Street, Apartment
    7D | Houston, TX | 77002 |'
  prefs: []
  type: TYPE_TB
- en: Table 12.2
  prefs: []
  type: TYPE_NORMAL
- en: Example data for table PRODUCT
  prefs: []
  type: TYPE_NORMAL
- en: '| Product ID | Description | Price |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| P001 | Garden shovel, stainless steel | 10.99 |'
  prefs: []
  type: TYPE_TB
- en: '| P002 | Balcony table, plastic, green | 24.99 |'
  prefs: []
  type: TYPE_TB
- en: Table 12.3
  prefs: []
  type: TYPE_NORMAL
- en: Example data for table ORDER
  prefs: []
  type: TYPE_NORMAL
- en: '| Order ID | Customer ID | Product ID | Date |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| B0001 | C00001 | P001 | 2019-06-01 0:08 AM |'
  prefs: []
  type: TYPE_TB
- en: '| B0002 | C00003 | P001 | 2018-12-05 7:49 AM |'
  prefs: []
  type: TYPE_TB
- en: '| B0002 | C00003 | P002 | 2018-12-05 7:49 AM |'
  prefs: []
  type: TYPE_TB
- en: '| B0003 | C00002 | P001 | 2019-05-16 9:58 PM |'
  prefs: []
  type: TYPE_TB
- en: Of course, we could have repeated all the customer and product data in the **ORDER**
    table; however, this would not only make the table unnecessarily large, but would
    also make data maintenance much more difficult, because changes to a customer’s
    master data (for example, his address) would then have to be made in two places
    in the database, the **CUSTOMER** table and the **ORDER** table. This would increase
    the risk of inconsistent data. These problems are avoided by the reference technique
    used here.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure of defining the essential objects only once and mapping relationships
    between them by means of references to their IDs, or keys, is referred to as *normalization*.
    The database system ensures that these references always work, so that a customer
    who is referenced in the **ORDER** table cannot be deleted from the **CUSTOMER**
    table, because that would make its existing order data inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, our example tables here are not yet perfectly normalized. The order
    date is actually attached to the order itself, not to the individual combinations
    of customer and product that belong to an order and are stored in the **ORDER**
    table. Complete normalization could be achieved by removing the products from
    the **ORDER** table (leaving only the ID of the order, the customer and the date
    in **ORDER**) and storing the assignment between the order and the ordered products
    via their keys in a separate table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data stored in databases in this way can be queried. A special programming
    language is used for this purpose—*SQL*, or *Structured Query Language*. Queries
    can be formulated in this language and processed by the database system which
    then returns the queried data as a result. The most important SQL statement is
    **SELECT**. The syntax of **SELECT** is basically quite simple (although it can
    be extended in many places to create more complex queries): **SELECT** ***fields***
    **FROM** ***table*** **WHERE** ***condition***.'
  prefs: []
  type: TYPE_NORMAL
- en: The statement
  prefs: []
  type: TYPE_NORMAL
- en: '**SELECT** FIRSTNAME, NAME **FROM** CUSTOMER **WHERE** **LOCATION = ''New York,
    NY''**queries all data records from the table **CUSTOMER** where the field **CITY**
    has the value **"New York, NY"**. However, not all fields are to be displayed,
    but only the fields **FIRSTNAME** and **NAME**. The result of this statement is
    therefore a table that contains only these two fields for the relevant data records,
    in the example as shown in ◘ Table [12.4](#Tab4). In the case of our **SELECT**
    statement, the results table only consists of one record, that of Ethan Collins.Table
    12.4'
  prefs: []
  type: TYPE_NORMAL
- en: Result of our SQL sample query with SELECT
  prefs: []
  type: TYPE_NORMAL
- en: '| First name | Name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Ethan | Collins |'
  prefs: []
  type: TYPE_TB
- en: However, SQL can not only be used to query data from databases, but also to
    write data to databases. For this purpose, the statements **INSERT** and **UPDATE**
    are used, which insert *new* records into a table (**INSERT**) or update *existing*
    records (**UPDATE**), i.e. change the value of one or more fields of a record
    (or several records at the same time).
  prefs: []
  type: TYPE_NORMAL
- en: From most programming languages, databases can be addressed (often with the
    help of extension libraries, covered in the following chapter), fed with SQL statements
    and their results received and processed.
  prefs: []
  type: TYPE_NORMAL
- en: 12.5 Your Roadmap to Learning a New Programming Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are learning a new programming language …
  prefs: []
  type: TYPE_NORMAL
- en: 'you’ll discover:'
  prefs: []
  type: TYPE_NORMAL
- en: which types of user interfaces (GUIs, console) you can equip your programs with,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if console applications are supported, which functions are available for the
    output of data as well as for the input of data by the user,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if graphical interfaces are supported, how they are designed (graphical WYSIWYG
    development in IDE, description of the interface in the code) and which controls
    are available to you for the design of your graphical user interface and which
    essential properties/configuration options they offer,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how to open (and close) files for reading, writing or appending data, in particular
    what different editing modes are available when opening and how to distinguish
    between opening text and binary files,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: what functions are available to write data into or read data from open files,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if you plan to work with databases, how to connect to databases as well as send
    SQL statements to the database and process the returned results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.6 Solutions to the Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exercise 12.1
  prefs: []
  type: TYPE_NORMAL
- en: Graphical user interfaces can be designed via an Integrated Development Environment
    (IDE) in WYSIWYG mode, where the individual control elements are selected and
    placed on the program interface with the mouse. Typically, the properties of the
    controls can be conveniently. The user interface is thus created without having
    to “program” it. But many programming languages also allow the user interface
    to be created as part of the program code. The individual controls are then mostly
    objects that can be created from within the program—just like other objects—and
    placed on the interface. The properties of the controls can be accessed via the
    attributes of the objects representing them.
  prefs: []
  type: TYPE_NORMAL
- en: Task 12.2
  prefs: []
  type: TYPE_NORMAL
- en: Console applications usually run in a completely linear fashion where the user
    is guided through the program, and the program determines the sequence of the
    user’s work. In applications with graphical interfaces, the user usually has more
    control over the order in which he or she executes which steps. For example, the
    user can click on buttons in any order. In this sense, the program does not determine
    user behavior; instead, it responds to *events* that the user triggers. For example,
    if the user clicks on a button, the associated event is triggered, and the program
    code intended for that event is executed. Although this type of event-oriented
    program control can, in principle, be reproduced in console applications, it is
    much less common there than in applications with graphical user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.3
  prefs: []
  type: TYPE_NORMAL
- en: A console application is usually fast and easy to use if you are familiar with
    it. The behavior of the program can often be controlled by command line parameters
    when it is called from the console. The usability is also facilitated by the fact
    that all control operations can be performed with the keyboard, whereas graphical
    user interfaces often require a pointing instrument (usually the mouse) and thus
    the switching of the hand or hands between the input devices. Console applications
    also have advantages in development because they can usually be programmed with
    less effort than applications with a graphical user interface. In addition, a
    lower level of knowledge of the programming language used is usually sufficient
    for the development of a console application than for the development of a graphical
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.4
  prefs: []
  type: TYPE_NORMAL
- en: In most programming languages, the modes for opening a file differ first by
    the editing operations that are allowed in each case. The file can be opened regularly
    for reading (**read**/**r**), writing (**write**/**w**) or appending (**append**/**a**).
    When opened in write mode, an existing file is completely overwritten. If data
    is to be appended to an existing file, it must be opened in append mode. A second
    difference is whether the file is opened as a text file or as a binary file, which
    mainly affects the way data written into it is encoded.
  prefs: []
  type: TYPE_NORMAL
