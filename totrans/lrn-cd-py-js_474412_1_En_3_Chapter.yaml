- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024J. L. ZuckarelliLearn coding with Python and JavaScript
    [https://doi.org/10.1007/978-3-658-42912-6_3](https://doi.org/10.1007/978-3-658-42912-6_3)
  prefs: []
  type: TYPE_NORMAL
- en: 3. What Is a Programming Language?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1)München, GermanyOverview
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming ultimately means giving instructions to the computer. This is done
    in a special language that both we as programmers and the computer understand:
    a programming language. Programming languages and natural languages have a lot
    in common, but they also have some important differences.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we deal with programming languages and thus with the crucial
    question of how we make ourselves understood by the computer, and how the computer
    manages to understand us and carry out our instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Languages for Humans, Languages for Machines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have dealt with *what* programming is and *why* it makes sense to
    learn it. Only the question of *how* remains to be dealt with. How do we program?
    How exactly do we tell the computer what the algorithm, i.e., the sequence of
    steps it is to process, looks like?
  prefs: []
  type: TYPE_NORMAL
- en: 'Somehow, the algorithm must be written down in a way the computer can understand.
    Now, as we know, computers work in a binary mode, they ultimately distinguish
    only two states, zero and one, on and off, voltage present and voltage absent.
    It is therefore natural to assume that we have to write programs in a binary way
    in order for the computer to understand them. Fortunately, this is not the case.
    If you look over the shoulder of a programmer, you will see that he or she writes
    texts in a language that is basically readable by humans. In the text you will
    recognize many English terms. A typical line of program text could read something
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '**if** value <0 **then** print "Value is less than zero"'
  prefs: []
  type: TYPE_NORMAL
- en: Even though many of the terms used are familiar from English, the language used
    by the programmer is an *artificial* language, a *programming language*. There
    are other artificial languages that are not programming languages, such as the
    lingua franca *Esperanto*, developed by the Polish ophthalmologist *Ludwik Lejzer
    Zamenhof*, or *Klingon*, the native language of the alien Klingon race known from
    *Star Trek*.
  prefs: []
  type: TYPE_NORMAL
- en: Like human languages, programming languages also have a grammar, the *syntax,*
    which describes which formulations are permissible and which are not. Nevertheless,
    programming languages differ significantly from human languages.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Programming languages are less complex, both in terms of grammar/syntax and
    in the terms used and their meaning (called *semantics*). The good news for you
    is that you don’t have to learn such a large vocabulary!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The grammatical rules must be strictly observed, otherwise you will not be understood.
    That is the bad news. In normal conversational situations, the human counterpart
    understands a sentence even if it is not quite grammatically correct. This is
    important, given the fact that only native speakers and speakers with a lot of
    experience can really master a language without errors. But this kind of internal
    error correction, or error-tolerant comprehension, requires mental performances
    that we commonly associate with intelligence. Now the problem—as you can guess—is
    that computers are simply not intelligent. They have no tolerance for error and
    only accept and understand correctly formed sentences. This is what makes programming
    difficult and, from time to time, frustrating, especially when the computer doesn’t
    want (or just can’t, because it doesn’t have free will) to understand you. Because
    the language must be so precise, its formulations often seem awkward, which makes
    it completely unusable as an everyday language. This brings us to the next point.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Programming languages are not made to be spoken. Two programmers are not going
    to talk in a programming language when they meet for lunch. But of course, programmers
    sometimes speak strangely because they talk about parts of a program written in
    a programming language and quote parts of the program to do so.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Programming languages in the strict sense (there are some descriptive languages
    that could be considered exceptions) are not made to transfer information, but
    solely to give instructions to the computer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Thus, although programming languages, as artificial languages, are designed
    to be considerably simpler than natural languages, both in terms of their grammar
    and vocabulary, the works of the authors, i.e., programmers, who use these languages
    are of considerable complexity and scope. Some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The programs that controlled NASA Apollo 11 lunar module and brought Neil Armstrong
    and Buzz Aldrin safely to the moon, had a length of about 40 thousand lines; that
    is 645 normally written pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Microsoft Windows 3.1 operating system had about 2.5 million lines; a little
    over 40,000 pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The office application suite, Microsoft Office 2013, draws its functionality
    from about 44 million lines of program code, which could be printed on about 694,000
    pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The social network Facebook is based on about 61 million lines of program code
    and thus about 984,000 pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: According to a Google developer, all Google applications together have about
    2 billion (!) lines; printed out, that would be about 32,300,000 pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For comparison: Goethe’s *Faust* has 12,111 lines, which corresponds to 195
    pages.Comparisons between these different programs are not easy, because:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: different programming languages need a different number of lines for the same
    operation,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: personal programming styles differ,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the way the program code is formatted (which influences the readability and
    thus “maintainability” of the code) may differ.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All these factors have an influence on the program size.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can see already that software programs are often extensive, and
    sometimes extraordinarily complex, works.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Translation and Execution of Programming Languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we had noted that most programming languages use English
    terms. This is mainly because the development of programming languages has been
    mainly driven in the English-speaking world, although the first real programming
    language was the invention of the German *Konrad Zuse,* to whom we will return
    later. Of course, one could just as easily design a programming language whose
    commands are all borrowed from a language other than English, such as Spanish,
    French, or Chinese. However, it is obvious that this is not normally done, except
    possibly for pedagogical purposes, given the dominant role of English as the world’s
    lingua franca and the understandable desire of every creator of a new programming
    language to see his work spread as widely as possible.
  prefs: []
  type: TYPE_NORMAL
- en: However, we have not yet solved the problem that the computer can handle neither
    English nor any other human language. But if the computer only understands zeros
    and ones, how does it cope with programming languages based on English? What is
    obviously missing is some step between writing the instructions of the program
    in a human-readable programming language, and its execution by the computer.
  prefs: []
  type: TYPE_NORMAL
- en: This task is performed by the *compiler*. The compiler translates the program
    into a language that the computer understands directly, the *machine language*.
    This machine language knows only a very limited set of basic commands, such as
    loading individual values into the processor’s registers, i.e., the small memory
    elements whose contents are accessible to the processor to work with.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a bit like having to explain a route to someone who doesn’t know the place.
    Whereas a person who knows the area would easily find his way to the meeting point
    from his current location with the instruction “Go to Time Square, we’ll meet
    there,” you have to break down the directions for the person who doesn’t know
    the area to more elementary components. For example, you could say “Go straight
    ahead to the second traffic light. Then turn left. Then go straight until the
    next intersection. There, turn right and go straight until you hit the square.”
    It is the same with machine language. It is the stream of instructions, broken
    down to elementary processor operations, that result from a program written in
    a programming language. The human-readable program may contain many “shortcuts”
    and references to already known sequences of instructions, but for the processor,
    all of this must be reduced to the basic operations that it can perform. This
    machine code runs directly on the computer’s processor. If you work with Windows,
    you’re probably familiar with the **.exe** and **.com** files. These are the programs
    translated into machine code that the computer understands and can execute directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'An *interpreter* works somewhat differently. The interpreter (which is itself
    a program) executes the program step by step; it “interprets” the program code.
    It is clear that the interpreter ultimately has to pass the program to be executed
    to the computer in machine language, otherwise the computer would not be able
    to understand it. But in the case of the interpreter, this translation takes place
    while the program is running (“at runtime,” as programmers say). So, the program
    itself does not run *directly* on the computer, but is mediated by the interpreter.
    However, this also means: You can’t just run the program everywhere, you always
    need the interpreter to get the source code of the program running on a computer.'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling, or the translation of the human-readable program code into a machine
    language understandable to the computer, usually has speed advantages because
    the translation itself takes time and is done by the compiler in advance. At runtime,
    there is then no need to spend time translating. For our purposes, considerations
    of code execution speed are not quite so important, but when it comes to computationally
    intensive or time-critical applications (think, for example, of monitoring systems
    in intensive care medicine), such considerations are certainly highly relevant.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is still a middle ground between compiler and interpreter. It works like
    this: First, a *bytecode compiler* generates an “intermediate code” from the source
    code of the program. This is very similar to machine language but is independent
    of the processor architecture. The problem with machine language is that it depends
    on exactly how the processor is built. Different processor types understand only
    “their” machine language. Bytecode, on the other hand, is machine-independent
    and so can easily be generated on one type of system and then executed on other
    types of systems. The code is said to be “portable”. The generation of the bytecode
    is done during the development of the program. At runtime, a just-in-time *compiler*
    (JIT compiler) generates the machine-specific code from the bytecode. To a certain
    extent, the JIT compiler is a bytecode interpreter. It reads the “precompiled”
    bytecode and passes instructions to the processor in the respective machine language
    of the system used for execution. This is faster than executing the untranslated
    source code directly, as a classical interpreter would do.'
  prefs: []
  type: TYPE_NORMAL
- en: The most prominent example of this approach of using a combination of bytecode
    compiler during development and JIT compiler at runtime, is the popular Java programming
    language. (Java’s JIT compilers are also referred to as “runtime environments”
    because they form the environment in which the Java program is executed.) Thanks
    to its JIT compilers which are adapted to the respective system, Java not only
    runs on computers with very different operating systems such as Windows, MacOS
    or Linux, but also on various other devices such as cars or refrigerators.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, it is considered a property of a programming language whether it
    is compiled or interpreted. However, there are also languages that are basically
    interpreted, but for which there is then nevertheless the possibility of bytecode
    compilation. Interpreters, too, may compile parts of the code that are particularly
    computationally intensive or are often traversed, and sometimes even all of the
    code, directly into executable machine code; this is also called JIT compilation.
    So, the world is indeed still a bit more colorful, and compiler construction in
    computer science is an art (and discipline) in itself.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 From Machine Language to High-Level Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All well and good with compiling and interpreting. But the question arises:
    Couldn’t you just write a program directly in machine language? Of course, this
    would be possible, but it would not be easy at all, on the contrary, it would
    be extremely tedious, and the result would be very difficult to understand. In
    addition, the program would have to be written in such a way that it takes into
    account the peculiarities of the processor on which it is to run. If you suddenly
    want it to run on a completely different system architecture, you might have to
    modify it considerably in many places. Programming in machine language is therefore
    not recommended. In the early days of computers, however, that was exactly what
    was needed. Ultimately, even the decoy card programs of *Charles Babbage* and
    colleagues are software written in the machine language that Babbage’s *Analytical
    Engine* would have understood directly had it ever been built during his lifetime.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to at least simplify the trouble of writing directly in machine language,
    *assembler languages* appeared from the 1940s onwards. Assembler languages are
    ultimately machine code in a readable form. For the (manageably) numerous machine
    commands, short commands (*mnemonics*) were created, which can be translated one-to-one
    into machine code. In other words: the assembler instructions correspond exactly
    to the instruction set of the processor. Programming in assembler is still incredibly
    tedious. For example, an assembler instruction is:MOV AL, 6Fh'
  prefs: []
  type: TYPE_NORMAL
- en: 'This tells the computer: load the value 111 (6Fh means 111 in the hexadecimal
    number system, that is, in the sixteen-based number system) into the processor
    register AL. To use a simple instruction written in a high-level language, such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: print "Hello World!"
  prefs: []
  type: TYPE_NORMAL
- en: in assembler, it requires a whole series of such operations. Above all, however,
    with assembler one is still dependent on the respective processor architecture.
  prefs: []
  type: TYPE_NORMAL
- en: It is easier with the *high-level languages*. High-level languages abstract
    from the processor architecture because their interpreters or compilers take over
    the consideration of the specifics of the target processor, so that the developer
    is relieved of this task. He writes his program only once; afterwards it can be
    translated into the machine language of completely different processor architectures.
  prefs: []
  type: TYPE_NORMAL
- en: The high-level languages, unlike assembler code and (even more so) machine code,
    are easier to read because they use English terms for the instructions. Many of
    these commands combine a whole series of machine commands, which means that one
    line of high-level language code may generate many different machine code commands
    when compiled. The programmer, of course, no longer needs to worry about these
    details. No wonder, then, that practically all programming languages in use today
    are such high-level languages.
  prefs: []
  type: TYPE_NORMAL
- en: The first simple high-level language was developed in the 1940s by the German
    engineer *Konrad Zuse* and was called *Plankalkül*. With *Plankalkül,* Zuse achieved
    a groundbreaking development that should have paved the way for modern software
    development in the first place. Due to World War II Zuse’s work remained unnoticed
    for a long time. The first implementation (i.e., usable technical realization)
    of Zuse’s *Plankalkül* took place in 1975 and was done by *Joachim Hohmann* in
    the context of his dissertation.
  prefs: []
  type: TYPE_NORMAL
- en: The breakthrough of high-level languages, on the other hand, came with *ALGOL*
    (short for *Algorithmic Language*), which was developed in the USA in the late
    1950s/early 1960s mainly for academic purposes and largely without reference to
    the pioneering work of *Konrad Zuse*. Even before that, in the 1950s, the American
    computer scientist *Grace Hopper* had designed the first working compiler. *Hopper*,
    who died in 1992 and was posthumously honored with the Presidential Medal of Freedom,
    the highest civilian award of the United States, was also involved in the development
    of the programming language *COBOL* (*Common Business-Oriented Language*). *COBOL*
    was a language widely used in a business context. Together with *FORTRAN* (*Formula
    Translation*), developed by *John Backus in* 1957 and mainly used in technical
    and scientific work, it completes the collection of early, truly operational high-level
    languages.
  prefs: []
  type: TYPE_NORMAL
