- en: '`Logarithms`'
  id: totrans-0
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: Let’s examine why algorithms such as `binary search` are described as `O(log
    N)`. What is a log, anyway?
  id: totrans-1
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Log` is shorthand for `logarithm`. The first thing to note is that the word
    `logarithm` has nothing to do with `algorithm`, even though the two words look
    and sound so similar.'
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Logarithms` are the inverse of exponents. Here’s a quick refresher on what
    exponents are:'
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`2³` is the equivalent of'
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`2 * 2 * 2`.'
  id: totrans-5
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: This just happens to be `8`.
  id: totrans-6
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Now, `log[2] 8` is the converse. It means: how many times do you have to multiply
    `2` by itself to get a result of `8`?'
  id: totrans-7
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Because you have to multiply `2` by itself three times to get `8`, `log[2] 8
    = 3`.
  id: totrans-8
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Here’s another example:'
  id: totrans-9
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`2⁶` translates to'
  id: totrans-10
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`2 * 2 * 2 * 2 * 2 * 2 = 64`.'
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Because we had to multiply `2` by itself six times to get `64`, we have, therefore,
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`log[2] 64 = 6`.'
  id: totrans-13
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: While the preceding explanation is the “textbook” definition of logarithms,
    I like to use an alternative way of describing the same concept because many people
    find that they can wrap their heads around it more easily, especially when it
    comes to `Big O` notation.
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Another way of explaining `log[2] 8` is this: if we kept dividing `8` by `2`
    until we ended up with `1`, how many `2`s would we have in our equation?'
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`8 / 2 / 2 / 2 = 1`'
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In other words, how many times do we need to halve `8` until we end up with
    `1`? In this example, it takes us three times. Therefore,
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`log[2] 8 = 3`.'
  id: totrans-18
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Similarly, we could explain `log[2] 64` like this: how many times do we need
    to halve `64` until we end up with `1`?'
  id: totrans-19
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`64 / 2 / 2 / 2 / 2 / 2 / 2 = 1`'
  id: totrans-20
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Since there are six `2`s, `log[2] 64 = 6`.
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Now that you understand what logarithms are, the meaning behind `O(log N)` will
    become clear.
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
