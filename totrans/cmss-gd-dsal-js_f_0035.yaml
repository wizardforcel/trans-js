- en: Logarithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s examine why algorithms such as binary search are described as O(log N).
    What is a log, anyway?
  prefs: []
  type: TYPE_NORMAL
- en: Log is shorthand for logarithm. The first thing to note is that word logarithm
    has nothing to do with algorithm, even though the two words look and sound so
    similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logarithms are the inverse of exponents. Here’s a quick refresher on what exponents
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: 2³ is the equivalent of
  prefs: []
  type: TYPE_NORMAL
- en: 2 * 2 * 2.
  prefs: []
  type: TYPE_NORMAL
- en: This just happens to be 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, log[2] 8 is the converse. It means: how many times do you have to multiply
    2 by itself to get a result of 8?'
  prefs: []
  type: TYPE_NORMAL
- en: Because you have to multiply 2 by itself three times to get 8, log[2] 8 = 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: 2⁶ translates to
  prefs: []
  type: TYPE_NORMAL
- en: 2 * 2 * 2 * 2 * 2 * 2 = 64.
  prefs: []
  type: TYPE_NORMAL
- en: Because we had to multiply 2 by itself six times to get 64, we have, therefore,
  prefs: []
  type: TYPE_NORMAL
- en: log[2] 64 = 6.
  prefs: []
  type: TYPE_NORMAL
- en: While the preceding explanation is the “textbook” definition of logarithms,
    I like to use an alternative way of describing the same concept because many people
    find that they can wrap their heads around it more easily, especially when it
    comes to Big O notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of explaining log[2] 8 is this: if we kept dividing 8 by 2 until
    we ended up with 1, how many 2s would we have in our equation?'
  prefs: []
  type: TYPE_NORMAL
- en: 8 / 2 / 2 / 2 = 1
  prefs: []
  type: TYPE_NORMAL
- en: In other words, how many times do we need to halve 8 until we end up with 1?
    In this example, it takes us three times. Therefore,
  prefs: []
  type: TYPE_NORMAL
- en: log[2] 8 = 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we could explain log[2] 64 like this: how many times do we need
    to halve 64 until we end up with 1?'
  prefs: []
  type: TYPE_NORMAL
- en: 64 / 2 / 2 / 2 / 2 / 2 / 2 = 1
  prefs: []
  type: TYPE_NORMAL
- en: Since there are six 2s, log[2] 64 = 6.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand what logarithms are, the meaning behind O(log N) will
    become clear.
  prefs: []
  type: TYPE_NORMAL
