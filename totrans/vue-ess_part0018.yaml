- en: 'Module 13:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 第 13 章：
- en: '|'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Advanced Vue.js Concepts
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 高级 Vue.js 概念
- en: '|'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'In the ever-evolving landscape of web development, staying ahead requires a
    deep dive into the advanced concepts that push the boundaries of what Vue.js can
    achieve. The module "Advanced Vue.js Concepts" serves as a pinnacle within the
    book "Vue.js Essentials: For Responsive Web Development," guiding readers through
    sophisticated techniques and advanced features of Vue.js. Developers will embark
    on a journey to explore intricate concepts, enabling them to enhance their proficiency
    and craft robust, scalable, and high-performing web applications.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '在不断发展的网页开发领域，保持领先需要深入研究推动 Vue.js 能力边界的高级概念。模块《高级 Vue.js 概念》是《Vue.js 精要：响应式网页开发》一书中的巅峰之作，指导读者通过
    Vue.js 的复杂技巧和高级功能。开发者将踏上探索复杂概念的旅程，从而提升自己的技能，打造强大、可扩展且高性能的 Web 应用。 '
- en: Elevating State Management with Vuex Advanced Techniques
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Vuex 高级技巧提升状态管理
- en: While Vuex is a powerful state management solution, this segment delves into
    advanced Vuex techniques to further elevate state management proficiency. Readers
    will explore concepts like module organization, dynamic module registration, and
    advanced state management patterns. By mastering these advanced Vuex techniques,
    developers can enhance code organization, facilitate collaboration in larger teams,
    and efficiently manage complex application states.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Vuex 是一个强大的状态管理解决方案，本节将深入探讨高级 Vuex 技巧，以进一步提升状态管理的熟练度。读者将探索诸如模块组织、动态模块注册和高级状态管理模式等概念。通过掌握这些高级
    Vuex 技巧，开发者可以增强代码组织，促进大团队间的协作，并高效管理复杂的应用状态。
- en: 'Reactive Programming with Vue.js: Advanced Observables and Computed Properties'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vue.js 的响应式编程：高级观察者和计算属性
- en: Reactive programming is at the core of Vue.js, and this module delves into advanced
    aspects of reactivity. Readers will explore advanced observables, diving deeper
    into Vue's reactivity system to understand the inner workings of data observation
    and reactivity caveats. The segment also covers advanced computed properties,
    allowing developers to optimize performance by understanding when and how to use
    complex computed properties efficiently.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是 Vue.js 的核心，本模块深入探讨响应性方面的高级内容。读者将探索高级观察者，深入了解 Vue 的响应式系统，以理解数据观察的内部机制和响应性陷阱。本节还涵盖了高级计算属性，帮助开发者通过了解何时以及如何高效使用复杂的计算属性来优化性能。
- en: Custom Directives and Vue.js Extensibility
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义指令和 Vue.js 可扩展性
- en: Vue.js extensibility is a powerful asset for developers seeking to tailor the
    framework to their specific needs. This part of the module explores the creation
    and usage of custom directives, enabling developers to extend Vue.js with their
    own behavior. Readers will gain insights into the life cycle of custom directives,
    creating directive hooks, and integrating them seamlessly into Vue.js applications,
    enhancing the framework's flexibility and adaptability.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 的扩展性是开发者在定制框架以满足特定需求时的强大资产。本模块的这一部分探讨了自定义指令的创建和使用，使开发者能够为 Vue.js 添加自己的行为。读者将深入了解自定义指令的生命周期、创建指令钩子，并将其无缝集成到
    Vue.js 应用程序中，从而增强框架的灵活性和适应性。
- en: Optimizing Performance with Advanced Vue.js Techniques
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用先进的 Vue.js 技术进行性能优化
- en: Performance optimization is a critical aspect of web development, and this module
    equips developers with advanced Vue.js techniques to achieve optimal rendering
    and resource utilization. Topics covered include virtual scrolling, asynchronous
    components, and server-side rendering optimization. By mastering these advanced
    techniques, developers can significantly enhance the performance of their Vue.js
    applications, ensuring a smooth and responsive user experience.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化是网页开发中的关键环节，本模块为开发者提供了先进的 Vue.js 技术，帮助实现最佳的渲染和资源利用。涵盖的主题包括虚拟滚动、异步组件和服务器端渲染优化。通过掌握这些先进技术，开发者能够显著提升
    Vue.js 应用程序的性能，确保流畅且响应迅速的用户体验。
- en: '"Advanced Vue.js Concepts" stands as a pinnacle within "Vue.js Essentials:
    For Responsive Web Development," providing readers with an advanced toolkit to
    tackle intricate challenges and optimize their Vue.js applications. By navigating
    through advanced state management, reactive programming, extensibility, and performance
    optimization, developers gain the knowledge and skills needed to excel in the
    ever-advancing field of web development. This module serves as a springboard for
    developers looking to push the boundaries of their Vue.js proficiency, creating
    web applications that are not only responsive but also showcase the full potential
    of the Vue.js framework.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 《"高级 Vue.js 概念"》是《Vue.js 基础：响应式网页开发》中的一项重要内容，为读者提供了一个高级工具包，帮助应对复杂的挑战并优化 Vue.js
    应用程序。通过掌握高级状态管理、响应式编程、扩展性和性能优化，开发者能够获得在不断发展的网页开发领域中脱颖而出的知识和技能。本模块为希望突破 Vue.js
    精通边界的开发者提供了一个跳板，帮助他们创建不仅响应迅速而且充分展示 Vue.js 框架潜力的网页应用。
- en: Mixins and Custom Directives
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混入与自定义指令
- en: 'Within the module "Advanced Vue.js Concepts" in the book "Vue.js Essentials:
    For Responsive Web Development," the section "Mixins and Custom Directives" serves
    as a gateway to advanced Vue.js development. This section delves into sophisticated
    techniques, offering developers powerful tools to enhance component reusability
    and extend Vue.js functionality through mixins and custom directives.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '在《Vue.js Essentials: For Responsive Web Development》一书的“Advanced Vue.js Concepts”模块中，“Mixins
    和自定义指令”部分是进入高级 Vue.js 开发的门户。该部分深入探讨了复杂的技术，提供了强大的工具，帮助开发者通过 Mixins 和自定义指令提升组件的可重用性并扩展
    Vue.js 的功能。'
- en: // src/mixins/logger.js
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: // src/mixins/logger.js
- en: export const loggerMixin = {
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: export const loggerMixin = {
- en: created() {
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: created() {
- en: 'console.log(`Component created: ${this.$options.name}`);'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 'console.log(`组件创建: ${this.$options.name}`);'
- en: '},'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: beforeDestroy() {
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: beforeDestroy() {
- en: 'console.log(`Component destroyed: ${this.$options.name}`);'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 'console.log(`组件销毁: ${this.$options.name}`);'
- en: '},'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '};'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: Mixins, as exemplified in the provided code snippet, are a powerful feature
    allowing developers to encapsulate and share reusable logic across multiple components.
    The loggerMixin showcases a basic logging functionality, printing component creation
    and destruction messages to the console. By applying mixins, developers can enhance
    component behavior without duplicating code, fostering maintainability and code
    organization.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如提供的代码片段所示，Mixins 是一个强大的特性，允许开发者封装并在多个组件之间共享可重用的逻辑。loggerMixin 展示了一个基本的日志功能，将组件的创建和销毁信息打印到控制台。通过使用
    Mixins，开发者可以增强组件行为，而无需重复编写代码，从而提高可维护性和代码组织性。
- en: 'Applying Mixins to Components: Harnessing Reusable Logic'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Mixins 应用到组件：利用可重用逻辑
- en: // src/components/MyComponent.vue
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: // src/components/MyComponent.vue
- en: import { loggerMixin } from '../mixins/logger';
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: import { loggerMixin } from '../mixins/logger';
- en: export default {
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: export default {
- en: 'mixins: [loggerMixin],'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 'mixins: [loggerMixin],'
- en: // Component-specific options
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: // 组件特定选项
- en: '};'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: To apply a mixin to a component, developers can use the mixins option within
    the component definition. In this example, the MyComponent incorporates the loggerMixin,
    gaining access to the logging functionality defined in the mixin. This approach
    allows developers to mix in various functionalities to different components, promoting
    code reusability and modularity.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Mixins 应用于组件，开发者可以在组件定义中使用 mixins 选项。在这个例子中，MyComponent 组件引入了 loggerMixin，从而获得了
    Mixins 中定义的日志功能。这种方式允许开发者将不同的功能混入到不同的组件中，促进代码重用和模块化。
- en: <!-- Usage in a template -->
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <!-- 在模板中的使用 -->
- en: <template>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <template>
- en: <div v-custom-directive="'arg'"></div>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <div v-custom-directive="'arg'"></div>
- en: </template>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: </template>
- en: Custom directives, on the other hand, provide a mechanism to create reusable,
    low-level functionalities that can be applied directly within templates. In the
    template snippet above, the custom directive v-custom-directive is invoked with
    an argument, showcasing the flexibility and expressiveness that custom directives
    bring to Vue.js applications.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，自定义指令提供了一种机制，可以创建可复用的低级功能，并且可以直接在模板中应用。在上面的模板代码中，`v-custom-directive` 自定义指令被带有参数的方式调用，展示了自定义指令为
    Vue.js 应用带来的灵活性和表现力。
- en: 'Implementing Custom Directives: Extending Vue.js Functionality'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实现自定义指令：扩展 Vue.js 功能
- en: // src/directives/customDirective.js
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: // src/directives/customDirective.js
- en: export const customDirective = {
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: export const customDirective = {
- en: mounted(el, binding) {
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: mounted(el, binding) {
- en: // Directive implementation
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: // 指令实现
- en: 'console.log(`Custom directive called with argument: ${binding.value}`);'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 'console.log(`自定义指令被调用，参数为: ${binding.value}`);'
- en: '},'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '};'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: // main.js
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: // main.js
- en: import { createApp } from 'vue';
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: import { createApp } from 'vue';
- en: import App from './App.vue';
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: import App from './App.vue';
- en: import { customDirective } from './directives/customDirective';
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: import { customDirective } from './directives/customDirective';
- en: const app = createApp(App);
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: const app = createApp(App);
- en: app.directive('custom-directive', customDirective);
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: app.directive('custom-directive', customDirective);
- en: app.mount('#app');
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: app.mount('#app');
- en: In the code above, the customDirective is defined and registered globally in
    the Vue application. This directive is then made available for use across components
    by attaching it to the directive option in the Vue app instance. Custom directives
    empower developers to extend Vue.js functionality in a way that suits their application's
    unique requirements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`customDirective` 被定义并在 Vue 应用中全局注册。然后，通过将其附加到 Vue 应用实例的指令选项中，使得该指令可以在各个组件中使用。自定义指令使开发者能够以符合其应用独特需求的方式扩展
    Vue.js 功能。
- en: Mastering Advanced Vue.js Concepts for Robust Applications
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 精通高级 Vue.js 概念，构建强大的应用
- en: The section "Mixins and Custom Directives" within the "Advanced Vue.js Concepts"
    module unlocks the potential of advanced Vue.js development. By embracing mixins
    for reusable logic and custom directives for extending Vue.js functionality, developers
    gain the tools needed to build robust and maintainable applications. These advanced
    concepts elevate the development experience, providing a deeper understanding
    of Vue.js and empowering developers to create flexible, scalable, and feature-rich
    Vue.js applications. As developers delve into the intricacies of mixins and custom
    directives, they unlock a new level of versatility and control, enhancing their
    ability to tackle complex application requirements with confidence.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在“高级 Vue.js 概念”模块中的“混入与自定义指令”部分，解锁了高级 Vue.js 开发的潜力。通过使用混入来复用逻辑和自定义指令来扩展 Vue.js
    功能，开发者获得了构建强大且可维护应用的工具。这些高级概念提升了开发体验，提供了更深入的 Vue.js 理解，并使开发者能够创建灵活、可扩展、功能丰富的 Vue.js
    应用。当开发者深入了解混入和自定义指令的细节时，他们解锁了新的多功能性和控制力，增强了应对复杂应用需求的信心。
- en: Render Functions and JSX
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Render 函数与 JSX
- en: 'In the module "Advanced Vue.js Concepts" within the book "Vue.js Essentials:
    For Responsive Web Development," the section "Render Functions and JSX" unveils
    an advanced layer of Vue.js development, exploring the versatility and expressive
    power offered by render functions and JSX. This section empowers developers to
    move beyond template-based syntax, diving into programmatic rendering to handle
    complex scenarios with finesse.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '在《Vue.js Essentials: For Responsive Web Development》一书的“高级 Vue.js 概念”模块中，“Render
    函数与 JSX”一节揭示了 Vue.js 开发的高级层次，探索了 render 函数和 JSX 所提供的多功能性和表达力。本节内容帮助开发者超越基于模板的语法，深入到程序化渲染中，以应对复杂场景。'
- en: // Example using the render function
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用 render 函数的示例
- en: render(h) {
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: render(h) {
- en: return h('div', {
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: return h('div', {
- en: 'attrs: {'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'attrs: {'
- en: 'class: ''example'','
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'class: ''example'','
- en: '},'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '}, ''This is an example'');'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '}, ''这是一个示例'');'
- en: '}'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The provided code snippet demonstrates a basic usage of a render function in
    a Vue.js component. The render function takes a function parameter h (short for
    createElement), allowing developers to describe the desired DOM structure programmatically.
    In this example, it creates a div element with the class 'example' and contains
    the text 'This is an example.' Render functions open the door to dynamic and fine-grained
    control over the rendered output.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的代码片段展示了在 Vue.js 组件中使用 render 函数的基本用法。render 函数接受一个参数 h（代表 createElement），允许开发者以编程方式描述所需的
    DOM 结构。在这个例子中，它创建了一个 class 为 'example' 的 div 元素，并包含文本 '这是一个示例'。render 函数为渲染输出提供了动态和细粒度的控制。
- en: 'Leveraging JSX in Vue.js: Merging Declarative and Imperative Paradigms'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue.js 中使用 JSX：融合声明式和命令式范式
- en: // Example using JSX
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用 JSX 的示例
- en: render() {
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: render() {
- en: return (
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: return (
- en: <div class="example">
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <div class="example">
- en: This is an example
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例
- en: </div>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: );
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Developers familiar with JSX from frameworks like React can leverage JSX in
    Vue.js as well. The JSX example achieves the same result as the previous render
    function but in a more declarative syntax. This blending of declarative and imperative
    paradigms allows developers to choose the approach that aligns with their preferences
    and project requirements.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉 React 等框架中的 JSX 的开发者，也可以在 Vue.js 中使用 JSX。这个 JSX 示例与之前的 render 函数实现了相同的效果，但采用了更具声明性的语法。声明式与命令式范式的结合，允许开发者选择与他们的偏好和项目需求相匹配的方法。
- en: 'Dynamic Components with Render Functions: A Programmable Approach'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 render 函数的动态组件：一种可编程的方法
- en: // Dynamically selecting components based on a condition
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: // 基于条件动态选择组件
- en: render(h) {
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: render(h) {
- en: return h('div', [
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: return h('div', [
- en: h('p', 'Welcome to the app!'),
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: h('p', '欢迎来到应用程序！'),
- en: this.showFeatureA
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: this.showFeatureA
- en: '? h(''feature-a'')'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '? h(''feature-a'')'
- en: ': h(''feature-b''),'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ': h(''feature-b''),'
- en: ']);'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ']);'
- en: '}'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Render functions excel in scenarios where components need to be dynamically
    selected based on conditions. In this example, the render function dynamically
    renders either feature-a or feature-b based on the value of the showFeatureA data
    property. This level of programmatic control is challenging to achieve with template-based
    syntax.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染函数在需要根据条件动态选择组件的场景中表现出色。在这个示例中，渲染函数根据 showFeatureA 数据属性的值动态渲染 feature-a 或
    feature-b。这种程序化控制在基于模板的语法中是很难实现的。
- en: 'Direct Manipulation of Virtual DOM with Render Functions: Optimizing Performance'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用渲染函数直接操作虚拟 DOM：优化性能
- en: // Optimizing performance with a render function
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用渲染函数优化性能
- en: render(h) {
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: render(h) {
- en: const children = [];
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: const children = [];
- en: for (let i = 0; i < this.items.length; i++) {
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: for (let i = 0; i < this.items.length; i++) {
- en: children.push(h('li', this.items[i]));
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: children.push(h('li', this.items[i]));
- en: '}'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return h('ul', children);
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: return h('ul', children);
- en: '}'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: When dealing with dynamic data rendering, render functions allow for direct
    manipulation of the virtual DOM, providing an avenue for performance optimizations.
    In this example, the render function efficiently creates a list of li elements
    based on the contents of the items array. This fine-grained control over rendering
    enables developers to optimize performance in scenarios with large datasets.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 处理动态数据渲染时，渲染函数允许直接操作虚拟 DOM，从而为性能优化提供了途径。在这个示例中，渲染函数根据 items 数组的内容高效地创建了一个 li
    元素列表。这种对渲染的精细控制使开发者能够在处理大数据集的场景中优化性能。
- en: Mastering the Art of Programmatic Rendering in Vue.js
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 精通 Vue.js 中的程序化渲染艺术
- en: '"Render Functions and JSX" within the "Advanced Vue.js Concepts" module equips
    developers with the tools to master programmatic rendering in Vue.js. By exploring
    the intricacies of render functions and JSX, developers can transcend the limitations
    of template-based syntax, gaining unparalleled control over the rendering process.
    This section is a guide to harnessing the expressive power of render functions,
    enabling developers to handle complex scenarios, optimize performance, and embrace
    a more dynamic and programmable approach to Vue.js development. As developers
    delve into this advanced concept, they unlock a new level of flexibility and efficiency,
    enhancing their ability to craft sophisticated and performant Vue.js applications.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '"《渲染函数与 JSX》" 章节属于 "高级 Vue.js 概念" 模块，旨在为开发者提供掌握 Vue.js 中程序化渲染的工具。通过探索渲染函数和
    JSX 的细节，开发者可以突破基于模板的语法限制，获得对渲染过程的无与伦比的控制力。本节内容是一本指南，帮助开发者掌握渲染函数的表达能力，使他们能够应对复杂场景、优化性能，并采用更加动态和可编程的方式进行
    Vue.js 开发。当开发者深入这个高级概念时，他们将解锁新的灵活性和效率，从而提高设计复杂且高性能 Vue.js 应用程序的能力。'
- en: Global Event Bus
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局事件总线
- en: 'The "Advanced Vue.js Concepts" module in the book "Vue.js Essentials: For Responsive
    Web Development" introduces a powerful section known as the "Global Event Bus."
    This section is a deep dive into cross-component communication, enabling developers
    to orchestrate seamless interactions between disparate components. By implementing
    a Global Event Bus, developers can overcome the hierarchical structure of Vue.js
    components, facilitating efficient communication in complex applications.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '书籍《Vue.js Essentials: For Responsive Web Development》中的“高级 Vue.js 概念”模块介绍了一个强大的部分，称为“全局事件总线”。这一部分深入探讨了跨组件通信，使开发者能够协调不同组件之间的无缝交互。通过实现全局事件总线，开发者可以突破
    Vue.js 组件的层级结构，促进复杂应用中的高效通信。'
- en: // Creating a Global Event Bus instance
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: // 创建一个全局事件总线实例
- en: export const EventBus = new Vue();
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: export const EventBus = new Vue();
- en: // Component A
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: // 组件 A
- en: EventBus.$emit('custom-event', data);
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: EventBus.$emit('custom-event', data);
- en: // Component B
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: // 组件 B
- en: EventBus.$on('custom-event', (data) => {
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: EventBus.$on('custom-event', (data) => {
- en: // Handle the data in Component B
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: // 在组件 B 中处理数据
- en: '});'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: The heart of the Global Event Bus lies in the creation of a centralized Vue
    instance named EventBus. This instance acts as a mediator, facilitating communication
    between components. In the code snippets, Component A emits a custom event along
    with data, while Component B listens for this event using $on and responds accordingly.
    This global channel for communication enables components to interact without direct
    parent-child relationships.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 全局事件总线的核心在于创建一个名为 EventBus 的集中式 Vue 实例。这个实例充当中介，促进组件间的通信。在代码片段中，组件 A 触发自定义事件并携带数据，而组件
    B 使用 $on 监听该事件并作出响应。这个全局通信通道使得组件可以在没有直接父子关系的情况下进行交互。
- en: 'Dynamic Component Communication: Breaking Hierarchical Barriers'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 动态组件通信：打破层级障碍
- en: // Parent Component
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: // 父组件
- en: <template>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <template>
- en: <child-component ref="child"></child-component>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <child-component ref="child"></child-component>
- en: </template>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: </template>
- en: <script>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <script>
- en: export default {
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: export default {
- en: 'methods: {'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'methods: {'
- en: communicateWithChild() {
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: communicateWithChild() {
- en: this.$refs.child.$emit('custom-event', data);
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: this.$refs.child.$emit('custom-event', data);
- en: '},'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '},'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '};'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: </script>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: </script>
- en: While Vue.js provides mechanisms for parent-child communication, the Global
    Event Bus extends communication capabilities beyond the parent-child hierarchy.
    In the example above, the parent component communicates with a child component
    using $emit on the child component's reference. This approach is particularly
    useful when direct parent-child relationships become impractical.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Vue.js 提供了父子组件通信的机制，但全局事件总线扩展了通信能力，超越了父子组件的层级结构。在上面的示例中，父组件通过子组件的引用使用 $emit
    与子组件进行通信。这种方式在直接的父子关系变得不实际时尤其有用。
- en: 'Enabling Cross-Component State Management: A Global Perspective'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 启用跨组件状态管理：全局视角
- en: // In a Vuex store module
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: // 在 Vuex store 模块中
- en: import { EventBus } from '../main';
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: import { EventBus } from '../main';
- en: const storeModule = {
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: const storeModule = {
- en: 'mutations: {'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'mutations: {'
- en: updateSharedState(state, payload) {
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: updateSharedState(state, payload) {
- en: state.sharedData = payload;
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: state.sharedData = payload;
- en: EventBus.$emit('shared-state-updated', payload);
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: EventBus.$emit('shared-state-updated', payload);
- en: '},'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '},'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '};'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: Integrating the Global Event Bus with Vuex, Vue's state management library,
    provides a powerful solution for cross-component state management. In the Vuex
    store module, a mutation updates the shared state and emits an event through the
    Global Event Bus. Components interested in this state change can listen for the
    event and react accordingly, ensuring a global perspective on application state.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将全局事件总线与 Vuex（Vue 的状态管理库）集成，提供了一种强大的跨组件状态管理解决方案。在 Vuex 存储模块中，通过突变更新共享状态，并通过全局事件总线触发事件。对该状态变化感兴趣的组件可以监听该事件并做出相应反应，从而确保应用状态的全局视角。
- en: 'Cautions and Considerations: Ensuring Scalability and Maintainability'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项与考虑：确保可扩展性与可维护性
- en: While the Global Event Bus offers flexibility in communication, developers must
    exercise caution to maintain a clear structure in their applications. Overuse
    of the event bus can lead to code that is hard to understand and maintain. As
    applications grow, adopting more structured patterns like Vuex for state management
    might become preferable.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然全局事件总线提供了灵活的通信方式，但开发者必须谨慎使用，以保持应用程序的结构清晰。过度使用事件总线可能导致代码难以理解和维护。随着应用的增长，采用更结构化的模式，如
    Vuex 进行状态管理，可能会成为更好的选择。
- en: Mastering Cross-Component Communication with the Global Event Bus
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 精通跨组件通信与全局事件总线
- en: The "Global Event Bus" section in the "Advanced Vue.js Concepts" module is a
    pivotal guide for developers seeking mastery in cross-component communication.
    By establishing a centralized event bus, developers transcend the limitations
    of hierarchical communication, enabling dynamic interactions between components.
    This advanced concept enhances the scalability and flexibility of Vue.js applications,
    providing a robust solution for managing state and orchestrating communication
    in complex scenarios. As developers delve into the Global Event Bus, they gain
    a versatile tool that empowers them to architect Vue.js applications with unparalleled
    flexibility and maintainability.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 《高级 Vue.js 概念》模块中的“全局事件总线”部分是开发者掌握跨组件通信的重要指南。通过建立一个集中式事件总线，开发者突破了层级通信的限制，实现了组件之间的动态交互。这个高级概念增强了
    Vue.js 应用的可扩展性和灵活性，为在复杂场景中管理状态和协调通信提供了强有力的解决方案。当开发者深入了解全局事件总线时，他们将获得一个多功能的工具，使他们能够以无与伦比的灵活性和可维护性构建
    Vue.js 应用。
- en: Custom Filters in Vue.js
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vue.js 中的自定义过滤器
- en: 'The "Advanced Vue.js Concepts" module in the book "Vue.js Essentials: For Responsive
    Web Development" introduces a transformative section titled "Custom Filters in
    Vue.js." This section dives deep into the capabilities of custom filters, empowering
    developers to refine and format data in a declarative and reusable manner. Custom
    filters provide an elegant solution for transforming data within Vue.js templates,
    enhancing readability and maintainability.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '《Vue.js Essentials: For Responsive Web Development》书中的“高级 Vue.js 概念”模块介绍了一个变革性的部分，标题为“Vue.js
    中的自定义过滤器”。该部分深入探讨了自定义过滤器的功能，赋予开发者以声明性和可重用的方式精炼和格式化数据的能力。自定义过滤器为在 Vue.js 模板中转换数据提供了一种优雅的解决方案，增强了可读性和可维护性。'
- en: // Registering a global custom filter
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: // 注册全局自定义过滤器
- en: Vue.filter('uppercase', function (value) {
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.filter('uppercase', function (value) {
- en: if (!value) return '';
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: if (!value) return '';
- en: return value.toString().toUpperCase();
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: return value.toString().toUpperCase();
- en: '});'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: // Using the custom filter in a template
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: // 在模板中使用自定义过滤器
- en: <template>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <template>
- en: <div>{{ message | uppercase }}</div>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <div>{{ message | uppercase }}</div>
- en: </template>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: </template>
- en: The cornerstone of custom filters is the ability to register them globally within
    a Vue.js application. In the provided code snippet, a custom filter named 'uppercase'
    is registered using Vue.filter. This filter transforms the input value to uppercase.
    Once registered, developers can seamlessly apply the filter within any template
    using the pipe symbol (|), enhancing the readability of data transformations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义过滤器的核心是能够在 Vue.js 应用程序中全局注册它们。在提供的代码片段中，一个名为 'uppercase' 的自定义过滤器是通过 Vue.filter
    注册的。该过滤器将输入值转换为大写字母。注册后，开发者可以在任何模板中使用管道符号 (|) 无缝地应用此过滤器，从而提升数据转换的可读性。
- en: 'Reusable Data Transformations: Enhancing Code Clarity'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可重用的数据转换：提升代码清晰度
- en: // Registering a local custom filter in a component
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: // 在组件中注册本地自定义过滤器
- en: 'filters: {'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'filters: {'
- en: 'capitalize: function (value) {'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'capitalize: function (value) {'
- en: if (!value) return '';
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: if (!value) return '';
- en: return value.toString().charAt(0).toUpperCase() + value.slice(1);
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: return value.toString().charAt(0).toUpperCase() + value.slice(1);
- en: '},'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '}'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // Using the local custom filter in the component's template
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: // 在组件模板中使用本地自定义过滤器
- en: <template>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <template>
- en: <div>{{ title | capitalize }}</div>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <div>{{ title | capitalize }}</div>
- en: </template>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: </template>
- en: Custom filters need not be global; developers can also define them locally within
    a component. This offers the advantage of encapsulating data transformations specific
    to a component, fostering code clarity and encapsulation. In this example, the
    'capitalize' filter transforms the first character of a string to uppercase, enhancing
    the presentation of data within the component.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义过滤器不必是全局的；开发者也可以在组件内部局部定义它们。这有助于封装特定于组件的数据转换，提升代码清晰度和封装性。在此示例中，'capitalize'
    过滤器将字符串的第一个字符转换为大写，从而改善组件内数据的展示。
- en: 'Chaining and Composing Filters: Building Complex Transformations'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 链式操作与组合过滤器：构建复杂的转换
- en: // Registering multiple filters
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: // 注册多个过滤器
- en: Vue.filter('capitalize', function (value) {
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.filter('capitalize', function (value) {
- en: if (!value) return '';
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: if (!value) return '';
- en: return value.toString().charAt(0).toUpperCase() + value.slice(1);
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: return value.toString().charAt(0).toUpperCase() + value.slice(1);
- en: '});'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: Vue.filter('truncate', function (value, length) {
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.filter('truncate', function (value, length) {
- en: if (!value) return '';
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: if (!value) return '';
- en: return value.slice(0, length);
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: return value.slice(0, length);
- en: '});'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: // Chaining filters in a template
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: // 在模板中链式调用过滤器
- en: <template>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <template>
- en: <div>{{ description | capitalize | truncate(50) }}</div>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <div>{{ description | capitalize | truncate(50) }}</div>
- en: </template>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: </template>
- en: One of the strengths of custom filters lies in their composability. Developers
    can register multiple filters and seamlessly chain them within templates. In the
    example above, the 'capitalize' filter is followed by the 'truncate' filter, creating
    a chain of transformations for the 'description' data. This approach facilitates
    the creation of complex and reusable data formatting pipelines.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义过滤器的一个优势在于其可组合性。开发者可以注册多个过滤器，并在模板中无缝地将它们串联起来。在上面的示例中，'capitalize' 过滤器后面跟着
    'truncate' 过滤器，形成了一个针对 'description' 数据的转换链。这种方法有助于创建复杂且可重用的数据格式化管道。
- en: 'Cautions and Considerations: Striking a Balance in Complexity'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项与建议：在复杂度中找到平衡
- en: While custom filters provide a powerful mechanism for data transformation, developers
    should exercise caution to strike a balance in complexity. Overuse of filters
    for intricate transformations might lead to template code that is hard to understand.
    In such cases, moving complex logic to computed properties or methods might be
    a more maintainable approach.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自定义过滤器提供了强大的数据转换机制，但开发者应谨慎使用，以确保在复杂度上保持平衡。过度使用过滤器进行复杂转换可能导致模板代码难以理解。在这种情况下，将复杂逻辑移至计算属性或方法中，可能是一种更易维护的方式。
- en: Elevating Data Presentation with Custom Filters in Vue.js
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 提升数据呈现：Vue.js中的自定义过滤器
- en: The "Custom Filters in Vue.js" section within the "Advanced Vue.js Concepts"
    module serves as a comprehensive guide for developers seeking to elevate their
    data presentation capabilities. By harnessing the power of custom filters, developers
    can encapsulate and reuse data transformations, enhancing code readability and
    maintainability. Whether applied globally or locally, custom filters provide a
    declarative and elegant solution for formatting data within Vue.js templates.
    As developers embrace this advanced concept, they unlock a toolset that streamlines
    the presentation layer of their applications, offering a more expressive and efficient
    approach to data transformation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '"Advanced Vue.js Concepts" 模块中的 "Vue.js中的自定义过滤器" 部分，为开发者提供了一个全面的指南，帮助他们提升数据呈现的能力。通过利用自定义过滤器的强大功能，开发者可以封装和重用数据转换，从而提高代码的可读性和可维护性。无论是全局应用还是局部应用，自定义过滤器都为在
    Vue.js 模板中格式化数据提供了一种声明式且优雅的解决方案。随着开发者深入理解这一高级概念，他们将解锁一套简化应用展示层的工具，从而为数据转换提供更具表现力和高效的方式。'
