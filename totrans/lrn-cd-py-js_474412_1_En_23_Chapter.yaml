- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024J. L. ZuckarelliLearn coding with Python and JavaScript
    [https://doi.org/10.1007/978-3-658-42912-6_23](https://doi.org/10.1007/978-3-658-42912-6_23)
  prefs: []
  type: TYPE_NORMAL
- en: '23. Functions & Methods: How Do I Work with Program Functions to Work with
    Data and Trigger Actions?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1)München, GermanyOverview
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve covered how to get Python programs running, how to work with variables/objects,
    and how to input and output data. In this chapter, we’ll focus on what happens
    in between, namely how to process data. If input and output of data are the bun
    halves of our “program burger”, then we are now mainly concerned with the meat
    in the middle (although there are, of course, also many functions for input and
    output).
  prefs: []
  type: TYPE_NORMAL
- en: The main way to manipulate data in programs is to call functions that modify
    the data or trigger other actions. Functions are so important because we can use
    them to perform certain tasks, even without knowing exactly how that actually
    works in detail. We simply call the function, and the function does what it is
    supposed to do, without us having to program this functionality ourselves and
    without us having to understand the function's inner workings. Of course, we can
    also define functions ourselves. Functions allow us to encapsulate a particular
    functionality and make it accessible from the outside. With functions, we ultimately
    offload pieces of code from the main program code and make them callable from
    anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to program functions in Python and how to call functions (your own or those
    provided by others)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how to combine functions (usually as methods of classes) into modules and packages
    and import them into your program when we want to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how to work with the *Python Package Index* (*PyPI*) to include functionality
    provided by other developers in your program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 23.1 Working with Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 23.1.1 Definition of Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember our calculator application that we developed in the last chapter using
    the **tkinter** package (► Sect. [22.​2.​6](474412_1_En_22_Chapter.xhtml#Sec20))?
    There we defined some functions of our own, for example this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def** delete_press():display[''text''] = '''''
  prefs: []
  type: TYPE_NORMAL
- en: This is a function that we don’t call ourselves, but an event handler function
    that is automatically called when the user clicks the “Clear” button to clear
    the current display. With this simple example, however, you can already see what
    a function is all about. Its definition begins with the statement **def**, followed
    by the name of the function. The name of the function is followed by round brackets
    that hold the function arguments. However, even if the function has no arguments
    at all (as in this case), the round brackets must be written in the definition
    (and later when the function is called).
  prefs: []
  type: TYPE_NORMAL
- en: 'The **def** statement, which is ultimately the *function head* of our function,
    is terminated with a colon, indicating that what now follows is the program code
    that is executed when the function is called, in short: What the function *does*.
    The function body is a code block that is identified, as always in Python, by
    the fact that it is indented. In this example, the code block consists of only
    one line of code. Incidentally, the code block must be at least one line. The
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def** my_function():print(''This is the main program.'')leads to an error
    message:IndentationError: expected an indented block'
  prefs: []
  type: TYPE_NORMAL
- en: Apparently, an indented code block is expected after the **def** statement.
    Sometimes you already know that you need a function, you want to call it from
    the main program, but you don’t know exactly how the function should work. What
    to do? Writing an “empty” function will result in the above error message, even
    if you write a comment as the only line in the code block; that is because the
    comment is not considered an executable statement that Python will accept as a
    code block. To solve this problem, Python has a special statement, namely **pass**.
    **pass** does absolutely nothing, but it is an executable statement. So, if you
    write **pass** as the only instruction in your function code, it will make your
    function syntactically correct without the function doing anything. Note that
    **pass** (just like **def**) is a Python *statement*, not a function, and is therefore
    not called with (empty, round) parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 23.1.2 Function Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us return to an example from the first part of the book (from ► Sect. [12.​2.​2](474412_1_En_12_Chapter.xhtml#Sec6)),
    namely the temperature conversion from Kelvin to degrees Celsius. This conversion
    can be written as a function. Unlike the fnction delete_press() from above, however,
    our function needs an argument, namely the temperature to be converted:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def** kelvin_to_celsius(kelvin):print(kelvin, ''Kelvin are'', round(kelvin
    - 273.15, 2),''degrees Celsius.'')'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could now call this function, for example with:'
  prefs: []
  type: TYPE_NORMAL
- en: kelvin_to_celsius(300)
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we received as output:'
  prefs: []
  type: TYPE_NORMAL
- en: 300 Kelvin are 26.85 degrees Celsius.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, functions can have more than one argument. Consider the following
    example, in which we output a welcome message to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def** welcome(name, greeting, message):print(greeting, '', '', name, ''!
    '', message, sep = '''')'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could now call the function as follows, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: welcome('Sophie', 'Welcome', 'Glad to have you with us.')
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this call looks like this in the (run) console:'
  prefs: []
  type: TYPE_NORMAL
- en: Welcome, Sophie! Glad to have you with us.Positional and Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: 'Which of the strings specified in the function call is assigned to the argument
    **name**, which to the argument **greeting**, and which to the argument **message**,
    is decided by the order in which they are passed, i.e., their position; these
    arguments are, as you already know, also referred to as *positional arguments*.
    However, we can specify the name of the argument when calling the function. This
    allows a call like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: welcome('Sophie', message = 'Glad to have you with us.',greeting = 'Welcome')
  prefs: []
  type: TYPE_NORMAL
- en: Here we pass the first argument by its position, but the following two by their
    names. Note that we pass the values for the **message** and **greet** arguments
    in a different order than the argument order from the function definition above.
    However, because we explicitly address the arguments by their names, Python can
    still correctly map the passed values to the function arguments. So, the advantage
    of these named arguments (also called *keyword arguments*) is that the order in
    which we specify the arguments doesn’t matter, which is especially nice if the
    called function has a whole bunch of arguments. It would be tedious to have to
    look up the exact order of the arguments first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful, however, if you mix position and keyword arguments, as we did in
    the example above: Because then the position arguments must always be at the beginning.
    So, you can’t pass the first argument as a keyword argument and the second as
    a position argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, we have already used a keyword argument in the definition of our
    function, namely when calling **print()**: Here we used the **sep** argument to
    specify that the individual strings should not be output separated by a space,
    which would otherwise have caused annoying white space in inappropriate places,
    for example before the exclamation mark that concludes the greeting.'
  prefs: []
  type: TYPE_NORMAL
- en: Optional Arguments
  prefs: []
  type: TYPE_NORMAL
- en: 'The **sep** argument of the **print()** function just mentioned is an example
    of an *optional* argument that we *can* specify, but *don’t have to* (in the Kelvin-to-Celsius
    conversion, for example, we called **print()** *without* the **sep** argument).
    **sep** has a default value, namely **'' ''** (i.e., a blank space), which is
    used whenever the **print()** function is called without explicitly specifying
    a value for **sep**. You can see this clearly when you call the help for **print()**
    in the Python console. There it says:'
  prefs: []
  type: TYPE_NORMAL
- en: '**print(value, ..., sep='' '', end=''\n'', file=sys.stdout, flush=False)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The optional argument **sep** is therefore “preallocated” with a default value,
    while the argument **value** is not an optional argument. If we were to refrain
    from specifying it in the function call, we would get an error message. Now, if
    we wanted to modify our **welcome()** function so that you don’t have to specify
    a greeting, all we have to do is add the default value of the **greeting** argument
    in the function header:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def** welcome(name, message, greeting = ''Welcome''):print(greeting, '',
    '', name, ''! '', message, sep = '''')'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we could also call our function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: welcome('Sophie', 'Nice to have you.')
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have swapped the order of the **greeting** and **message** arguments
    in the function header. The reason is that in Python, arguments with default values
    must come last in the function definition. If multiple optional arguments follow,
    they must be passed as keyword arguments when the function is called, i.e., by
    specifying their names, otherwise Python will not know which of the passed values
    to assign to which optional arguments—after all, any of the optional arguments
    may or may not be provided with a value.
  prefs: []
  type: TYPE_NORMAL
- en: Indefinite Number of Arguments
  prefs: []
  type: TYPE_NORMAL
- en: For some functions, you don’t know a priori with which arguments they will eventually
    be called. A good example of this is the **print()** function. It can take a whole
    set of variables or values and print them all on the screen. Each time **print()**
    is called, the number of arguments may be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we wanted to extend our **welcome()** function so that it welcomes
    not only one, but several people. We want the number of people to be variable.
    We achieve this by using a *tuple* argument that is marked with an asterisk in
    front of the identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def** welcome(*name, message, greeting = ''Welcome''):print(greeting,'',
    '', end = '''', sep = '''')print(*name, end = '''', sep ='', '')print(''!'', message)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now call this function with several names, for example like this:'
  prefs: []
  type: TYPE_NORMAL
- en: welcome('Sophie', 'Marc', 'Celine', message = 'Glad you're here.')
  prefs: []
  type: TYPE_NORMAL
- en: 'The output then reads:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Welcome, Sophie, Marc, Celine! Glad you''re here.Two things are noteworthy
    about our feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compared to the previous version of **welcome()** we work here with several
    print statements. This is necessary to achieve the correct positioning of commas
    and spaces. By setting the (optional) argument **end** of the **print()** function
    to an empty string (default value is **'\n'**, i.e. newline) we ensure that we
    always continue writing on the same line despite several successive **print()**
    calls.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The argument **name** now collects the “loose” arguments, i.e., the names of
    the persons we specify in the function call, and packs them into a tuple with
    the identifier **name**. We can then work with this tuple in the function body.
    In our example, we “unpack” the tuple (using the asterisk again) and output its
    elements using **print()**. If we had omitted the asterisk in the call to **print()**,
    we would have simply output the tuple en bloc, which is not as visually appealing
    (try it out!).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An alternative to this approach would have been to pass only one argument when
    calling for the names of the people to be greeted, namely a list, which we would
    then have had to process accordingly in our function. With such an adapted function,
    the function call would then look like this:welcome(['Sophie', 'Marc', 'Celine'],
    message = 'Glad you're here.')
  prefs: []
  type: TYPE_NORMAL
- en: Note that in this case the three names represent only *one* argument, namely
    our list of names, whereas in the previous call to the function we passed *three
    different* name arguments, namely **'Sophie'**, **'Marc'** and **'Celine'**, which
    Python just conveniently collects for us and puts into a tuple that we can then
    work with. This way of calling the function is a bit more ‘natural’ and intuitive,
    and therefore preferable to the list solution. If a function uses such an undefined
    tuple argument, all *subsequent* arguments must be called as keyword arguments,
    i.e., with their identifier; this is obvious, because how else is Python supposed
    to distinguish whether a passed value still belongs to the tuple argument or already
    belongs to the next argument.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, every now and then you will see functions with arguments prefixed
    with a double asterisk (******); the **tkinter** function **config()**, which
    we can use to set the options of **tkinter** widgets (see ► Sect. [22.​2.​3.​1](474412_1_En_22_Chapter.xhtml#Sec6))
    is one such function (check the help!). Such arguments are also collection arguments,
    but for keyword arguments. In this way, different arguments passed as keyword
    arguments can be collected and put into a dictionary whose keys are the argument
    names and whose values are the values passed for those arguments. Unlike the collection
    arguments for non-named arguments (i.e., the “*** arguments**”), a collection
    argument for keyword arguments must *always* be placed *at the end of* the argument
    list in the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data Types of Function Arguments: Type Hint Annotations (Function Annotations)'
  prefs: []
  type: TYPE_NORMAL
- en: You have probably already noticed that the arguments of functions are *not typed*,
    that is, the data types of the arguments are not specified. Accordingly, Python
    cannot check whether a function is called with arguments of the correct type.
    When we wrote our **welcome()** function, we naturally assumed that the arguments
    **name**, **greeting**, and **message** are all **strings**, i.e. arguments of
    type **str**. But this does not have to be the case at all! A user of our function
    who is not aware of the exact meaning of the individual arguments could, for example,
    specify a boolean value as the argument **greeting**, expecting it to be an option
    that determines whether a greeting message is displayed or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'To counter this problem, Python has a concept called *type hints* (also known
    as *function annotations*). They are built into the function definition and specify
    the expected type of the argument. For our original **welcome()** function, this
    might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def** welcome(name: str, message: str,greeting: str = ''Welcome''):print(greeting,
    '', '', name, ''! '', message, sep = '''')'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, each argument identifier is followed by a colon, followed by
    the type expected for that argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is by no means the case that Python automatically checks whether the
    user really adheres to the type default. The default is only indicative. Nevertheless,
    it is useful for two reasons: First, the type hints are also included in the automatically
    generated help for the function and are visible there for every user of the function.
    Second, there are development tools that evaluate these type hints. One of these
    tools is *PyCharm*. For example, if you try to call our **welcome()** function
    with a boolean value for the **greeting** argument:'
  prefs: []
  type: TYPE_NORMAL
- en: welcome('Sophie', 'Glad you could join us.', True)
  prefs: []
  type: TYPE_NORMAL
- en: '*PyCharm* highlights the boolean value in the code editor window. If you hover
    over it, a small popup window will inform you of the error with the message **Expected
    type ''str'', got ''bool'' instead.**'
  prefs: []
  type: TYPE_NORMAL
- en: 23.1.3 Return Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our function **kelvin_to_celsius()** from the last section was passed a Kelvin
    temperature value as an argument, converted it to degrees Celsius and output the
    result on the screen. Of course, we could also forgo the output and simply *return*
    the calculated Celsius value instead. In this case, it is a function with a *return
    value*.
  prefs: []
  type: TYPE_NORMAL
- en: The return is accomplished with the **return** statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**def** kelvin_to_celsius(kelvin: float):return kelvin - 273.15'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now call this function from our main program, store its result in a
    variable first and then output it to the (run) console:'
  prefs: []
  type: TYPE_NORMAL
- en: temp = kelvin_to_celsius(290)print(temp)
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added a type hint to the argument **kelvin** in the function definition.
    We can do the same with the return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def** kelvin_to_celsius(kelvin: float) -> float:return kelvin - 273.15'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, the type of the return value is written after the actual head of
    the function with an arrow **->**; the colon again introduces the following code
    block, i.e., the function body (note: we had used the colon for type hints in
    the function arguments).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you will want to return more than one return value. In that case,
    it’s a good idea to wrap the different elements of the return value in a *tuple*.
    In the following, our **kelvin_to_celsius()** function is modified to return both
    the calculated Celsius and the original Kelvin value, as two elements of a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def** kelvin_to_celsius(kelvin: float) -> float:return (kelvin, kelvin -
    273.15)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The brackets around the two values can also be omitted and are only written
    here to make clear that a tuple is created. In fact, the **return** statement
    automatically creates a tuple if it is followed by several objects separated by
    commas. The elements of the tuple can be easily accessed after the function call,
    either by indexing or by “unpacking” the tuple directly in the assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: temp = kelvin_to_celsius(290)print(temp[1])cel, kel = kelvin_to_celsius(290)print(kel)
  prefs: []
  type: TYPE_NORMAL
- en: The **return** statement automatically exits the function. Therefore, **return**
    should always be the last instruction in a function. All code after it would not
    be executed anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 23.1.4 Local and Global Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: greet = 'Good morning'**def** welcome(name, message, greeting):greet = greeting
    + ', ' + name + '! ' + messageprint(greet)welcome('Sophie', 'Nice to have you
    with us!', 'Hello')print(greet)
  prefs: []
  type: TYPE_NORMAL
- en: Think about what this code will output in the (run) console. Do you have an
    idea? Then try it out in Python. Was your expectation correct?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start the program, the following is output:'
  prefs: []
  type: TYPE_NORMAL
- en: Hello, Sophie! Nice to have you with us!Good morning
  prefs: []
  type: TYPE_NORMAL
- en: The interesting question now is why the variable **greet**, when we **print()**
    it, still has the value **'Good morning'**, which we assigned to it at the beginning
    of the program. Before we print its value, we call the function **welcome()**,
    which changes the value of **greet**, in our example to **"Hello, Sophie! Nice
    to have you with us!"**. Shouldn’t **greet** contain this value at the end of
    the program?
  prefs: []
  type: TYPE_NORMAL
- en: The solution to the puzzle is that the variable **greet** in our main program
    and the variable **greet** in the **welcome()** function are ultimately *two different*
    variables. The variable **greet**, which we create in the function body of **welcome()**,
    only exists within this code block, its *scope* is limited to the function **welcome()**.
    However, whenever we access the variable **greet** within the function body of
    **welcome()**, we are working with the variable created in this code block, not
    the variable we defined in the main program. So you could say that the variable
    **greet** in our **welcome()** function “hides” the variable of the same name
    in the main program. We cannot get to the variable of the same name in the main
    program from within the function; the variable defined in the function is “in
    the way”, so to speak.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a way to access the variable of the main program. Consider
    the following, slightly adapted code:'
  prefs: []
  type: TYPE_NORMAL
- en: greet = 'Good morning'**def** welcome(name, message, greeting):global greetgreet
    = greeting + ', ' + name + '! ' + messageprint(greeting)welcome('Sophie', 'Nice
    to have you with us!', 'Hello')print(greet)
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have only added the **global greeting** statement to the
    **welcome()** function. The effect of this is that Python does not create a new
    variable that is only valid within the **welcome()** function—this scope is also
    referred to as the function’s *namespace*. Instead, the global namespace, i.e.,
    the namespace of our main program, is searched for a variable with this name;
    if one is found, it is used, otherwise an extra variable is created in the smaller
    namespace of the function, which ceases to exist as soon as the function is exited
    (try it out and change all occurrences of **greet** to a different identifier
    within the function).
  prefs: []
  type: TYPE_NORMAL
- en: 'You might now argue that the situation in our example is somewhat artificial
    and that its problems are ultimately only due to the fact that variables with
    the same name are used in the definition of the function and in the main program.
    Imagine, however, that you wanted to change a *global* status variable from within
    the function, i.e., a variable defined in the namespace of the main program, for
    example, a variable that indicates whether the document currently being processed
    has already been saved or not. This status variable should, of course, exist independently
    of the function and still be available when your function has long since been
    exited and all *local* variables, i.e., those defined in the function itself (more
    precisely: in its namespace), have long since been deleted again. If you access
    the presumable global status variable without a global statement in your function,
    a local variable of the same name is created in the namespace of the function,
    which disappears when the function has been completely executed. The global status
    variable remains unaffected. Only by using the **global** statement do you make
    it clear to Python that you are working with the global variable and do not want
    to create a new local variable inside your function. Your function then changes
    its environment (in the form of the status variable). Such *side effects* are
    generally avoided to make the function more independent of the code that calls
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 23.1 [20 min]
  prefs: []
  type: TYPE_NORMAL
- en: Write a function called **create_website()** that takes as arguments a title,
    a heading, and a text (each as strings), creates an HTML document (i.e., ultimately
    a simple web page) from them, and saves it in a file called **website.html**.
    Document your function as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'An HTML document has the following basic structure (the indentations are only
    for better clarification of the structure; they do not have to be written into
    the file):'
  prefs: []
  type: TYPE_NORMAL
- en: '**<html>****<head>****<title>**Here is the title of the website**</title>****</head>****<body>****<h1>**Here
    is a headline**</h1>****<p>**Here is a text**</p>****</body>****</html>**'
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the HTML document is a collection of elements such as **h1** (for
    header 1) or **p** for paragraph. The beginning and end of the elements are marked
    by tags, whereby the end tags correspond to the beginning tags, supplemented by
    a leading slash. Between the start and end tags is the content, whereby HTML elements
    can also contain other HTML elements (for example, the enclosing **html** element
    contains the elements **head** and **body**, which in turn can contain other elements).
  prefs: []
  type: TYPE_NORMAL
- en: The function **create_website()** is supposed to create such a HTML document,
    “build in” the information passed as arguments and save the whole thing as **website.html**.
    After that you can view this file with your web browser!
  prefs: []
  type: TYPE_NORMAL
- en: 23.2 [10 min]
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two functions have errors. Rewrite the functions so that they
    are syntactically correct and serve their purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '(a)**from** random import ***def** dice() -> int:*'''''' Generates a random
    number analogous to a dice roll ''''''*dice_result = randint(1,6)(b)**def** create_phonenumber(country:
    str, areacode: str) : -> str*''''''Creates a formatted phone number based on its
    components; country is the country''s ISO code''''''*countries_dict = {''US'':
    ''1'', ''DE'': ''49'', ''FR'': ''33'',''AT'': ''43'', ''NL'': ''31'', ''BE'':''32'',''PL'':
    ''48'', ''DK'': ''45'', ''CZ'': ''42''}return ''+'' + countries_dict[country]
    + areacode + number23.3 [5 min]'
  prefs: []
  type: TYPE_NORMAL
- en: Develop a function **deal_with_myself()** that deals only with itself, taking
    a variable number of named (i.e., keyword) arguments and printing first their
    names and then their values to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '23.4 [5 min]What output does the following program produce, and why?**from**
    datetime **import** *total_sales = 0.00last_sale = 0.00**def** new_sale(amount,
    article):**global** total_saleslast_sale = amounttotal_sales = total_sales + amountcurrenttime
    = datetime.now()print(currenttime.strftime(''%Y-%m-%d %H:%M:%S'') + '' -- New
    sale: '' + str(round(amount, 2)) + '' dollars with article number '' +article
    + ''.'')new_sale(10.99, ''US07011981'')new_sale(24.99, ''CA25101878'')print(''Total
    sales: '' + str(total_sales))print(''Last sale: '' + str(last_sale))'
  prefs: []
  type: TYPE_NORMAL
- en: 23.2 Using Functions as Class Methods of Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many places we have already worked with functions that are part of classes
    as a matter of course. As you know, such functions are also called *methods* (if
    you are no longer familiar with this, it is best to go back and review ► Sect.
    [11.​7.​4](474412_1_En_11_Chapter.xhtml#Sec14)).
  prefs: []
  type: TYPE_NORMAL
- en: For example, when we set the arrangement of the controls of our **tkinter**
    user interface with **grid()**, we had call a method like **mybutton.grid(row
    = 1, column = 4, sticky = 'news')** (see the calculator example in ► Sect. [22.​2.​6](474412_1_En_22_Chapter.xhtml#Sec20)).
    In this case, we call the method of the **mybutton** object, which is an instance
    of the **tkinter** class **Button**. To let Python know exactly which object’s
    methods we want to call, we attach the function call to the identifier of the
    object in question using the dot operator. So in general, method calls have the
    form ***object*****.*****method*****(…)**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since methods are nothing more than normal functions that we can use to work
    with the object they belong to, we don’t really need to discuss them separately
    here. However, we should take a brief look at three special topics in connection
    with methods, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: How methods are *defined* as part of classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What special role *constructor methods* play in this
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What useful *standard methods* classes in Python have that we can adapt for
    our purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining Methods as Part of ClassesIn ► Sect. [21.​7](474412_1_En_21_Chapter.xhtml#Sec23),
    we had defined a class **Product** as follows.**class** Product:name = ''description
    = ''item_number = ''manufacturer = ''price = 0.0
  prefs: []
  type: TYPE_NORMAL
- en: 'This class consists solely of properties/attributes. Suppose we now wanted
    to give our class a special **show()** method that displays the properties of
    a product in a nice way. To do this, we would simply have to extend the code block
    of the class with the definition of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**class** Product:name = ''''description = ''''item_number = ''''manufacturer
    = ''''price = 0.0**def** show(self):print(''Product:'', self.name,''\nDescription:'',
    self.description,''\nItemnumber:'', self.item_number,''\nManufacturer:'', self.manufacturer,''\nPrice:'',
    self.price, ''\n'')'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the function definition header is indented the same way as
    the attributes. The **show()** function is thus part of the class definition of
    **Product**. For all objects of type **Product**, the method can be called from
    now on. For example, we could define the following product:'
  prefs: []
  type: TYPE_NORMAL
- en: p = Product()p.price = 10.99p.name = 'Garden shovel'.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the product properties, we can then conveniently call our self-defined
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: p.show()
  prefs: []
  type: TYPE_NORMAL
- en: 'This results in a cleanly structured output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Product: Garden shovelDescription:Article number:Manufacturer:Price: 10.99'
  prefs: []
  type: TYPE_NORMAL
- en: The properties to which we have not explicitly assigned values (such as **description**)
    are displayed with their default values (i.e. “empty” string).
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed the **self** argument in the definition of our **show()**
    method. **self** always represents the object for which the method is called.
    This way, we can conveniently access the properties (and possibly other methods)
    of the current class instance for which our method is called. This argument does
    not necessarily have to be called **self** (it just has to be first in the argument
    list), but it is good practice to use the easily understandable identifier **self**.
  prefs: []
  type: TYPE_NORMAL
- en: Methods, like properties, are also inherited. In ► Sect. [21.​7.​2](474412_1_En_21_Chapter.xhtml#Sec25)
    we derived a class **Book** from the class **Product**, i.e., a special type of
    product. This class inherited all the properties of the parent class, and also
    had additional properties that are only relevant for books, such as the number
    of pages. Inheritance of methods works in a similar way.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the possibility to *overload* methods. This means that the more
    special class (in our case **Book**) has its own **show()** method, which perhaps
    also displays the special properties of books like author and number of pages.
    Thus, both the parent class and the class derived from it now each have a method
    **show()**.
  prefs: []
  type: TYPE_NORMAL
- en: When we call the **show()** method for an object of type **Book**, Python first
    looks to see if that *class itself* has a corresponding method; if so, it executes
    it. However, if **Book** itself does not have a **show()** method, it checks whether
    the next higher class in the class hierarchy, i.e. the parent class **Product**,
    has such a method. In this way, it is possible to provide classes at different
    levels of the class hierarchy with methods of the same name, but with behavior
    specific to that class. The user can simply call the same method every time and
    does not have to deal with the specifics of the different classes. A great strength
    of object-oriented programming!
  prefs: []
  type: TYPE_NORMAL
- en: The Special Role of the Constructor Method
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, we had created an instance of the **Product** class using
    its default constructor **Product()**. This simply returns a new object of that
    class. However, we can alternatively define our *own* constructor, perhaps taking
    some arguments, such as the name of the product and its price as the two most
    important properties. The constructor would then assign the values passed as arguments
    to the corresponding attributes and return the object defined in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create our own constructor by adapting the default **__init__()** method
    (two underscores each!) So, we would add the following method definition to our
    class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def** __init__(self, name, price):self.name = nameself.price = price'
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor function takes **self** as the first argument, in this case
    the object that is created by it. We have defined the further arguments freely.
    With this, we could now also create the previously used product with the name
    **"garden shovel"** at a price of **10.99** as follows (**self** does not have
    to be specified in the call, because, fortunately, Python takes care of that itself):'
  prefs: []
  type: TYPE_NORMAL
- en: p = Product('garden shovel', 10.99)
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are not calling the **__init__()** constructor function by its
    name at all, but the constructor of the class, whose identifier is identical to
    that of the class. In the background, however, Python then calls the **__init__()**
    method, either the default version, or, if we have overloaded it, our own variant.
    Normally, you won’t call **__init__()** yourself unless you want to call the constructor
    of the parent class from within the constructor of a derived class.
  prefs: []
  type: TYPE_NORMAL
- en: Two Useful Standard Methods of Classes
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create an object of our class **Product** in the Python console (you
    have to execute the definition of the class in the console first!) and then enter
    the name of the object, for example **p**, you get a rather unattractive output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>** p**<__main__.product at 0x1ff91106048>**'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this can be changed, and we can do so by overloading the default
    **__repr__()** method. This method is called whenever the user enters the identifier
    of an object in the console. It returns the string to be displayed in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could overload the method by adding a corresponding method definition to
    our **Product** class definition, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def** __repr__(self):return ''Product: '' + self.name + ''\nPrice: '' +str(self.price)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now enter the identifier of our object into the console, we get a nicer
    output (note: after adjusting the class definition, you need to create a *new*
    object of this class **Product** so that it has the new method **__repr()__**):'
  prefs: []
  type: TYPE_NORMAL
- en: '**>** pProduct: Garden shovelPrice: 10.99'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can determine what should happen when the user calls the **print()**
    function and tries to display our object. **print()** automatically calls the
    **__str__()** method in the background and outputs its return value. Thus, in
    the definition of our **Product** class, we could overload the **__str__()** method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def** __str__(self):return "Product ''" + self.name + "'' ($" + str(self.price)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can call the **print()** method with our object **p** as an argument
    and get a prettier representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>** print(p)Product "Garden shovel" ($10.99)'
  prefs: []
  type: TYPE_NORMAL
- en: 23.3 Working with Modules and Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 23.3.1 Modularizing Program Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python allows you to offload code to other files for better reuse. For example,
    you could combine functions or entire classes that you have developed and want
    to use in different programs into one Python file and then access them from other
    programs. Such files, which hold outsourced program code, are called *modules*.
    A module is therefore nothing more than program code that has been combined into
    its own Python file for reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Several modules with related content can be combined into a *package*. While
    a module is technically nothing more than a Python (**.py**) *file*, a package
    is a *directory* containing *several* modules, i.e., several **.py** files. For
    Python to know that this directory should be a package, there must also be a file
    named **__init__.py** (double underscores!) in the directory. This file may be
    empty, it just tells Python that this directory should be considered a package.
    Of course, **__init__.py** may also contain code itself. A good example of this
    is the package **tkinter**, of which we have already made extensive use. ◘ Figure
    [23.1](#Fig1) shows the directory structure of this package.![](../images/474412_1_En_23_Chapter/474412_1_En_23_Fig1_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a Python directory. It lists the names of Python files along
    with their modification date, type, and size. The files include font dot p y,
    tix dot p y, and d n d dot p y.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 23.1
  prefs: []
  type: TYPE_NORMAL
- en: Directory structure of the Python module **tkinter**
  prefs: []
  type: TYPE_NORMAL
- en: Here you can also see that the file **__init__.py** is pretty large, so it is
    by no means just an empty shell but contains quite a lot of code.
  prefs: []
  type: TYPE_NORMAL
- en: 23.3.2 Importing Elements from Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After we have seen that modules and packages allow us to extract program code
    from a program, the question naturally arises as to exactly how we can access
    the extracted program code, i.e., the classes and functions of module. After all,
    their program code is no longer in our main program file, so it has to be made
    “available” somehow. This making available is called *importing* and is something
    we have already done several times without discussing it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Import Selected Classes
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, import statements look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**from** tkinter **import** Tk, Button, Label**from** tkinter.font **import**
    Font'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that these follow the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**from** *modulname_or_packagename* **import** *classlist*'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the first statement imports the classes **Tk**, **Button**, and
    **Label** from the **tkinter** module. The second statement imports the class
    **Font** from the module **font**, which belongs to the package **tkinter** (therefore
    **tkinter.font**).
  prefs: []
  type: TYPE_NORMAL
- en: If you take another look at the directory structure of the **tkinter** package
    (◘ Fig. [23.1](#Fig1)), you will see that there is indeed a file **font.py**,
    the module **font**, from which we import the class **Font** with the second statement.
    On your hard disk in the Python installation, find the path **\Lib\tkinter**,
    and open the file **font.py**. In it you will find, among other things, a definition
    of the class **Font** that we import.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what about the first import statement? Here we import three classes, apparently
    directly from the package **tkinter**. But which file contains these three classes?
    You have probably already guessed: These classes are in the **__init__.py** file,
    which you can easily see for yourself by opening this file. After we have imported
    the classes with an **import** statement, we can use them in our program, without
    further ado, simply by using their identifier, for example by calling the constructor
    method of the **Tk** class: **win = Tk()**.'
  prefs: []
  type: TYPE_NORMAL
- en: Import the Entire Contents of a Module
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of explicitly specifying the list of classes we want to import, we
    could have used a *wildcard* and just imported *all* classes that way:'
  prefs: []
  type: TYPE_NORMAL
- en: '**from** tkinter **import** *'
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly how we did it for simplicity in the last chapter. However, this
    approach is frowned upon among Python programmers because you don’t know exactly
    what you are importing, and this may lead to naming conflicts with other classes
    that you have already used in your code. The controlled approach with explicit
    specification of the classes to be imported is therefore usually preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Import the Entire Module
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of importing is to simply import the entire module:'
  prefs: []
  type: TYPE_NORMAL
- en: '**import** tkinter **as** tk'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the statement, **as tk**, can also be omitted. However, using
    **as** makes it easier to access the module, especially if the module name is
    long. This is because with this type of import, the module name *must always*
    be included when accessing the module’s classes, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: clear_button = tkinter.Button(win,text = 'Clear',command = clear_press)
  prefs: []
  type: TYPE_NORMAL
- en: 'When using renaming with the help of **as**, this shortens to:'
  prefs: []
  type: TYPE_NORMAL
- en: clear_button = tk.Button(win,text = 'Clear',command = clear_press)
  prefs: []
  type: TYPE_NORMAL
- en: '**as**, by the way, can also be used to “rename” individual classes imported
    with **from** ***module*** **import** ***class***; this is useful, especially
    to avoid naming conflicts with existing classes (possibly developed by yourself!)'
  prefs: []
  type: TYPE_NORMAL
- en: '23.3.3 Using the Community: The Python Package Index (PyPI)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python comes with a number of out of the box modules and packages, including
    the already used package **tkinter**. In addition to the packages installed by
    default, the *Python Package Index* (*PyPI*) at ► [https://​pypi.​org/​](https://pypi.org/)
    offers a variety of packages for almost every imaginable task. Each package has
    its own page with some important information about the package, such as the author,
    the license under which it is provided, or the Python version needed to use the
    package. Generally, a short description of the package is also provided, which
    is important for deciding whether a package that sounds good by name serves the
    desired purpose. However, the descriptions on the *PyPI* page of the package are
    often quite poor, and so it is good that some packages have their own home page
    linked from the *PyPI* page which then provides more detailed information about
    the package. An example of such a *PyPI* page is ► [https://​pypi.​org/​project/​numpy/​](https://pypi.org/project/numpy/),
    the page of the well-known package **NumPy**, which adds data types to Python
    for efficient work with multidimensional arrays.
  prefs: []
  type: TYPE_NORMAL
- en: The *Python Package Index* offers an incredible number of packages. However,
    since the packages vary greatly in scope and quality, it is advisable not to simply
    “search” the *Python Package Index,* but to first find interesting “package candidates”
    on the Internet in the relevant discussion forums, on blogs and other websites
    and then try them out. If necessary, simply install several packages for the same
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Packages with PyCharm
  prefs: []
  type: TYPE_NORMAL
- en: Once you have found a package you want to use, you must install the package
    before you can use it. In *PyCharm*, you can do this via the graphical user interface
    by going to the *Settings* dialogue (click the gear button in the title bar of
    the PyCharm application window) then *Project* | *Project Interpreter*. Here you
    will see a list of packages that are currently available. By clicking on the small
    plus button, you will get to a dialog where you can select and install a package
    from the *Python Package Index*.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Packages with pip
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to work via the console of the operating system rather than via
    the graphical user interface of *PyCharm*, you can use **pip**, a program that
    allows the administration of packages. By the way, **pip** is a recursive abbreviation,
    it contains itself in the long form: *pip installs packages*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to work with **pip**, you must first make sure that it is installed.
    To do this, change to the **scripts** directory of your Python installation. If
    you are working with Microsoft Windows and have installed Python in **C:\python37**,
    **pip** has the path **C:\python37\Scripts\pip.exe**. If **pip** is not there,
    change to the directory where **python.exe** is located (typically **C:\python37**
    in our example) and execute the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: python -m ensurepip --default-pip
  prefs: []
  type: TYPE_NORMAL
- en: '**pip** checks itself whether it is up to date. If this is not the case, you
    can easily update to the current version:'
  prefs: []
  type: TYPE_NORMAL
- en: python -m pip install --upgrade pip
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you install packages with **pip** by executing the **pip install**
    ***packagename*** statement, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: pip install NumPy
  prefs: []
  type: TYPE_NORMAL
- en: 'But **pip** can do much more. You can display information about a package with
    **pip show**, for example for **NumPy**:'
  prefs: []
  type: TYPE_NORMAL
- en: pip show NumPy
  prefs: []
  type: TYPE_NORMAL
- en: 'With **pip deinstall** ***packagename*** you can also uninstall a package,
    with **pip search** you can search the *Python Package Index* directly from the
    command line, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: pip search webscraping
  prefs: []
  type: TYPE_NORMAL
- en: For help with **pip** and its many options, use the command
  prefs: []
  type: TYPE_NORMAL
- en: pip -horpip –helpVirtual Environments
  prefs: []
  type: TYPE_NORMAL
- en: Python can install the package into a *virtual environment* if needed. Then
    the package is not added to the general package library but installed in a separate
    library for your current project. This allows you to work with different versions
    of the same package in different projects which can be important if, for example,
    your project requires an older version of a package because it cannot run with
    the current version. With a *virtual environment*, you keep your project running
    while you can work with the current version of the package elsewhere. This is
    made possible by the fact that you can also specify the version to be installed
    when you install packages, so that you do not necessarily have to use the latest
    version.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, the same is true for Python itself. You can specify which Python
    interpreter you want to work with. With Python version 3.x, some significant changes
    have been made to the language definition compared to the older 2.x versions,
    and Python projects developed under Python 2.x are not necessarily fully executable
    under version 3.x. In *PyCharm*, you can easily specify which should be the *Project
    Interpreter*, you want to use in the current project. This way, an older project
    developed under Python 2.x will still be executable without the need for extensive
    rebuilding. When you create a virtual environment, the interpreter you want to
    work with is also copied into the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: But of course, you can also select a project interpreter without creating a
    virtual environment. So, if you simply want to work with the Python 2.x interpreter
    and the packages installed for that interpreter (in its “main” installation),
    you can simply switch the project interpreter in *PyCharm* to that interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, it is recommended to refrain from creating a virtual environment
    right from the start of your project, unless you absolutely need one (which, as
    a rule, should not be the case).
  prefs: []
  type: TYPE_NORMAL
- en: 23.4 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we saw how functions are defined and used in Python; we also
    looked at how modules and packages work and learned about the *Python Package
    Index* (*PyPI*) as an important source of useful program code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to take the following points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions are defined in Python with the **def** statement and consist of the
    function header, containing the function’s identifier and arguments, and the function
    body, the (indented) block of code that is executed when the function is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional arguments are assigned their default value in the function header of
    the function definition (***argument*** **=** ***default_value***).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The function arguments are in the function definition without data type, but
    can be provided with a type hint of the form: **datatype**, which is not binding,
    but is processed by many IDEs and is also displayed in the help for the function;
    in addition to function arguments, the return values of the function can also
    be provided with type hints of the form **−> datatype**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return values are returned with the **return** keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables defined within functions, like function arguments, are local variables
    and therefore can only be used within the code block of the function; if you want
    to access a global variable from within a function, you must use the keyword **global**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if a function has no arguments, the round (but in this case empty) argument
    brackets must be written when it is called (as well as when it is defined).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When calling a function, the arguments can also be passed as keyword arguments,
    that is, with their names (in the form ***argument*** **=** ***value***); then
    the order of the arguments does not matter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python code can be grouped into modules, and multiple modules can be grouped
    into packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes from modules used in the program must first be imported, either by explicitly
    specifying the classes to be imported in the form **from** ***modulename_or_packagename***
    **import** ***classlist*** (recommended procedure) or by importing *all* classes
    in the form **from** ***modulename_or_packagename*** **import ***; also, the module
    can be imported with a statement of the form **import** ***modulename_or_packagename***.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important source for Python modules is the *Python Package Index* (*PyPI*);
    here you can find solutions for many different programming tasks. Researching
    for a suitable package is always worthwhile before you start programming the functionality
    you are looking for yourself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The installation of modules of the *PyPI is* done either with the help of the
    command line program **pip** or via the an IDE like *PyCharm*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 23.5 Solutions to the Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exercise 23.1
  prefs: []
  type: TYPE_NORMAL
- en: 'The function **create_website()** could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def** create_website(title: str, header: str, text: str):'''''' Creates a
    simple website and saves it as website.html.Arguments:-- title: Title of the website--
    header: Header text-- text: The actual content''''''html_content = ''<html><head><title>''
    + title +''</title></head><body><h1>'' +header + ''</h1><p>'' + text +''</p></body></html>''html_file
    = open(''C:\website.html'', ''w'')html_file.write(html_content)html_file.close()'
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible call would then be:'
  prefs: []
  type: TYPE_NORMAL
- en: create_website(My first Python website', 'Section 1','Here could be a longer
    text')
  prefs: []
  type: TYPE_NORMAL
- en: The function is called with three string arguments for title, heading and text
    content of the website to be created. It does not have a return value. Instead,
    it generates the HTML code of the website as string variable **html_content**
    and then writes it to the file **website.html**. Instead of first creating a large
    string with the file content and then writing it to the file, it would also have
    been possible to use several **write()** statements to write the file content
    step by step to the file without already completely assembling it at the beginning.
    If you now call the finished function, you can open the website it generates in
    your web browser afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the actual function, however, the task also required documentation.
    For this purpose, we first work with a docstring. It briefly describes what the
    function does and what its arguments mean. If you copy the function to the Python
    console and execute it there, you can then use **help(create_website)** to view
    the function’s help, which is fed from exactly this docstring. For further documentation,
    we have included type hints for the arguments in the function header. A commenting
    of the code in the function body was omitted because the code is quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 23.2
  prefs: []
  type: TYPE_NORMAL
- en: (a)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function **dice()** generates a random number with the help of the function
    **randint()** imported from the module **random**. This random number is stored
    in the integer variable **dice_result**. However, we forgot to return the result
    with **return**. If you call this function and catch its return value in a variable
    or output it to the console, you will notice that you get the special value **None**
    every time. It indicates that the function returns no value. However, if you now
    add the missing **return** statement, you will get back a random integer value
    between 1 and 6, just like rolling dice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (b)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The function **create_phonenumber()** suffers from two problems: First, the
    colon in the function header is placed *before* the type hint, although it should
    actually be placed at the end of the function header after all, it introduces
    the following code block, i.e., the function body. Secondly, the argument **number**
    is used in the body of the function, as the actual subscriber line number without
    prefixes. However, it does not appear at all in the argument list in the function
    header. Of course, the code of the function cannot access an argument that is
    not passed to the function. After these corrections, the function can then be
    called to generate a nicely formatted phone number, for example in this call:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print(create_phone_number('DE', '171', '3456789'))
  prefs: []
  type: TYPE_NORMAL
- en: The country code **'DE'** is translated into the corresponding country code
    with the help of a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 23.3
  prefs: []
  type: TYPE_NORMAL
- en: 'The function **deal_with_myself()** could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def** deal_with_myself(**args):print(list(args.keys()))print(list(args.values()))'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you recall, a principally indefinite list of named, or keyword, arguments
    can be accessed with an argument prefixed with two asterisks in the function header.
    This argument is then a dictionary with the names of the arguments as keys and
    the argument values passed as values of the dictionary entry. Accordingly, we
    can use the **keys()** and **values()** methods to get the keys, that is, the
    argument names and their values. A call to this function might then look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: deal_with_myself(first_argument = 'An str argument',still_an_argument2 = 5)Exercise
    23.4
  prefs: []
  type: TYPE_NORMAL
- en: 'This program, which “books” new sales, generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '24.08.2019 12:48:24 – New sale: 10.99 dollars with article number US07011981.24.08.2019
    12:48:24 -- New sale: 24.99 dollars with article number CA25101878.Total sales:
    35.98Last sale: 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: The first two outputs are generated directly by the **new_sale()** function.
    The following two outputs, namely on the total turnover and the turnover of the
    last sale, are simply outputs of the variables **total_sales** and **last_sale**.
    These two variables are created in the main program and initially default to the
    value **0.00**. The function then attempts to change these variables, which it
    seems to succeed in doing in the case of **total_sales**. To the current value
    of **new_sale()**, it adds the value of each newly posted sale. The sum of our
    two sales is indeed 35.98\. But what about **last_sale**? Although this variable
    is also assigned a new value in the code of the function **new_sale()**, it still
    has the value at the end with which it was initialized at the beginning of the
    program. What happened? The two variables, the one initialized at the beginning
    and the one used in the function body of **new_sale()**, are two different objects.
    The variable used in the function body is a *local* variable that ceases to exist
    at the end of the function. Value assignments to this variable have no effect
    on the variable initialized at the beginning of the program, outside the function.
    If we wanted to change this variable instead, we would have to tell Python to
    do so with a **global** statement, as we did for **total_sales**. This way Python
    knows that we don’t want to create a local variable but write to the global variable
    of the same name that was created outside the function.
  prefs: []
  type: TYPE_NORMAL
