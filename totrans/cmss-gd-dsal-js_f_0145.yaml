- en: Binary Search Trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many different kinds of tree-based data structures exist, but in this chapter,
    we’ll focus on a particular tree known as a binary search tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there are two adjectives here: binary and search.'
  prefs: []
  type: TYPE_NORMAL
- en: A binary tree is a tree in which each node has zero, one, or two children.
  prefs: []
  type: TYPE_NORMAL
- en: 'A binary search tree is a binary tree that also abides by the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Each node can have at most one left child and one right child.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A node’s left descendants can only contain values that are less than the node
    itself. Likewise, a node’s right descendants can only contain values that are
    greater than the node itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of a binary search tree, in which the values are numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/binary_trees/bst_4.png](images/binary_trees/bst_4.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that each node has one child with a lesser value than itself, which is
    depicted using a left arrow, and one child with a greater value than itself, which
    is depicted using a right arrow.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, notice that all of the 50’s left descendants are less than it.
    At the same time, all of the 50’s right descendants are greater than it. The same
    pattern goes for each and every node.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the following example is a binary tree, it’s not a binary search tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/binary_trees/bst_5.png](images/binary_trees/bst_5.png)'
  prefs: []
  type: TYPE_IMG
- en: It’s a binary tree because each node has zero, one, or two children. But it’s
    not a binary search tree, because the root node has two left children; that is,
    it has two children than are less than it. For a binary search tree to be valid,
    it can have at most one left (lesser) child and one right (greater) child.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of a tree node in JavaScript might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**class**​ TreeNode { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**constructor**​(value, left=​**null**​, right=​**null**​) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**this**​.value = value; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**this**​.leftChild = left; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**this**​.rightChild = right; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**export**​ ​**default**​ TreeNode; |'
  prefs: []
  type: TYPE_TB
- en: 'We can then build a simple tree like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**const**​ node1 = ​**new**​ TreeNode(25); |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**const**​ node2 = ​**new**​ TreeNode(75); |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**let**​ root = ​**new**​ TreeNode(50, node1, node2); |'
  prefs: []
  type: TYPE_TB
- en: Because of the unique structure of a binary search tree, we can search for any
    value within it very quickly, as we’ll now see.
  prefs: []
  type: TYPE_NORMAL
