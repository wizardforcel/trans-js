- en: The Efficiency of Bubble Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Bubble Sort algorithm contains two significant kinds of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparisons: Two numbers are compared with one another to determine which is
    greater.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Swaps: Two numbers are swapped with one another to sort them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by determining how many comparisons take place in Bubble Sort.
  prefs: []
  type: TYPE_NORMAL
- en: Our example array has five elements. Looking back, you can see that in our first
    pass-through, we had to make four comparisons between sets of two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: In our second pass-through, we only had to make three comparisons. This is because
    we didn’t have to compare the final two numbers, since we knew that the final
    number was in the correct spot due to the first pass-through.
  prefs: []
  type: TYPE_NORMAL
- en: In our third pass-through, we made two comparisons, and in our fourth pass-through,
    we made just one comparison.
  prefs: []
  type: TYPE_NORMAL
- en: So that’s
  prefs: []
  type: TYPE_NORMAL
- en: 4 + 3 + 2 + 1 = 10 comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: To put this in a way that would hold true for arrays of all sizes, we’d say
    that for N elements, we make
  prefs: []
  type: TYPE_NORMAL
- en: (N - 1) + (N - 2) + (N - 3) … + 1 comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve analyzed the number of comparisons that take place in Bubble
    Sort, let’s analyze the swaps.
  prefs: []
  type: TYPE_NORMAL
- en: In a worst-case scenario, where the array is sorted in descending order (the
    exact opposite of what we want), we’d actually need a swap for each comparison.
    So we’d have 10 comparisons and 10 swaps in such a scenario for a grand total
    of 20 steps.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the big picture. With an array containing five values in reverse
    order, we make 4 + 3 + 2 + 1 = 10 comparisons. Along with the 10 comparisons,
    we also have 10 swaps, totaling 20 steps.
  prefs: []
  type: TYPE_NORMAL
- en: For such an array with 10 values, we get 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 =
    45 comparisons, and another 45 swaps. That’s a total of 90 steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an array containing 20 values, we’d have:'
  prefs: []
  type: TYPE_NORMAL
- en: 19 + 18 + 17 + 16 + 15 + 14 + 13 + 12 + 11 + 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3
    + 2 + 1 = 190 comparisons, and approximately 190 swaps, for a total of 380 steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the inefficiency here. As the number of elements increases, the number
    of steps grows exponentially. (In technical math terms, we’d actually say that
    it grows quadratically.) We can see this clearly in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| N Data Elements | Max # of Steps |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 20 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 90 |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | 380 |'
  prefs: []
  type: TYPE_TB
- en: '| 40 | 1560 |'
  prefs: []
  type: TYPE_TB
- en: '| 80 | 6320 |'
  prefs: []
  type: TYPE_TB
- en: 'If you look at the growth of steps as N increases, you’ll see that it’s growing
    by approximately N². Take a look at the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| N Data Elements | # of Bubble Sort Steps | N² |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 20 | 25 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 90 | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | 380 | 400 |'
  prefs: []
  type: TYPE_TB
- en: '| 40 | 1560 | 1600 |'
  prefs: []
  type: TYPE_TB
- en: '| 80 | 6320 | 6400 |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s express the time complexity of Bubble Sort with Big O notation. Remember,
    Big O always answers the key question: if there are N data elements, how many
    steps will the algorithm take? Because for N values, Bubble Sort takes N² steps,
    in Big O we say that Bubble Sort has an efficiency of O(N²).'
  prefs: []
  type: TYPE_NORMAL
- en: 'O(N²) is considered to be a relatively inefficient algorithm since as the data
    increases, the steps increase dramatically. Look at the following graph, which
    compares O(N²) against the faster O(N):'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/speeding_up_your_code_with_big_o/bubble_sort_30.png](images/speeding_up_your_code_with_big_o/bubble_sort_30.png)'
  prefs: []
  type: TYPE_IMG
- en: Note how O(N²) curves sharply upward in terms of number of steps as the data
    grows. Compare this with O(N), which plots along a simple, diagonal line.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last note: O(N²) is also referred to as quadratic time.'
  prefs: []
  type: TYPE_NORMAL
