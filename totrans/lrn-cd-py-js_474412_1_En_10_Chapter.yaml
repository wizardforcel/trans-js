- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024J. L. ZuckarelliLearn coding with Python and JavaScript
    [https://doi.org/10.1007/978-3-658-42912-6_10](https://doi.org/10.1007/978-3-658-42912-6_10)
  prefs: []
  type: TYPE_NORMAL
- en: 10. How Do I Make Sure That I (and Others) Still Understand My Program Later?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1)München, Germany
  prefs: []
  type: TYPE_NORMAL
- en: When I wrote this, only God and I understood what I was doing. Now, only God
    knows.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (User *johnc* on *Stack Overflow* “What is the best comment in source code you
    have ever encountered?”)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There are only two hard things in Computer Science: cache invalidation and
    naming things.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Phil Karlton)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: That you should program in a way that allows you to understand later exactly
    how you proceeded and how the solutions you developed work, is a trivial demand
    that should be obvious. But, in fact, many programmers, even professional ones,
    do far too little to put this into practice. So next we’ll look at how you can
    design your code so that it is understandable to you and others who need to work
    with it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to make program code readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What comments are and why they are useful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use comments cleverly to explain your program code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What role documentation of the program code plays if other programmers are to
    use it for their own developments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.1 Understandable Program Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developing understandable program code is tedious and exhausting, and what it
    takes to do it is one of the least favorite tasks of many programmers.
  prefs: []
  type: TYPE_NORMAL
- en: For one thing, it takes more effort to program in a comprehensible way, because
    you have to stick to conventions and write notes, *comments* in programmer jargon,
    so that later on you can quickly understand how the program you wrote works. When
    you are mentally deep in the details of a problem solution, most people—including
    the author of this book—tend to massively overestimate their ability to understand
    their own actions later on.
  prefs: []
  type: TYPE_NORMAL
- en: But you should keep in mind, and this may be an additional motivation to invest
    the necessary work, that this “later” does not necessarily have to be in five
    years. It can also be the day after tomorrow that the lack of readability of your
    program code becomes your undoing and causes unnecessary effort that could have
    been avoided with a little more effort when originally writing the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, it makes sense to start looking at what you can do to counteract this early
    on, and to make sure that you work in such a way from the start that you can always
    get back into your program code without too much difficulty. Three factors can
    contribute significantly to this:'
  prefs: []
  type: TYPE_NORMAL
- en: The *visual design of the program code* has an influence on how quickly you
    can orientate yourself in it and recognize connections between different parts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way various elements of a program are *named* (such as variables and functions,
    which we’ll discuss in detail later) goes a long way toward determining how quickly
    you can grasp the content of what certain parts of the code do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments, such as explanations written by the programmer and placed directly
    in the program code, can, if they are well written, explain a lot of things that
    cannot be read out of the code itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.2 Design of the Program Code and Naming of Program Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One important factor that will help ensure that you still easily understand
    your program code later is how you format it, especially how you use *line indentation*.
    An example:**for**(i=1; i<=100; i++) {**if**(i **mod** 2 == 0) {**for**(f=1; f<=100;
    f++) {printf("field (", i, ", ", f, ")");}}printf("\n");}
  prefs: []
  type: TYPE_NORMAL
- en: 'Even without understanding what this code, written in the C programming language,
    does you will see a whole series of curly brackets that open after certain statements
    and close again sometime later. Everything in between is a code block that belongs
    to the preceding statement. The code blocks here are obviously nested within each
    other, meaning that there are code blocks that in turn contain other code blocks.
    In the above notation, however, this nested structure is difficult to see. This
    is especially obvious at the end, where a whole series of blocks is closed in
    a cascade. Which bracket now belongs to which block, and therefore which statement
    is in which block, is not easy to find out. But this question is essential if
    you want to understand what the program does and how it works exactly. (For those
    interested in what this code does: for a matrix with 100 rows and 100 columns,
    it writes all the field coordinates to the screen in the form (row, column), but
    omits the odd rows.)'
  prefs: []
  type: TYPE_NORMAL
- en: The code becomes clearer if you insert indentations, for example with the tab
    key:**for**(i=1; i<=100; i++) {**if**(i **mod** 2 == 0) {**for**(f=1; f<=100;
    f++) {printf("field (", i, ", ", f, ")");}}printf("\n");}
  prefs: []
  type: TYPE_NORMAL
- en: Now it is much easier to see where a code block starts and where it ends. The
    code becomes more *readable*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most programming languages allow you to format code arbitrarily using indentation.
    However, there are some exceptions, such as Python, where indentations have a
    content-related meaning and therefore cannot be set arbitrarily. However, the
    all-clear can be given for Python as well: The way Python requires indentations
    virtually forces the programmer to make his code readable anyway. Or to put it
    another way: a correct syntax (i.e., executable program code) in Python automatically
    brings with it a minimum level of readability. We will take a closer look at this
    in the third part of the book, when we learn the fundamentals of Python.'
  prefs: []
  type: TYPE_NORMAL
- en: But not only the formatting of the source code plays a big role for the readability
    and comprehensibility of the code. When programming, you have to give many things
    a name, for example variables or functions. The user of your program will not
    see these names (also called *identifiers* in programmer jargon), but that is
    not a justification to give you free rein to your wildest fantasies when choosing
    the identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following program written in Python that calculates
    body mass index (BMI):a = input("Your weight [in kg]: ")b = input("Your height
    [in m]: ")c = float(a)/float(b)**2print("Your body mass index is: ", c, "\n")print("Your
    input was:")print("Size:", a, "m")print("Weight:", b, "kg")Without knowing Python,
    do you notice anything? The program first asks you for your weight and height.
    If you enter a height of 1.78 m and a weight of 80 kg, for example, the body mass
    index is output as 25.25 (a value that indicates slight overweight). Afterwards,
    the initial values with which you fed the program will be displayed again; it
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your input was:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Size: 80 m'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Weight: 1.78 kg'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these values you would be clearly underweight, but with a height of 80
    meters this would be a comparatively insignificant problem! What happened? This
    is not a program bug, but a programmer error! In the program, the variable names
    were swapped when outputting the weight and size parameters. As a result, the
    wrong values are shown on the screen. Since the variables are called **a** and
    **b** here, such mix-ups in the program code are not easily to spot at first.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is much easier to detect the error if you choose *speaking* variable names:'
  prefs: []
  type: TYPE_NORMAL
- en: 'weight = input("your weight [in kg]: ")height = input("Your height [in m]:
    ")bmi = float(weight)/float(size)**2print("Your body mass index is: ", bmi, "\n")print("Your
    input was:")print("Size:", height, "m")print("Weight:", weight, "kg")'
  prefs: []
  type: TYPE_NORMAL
- en: So, use easy-to-understand, meaningful identifiers that convey an idea of what
    the thing you are naming contains (in the case of a variable) or what it does
    (in the case of a function). When you’re programming quickly, it’s tempting to
    use short, often one-letter variable names (for example, **x**, **y**, **i**,
    **f**) without much thought, because they’re easy to type quickly. But you should
    resist this temptation. Your “later self” who tries to read your program code
    will thank you!
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, it is not enough to use just one word for the identifiers,
    such as **size** or **weight**. It is with compound identifiers that we see differences
    in the naming conventions of programming languages. Suppose we wanted to distinguish
    height and weight according to whether the user of the program is a man or a woman
    and introduced different variables for both sexes to do so. Some programming languages
    prefer the notation **heightMan** for the height of a man, others **height**_man,
    still others **height.man**.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in the end it doesn’t matter at all whether you follow the convention
    that most programmers follow in your programming language or not. For the syntactic
    correctness and thus the executability of your program, this is of course irrelevant,
    at least as long as you use only the characters permitted in variable names (in
    some languages, for example, **$** is a reserved character; **exchangerate$**
    would then be an invalid variable name and would lead to an error). However, it
    is recommended to stick to *some* standard. This saves thinking, because you don’t
    have to rethink every time, and makes your program more readable later.
  prefs: []
  type: TYPE_NORMAL
- en: On the question of formatting code, and choosing appropriate identifiers many
    people have done a lot of smart thinking. *Google* has compiled these thoughts
    for a whole range of programming languages in its *Google Style Guides*, and you
    will also find style guides (sometimes slightly deviating from *Google*’s guidelines)
    in many other places on the internet. Feel free to look at such a style guide
    for your programming language. Of course, you don’t have to follow it slavishly.
    More important than following a certain style is to have a style in the first
    place, which you can implement more or less consistently, in order to save yourself
    mental work and to keep your code readable and thus understandable.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 10.3.1 Explain Your Own Program Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not only good formatting and a sensible choice of identifiers that help
    you to write code that you will understand later. Another important tool on this
    path are *comments*. Comments are texts in the program code that are *ignored
    by* the compiler or interpreter. Unlike in the rest of the source code, where
    you have to stick scrupulously to the syntax rules so that the computer understands
    what you want, in comments you can write to your heart’s content. The trick is
    to make it clear to the compiler or interpreter that your comment is not part
    of the actual program code, and that it can therefore safely disregard it.
  prefs: []
  type: TYPE_NORMAL
- en: In order for the compiler or interpreter to know what is program code and what
    is comment, comments are always introduced with a special symbol. Depending on
    the programming language, the comment then extends either to the end of the line
    or to the point where it is again terminated with a special symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Some languages only support the first mode, which means that there are only
    single-line comments. If a comment is to extend over several lines, the comment
    must again start with the comment symbol in each line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some examples. First, an example in the C programming language:*//
    Counter reading has now run up completely.**// Output counter reading.*printf("Counter
    reading: ", counter,"\n");counter = 0; // Reinitialize counter'
  prefs: []
  type: TYPE_NORMAL
- en: 'The symbol that introduces comments here is **//**. Everything between **//**
    and the end of the line is a comment and is ignored by the C compiler. Therefore,
    comment and code can also be on the same line, although the code must of course
    be to the left of the comment symbol **//**. Interestingly, the C programming
    language and many languages based on it know not only the single-line comment
    with **//**, but also multiline comments. These are enclosed between the symbols
    **/*** and ***/** (Note, the asterisks always face the comment text). This would
    allow the example above to be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/* Counter reading has now run up completely.**Output counter reading */*printf("Counter
    reading: ", counter,"\n");counter = 0; */* Reinitialize counter */*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the second line of the first comment does not need a separate
    symbol to start the comment, because we are still in the comment area that was
    opened by **/*** in the previous line. Only with ***/** is the comment closed
    again. Since this comment has a clearly defined beginning and end, it can also
    be placed in the middle of the code, although this is not recommended since it
    is detrimental to the readability of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: counter */* the loop counter */* = 0;
  prefs: []
  type: TYPE_NORMAL
- en: Of course, every programming language has its own symbols for comments. However,
    the aforementioned ***//***, the combination of opening */** and closing **/*,
    and the *#* symbol (usually for single-line comments) are frequently encountered.
  prefs: []
  type: TYPE_NORMAL
- en: Using comments can help you document how your program works directly in the
    code. Everyone who has the code sees the documentation at the same time. Of course,
    this is especially interesting if you are working with someone else. Your collaborator
    will certainly appreciate a hint or two in particularly complicated places.
  prefs: []
  type: TYPE_NORMAL
- en: But you yourself, at least your “later self”, will also benefit immensely from
    the comments. Nothing is nicer than looking at an old piece of code and being
    happily surprised to find that the developer at the time (yourself) left a little
    help that makes it considerably easier to understand the difficult passage.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, because commenting your solution takes time, you should only use comments
    where it is really necessary, that is, at points in the program where you can
    expect that you will not easily understand them later. So don’t comment every
    triviality but use comments economically. Commenting is probably the least popular
    part of programming work. So, write your comments promptly, ideally right after
    you have written the code in question. This way, you will not only remember exactly
    how your solution works, but you will also avoid having to think about the solution
    again later to write the comment, a mental effort that may discourage not only
    die-hard fans of procrastination from adding comments. Artificial intelligence
    tools such as ChatGPT can help here. Ask ChatGPT to comment your code once, for
    example with the following prompt: “Comment the following code so that it is understandable
    for beginners”. You will be surprised how much tedious work ChatGPT, Gemini, Claude
    & Co can do for you.'
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.2 What Else Comments Are Useful For
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With comments, you can not only document the procedure you used, but also, for
    example, note unfinished tasks. A clear **TODO** marks the comment as an open
    task for you. In the same way, you can use **REVIEW** to highlight code segments
    that you want to take a closer look at or assign any other meaningful tags that
    mark specific types of comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use comments in a much more mundane way, namely to better structure
    your source code and make it clearer for you. In this sense, you can use comments
    to visually separate parts of the source code from each other, for example like
    this (in C++):'
  prefs: []
  type: TYPE_NORMAL
- en: /* ------------ START READING IN THE DATA ------------ */
  prefs: []
  type: TYPE_NORMAL
- en: 'When you start programming, you will see how helpful it can sometimes be to
    “comment out” a program statement. This means to put the instruction into a comment
    and thus “switch it off”. After all, the compiler or interpreter does not execute
    what is written in a comment. So, by enclosing a statement in a comment, you can
    make that statement temporarily ineffective. A small example in C:'
  prefs: []
  type: TYPE_NORMAL
- en: printf("This text is printed on the screen!");*/* printf("This text does not
    appear because the printf statement is commented out"); */*
  prefs: []
  type: TYPE_NORMAL
- en: Comments are very helpful when you are just starting to deal with a new programming
    language and want to record the knowledge you gain from trying it out in the code
    of the test programs right away. It is well known that you learn best when you
    write down what you have learned (the acknowledged most effective method for this,
    handwritten notes, is naturally ruled out for program code).
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.3 Documentation Outside the Program Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Comments are a kind of documentation *in the* program code. This is advantageous,
    since the explanations and what is explained are right next to each other. However,
    there is nothing against storing documentation *outside* the source code. This
    is useful, for example, if you want to write more comprehensive explanations,
    or if you want to include other information in the text (such as a table or a
    photograph of a handwritten note or sketch). The same is true if you want to document
    overarching contexts, such as the overall structure of your program or the interrelationship
    of different parts of the program. In all these cases it is okay to separate at
    least part of the documentation from the code and to place it to another document.
    Whether you write this external documentation with a word processor or record
    it in your electronic notebook is completely irrelevant. The principle applies:
    Praise be to that which helps understanding!'
  prefs: []
  type: TYPE_NORMAL
- en: A special way to generate documentation outside of the source code are special
    *documentation generators*, which are available for many programming languages.
    In their basic function, these tools do little more than automatically read out
    certain comments specially marked in the program code and prepare them in a visually
    appealing form. The result is then usually output as an HTML document or in PDF
    format. Examples of such tools are *Javadoc* for Java, *phpDocumentor* for PHP,
    *roxygen* for R or *Doxygen*, which supports several different languages, including
    Python and C++. Generating documentation in this way is particularly interesting
    when writing program code that will later be called by others (we’ll see below
    how to package parts of programs into modules that can then be called from elsewhere).
    While those who will call the program code do not necessarily need to understand
    in detail how it works, they do need to know how exactly to call the program,
    and how to control its operation for their purposes. Since these developers are
    not interested in the program code as such, but only in its *interface*, it would
    be impractical if they had to rummage through the code to find the relevant hints.
    That’s why the documentation is placed outside the code. This way, it stays “clean”
    and concise, and is easy for the user to use. For the developer of the code, it
    is also easy to write because it is embedded directly in the program code, just
    like conventional comments. In Java, for example, this could look like this:*/*****
    Reads the name of the user****** @author Marc McIntosh*** @version 1.3****** @param
    prompt Text of the prompt shown to the user*** @return Name the user has entered***/***public
    String** getUserName(prompt) {*/* Here comes the actual program code */*}
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, a special part of the program, called a function, is documented using
    *Javadoc.* The function can be called with a prompt, for example getUserName("Enter
    your name: "), then reads a user input and returns the user’s input as a value
    to the person who called the function. (We’ll deal with functions in more detail
    later.) The important thing here is that this function is a part of a module that
    can be called by other programs. To understand what the function needs to be called
    (the text of the prompt to be displayed to the user) and what it returns (the
    name the user has entered), the function is documented here in such a way that
    the documentation tool Javadoc can automatically generate appealing HTML documentation.
    Javadoc uses special comments for this purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: Normal comments in Java are placed between the symbols **/*** and ***/**. However,
    if a comment is prefixed with **/**,** Javadoc knows that this is a comment that
    should become part of the documentation. Special predefined tags prefixed with
    **@** can be used to address specific fields in the documentation. For example,
    **@param prompt** is used to explain what the **prompt** parameter means when
    calling the **getUserName** function. These predefined fields can then be presented
    in a special way in the documentation, for example in a special formatting or
    at a special position within the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Often a stricter distinction is made between documentation and commenting than
    we do here. Based on the target audience, comments are aimed at the person who
    wants to understand and edit your code (usually yourself, but possibly others
    as well). Another developer, however, who simply wants to use your code in his
    own programs, is not interested in its inner structure and workings, and will
    not read your comments in the code at all but will only look for information on
    how exactly to use your code properly. Similarly, the user of a word processor
    is not interested in exactly how it works inside, he wants to know how to change
    the font color for a selected text! The provision of this information about the
    use of the code is done by the documentation in the narrower sense, which of course
    may be generated via documentation generators from special comments in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4 Your Roadmap to Learning a New Programming Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you learn a new programming language …
  prefs: []
  type: TYPE_NORMAL
- en: to determine whether the programming language allows you to format your code
    in any way you want (for example, with indentations), or whether the formatting
    has a meaning in terms of content, take a look at a style guide that gives information
    on how to format your code in the programming language and how to choose the identifiers/names
    of variables, functions and other elements,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: decide on a way to format your code and name the variables, functions, and other
    elements. You don’t necessarily have to follow a style guide, but you should remain
    consistent,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: determine how comments can be built into the code, in particular whether comments
    can be multiline, and whether they are bounded at the front and back, or always
    extend to the end of the line,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: get into the habit of commenting your code so that you can understand it later,
    but do so economically and concentrate on the difficult parts where there is a
    real risk that you will not understand them later, or only with great difficulty,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: determine whether there are documentation generators that allow you to create
    attractive HTML or PDF documentation from the comments integrated into the program
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
