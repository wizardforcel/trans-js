- en: Depth-First Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two well-known approaches for graph search are depth-first search and breadth-first
    search. Both approaches can get the job done, but each provides unique advantages
    in particular situations. We’re going to start with depth-first search, also referred
    to as DFS, because it’s actually quite similar to the algorithm for binary tree
    traversal that we discussed back in [​*Binary Search Tree Traversal*​](f_0150.xhtml#sect.binary-tree-traversal).
    In fact, it’s also the same essential algorithm that we saw in [​*Filesystem Traversal*​](f_0101.xhtml#sect.filesystem-traversal).
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, graph search can be used either to find a particular vertex
    or to simply traverse the graph. We’re going to begin by using depth-first search
    to traverse the graph since that algorithm is slightly simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to any graph search algorithm is keeping track of which vertices we’ve
    visited so far. If we don’t do this, we can end up in an infinite cycle. Take
    the following graph, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/cycle_graph.png](images/graphs/cycle_graph.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, Mohammad is friends with Felicia. And Felicia also happens to be friends
    with Zeina. But Zeina is friends with Mohammad. So our code would end up going
    in circles unless we keep track of which vertices we’ve already traversed.
  prefs: []
  type: TYPE_NORMAL
- en: This problem didn’t occur when we dealt with trees (or filesystem traversal),
    since trees can’t have cycles. But since a graph can have a cycle, we need to
    address this issue now.
  prefs: []
  type: TYPE_NORMAL
- en: One way to keep track of our visited vertices is by using a hash table. As we
    visit each vertex, we add the vertex (or its value) as a key in the hash table
    and assign it an arbitrary value, such as the Boolean true. If a vertex is present
    in the hash table, it means we’ve already visited it.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, the depth-first search algorithm works as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Start at any random vertex within the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the current vertex to the hash table to mark it as having been visited.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate through the current vertex’s adjacent vertices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each adjacent vertex, if the adjacent vertex has already been visited, ignore
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the adjacent vertex has not yet been visited, recursively perform depth-first
    search on that vertex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Depth-First Search Walk-Through
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s see this in action.
  prefs: []
  type: TYPE_NORMAL
- en: In this walk-through, we’re going to start with Alice. In the following diagrams,
    the vertex with lines around it is the current vertex. A check mark means we’ve
    officially marked the vertex as having been visited (and added to the hash table).
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: We start with Alice and give her a check mark to indicate that we’ve
    officially visited her vertex:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/visited_alice.png](images/graphs/visited_alice.png)'
  prefs: []
  type: TYPE_IMG
- en: Next up, we’ll iterate over Alice’s neighbors using a loop. These will be Bob,
    Candy, Derek, and Elaine.
  prefs: []
  type: TYPE_NORMAL
- en: The order of which neighbor to visit first doesn’t matter, so let’s just start
    with Bob. He seems nice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: We now perform depth-first search on Bob. Note that this is making
    a recursive call, as we’re already in the middle of a depth-first search of Alice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with all recursion, the computer needs to remember which function calls
    it’s still in the middle of, so it first adds Alice to the call stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/alice_call_stack.png](images/graphs/alice_call_stack.png)'
  prefs: []
  type: TYPE_IMG
- en: We can now begin the depth-first search on Bob, which makes Bob the current
    vertex. We mark him as visited, as shown in the [graph](#fig.ch18.visit_bob).
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/visit_bob.png](images/graphs/visit_bob.png)'
  prefs: []
  type: TYPE_IMG
- en: We then iterate over Bob’s adjacent vertices. These are Alice and Fred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Alice has already been visited, so we can ignore her.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: The only other neighbor, then, is Fred. We call the depth-first search
    function on Fred’s vertex. The computer first adds Bob to the call stack to remember
    that it’s still in the middle of searching Bob:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/bob_call_stack.png](images/graphs/bob_call_stack.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We now perform depth-first search on Fred. He’s now the current vertex, so
    we mark him as visited:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/visit_fred.png](images/graphs/visit_fred.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we iterate over Fred’s adjacent vertices, which are Bob and Helen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Bob has already been visited, so we ignore him.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 6: The only remaining adjacent vertex is Helen. We recursively perform
    depth-search first on Helen, so the computer first adds Fred to the call stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/fred_call_stack.png](images/graphs/fred_call_stack.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We now begin depth-first search on Helen. She’s the current vertex, so we mark
    her as visited:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/visit_helen.png](images/graphs/visit_helen.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Helen has two adjacent vertices: Fred and Candy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 7: We’ve already visited Fred, so we can ignore him.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 8: Candy has not yet been visited, so we recursively perform depth-search
    on Candy. First, though, Helen gets added to the call stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/helen_call_stack.png](images/graphs/helen_call_stack.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We perform depth-first search on Candy. She’s now the current vertex, and we
    mark her as visited:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/visit_candy.png](images/graphs/visit_candy.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Candy has two adjacent vertices: Alice and Helen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 9: We’ve already visited Alice, so we can ignore her.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 10: We’ve already visited Helen, so we can ignore her as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Since Candy has no other neighbors, we’re done performing depth-first search
    on Candy. At this point, then, the computer begins to unwind the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: First, it pops off Helen from the call stack. We’ve already iterated over all
    her neighbors, so the depth-first search on Helen is complete.
  prefs: []
  type: TYPE_NORMAL
- en: The computer pops off Fred. We’ve iterated over all his neighbors too, so we’re
    done searching him as well.
  prefs: []
  type: TYPE_NORMAL
- en: The computer pops off Bob, but we’re done with him as well.
  prefs: []
  type: TYPE_NORMAL
- en: The computer then pops Alice off the call stack. Within our search of Alice,
    we were in the middle of looping through all of Alice’s neighbors. Now, this loop
    already iterated over Bob. (This was Step 2.) This leaves Candy, Derek, and Elaine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 11: Candy has already been visited, so there’s no need to perform search
    on her.'
  prefs: []
  type: TYPE_NORMAL
- en: However, we’ve not yet visited Derek or Elaine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 12: Let’s proceed by recursively performing depth-first search on Derek.
    The computer adds Alice to the call stack once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/alice_call_stack.png](images/graphs/alice_call_stack.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The depth-first search of Derek now begins. Derek is the current vertex, so
    we mark him as visited:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/visit_derek.png](images/graphs/visit_derek.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Derek has three adjacent vertices: Alice, Elaine, and Gina.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 13: Alice has already been visited, so we don’t need to perform another
    search on her.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 14: Let’s visit Elaine next, by recursively performing depth-first search
    on her vertex. Before we do, the computer adds Derek to the call stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/derek_call_stack.png](images/graphs/derek_call_stack.png)'
  prefs: []
  type: TYPE_IMG
- en: We now perform depth-first search on Elaine. We mark Elaine as visited, as shown
    in the [graph](#fig.ch18.visit_elaine).
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/visit_elaine.png](images/graphs/visit_elaine.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Elaine has two adjacent vertices: Alice and Derek.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 15: Alice has already been visited, so there’s no need to perform another
    search on her.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 16: Derek, too, has already been visited.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we iterated over all Elaine’s neighbors, we’re done searching Elaine.
    The computer now pops Derek from the call stack and loops over his remaining adjacent
    vertices. In this case, Gina is the final neighbor to visit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 17: We’ve never visited Gina before, so we recursively perform depth-first
    search on her vertex. First, though, the computer adds Derek to the call stack
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/derek_call_stack.png](images/graphs/derek_call_stack.png)'
  prefs: []
  type: TYPE_IMG
- en: We begin our depth-first search of Gina, and mark her as visited, as shown in
    the [graph](#fig.ch18.visit_gina).
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/visit_gina.png](images/graphs/visit_gina.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Gina has two neighbors: Derek and Irena.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 18: Derek has already been visited.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 19: Gina has one unvisited adjacent vertex—namely, Irena. Gina gets added
    to the call stack so that we can recursively perform depth-first search on Irena:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/gina_call_stack.png](images/graphs/gina_call_stack.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We begin search on Irena and mark her as visited:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/graphs/visit_irena.png](images/graphs/visit_irena.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We iterate over Irena’s neighbors. Irena has only one neighbor: Gina.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 20: Gina has already been visited.'
  prefs: []
  type: TYPE_NORMAL
- en: The computer then unwinds the call stack, popping off each vertex one by one.
    However, since each vertex on the call stack has already iterated over all of
    its neighbors, there’s nothing more for the computer to do with each vertex.
  prefs: []
  type: TYPE_NORMAL
- en: This means we’re done!
  prefs: []
  type: TYPE_NORMAL
- en: 'Code Implementation: Depth-First Search'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is an implementation of depth-first traversal:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ dfsTraverse(vertex, visitedVertices={}) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | visitedVertices[vertex.value] = ​**true**​; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | console.log(vertex.value); |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**for**​ (​**const**​ adjacentVertex ​**of**​ vertex.adjacentVertices)
    { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (!visitedVertices[adjacentVertex.value]) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | dfsTraverse(adjacentVertex, visitedVertices); |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: 'Our dfsTraverse method accepts a single vertex and a visitedVertices hash table.
    The first time we call this function, visitedVertices defaults to an empty hash
    table. For the above example, we’d perform a depth-first traversal starting with
    the alice vertex, with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | dfsTraverse(alice); |'
  prefs: []
  type: TYPE_TB
- en: As we visit vertices, though, we populate this hash table with the vertices
    we’ve visited and pass along the same hash table with each recursive call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do within the function is mark the current vertex as visited.
    We do this by adding the vertex’s value to the hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | visitedVertices[vertex.value] = ​**true**​; |'
  prefs: []
  type: TYPE_TB
- en: 'We then optionally print the vertex’s value just to get feedback that we’ve
    truly traversed it:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | console.log(vertex.value); |'
  prefs: []
  type: TYPE_TB
- en: 'Next, we iterate over all the adjacent vertices of the current vertex:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**for**​ (​**const**​ adjacentVertex ​**of**​ vertex.adjacentVertices)
    { |'
  prefs: []
  type: TYPE_TB
- en: 'We check each adjacent vertex to see whether it has already been visited. If
    it has, we do nothing, but if it has never been visited, we recursively call dfsTraverse
    on that adjacent vertex:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**if**​ (!visitedVertices[adjacentVertex.value]) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | dfsTraverse(adjacentVertex, visitedVertices); |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: Again, we also pass in the visitedVertices hash table so the ensuing call has
    access to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use depth-first search to search for a particular vertex, we
    can use a modified version of the previous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ dfs(vertex, searchValue, visitedVertices={}) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | visitedVertices[vertex.value] = ​**true**​; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (vertex.value === searchValue) { ​**return**​ vertex; } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**for**​ (​**const**​ adjacentVertex ​**of**​ vertex.adjacentVertices)
    { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (adjacentVertex.value === searchValue) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**return**​ adjacentVertex; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (!visitedVertices[adjacentVertex.value]) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**const**​ vertexWeAreSearchingFor = |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | dfs(adjacentVertex, searchValue, visitedVertices); |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (vertexWeAreSearchingFor) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**return**​ vertexWeAreSearchingFor; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**return**​ ​**null**​; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: This implementation also recursively calls itself for each vertex but returns
    the vertexWeAreSearchingFor if it finds the correct vertex.
  prefs: []
  type: TYPE_NORMAL
