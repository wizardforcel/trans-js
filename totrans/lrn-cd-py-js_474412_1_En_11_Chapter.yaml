- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024 J. L. Zuckarelli Learn coding with Python and JavaScript
    [https://doi.org/10.1007/978-3-658-42912-6_11](https://doi.org/10.1007/978-3-658-42912-6_11)
  id: totrans-0
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: © 作者，Springer Fachmedien Wiesbaden GmbH 独家授权，Springer Nature 2024 J. L. Zuckarelli
    《用 Python 和 JavaScript 学习编程》 [https://doi.org/10.1007/978-3-658-42912-6_11](https://doi.org/10.1007/978-3-658-42912-6_11)
- en: 11. How Do I Store Data to Work With?
  id: totrans-1
  prefs:
  - PREF_H1
  stylish: true
  type: TYPE_NORMAL
  zh: 11. 我如何存储数据以便使用？
- en: Joachim L. Zuckarelli^([1](#Aff2) )(1) München, Germany Overview.
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: Joachim L. Zuckarelli^([1](#Aff2) )(1) 慕尼黑，德国 概述。
- en: 'Programs work with data. These are read in from the user or from files, databases
    or other sources. We will look at exactly how this happens in the following chapter.
    This chapter is about something else: all data must be stored in the computer''s
    memory so that it can be processed. This is done in the form of variables. But
    don''t worry: even if these variables have a lot in common with their namesakes
    from mathematics, you don''t need to delve into the depths of mathematics to understand
    how to work safely with variables when programming.'
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 程序处理数据。这些数据可以从用户输入或文件、数据库或其他来源读取。我们将在接下来的章节中详细讨论这些过程。本章讲的是别的内容：所有数据必须存储在计算机的内存中，以便可以进行处理。这是通过变量的形式来实现的。但不用担心：即使这些变量与数学中的变量有很多相似之处，您也不需要深入研究数学原理，就能理解如何在编程时安全地使用变量。
- en: 'In this chapter you will learn the following:'
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 本章您将学习以下内容：
- en: What variables are and how to create them.
  id: totrans-5
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 变量是什么以及如何创建它们。
- en: What types of data variables can hold.
  id: totrans-6
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 数据变量可以存储哪些类型。
- en: How to combine many variables of the same kind into variable fields (`arrays`
    and `hashes`).
  id: totrans-7
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何将许多相同类型的变量组合成变量字段（`数组` 和 `哈希`）。
- en: How to combine different variables reflecting the properties of a certain real-world
    object (e.g., a car with the properties `brand`, `maximum speed` and `list price`)
    into one object and how to then manipulate these properties (object-oriented programming
    paradigm).
  id: totrans-8
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何将反映某个现实世界对象（例如，一辆具有 `品牌`、`最高速度` 和 `标价` 属性的汽车）属性的不同变量组合成一个对象，并随后如何操作这些属性（面向对象编程范式）。
- en: 11.1 Variables as Placeholders for Data.
  id: totrans-9
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 11.1 变量作为数据的占位符。
- en: Variables are tools with which we record data in programs. As in mathematics,
    variables act as `placeholders` that we can address by their name, as with the
    `identifiers` discussed in ► Chap. [10](474412_1_En_10_Chapter.xhtml). As the
    name suggests, their content is variable, so we can store different data in the
    variable (one after the other), but no matter what the current content of the
    variable may be, it is always accessible via their identifier.
  id: totrans-10
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 变量是我们在程序中记录数据的工具。与数学中的变量一样，变量充当 `占位符`，我们可以通过它们的名称来访问它们，就像在►第[10章](474412_1_En_10_Chapter.xhtml)讨论的
    `标识符` 一样。顾名思义，变量的内容是可变的，因此我们可以在变量中存储不同的数据（一个接一个），但是无论变量当前的内容是什么，都可以通过它们的标识符访问。
- en: A variable is comparable to a box that we label. The label, or the name or identifier,
    always remains the same, even if we change the contents of the box. The contents
    of the box should match the label to some extent, otherwise confusion arises.
    It is exactly the same with variables.
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 变量类似于一个我们标记的盒子。标签或名称或标识符始终保持不变，即使我们改变盒子的内容。盒子的内容应与标签相匹配，否则会引起混乱。变量也是如此。
- en: In general, we are quite free in choosing the name of the variable. However,
    as you have already seen in the previous chapter, there are some language-specific
    basic rules that must be observed. These rules usually dictate which characters
    may appear in the name of a variable (certain special characters such as `%` or
    `#` are usually not allowed). In addition, many programming languages also specify
    which characters may or even must appear at the beginning of a variable name.
    In `R`, for example, variable names may not begin with a digit, in `PHP` variable
    names `must` begin with the dollar sign (`$`). However, as you will remember from
    the last chapter, it is important not only to follow these “hard” rules, the violation
    of which will inevitably lead to the compiler or interpreter refusing to obey
    you, but also to name variables meaningfully and `consistently.` Meaningful in
    this context means that you can tell the content or purpose of the variable from
    its name. Consistent means that you ideally always form variable names in the
    same way, for example, always capitalize and lowercase the parts of compound variable
    names in the same way. Let’s say you are developing a web-shop and want to store
    the number of orders a customer placed in the last `12 months` in a variable.
    This variable could be called, for example, `CountOrders12Months`, but also `CntOrd12M`
    or `cntOrd12M` or `Count_Orders_12_Months` or … The possibilities are numerous,
    and there are few limits to creativity. For the readability and comprehensibility
    of the program code, it is important that you think about a system, how you want
    to form variable names, and then follow this system as consistently as possible.
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一般来说，我们在选择变量名称时相对自由。然而，正如你在上一章中所看到的，仍然有一些特定于语言的基本规则必须遵守。这些规则通常规定了变量名称中可以出现哪些字符（某些特殊字符，如`%`或`#`，通常是不允许的）。此外，许多编程语言还规定了变量名开头可以或必须包含的字符。例如，在`R`中，变量名不能以数字开头，而在`PHP`中，变量名`必须`以美元符号（`$`）开头。然而，正如你从上一章记得的那样，遵循这些“硬性”规则不仅很重要，而且变量的命名要有意义并且`一致`。在这个上下文中，有意义意味着你可以通过变量名了解它的内容或目的；而一致则意味着你应该尽可能以相同的方式形成变量名，例如，始终以相同的方式对复合变量名的各个部分进行大小写处理。假设你正在开发一个网上商店，并希望将一个顾客在过去`12个月`内下的订单数量存储在一个变量中。这个变量可以命名为`CountOrders12Months`，也可以是`CntOrd12M`、`cntOrd12M`、`Count_Orders_12_Months`，或者其他形式。可能性很多，创造力几乎没有限制。为了程序代码的可读性和可理解性，重要的是你要思考出一种命名规则，然后尽可能一致地遵循这一规则。
- en: '`11.2 Data Types of Variables`'
  id: totrans-13
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`11.2 变量的数据类型`'
- en: '`11.2.1 Different Types of Data Require Different Types of Variables`'
  id: totrans-14
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`11.2.1 不同类型的数据需要不同类型的变量`'
- en: So far, we haven’t talked about what `kind of information` a variable can hold,
    such as a number or a text. For the compiler or interpreter of your programming
    language, this makes a difference, for at least two reasons.
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论变量可以存储什么样的`信息`，比如数字或文本。对于你的编程语言的编译器或解释器来说，这一点是有区别的，至少有两个原因。
- en: For one thing, the compiler or interpreter of your language must reserve memory
    for the variable. It is obvious that a long text (for example, a street name)
    requires more memory than a number (for example, a house number). If you first
    assign a number to a variable, let’s say the house number `58`, your compiler
    or interpreter then makes sure that enough memory is reserved to store a number.
    If then you assign a long text to the same variable, for example the address `"Times
    Square, Manhattan, NY"`, the space initially reserved is no longer sufficient.
    Additional memory space must be found, possibly at a completely different location
    in memory.
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 其一，编译器或解释器需要为变量分配内存。显然，一段长文本（例如，一个街道名称）需要的内存比一个数字（例如，门牌号）要多。如果你先给一个变量赋一个数字，比如门牌号`58`，编译器或解释器会确保为存储数字分配足够的内存。如果你接着给同一个变量赋予一段长文本，例如地址`"Times
    Square, Manhattan, NY"`，最初分配的内存就不再足够。必须找到额外的内存空间，可能是在内存中的完全不同位置。
- en: Secondly, very different operations can be performed with numbers and texts.
    For example, you can multiply a number by another number. With a text, these operations
    make no sense. In the worst case, the program will even crash if you perform an
    operation that is not allowed for the kind of data your variable contains. Therefore,
    it makes sense to check at times whether the data in a variable is of the “right”
    kind, has the right data type, in programming terms.
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 其次，不同的数据类型可以进行不同的操作。例如，你可以将一个数字乘以另一个数字。但对于文本而言，这些操作是没有意义的。在最坏的情况下，如果你对变量所包含的数据类型进行不允许的操作，程序甚至可能崩溃。因此，时常检查一个变量中的数据是否为“正确”的类型，即是否具有正确的数据类型，在编程中是有意义的。
- en: 'The data type of a variable describes what kind of information can be stored
    in it. In this respect, a data type specifies, for example, whether a variable
    should hold `integers`, `fractional numbers`, or `texts`. In practice, however,
    data types differ not only in the type of data they cover. They also differ in
    terms of the range of values or length of information they can hold: A variable
    that is intended for a text and provides 10 characters for it, will store “Peter
    Miller” as “Peter Mill” (the space counts also as a character here). In an `integer`
    variable whose value range is from `0` to `65,535` (that’s a value range you can
    cover with two bytes), you won’t be able to store a negative account balance of
    `–254 USD`. In the same way, an `integer` variable with the value range from `–32,768`
    to `32,767` (which also requires two bytes of memory) will not be able to handle
    an account balance of `50,000 USD`. Data types therefore have different value
    ranges, which – just like the basic type of information for which they are intended
    – limits the data they can hold. In the case of data types for floating-point
    numbers, such as fractional decimal numbers like `3.1415926`, another characteristic
    comes into play in the form of precision, or the number of decimal places. Accuracy
    matters. Whether you receive the gold medal at a skiing or speed skating world
    championship together with a competitor, or come in second behind this competitor,
    may depend on whether the result is measured in hundredths of a second (and both
    athletes have the same result and would therefore both be declared winners) or
    whether thousandths of a second are also taken into account, and a small difference
    between the two times then becomes apparent.'
  id: totrans-18
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 变量的数据类型描述了它可以存储什么类型的信息。在这方面，数据类型指定了一个变量应该保存 `整数`、`分数` 还是 `文本`。然而，在实践中，数据类型不仅在它们涵盖的数据类型上有所不同。它们在可以存储的数据范围或信息长度方面也有所不同：一个为文本设计并为其提供10个字符的变量，将会把“Peter
    Miller”存储为“Peter Mill”（其中空格也算作一个字符）。在一个值范围为 `0` 到 `65,535` 的 `整数` 变量中（这个值范围可以用两个字节来表示），你将无法存储负数账户余额
    `–254 USD`。同样，一个值范围从 `–32,768` 到 `32,767` 的 `整数` 变量（也需要两个字节的内存）将无法处理 `50,000 USD`
    的账户余额。因此，数据类型有不同的值范围，这些范围就像它们所针对的基本信息类型一样，限制了它们可以存储的数据。在浮点数数据类型的情况下，比如像 `3.1415926`
    这样的分数十进制数，另一个特点则是精度或小数位数。精度很重要。无论你和竞争对手一起获得滑雪或速度滑冰世界锦标赛的金牌，还是在这位竞争者之后名列第二，都可能取决于结果是否以百分之一秒为单位进行测量（如果两名运动员的成绩相同，则两人都会被宣布为冠军），或者千分之一秒是否也被考虑在内，并且两者之间的微小差距才显现出来。
- en: '`11.2.2 Important Data Types`'
  id: totrans-19
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`11.2.2 重要数据类型`'
- en: 'The basic data types are quite similar in most programming languages. Usually
    there are data types for:'
  id: totrans-20
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 基本数据类型在大多数编程语言中非常相似。通常有以下几种数据类型：
- en: '`Integers`'
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`整数`'
- en: These data types take `integers` such as `–4`, `–3`, `–2`, `0`, `1`, `2`, `3`,
    `4`. Optionally, there are data types that take only positive integers (including
    zero), that is, natural numbers. `Integer` data types in many programming languages
    have a name that includes the word `integer`, or an abbreviation of it. Classical
    names of such data types are `integer` or `int`. For `integer` data types with
    a particularly large value range, i.e., the possibility of storing very large
    numbers, they are also often called `bigint`, `long int` or simply `long`.
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这些数据类型接受 `整数`，例如 `–4`、`–3`、`–2`、`0`、`1`、`2`、`3`、`4`。可选地，还有只接受正整数（包括零）的数据类型，即自然数。在许多编程语言中，`整数`数据类型的名称通常包括“integer”一词，或者它的缩写。此类数据类型的经典名称有
    `integer` 或 `int`。对于具有特别大值范围的 `整数` 数据类型，即能够存储非常大数字的类型，它们通常也被称为 `bigint`、`long
    int` 或简称 `long`。
- en: '`Floating-Point Values`'
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`浮点值`'
- en: Floating point data types take fractional decimal numbers, such as `1.7` or
    `3.141459`. Of course, integers can also be represented as floating-point numbers,
    e.g., `4` as `4.0`. Accordingly, all integers can also be stored in floating-point
    variables.
  id: totrans-24
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 浮动点数据类型可以表示分数的小数数字，例如`1.7`或`3.141459`。当然，整数也可以表示为浮动点数，例如将`4`表示为`4.0`。因此，所有整数也可以存储在浮动点变量中。
- en: If this is so, the question naturally arises why one needs integer variables
    at all and does not simply always work with floating-point variables. The reason
    is mainly the larger memory requirement of floating-point values, because they
    must store the fractional part of the decimal point as well as the digits before
    the decimal point, or they have to keep capacity for its storage, even if the
    fractional part after the decimal point is always zero, as is the case for integer
    numbers. The problem is that our compiler or interpreter does not know in advance
    that we only want to store integer values. Therefore, it always reserves as much
    memory as it needs to store a fractional decimal number. If you need a lot of
    such floating-point variables at once, this will result in a noticeably higher
    memory requirement.
  id: totrans-25
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果是这样，问题自然就来了，为什么需要整数变量，而不是总是使用浮动点变量。原因主要在于浮动点值的内存需求更大，因为它们不仅需要存储小数点前的数字，还要存储小数点后的分数部分，或者即便小数点后的部分始终为零（就像整数一样），也需要为其存储留出空间。问题在于，我们的编译器或解释器无法预先知道我们只想存储整数值。因此，它总是预留足够的内存来存储一个浮动小数。如果你同时需要大量这样的浮动点变量，内存需求就会明显增加。
- en: There are a number of names for floating-point data types in different programming
    languages, such as `real` (for real numbers) or `float`. In most languages there
    is – analogous to `integer` and `long integer` – another floating-point data type,
    which offers higher precision (i.e., more decimal places) and a larger range of
    values. In most cases, names such as `double` or even `long double` already indicate
    the higher precision.
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在不同的编程语言中，浮动点数据类型有多个名称，例如`real`（表示实数）或`float`。在大多数语言中，有一个类似于`integer`和`long
    integer`的浮动点数据类型，它提供更高的精度（即更多的小数位）和更大的数值范围。在大多数情况下，像`double`甚至`long double`这样的名称已经表示了更高的精度。
- en: Characters and Strings
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 字符与字符串
- en: Individual characters, such as letters, are not dissimilar to integers, because
    every character that the computer understands, i.e., that is part of its `character
    set`, can also be encoded as a number. Well-known character sets are `ASCII` or
    `Unicode`. Although there is a close connection between characters and numbers,
    most programming languages have a special data type for individual characters,
    often with a name based on the word `character`. Accordingly, many languages have
    a character type `char` for individual characters.
  id: totrans-28
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 单个字符，如字母，与整数并没有太大区别，因为计算机可以理解的每个字符，即属于其`字符集`的一部分，也可以编码为数字。众所周知的字符集有`ASCII`或`Unicode`。尽管字符与数字之间有着紧密的联系，大多数编程语言为单个字符提供了特殊的数据类型，通常其名称基于“字符”一词。因此，许多语言为单个字符定义了`char`类型。
- en: Entire texts are ultimately sequences of characters, or `strings`. Some programming
    languages therefore do not know a separate type for character strings but build
    character strings from a string of individual character variables. Here, a more
    complex data type is created from a simple data type, in which many variables
    of the simple data type are practically connected in series. This kind of series
    connection is called an `array`, a construction we will deal with more intensively
    later.
  id: totrans-29
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 整篇文本最终都是字符的序列，或称`字符串`。因此，一些编程语言并没有单独的字符字符串类型，而是通过将多个单独的字符变量串联在一起构建字符串。在这里，一个复杂的数据类型是由一个简单的数据类型构成的，多个简单数据类型的变量实际上是串联在一起的。这种串联方式称为`数组`，我们稍后将更深入地讨论这种结构。
- en: Other languages do have a special data type for strings, which is often simply
    called `string`. This somewhat shields the programmer from the nature of the string,
    namely that it consists of different characters strung together. For him, it then
    “feels” as if the text is a single variable and not composed of individual variables
    arranged in a field.
  id: totrans-30
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 其他语言则有专门的字符串数据类型，通常简单地称为`string`。这在一定程度上将程序员与字符串的本质隔离开来，即字符串是由多个字符拼接在一起的。对于程序员而言，它“感觉”就像是文本是一个单一的变量，而不是由在字段中排列的多个单独变量组成的。
- en: However, strings can often contain not only letters, digits and special characters
    (such as punctuation marks, `#, <`, `>`, `*****`, `~`), but also so-called escape
    sequences. These are special control instructions. In practice, the most important
    one marks a line break and is represented as `\n`。The backslash (`\`) tells the
    interpreter or compiler that the following character is not a letter but a control
    statement; the `n` itself stands for `new line`。Thus, the string `"Mr./Mrs.\nFirstName
    Name\nStreet\nZIP City"` would be interpreted as
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，字符串往往不仅包含字母、数字和特殊字符（如标点符号、`#, <`、`>`、`*****`、`~`），还包含所谓的转义序列。这些是特殊的控制指令。实际上，最重要的一个是表示换行符的`\\n`。反斜杠（`\`）告诉解释器或编译器，后面的字符不是字母，而是控制语句；`n`本身代表`新行`。因此，字符串`"Mr./Mrs.\nFirstName
    Name\nStreet\nZIP City"`将被解释为：
- en: '`Mr/MrsFirstName NameStreetZIP city`'
  id: totrans-32
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Mr/MrsFirstName NameStreetZIP city`'
- en: 'Wherever the escape sequence `\n` is encountered, a line break is inserted.
    While the escape sequence marks the position of the line break within the string,
    certain program functions – such as those for outputting strings to the screen
    – “understand” the encoding and implement it accordingly. Besides `\n`，there are
    several other escape sequences, for example `\t` for a tabulator jump. Escape
    sequences solve another common problem: In most programming languages, strings
    are enclosed by single (`''`) or double (`"`) quotes. But what if a string is
    supposed to contain a quote, for example, so how do the quotes need to be `real
    characters` within the string? Consider the following string:'
  id: totrans-33
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 每当遇到转义序列`\n`时，就会插入一个换行符。虽然转义序列标记了字符串中换行的位置，但某些程序功能——例如用于将字符串输出到屏幕上的功能——会“理解”该编码并相应地执行。除了`\n`，还有几个其他转义序列，例如`\t`表示制表符跳转。转义序列还解决了另一个常见问题：在大多数编程语言中，字符串由单引号（`'`）或双引号（`"`）包围。那么，如果一个字符串应该包含引号，该怎么做呢？例如，如何让引号在字符串中成为`真实字符`？考虑以下字符串：
- en: '`"He said, "I love you!""`'
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`"他说，"我爱你！""`'
- en: 'It is enclosed in double quotes, but contains a quote that itself uses double
    quotes. Normally, the interpreter or compiler would refuse to follow us here.
    It would first recognize a string `"He said: "`。However, this is followed (without
    this being understood as a string) by `I love you!` followed by an empty string
    (`""`)。The `I love you!` would probably cause problems, because it will not be
    a valid statement in the respective programming language, so outside of a string
    the interpreter or compiler would try to interpret it as a statement. So what
    to do? Apart from the trivial solution of simply using single quotes for the quote
    inside the string, the “inner” double quotes can also simply be `escaped`，as follows:'
  id: totrans-35
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '它被双引号包围，但包含一个本身使用双引号的引号。通常，解释器或编译器会拒绝执行此操作。它首先会识别字符串`"He said: "`。然而，接着（而不会被理解为字符串）是`I
    love you!`，后面跟着一个空字符串（`""`）。`I love you!`可能会引发问题，因为它在相应的编程语言中不是一个有效的语句，因此在字符串外，解释器或编译器会尝试将其解释为一个语句。那么该怎么做呢？除了简单地使用单引号包裹字符串中的引号外，还可以通过转义“内部”的双引号，如下所示：'
- en: '`"He said: \"I love you!\""`'
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`"他说：\"我爱你！\""`'
- en: The backslashes tell the interpreter or compiler that the following quotation
    mark should be understood as `part of the string`，not as its delimiter.
  id: totrans-37
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 反斜杠告诉解释器或编译器，后面的引号应该被理解为`字符串的一部分`，而不是它的分隔符。
- en: 'But what if there should be a backslash in the string? For example, in this
    string:'
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 但是，如果字符串中应该有一个反斜杠呢？例如，在这个字符串中：
- en: '`"\n is an escape sequence."`'
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`"\n 是一个转义序列。" `'
- en: 'The escape sequence `\n` would normally lead to an undesired line break within
    the string. Masking by the backslash helps here too, only this time the existing
    backslash itself is masked, because it should be understood as part of the text
    and not as the start of a control statement. So:'
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 转义序列`\n`通常会导致字符串中出现不希望的换行符。反斜杠的屏蔽也有助于解决这个问题，只不过这次是屏蔽了现有的反斜杠本身，因为它应该被理解为文本的一部分，而不是控制语句的开始。因此：
- en: '`"\\n is an escape sequence."`'
  id: totrans-41
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`"\\n 是一个转义序列。"`'
- en: This string would result in the correct output. Escaping the backslash itself
    is especially important when you code paths on Windows systems, for example `C:\\Home\\My
    source codes`。A common cause of errors is that escaping is forgotten in strings
    like this.
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这个字符串会产生正确的输出。特别是在Windows系统上编写路径时，转义反斜杠本身非常重要，例如 `C:\\Home\\My source codes`。一个常见的错误原因是，像这样的字符串中忘记了转义。
- en: 转义序列在许多编程语言中使用，例如在`C`、`Python`、`Perl`或`R`中。
  id: totrans-43
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 转义序列在许多编程语言中使用，例如在`C`、`Python`、`Perl`或`R`中。
- en: Truth/Logical Values
  id: totrans-44
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 真值/逻辑值
- en: 几乎所有编程语言都有一个特殊的数据类型，用于表示语句的真值内容，即`true`或`false`。在这个上下文中，我们通常称之为`boolean`（以19世纪的英语数学家和逻辑学家`George
    Boole`命名）或`logical`变量。与我们迄今为止考虑的数据类型不同，布尔变量仅允许存储两种不同的值：`true`和`false`。这与可以存储`任何`整数的整数变量完全不同。在大多数编程语言中，这两个真值有特殊标识符，通常是`true`和`false`，以便布尔变量可以轻松赋值或比较，而这些赋值和比较在程序代码中也易于阅读。由于有易于理解的标识符`true`和`false`，编程语言通常只存储`1`和`0`作为布尔变量的值。从这个意义上说，布尔变量大多只是整数变量，编译器或解释器负责确保它们仅有两个可能的值，这些值通常可以通过特殊标识符方便地访问，通常只是`true`和`false`。
  id: totrans-45
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 几乎所有编程语言都有一个特殊的数据类型，用于表示语句的真值内容，即`true`或`false`。在这个上下文中，我们通常称之为`boolean`（以19世纪的英语数学家和逻辑学家`George
    Boole`命名）或`logical`变量。与我们迄今为止考虑的数据类型不同，布尔变量仅允许存储两种不同的值：`true`和`false`。这与可以存储`任何`整数的整数变量完全不同。在大多数编程语言中，这两个真值有特殊标识符，通常是`true`和`false`，以便布尔变量可以轻松赋值或比较，而这些赋值和比较在程序代码中也易于阅读。由于有易于理解的标识符`true`和`false`，编程语言通常只存储`1`和`0`作为布尔变量的值。从这个意义上说，布尔变量大多只是整数变量，编译器或解释器负责确保它们仅有两个可能的值，这些值通常可以通过特殊标识符方便地访问，通常只是`true`和`false`。
- en: 在编程语言中，布尔数据类型通常被称为`bool`、`boolean`或`logical`。
  id: totrans-46
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在编程语言中，布尔数据类型通常被称为`bool`、`boolean`或`logical`。
- en: Other Data Types
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 其他数据类型
- en: 这些数据类型几乎可以在所有现代高级语言中找到，尽管它们的名称、值范围和精度不同。此外，大多数编程语言还有几种其他更复杂的数据类型，通常基于你刚刚了解的简单类型。
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这些数据类型几乎可以在所有现代高级语言中找到，尽管它们的名称、值范围和精度不同。此外，大多数编程语言还有几种其他更复杂的数据类型，通常基于你刚刚了解的简单类型。
- en: 一些语言，例如，有（至少）一种特殊数据类型用于日期或时间。如果你想存储日期和时间，似乎没有其他选择，只能将天、月、年、小时、分钟和秒作为整数存储，然后将它们“组装”成某种复杂数据类型。这确实是一个常用的解决方案，但还有其他方法。例如，使用UNIX操作系统的系统，其时间从1970年代开始，仅使用一个整数来表示自1970年1月1日0:00
    GMT以来经过的秒数。例如，千年之交，即2000年1月1日0:00，在纽约市对应的Unix时间为946,702,800。这个时间概念也被称为`UNIX Epoch`。因此，日期也可以用一个数字表示，但在许多编程语言中，它被视为一种单独的数据类型，尽管最终它是一个整数。
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一些语言，例如，有（至少）一种特殊数据类型用于日期或时间。如果你想存储日期和时间，似乎没有其他选择，只能将天、月、年、小时、分钟和秒作为整数存储，然后将它们“组装”成某种复杂数据类型。这确实是一个常用的解决方案，但还有其他方法。例如，使用UNIX操作系统的系统，其时间从1970年代开始，仅使用一个整数来表示自1970年1月1日0:00
    GMT以来经过的秒数。例如，千年之交，即2000年1月1日0:00，在纽约市对应的Unix时间为946,702,800。这个时间概念也被称为`UNIX Epoch`。因此，日期也可以用一个数字表示，但在许多编程语言中，它被视为一种单独的数据类型，尽管最终它是一个整数。
- en: This example also nicely illustrates the role of the value range in data types.
    Systems running on `UNIX` did not have a year 2000 problem. However, they will
    run into trouble for this on Tuesday, January 19, 2038 at 3:14:08 `UTC`. This
    is because the data type used by `UNIX` (at least on the older systems) to store
    the time will then reach the value `2,147,483,647` and thus the limit of its value
    range. This data type cannot store larger numbers. So, what happens one second
    later, at 3:14:09? The date value measured in seconds will jump back to its smallest
    possible value, `–2,147,483,648`。According to `Unix` chronology, this corresponds
    to a time in December 1913。The developers of `Unix`, of course, knew this, but
    accepted it; the year 2038 was still far away from the perspective of the 1970s,
    and data types with a larger value range were not available.
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这个例子也很好地说明了数据类型中值范围的作用。运行在`UNIX`上的系统没有遇到2000年问题。然而，它们将在2038年1月19日星期二3:14:08
    `UTC`遇到麻烦。原因是，`UNIX`使用的数据类型（至少在老旧系统中）来存储时间将会达到`2,147,483,647`，也就是它的值范围的上限。这个数据类型无法存储更大的数值。那么，1秒钟后，3:14:09会发生什么呢？以秒为单位的日期值会回跳到其最小值`–2,147,483,648`。根据`Unix`的时间线，这对应的是1913年12月的某个时间。`Unix`的开发者当然知道这一点，但接受了它；从1970年代的角度来看，2038年还很遥远，并且当时并没有更大值范围的数据类型可用。
- en: But the example shows very well that you have to think about whether the data
    type you intend to use is really sufficient for the intended purpose, or whether
    you need a data type with a larger range of values (if you have one available,
    unlike the `UNIX` developers).
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 但是这个例子很好地说明了，你必须考虑你打算使用的数据类型是否足够满足预期的用途，或者是否需要一个具有更大数值范围的数据类型（如果你有这样的选择，而不是像`UNIX`开发者那样没有选择）。
- en: Date/time is an example of a data type that exists in many languages alongside
    the other data types discussed above. In addition, there are often other data
    types, such as for enumerations. In variables of these types, categorical data
    can be stored, i.e., data that can only have certain distinct values, for example
    the sex of a person, their highest school-leaving qualification, or a car color.
    In this sense, they are like `boolean` variables, except that the number of possible
    values may well be more than two. Often, such `enumerations` (`sets` or `factors`)
    are special data types in a programming language even though “under the hood”
    they are essentially stored as `integers` (each category/value is represented
    by a specific number).
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 日期/时间是许多编程语言中存在的一个数据类型，它与上述讨论的其他数据类型一起存在。此外，通常还有其他数据类型，例如枚举类型。在这些类型的变量中，可以存储分类数据，即只能有特定值的数据，例如人的性别、最高学历或汽车颜色。从这个意义上说，它们与`boolean`变量类似，不同之处在于它们的可能值个数通常超过两个。通常，这类`枚举`（`集合`或`因子`）是编程语言中的特殊数据类型，尽管“底层”它们本质上是以`整数`形式存储的（每个类别/值由一个特定的数字表示）。
- en: Date values, strings, and enumerations are all examples of data types that are
    based on simpler data types. When we discussed strings which can be thought of
    as consisting of a sequence of characters you already became acquainted with the
    field as a way of combining variables into a more complex data type. Besides fields,
    we will later take a closer look at another possibility, the core idea of which
    is to combine variables of `different` types into one object. Such an object then
    often represents a real object with its central properties, for example a car,
    which can be described by its age in years (`integer`), its brand (`string`),
    and its color (`enumeration`), among other things.
  id: totrans-53
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 日期值、字符串和枚举都是基于更简单数据类型的数据类型的例子。当我们讨论字符串时，您已经了解到它可以被视为由一系列字符组成的字段，作为将变量组合成更复杂数据类型的一种方式。除了字段，我们稍后还会仔细研究另一种可能性，其核心思想是将`不同`类型的变量组合成一个对象。这样的对象通常代表一个具有核心属性的实际对象，例如一辆车，它可以通过其年龄（`integer`）、品牌（`string`）和颜色（`enumeration`）等特征来描述。
- en: '11.2.3 Changing the Data Type: Conversion of Variables'
  id: totrans-54
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 11.2.3 改变数据类型：变量转换
- en: 有时，您需要更改变量的数据类型。这称为`converting`变量。例如，假设您为在线书店编写了软件。您的程序的用户刚刚输入了他想购买的书籍数量的信息（通常是一本，但有时可能是两本，一本给自己，一本作为礼物）。在结账页面上，您希望向用户显示他们总共订购了多少本书。如果您将数量读入整数变量，这很简单。然而，如果您使用了字符串变量，这就变得问题重重。您的加法将无法成功。为什么这两个变量之间的差异如此重要？
  id: totrans-55
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 有时，您需要更改变量的数据类型。这称为`converting`变量。例如，假设您为在线书店编写了软件。您的程序的用户刚刚输入了他想购买的书籍数量的信息（通常是一本，但有时可能是两本，一本给自己，一本作为礼物）。在结账页面上，您希望向用户显示他们总共订购了多少本书。如果您将数量读入整数变量，这很简单。然而，如果您使用了字符串变量，这就变得问题重重。您的加法将无法成功。为什么这两个变量之间的差异如此重要？
- en: 数据类型，如您在前面的章节中所见，是由变量可以持有的值的范围类型定义的，并且（如果适用）还由（浮点）值存储的精度定义。但是还有另一个特征可以区分数据类型：变量的类型可以进行哪些操作的问题。可以对整数进行加法运算是显而易见的。但字符串呢？您能在数学意义上将两个字符串`"apples"`和`"pears"`相加吗？当然不可以。但`"2"`和`"1"`这两个字符串呢？这些可能是我们在线商店示例中两本书的数量。这两个字符串能加在一起吗？答案是，可能让您感到惊讶的是：不能。
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 数据类型，如您在前面的章节中所见，是由变量可以持有的值的范围类型定义的，并且（如果适用）还由（浮点）值存储的精度定义。但是还有另一个特征可以区分数据类型：变量的类型可以进行哪些操作的问题。可以对整数进行加法运算是显而易见的。但字符串呢？您能在数学意义上将两个字符串`"apples"`和`"pears"`相加吗？当然不可以。但`"2"`和`"1"`这两个字符串呢？这些可能是我们在线商店示例中两本书的数量。这两个字符串能加在一起吗？答案是，可能让您感到惊讶的是：不能。
- en: 编译器或解释器处理您的程序代码时，根本不关心变量中到底包含什么。它只是一串字符，对计算机来说完全没有意义。无论字符串包含字母、数字，还是任何特殊字符如美元符号或下划线，都无关紧要。编译器或解释器对内容不感兴趣。因此，字符串不允许进行加法运算。但如果您现在知道通过在线商店网站读取的字符串变量肯定包含数字，您当然还是想对它们进行计算。该怎么办呢？
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 编译器或解释器处理您的程序代码时，根本不关心变量中到底包含什么。它只是一串字符，对计算机来说完全没有意义。无论字符串包含字母、数字，还是任何特殊字符如美元符号或下划线，都无关紧要。编译器或解释器对内容不感兴趣。因此，字符串不允许进行加法运算。但如果您现在知道通过在线商店网站读取的字符串变量肯定包含数字，您当然还是想对它们进行计算。该怎么办呢？
- en: 解决此问题的关键是改变变量的类型。许多编程语言提供特殊语句，允许您做到这一点，并执行`explicit type conversion`。然而，一些语言也具有`implicit
    type conversion`。在某种意义上，它们并不像之前描述的那样无知，但如果您想计算例如`"2" + 1`（其中`"2"`是字符串值），它们会仔细查看变量及其内容，并会认识到在我们的示例中，如果将字符串`"2"`转换为数字，则可以进行计算。然后，转换会自动执行，而无需您通过特殊语句干预。
  id: totrans-58
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 解决此问题的关键是改变变量的类型。许多编程语言提供特殊语句，允许您做到这一点，并执行`explicit type conversion`。然而，一些语言也具有`implicit
    type conversion`。在某种意义上，它们并不像之前描述的那样无知，但如果您想计算例如`"2" + 1`（其中`"2"`是字符串值），它们会仔细查看变量及其内容，并会认识到在我们的示例中，如果将字符串`"2"`转换为数字，则可以进行计算。然后，转换会自动执行，而无需您通过特殊语句干预。
- en: 'Another example of this is the following calculation: `TRUE – 1`: Here, an
    integer value is subtracted from a Boolean value. Languages that follow a very
    strict type concept would reject this calculation with an error message. Languages
    that support implicit conversion would recognize that `TRUE` is ultimately (in
    most languages) represented by the value `1`, because it is this that is stored
    internally as the truth value. Thus, the value of `TRUE – 1` can be determined.
    In this sense it is even true: `TRUE – 1 = 0 = FALSE`.'
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 另一个例子是以下计算：`TRUE – 1`：这里，从布尔值中减去一个整数值。遵循严格类型概念的语言会因为出现错误而拒绝此计算。而支持隐式转换的语言则会认识到`TRUE`在大多数语言中最终被表示为值`1`，因为它作为真值被内部存储。因此，`TRUE
    – 1`的值可以被确定。从这个意义上讲，甚至可以说是正确的：`TRUE – 1 = 0 = FALSE`。
- en: 'Languages that look very strictly at the adherence to the data types, convert
    little implicitly and possibly even allow little explicit conversion, are called
    `strongly typed`. Here the data types of variables play a big role. At the other
    end of the spectrum are languages where the programmer does not have to specify
    the type of the variables, but where the data type always adapts automatically
    by implicit conversion in such a way that the desired operations can be performed
    as far as possible. Such languages are `weaker typed`. In extreme cases, even
    operations that make no sense at all can be performed without an error message:
    The addition `3 + "My name"` (where `3` is a number, `"My name"` is a string)
    would then perhaps simply result in `3`. The type conversion from `"My name"`
    to a number fails, of course, but the programming language is so weakly typed
    that it just “keeps on calculating” as best it can.'
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 严格要求数据类型的语言，几乎不进行隐式转换，并且可能连显式转换也很少允许，被称为`强类型`语言。在这里，变量的数据类型扮演着重要角色。与此相对的是一些语言，程序员不需要指定变量的类型，而是通过隐式转换，数据类型会自动适应，以便尽可能地执行所需的操作。这些语言被称为`弱类型`语言。在极端情况下，甚至可以执行没有任何意义的操作而不报错：比如
    `3 + "My name"`（其中`3`是一个数字，`"My name"`是一个字符串），这时可能简单地返回 `3`。当然，`"My name"` 到数字的类型转换会失败，但这种编程语言如此弱类型，它仍然会尽最大努力“继续计算”。
- en: What may sound tempting is at the same time dangerous. Because obviously it
    would be bad if the user of our online shop enters the quantity `3` for one book
    and the quantity `"Tom Peterson"` for the other book. We can’t really work with
    this information. In the worst case, our program gets into trouble and produces
    implausible results or even crashes completely. A little more “control” over whether
    the variables are good for the operations you want to perform should not be seen
    as a restriction on your own programming freedom. It is simply an aid to writing
    safer, more stable program code and to detecting errors at an early stage (ideally
    during development and testing, and not at runtime).
  id: totrans-61
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 看起来很诱人的做法同时也充满风险。显然，如果我们在线商店的用户输入了一本书的数量为 `3`，而另一册书的数量为 `"Tom Peterson"`，这将是很糟糕的，因为我们无法真正使用这些信息。在最坏的情况下，我们的程序会遇到问题，产生不合逻辑的结果，甚至完全崩溃。对变量是否适合进行所需操作进行更多的“控制”，不应被视为对自身编程自由的限制。它仅仅是帮助编写更安全、更稳定的程序代码，并在早期（理想情况下是在开发和测试阶段，而不是在运行时）检测错误的一个工具。
- en: 11.3 Creating and Initializing Variables
  id: totrans-62
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 11.3 创建与初始化变量
- en: 'In the last section, you saw that variables can be distinguished according
    to their data type, i.e., according to what kind of information they can store
    and what range of values can be covered with them. Now the question arises - how
    do you create a variable in order to be able to work with it. The “birth” of a
    variable is done differently in different programming languages. Roughly, however,
    two types of languages can be distinguished: Those in which you have to create
    a variable explicitly before using it for the first time, and those that create
    the variable automatically as soon as you use it for the first time.'
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上一节中，你看到变量可以根据其数据类型进行区分，即根据它们能够存储什么类型的信息以及能够覆盖哪些值的范围。现在，问题来了——如何创建一个变量以便能够使用它？不同编程语言中，变量的“诞生”方式是不同的。大致来说，可以将语言分为两种类型：一种是你必须在第一次使用之前显式地创建变量；另一种是在你第一次使用时，变量会自动创建。
- en: Languages of the former kind include `C`, `Visual Basic for Applications (VBA)`,
    and `JavaScript`. Suppose we wanted to assign the value `10` to an integer variable
    called `piececount` in both languages. Before that happens, however, the variable
    must be created. Programmers refer to this as `declaring`, which is the process
    of telling the compiler or interpreter that you want to use this variable from
    now on. The compiler or interpreter then takes over the technical part of variable
    creation.
  id: totrans-64
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 前者类型的语言包括 `C`、`Visual Basic for Applications (VBA)` 和 `JavaScript`。假设我们希望在这两种语言中将值
    `10` 赋给一个名为 `piececount` 的整数变量。但在此之前，变量必须先被创建。程序员称这一过程为 `声明`，即告知编译器或解释器从现在开始使用该变量。然后，编译器或解释器会负责变量创建的技术部分。
- en: 'The declaration of the variable including the assignment of the value `10`
    would look like this in `C`:'
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在 `C` 语言中，变量声明及赋值 `10` 的写法如下：
- en: '`int piececount; piececount = 10;`'
  id: totrans-66
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`int piececount; piececount = 10;`'
- en: '`int piececount` not only declares a new variable `piececount`, but also specifies
    its type as `int`, which in `C` is the integer data type. After this declaration,
    the compiler knows that there is an integer variable called `piececount`, and
    it can be used in the program from now on. Without the declaration, the assignment
    `piececount = 10` would lead to an error message, with which the compiler points
    out that it does not know the variable `piececount` and thus cannot assign a value
    to it.'
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`int piececount` 不仅声明了一个新变量 `piececount`，还指定了它的类型为 `int`，这是 `C` 中的整数数据类型。在这条声明之后，编译器知道有一个名为
    `piececount` 的整数变量，从此可以在程序中使用它。如果没有这条声明，`piececount = 10` 这样的赋值语句会导致错误信息，编译器会指出它不知道变量
    `piececount`，因此无法给它赋值。'
- en: 'The same code section in `VBA` would look like this:'
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在 `VBA` 中，相同的代码部分如下所示：
- en: '`Dim piececount As Integer piececount = 10`'
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Dim piececount As Integer piececount = 10`'
- en: Unlike in `C` (where the declaration was introduced with the type of the variable),
    a special keyword is used here to declare the variable, namely `Dim`, from `to
    dimension`. And that’s actually very good, because what happens when the variable
    is created is that memory is reserved, as much as the data type of the variable
    requires. In this sense, the memory is `dimensioned` according to need.
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与 `C` 不同（在 `C` 中声明时会指定变量的类型），这里使用了一个特殊的关键字来声明变量，即 `Dim`，来源于 `to dimension`。这实际上非常好，因为当变量被创建时，内存会根据变量的数据类型需求进行分配。就此而言，内存是根据需求进行
    `维度化` 的。
- en: 'Some languages like `JavaScript` require a declaration of variables, but no
    type is specified:'
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一些语言，如 `JavaScript`，需要声明变量，但不指定类型：
- en: '`var piececount; piececount = 10;`'
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`var piececount; piececount = 10;`'
- en: Here the compiler or interpreter decides based on the use of the variables,
    which data type it needs. By the assignment `piececount = 10` it becomes clear
    that this must be an integer variable. If the variable is later assigned a value
    that requires a different data type, for example by the assignment `piececount
    = "Not specified"`, then the data type of the variable changes accordingly in
    the background without you as the programmer noticing anything. Unlike in `C`
    or `VBA`, the typing is `implicit`. In `C` and `VBA`, on the other hand, the type
    must be specified `explicitly`; this is why we also speak of `explicitly typed`
    programming languages.
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这里，编译器或解释器根据变量的使用情况决定需要哪种数据类型。通过赋值 `piececount = 10`，可以清楚地知道这必须是一个整数变量。如果以后给该变量赋值一个需要不同数据类型的值，例如通过赋值
    `piececount = "Not specified"`，则该变量的数据类型会在后台相应地发生变化，而你作为程序员并不会注意到任何变化。与 `C` 或
    `VBA` 不同，这里的类型是 `隐式` 的。而在 `C` 和 `VBA` 中，类型必须 `显式` 指定；因此我们也称这些语言为 `显式类型` 编程语言。
- en: You may now ask yourself whether a declaration in JavaScript is really that
    useful, since the type of the variable is not specified at all. If the type has
    to be specified, it can be argued that the compiler or interpreter can check whether
    a variable is unintentionally assigned values that it cannot accept due to its
    data type. This additional check provides security and may prevent troublesome
    errors and strange behavior of the program. After the above declaration, the `C`
    compiler will refuse to work with an assignment such as `piececount = "Not specified"`
    and abort with an error message. This way, the programmer is made aware of the
    fact that he has somehow worked inconsistently in the code.
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可能会问，JavaScript 中的声明是否真的那么有用，因为变量的类型根本没有指定。如果必须指定类型，可以认为编译器或解释器可以检查变量是否意外地被赋予了由于数据类型不匹配而无法接受的值。这一额外的检查提供了安全性，并且可能防止程序出现麻烦的错误和奇怪的行为。在上述声明之后，`C`
    编译器会拒绝处理像 `piececount = "Not specified"` 这样的赋值，并会中止并报错。这样，程序员会意识到自己在代码中某种程度上存在不一致的操作。
- en: Does the necessity to declare a variable the way it is done in JavaScript have
    any benefit for the programmer? Or is it simply a chicanery devised by the inventor
    of the language to drive the users of his invention crazy? As you can imagine,
    this is not the case. There is a point to forcing the programmer to register his
    variables, because that way, the compiler or interpreter knows `which variable
    identifiers` are allowed. If you then make a typo, as happened to the author several
    times while writing these lines, and for example write the assignment `pieccount
    = "Not specified"` (note the missing `e`) in your code, the JavaScript interpreter
    will recognize that you are trying to access a variable that does not exist. This
    is because the variable you declared has a different name. This way you will quickly
    get to the root of the problem and be able to fix it. This would be much more
    difficult if the programming language did not require a declaration. Then the
    statement `pieccount = 10` would simply create a new variable called `pieccount`.
    In that case, you’d probably have some trouble determining what’s causing your
    program not to behave the way you want it to. Uncovering the real cause, namely
    that you are actually working with two different variables, is then considerably
    more time-consuming than if the compiler or interpreter already gives you a “hint”.
  id: totrans-75
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在`JavaScript`中声明变量的必要性对程序员有何益处？还是仅仅是语言发明者设计的一种花招，目的是让使用者感到疯狂？如你所想，这并非如此。强制程序员注册他的变量是有意义的，因为这样，编译器或解释器就知道`哪些变量标识符`是被允许的。如果你接着输入错误，就像作者在写这些代码时曾发生过几次，比如在代码中写了`pieccount
    = "Not specified"`（注意缺少了`e`），JavaScript解释器会识别出你试图访问一个不存在的变量。这是因为你声明的变量名称不同。这样，你会迅速发现问题的根源并能及时修复。如果编程语言没有强制声明，那么语句`pieccount
    = 10`会直接创建一个名为`pieccount`的新变量。在这种情况下，你可能会遇到一些麻烦，无法确定为什么程序没有按预期运行。揭示真正的原因——实际上你正在处理两个不同的变量——会比编译器或解释器提前给出“提示”时花费更多时间。
- en: So sometimes it can be quite helpful to accept a stricter regime. This strictness
    makes it easier to detect and locate problems. If your programming language offers
    the possibility to switch to a stricter mode (which can be achieved in `VBA`,
    for example, by a special option that forces variable declaration), you should
    accept this offer, even if it looks like more control and less freedom at first
    glance.
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 所以有时候接受更严格的规定是非常有帮助的。这种严格性使得问题更容易被发现和定位。如果你的编程语言提供切换到更严格模式的可能性（例如在`VBA`中，可以通过一个特殊选项强制声明变量），你应该接受这个建议，尽管乍一看这似乎是更多的控制和更少的自由。
- en: The strictness that some programming languages impose on their users sometimes
    includes that the declaration of variables is only allowed at the beginning of
    a program, which improves the structure and thus the readability of the code.
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一些编程语言对用户施加的严格性有时还包括，变量只能在程序的开头进行声明，这样可以改善程序结构，从而提高代码的可读性。
- en: 在我们上述的例子中，我们在声明后直接为`variable`赋值。但是如果我们不这样做，但仍然在后面使用该`variable`，例如在屏幕上输出其内容，那么会显示什么呢？换句话说，`variable`“出生”时的值是什么？在过去，`variables`在声明后往往会有一个随机值，即操作系统释放的内存区域中当前存在的值，这个值是由之前使用同一内存区域但没有“清理”的程序留下的残余。因此，对任何程序员来说，一个非常重要的建议是始终在开始时为他的`variables`加载一个值，即`initialize`它们，或给它们一个明确的、已知的内容。这可以防止程序由于“奇怪”的`variable`内容而崩溃或表现得不可预测。
  id: totrans-78
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在我们上述的例子中，我们在声明后直接为`variable`赋值。但是如果我们不这样做，但仍然在后面使用该`variable`，例如在屏幕上输出其内容，那么会显示什么呢？换句话说，`variable`“出生”时的值是什么？在过去，`variables`在声明后往往会有一个随机值，即操作系统释放的内存区域中当前存在的值，这个值是由之前使用同一内存区域但没有“清理”的程序留下的残余。因此，对任何程序员来说，一个非常重要的建议是始终在开始时为他的`variables`加载一个值，即`initialize`它们，或给它们一个明确的、已知的内容。这可以防止程序由于“奇怪”的`variable`内容而崩溃或表现得不可预测。
- en: 今天，大多数编程语言会自动初始化`variables`，数值`variables`初始化为`0`，字符串初始化为空字符串。一些语言甚至对用户未显式初始化的`variables`有一个特殊值，比如在`JavaScript`中的`undefined`。这个值表示该`variable`尚未具有真实的值，因为它还没有被初始化。许多语言还有另一个值，表示用户故意留空该`variable`的值（想想在调查中未回答的问题，例如）。在`JavaScript`中，例如，这个值是`null`（与数字`0`不同），在`Delphi/Object
    Pascal`中是`nil`，在`R`中是`NA`（表示`not available`）。如果`variable`有这样的值，这表明该`variable`确实被使用，只是它不包含显式的值。换句话说：没有值也是一种值！
  id: totrans-79
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 今天，大多数编程语言会自动初始化`variables`，数值`variables`初始化为`0`，字符串初始化为空字符串。一些语言甚至对用户未显式初始化的`variables`有一个特殊值，比如在`JavaScript`中的`undefined`。这个值表示该`variable`尚未具有真实的值，因为它还没有被初始化。许多语言还有另一个值，表示用户故意留空该`variable`的值（想想在调查中未回答的问题，例如）。在`JavaScript`中，例如，这个值是`null`（与数字`0`不同），在`Delphi/Object
    Pascal`中是`nil`，在`R`中是`NA`（表示`not available`）。如果`variable`有这样的值，这表明该`variable`确实被使用，只是它不包含显式的值。换句话说：没有值也是一种值！
- en: 尽管在今天的许多编程语言中，严格来说不再需要初始化，但这是一个好习惯。通常，初始化可以在声明时直接完成，例如在`C`中。我们上面的例子可以简化为：
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 尽管在今天的许多编程语言中，严格来说不再需要初始化，但这是一个好习惯。通常，初始化可以在声明时直接完成，例如在`C`中。我们上面的例子可以简化为：
- en: '`int piececount = 10;`'
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`int piececount = 10;`'
- en: 11.4 不那么变量的：`Constants`
  id: totrans-82
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 11.4 不那么变量的：`常量`
- en: 另一种语言元素，通常在声明时直接初始化的是`constants`。`Constants`在程序中以特定名称（即其标识符）来表示的值与`variables`相似。然而，与`variables`不同的是，一旦`constants`的值被设定，就不能在程序的后续过程中更改。这保护了`constant`的值不被意外覆盖。通常，`constants`必须在声明时用其（此后称为`constant`）值初始化。以下是来自Pascal的一个例子：
  id: totrans-83
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 另一种语言元素，通常在声明时直接初始化的是`constants`（常量）。`Constants`在程序中通过特定名称（即其标识符）表示的值与`variables`（变量）类似。然而，与`variables`不同的是，一旦`constants`的值被设定，就不能在程序的后续过程中更改。这保护了`constant`的值不被意外覆盖。通常，`constants`必须在声明时用其（此后称为`constant`）值初始化。以下是来自Pascal的一个例子：
- en: '`const pi = 3.14159;`'
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`const pi = 3.14159;`'
- en: 在`C`中，`constant`声明与`variable`声明看起来是一样的，只是多了`const`关键字：
  id: totrans-85
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在`C`语言中，`constant`（常量）声明与`variable`（变量）声明看起来是一样的，只是多了`const`关键字：
- en: '`const int pi = 3.14159;`'
  id: totrans-86
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`const int pi = 3.14159;`'
- en: 11.5 变量/数组的有序字段
  id: totrans-87
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 11.5 变量/数组的有序字段
- en: So far, we have always created single variables. However, most programming languages
    also support`arrays` of variables. An array is an ordered collection of variables
    of the same type that can be addressed under the same name. The individual values
    of the field are accessed via an index.
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在创建单个变量。然而，大多数编程语言也支持`arrays`（数组）变量。数组是同类型变量的有序集合，这些变量可以通过相同的名称进行访问。字段中的各个值通过索引来访问。
- en: In the context of our hypothetical online shop example, we could, for example,
    store the click history, i.e., the sequence of products that the customer has
    looked at, in an array. This is important information when it comes to analyzing
    customer behavior in more detail and making tailored suggestions to the customer
    as to which products might also interest him, as is the case with many online
    shops today.
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在我们假设的在线商店的例子中，我们可以将点击历史记录，即客户查看的产品序列，存储在一个数组中。这在分析客户行为并为客户提供个性化的产品推荐时非常重要，正如今天许多在线商店所做的那样。
- en: In this example, our field could be called`history`。In this field, we would
    sequentially store the IDs of the products that the customer has viewed. Let’s
    assume here that these IDs are integer values. Then we have a field of integer
    variables. We can now use an`index` to access the individual`elements` of the
    field. We could access the fifth element in the click history this way through`history[5]`。In
    the square brackets you see the number of the element that is to be accessed,
    in this case the fifth product that our current customer has looked at.
  id: totrans-90
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的字段可以称为`history`。在这个字段中，我们将按顺序存储客户查看过的产品的ID。假设这些ID是整数值。那么我们就有了一个整数变量的字段。现在我们可以使用`index`来访问字段中的各个`elements`。我们可以通过`history[5]`这种方式来访问点击历史中的第五个元素。在方括号中，你可以看到要访问的元素的编号，在本例中是当前客户查看的第五个产品。
- en: 'Of course, we could have implemented the whole thing with single variables:
    Thus, we could have created variables`history1`、`history2`、`history3`、`history4`、`history5`、`history6`，and
    stored the sequence of products under consideration in these variables. However,
    this has some disadvantages. For one thing, in many languages the variables must
    be explicitly declared. If you envision a click history with, say, 30 products,
    you would have a lot of typing to do just to declare the variables in the first
    place. On the other hand, in practically all languages that support fields, there
    are very efficient mechanisms for traversing those fields, namely by moving the
    index that identifies a field element one position at a time. This way you can
    go through the whole field step by step. The whole thing can be solved very elegantly
    from a programming point of view, so that you do not have to write much code.
    It would be much more complex and maintenance-intensive (think of the case where
    you just want to quickly increase the length of the history from 30 to 100 products)
    if you were to work with individual, independent variables.'
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当然，我们也可以用单个变量来实现整个过程：例如，我们可以创建`history1`、`history2`、`history3`、`history4`、`history5`、`history6`等变量，将考虑中的产品顺序存储在这些变量中。然而，这样做有一些缺点。首先，在许多语言中，变量必须显式声明。如果你设想有一个点击历史记录，假设有30个产品，你会在声明变量时进行大量的输入。另外，几乎所有支持字段的语言都有非常高效的机制来遍历这些字段，即通过逐步移动标识字段元素的索引。这种方式可以一步一步地遍历整个字段。从编程的角度来看，这种方式非常简洁优雅，代码量也少。如果你使用独立的单个变量，解决方案会复杂得多，而且更需要维护（比如说，如果你只想快速将历史记录长度从30个产品增加到100个产品）。
- en: Although virtually all modern high-level languages provide fields, the languages
    differ in one important respect; namely, what the index value of the`first` field
    element is. In many languages, field indices start at 0。Then`history[0]`would
    be the product ID of the first product the user looked at.
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 尽管几乎所有现代高级语言都提供字段，语言之间在一个重要方面有所不同；即`first`字段元素的索引值是什么。在许多语言中，字段的索引从0开始。然后`history[0]`将是用户查看的第一个产品的产品ID。
- en: Fields/arrays can also be multi-dimensional. In our example, we could store
    the click history of all our visitors in one field; we would use a two-dimensional
    field, which we can think of as a table or matrix. The rows would contain the
    users, and the columns would contain the IDs of the products they viewed. Then
    `history[3][1]` would be the ID that website visitor number 3 looked at first
    (assuming our field indexing starts at 1). To access elements of a field, we now
    need two indexes as coordinates that describe exactly where we want to reach in
    our two-dimensional tableau.
  id: totrans-93
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 字段/数组也可以是多维的。在我们的例子中，我们可以将所有访客的点击历史存储在一个字段中；我们会使用一个二维字段，可以将其视为一个表格或矩阵。行表示用户，列表示他们查看的产品ID。然后，`history[3][1]`将是网站访客3查看的第一个产品的ID（假设我们的字段索引从1开始）。要访问字段的元素，我们现在需要两个索引作为坐标，准确描述我们想要在二维表格中到达的位置。
- en: The dimensionality of fields is, of course, by no means limited to two dimensions.
    We could easily add a third, fourth, fifth dimension. All no problem, as long
    as we still have in mind which index (and thus which dimension) stands for which
    “coordinate” we use to store the information in our field. For example, in addition
    to the user, we could also store the day (from 1 = Monday, to 7 = Sunday) and
    thus have a third dimension. Our field would have the structure `history[day][user][productid]`
    and with `history[2][3][1]` we would get the ID of the first product that user
    3 looked at on Tuesday.
  id: totrans-94
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 字段的维度当然不仅限于二维。我们可以轻松地添加第三维、第四维、第五维等。只要我们始终记住哪个索引（因此哪个维度）表示存储信息时使用的“坐标”，这一切都不成问题。例如，除了用户之外，我们还可以存储日期（1
    = 周一，7 = 周日），从而增加一个第三维。我们的字段结构将是`history[day][user][productid]`，通过`history[2][3][1]`我们将获得用户3在星期二查看的第一个产品的ID。
- en: 'Without going into it in detail, we have introduced a notation in the past
    paragraphs to access the individual elements of fields with indexes: We put the
    index number in square brackets. This is actually how many programming languages
    do it, but not all: some put the indexes in `round` brackets. However, the possibilities
    of indexing are not exhausted by simply specifying an index number. Many programming
    languages allow further methods of indexing, for example indexing by exclusion:
    Here, not the index or indices of those elements of the field are specified that
    you want to select, but just the other way around, those that you do not want
    to select. This is often done by prefixing the index with a minus sign. `history[–5]`
    would then be the entire field except for the fifth element. In some programming
    languages, however, a negative value means something else, namely that the field
    is indexed from the end. In this case, `history[–5]` would be the fifth element
    `from` the end. Some languages also offer the specification of a whole range of
    indices: so `history[5:9]` would grab the fifth, sixth, seventh, eighth and ninth
    element of the field. A notation in the form `history[from:to]` not only saves
    typing work but makes it easier especially when the selection limits `from` and
    `to` are not yet known, but variables are used in their place whose values are
    first determined by the program (for example, by a user input).'
  id: totrans-95
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 不详细讨论，我们在前几段中引入了一种符号表示法，用于通过索引访问字段的单个元素：我们将索引号放在方括号中。这实际上是许多编程语言的做法，但并非所有语言都如此：有些语言将索引放在`圆括号`中。然而，索引的可能性不仅仅限于指定一个索引号。许多编程语言还允许使用其他索引方法，例如通过排除进行索引：在这种方法中，您并不是指定要选择的字段元素的索引，而是相反，指定不想选择的那些元素。这通常通过在索引前加上负号来实现。`history[–5]`将表示整个字段，除了第五个元素外。然而，在一些编程语言中，负值有不同的含义，即字段是从末尾开始索引的。在这种情况下，`history[–5]`将是倒数第五个元素。一些编程语言还允许指定一个完整的索引范围：例如，`history[5:9]`将获取字段中的第五、六、七、八和九个元素。`history[from:to]`的符号不仅节省了输入工作，尤其是在选择的限制`from`和`to`尚不确定时，它使得使用程序先确定这些值的变量变得更容易（例如，通过用户输入）。
- en: 'The world of fields is relatively colorful across programming languages. However,
    most of them have the following principles in common:'
  id: totrans-96
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在编程语言中，字段的世界相对多彩。然而，它们中的大多数具有以下共同原则：
- en: 'Fields are combinations of several single variables (however, there are exceptions
    to this fundamental definition): In the statistical language `R`，one-dimensional
    fields, so-called vectors, are even the standard; a single variable is then only
    a special case of such a vector, namely a vector of length one)。'
  id: totrans-97
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 字段是由多个单一变量组成的（不过，这一基本定义也有例外）：在统计语言`R`中，一维字段，即所谓的向量，甚至是标准；单个变量只是这种向量的特例，即长度为一的向量）。
- en: The variables in a field all have the same type (for example, they are all strings,
    or all numbers)。
  id: totrans-98
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 字段中的变量都具有相同的类型（例如，它们都是字符串，或都是数字）。
- en: Fields can be one-dimensional or multidimensional。
  id: totrans-99
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 字段可以是一维的，也可以是多维的。
- en: Individual elements of the fields can be accessed via a numerical index by specifying
    the element to be selected。
  id: totrans-100
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 可以通过指定要选择的元素，使用数值索引访问字段的单个元素。
- en: When creating a field (if variables have to be declared at all) its dimensions
    as well as the type of the field variable have to be specified。
  id: totrans-101
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 创建字段时（如果必须声明变量），必须指定字段的维度以及字段变量的类型。
- en: Beyond that, however, working with fields can differ greatly in different programming
    languages. We had already learned about some of these differences. In summary,
    among other things, the following questions may well be handled very differently
    in different programming languages：
  id: totrans-102
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，除此之外，不同编程语言中处理字段的方式可能差异巨大。我们已经了解了其中的一些差异。总的来说，除了其他方面，不同编程语言中可能会有以下问题处理得非常不同：
- en: Whether the numeric indices start at `0` or at `1`。
  id: totrans-103
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 数值索引是从`0`开始还是从`1`开始。
- en: Whether round or square brackets are used in indexing。
  id: totrans-104
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 是否使用圆括号或方括号进行索引。
- en: What indexing options are available beyond simply specifying the element number。
  id: totrans-105
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 除了简单地指定元素编号之外，还有哪些索引选项可用。
- en: Whether, and if so, which functions are available to work with fields (for example,
    to determine the length of a field or to delete an element from a field)。
  id: totrans-106
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 是否有可用的函数用于处理字段（例如，确定字段的长度或删除字段中的元素）。
- en: Which data types are allowed for fields。
  id: totrans-107
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 字段允许使用哪些数据类型。
- en: The maximum size of fields。
  id: totrans-108
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 字段的最大大小。
- en: Next, let’s look at how fields are actually declared and used in some programming
    languages. In all cases, we want to create a field of six variables that can hold
    the names of a group of people. We then want to set the second name to `"Sophie"`。
  id: totrans-109
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，让我们看看在一些编程语言中如何实际声明和使用字段。在所有情况下，我们都希望创建一个包含六个变量的字段，用于存储一组人的姓名。然后，我们希望将第二个名字设置为`"Sophie"`。
- en: The whole thing first in `Visual Basic for Application (VBA)`：
  id: totrans-110
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 首先是`Visual Basic for Application (VBA)`：
- en: '`Dim names(6) As String` `names(1) = "Sophie"` The same in JavaScript: `var
    names = [];` `names[1] = "Cathy"`'
  id: totrans-111
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Dim names(6) As String` `names(1) = "Sophie"` JavaScript 中相同：`var names =
    [];` `names[1] = "Cathy"`'
- en: As you can see, in JavaScript the size of the array does not have to be specified
    in advance. The indexing also starts here at `0`。
  id: totrans-112
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如您所见，在 JavaScript 中，数组的大小不必预先指定。索引在这里也从`0`开始。
- en: And finally, `Delphi`：
  id: totrans-113
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 最后是`Delphi`：
- en: '`var names: array[1..6] of string;` `names[2] = "Cathy";`'
  id: totrans-114
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`var names: array[1..6] of string;` `names[2] = "Cathy";`'
- en: Here, the value range of the indices can be set explicitly. We set it so that
    it runs from `1` to `6`。 The second element thus has the index `2`。
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这里，索引的值范围可以显式设置。我们将其设置为从`1`到`6`。因此，第二个元素的索引为`2`。
- en: Finally, it should be mentioned that in some programming languages string variables
    are understood as fields of individual characters. The individual characters within
    the string can then be accessed by normal indexing. Consider the following examples
    from C and Python; first the C version：
  id: totrans-116
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 最后，需要提到的是，在某些编程语言中，字符串变量被理解为单个字符的字段。然后，可以通过常规索引访问字符串中的单个字符。以下是 C 和 Python 的示例；首先是
    C 版本：
- en: '`char my_name[] = "Thomas";` `printf("Third character: %c", my_name[2]);`'
  id: totrans-117
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`char my_name[] = "Thomas";` `printf("第三个字符：%c", my_name[2]);`'
- en: Then in `Python`：
  id: totrans-118
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然后是`Python`：
- en: '`my_name = "Thomas"` `print("Third character: ", my_name[2])`'
  id: totrans-119
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`my_name = "Thomas"` `print("第三个字符：", my_name[2])`'
- en: In both cases we grab the character with index `2`，i.e., the third character
    (because both programming languages start the field indexing at `0`) and display
    it. Both languages understand strings as fields, but `C` is much stricter than
    `Python`。
  id: totrans-120
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们获取索引为`2`的字符，即第三个字符（因为这两种编程语言的字段索引都是从`0`开始的），并显示它。两种语言都将字符串视为字段，但`C`语言比`Python`语言更严格。
- en: '`11.6 Associative Fields of Variables/Hashes`'
  id: totrans-121
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`11.6 变量的关联字段/哈希表`'
- en: In addition to the classical ordered fields/arrays, some programming languages
    know a second type of fields, the `associative fields`, sometimes also called
    `hashes`, `dictionaries` or `maps`.
  id: totrans-122
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 除了经典的有序字段/数组外，一些编程语言还知道第二种类型的字段，称为`关联字段`，有时也叫`哈希表`、`字典`或`映射`。
- en: Associative fields consist of an `unordered` set of `key-value pairs`. The key
    can be used to access the respective value. Such key-value pairs could, for example,
    consist of the name of a customer (key) and the order value of his last order
    (value). The entries in an associative field, unlike those in an ordered field/array,
    do not have a natural order; they don’t need one, since the individual elements
    are accessed via a clearly defined key.
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 关联字段由一组`无序`的`键值对`组成。可以使用键来访问相应的值。这些键值对例如可以由客户的姓名（键）和他最后一次订单的订单值（值）组成。与有序字段/数组中的条目不同，关联字段中的条目没有自然顺序；它们不需要顺序，因为每个元素都通过一个明确定义的键来访问。
- en: 'Let’s look at the example of two languages that support associative fields:
    Perl – associative fields are called `hashes` here – and in Python where they
    are called `dictionaries`. First the Perl variant:'
  id: totrans-124
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们来看一个支持关联字段的两种语言的例子：Perl —— 关联字段在这里称为`哈希表` —— 以及 Python，它们称之为`字典`。首先是 Perl
    版本：
- en: '`my` %`ordervalues` = (`"Thomas_Schultz"` => 43.99,`"Jim_Scott"` => 19.49,`"Mary_McGregor"`
    => 68.99,);`$ordervalues{" Mary_McGregor"}` = 8.99;`print(''Last order of Thomas
    Schultz was: $bestellwerte{" Jim_Scott "}'')`;'
  id: totrans-125
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`my` %`ordervalues` = (`"Thomas_Schultz"` => 43.99,`"Jim_Scott"` => 19.49,`"Mary_McGregor"`
    => 68.99,);`$ordervalues{" Mary_McGregor"}` = 8.99;`print(''Last order of Thomas
    Schultz was: $bestellwerte{" Jim_Scott "}'')`;'
- en: As you can see, the upper part of the code first creates a new `hash` field
    called `ordervalues` (hash identifiers in Perl are always preceded by the percent
    sign when speaking of the field as a “whole”). The hash field is immediately initialized
    with three key-value pairs. To the left of the operator `=>` is the key, in this
    case the name of the customer, to the right of the operator the last order value.
    Further down in the code, a special element of the hash field is accessed, once
    to change a value, another time to display a value on the screen. As expected,
    access is not made with a numerical index (after all, the elements in the hash
    field are not sorted), but via the key, in this case the customer name.
  id: totrans-126
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 正如你所看到的，代码的上半部分首先创建了一个新的`hash`字段，名为`ordervalues`（在 Perl 中，当谈论字段作为“整体”时，哈希标识符总是以百分号开头）。该哈希字段立即初始化了三个键值对。在操作符`=>`的左边是键，在本例中是客户的姓名，操作符右边是最后的订单值。在代码的后面部分，哈希字段的一个特殊元素被访问，一次是修改值，另一次是显示屏幕上的值。正如预期的那样，访问不是通过数字索引（毕竟哈希字段中的元素是未排序的），而是通过键，在这种情况下是客户的姓名。
- en: 'Now the same again in Python:'
  id: totrans-127
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在，用 Python 语言实现相同的功能：
- en: '`ordervalues` = `{"Thomas_Schulz" : 43.99," Jim_Scott" : 19.49," Mary_McGregor"
    : 68.99,}` `ordervalues[''Mary_McGregor'']` = 8.99 `print("Last order of Thomas
    Schultz was: ", ordervalues[''Thomas_Schultz''])`'
  id: totrans-128
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`ordervalues` = `{"Thomas_Schulz" : 43.99," Jim_Scott" : 19.49," Mary_McGregor"
    : 68.99,}` `ordervalues[''Mary_McGregor'']` = 8.99 `print("Last order of Thomas
    Schultz was: ", ordervalues[''Thomas_Schultz''])`'
- en: Even if the exact syntax differs slightly in both languages, the parallels in
    dealing with `hashes` or `dictionaries`, as the associative fields are called
    in Python, cannot be overlooked. It becomes clear how easily values can be looked
    up in an associative field – in fact, like a dictionary.
  id: totrans-129
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 即使两种语言的确切语法略有不同，但在处理`哈希表`或`字典`（在 Python 中称为关联字段）时的相似之处是显而易见的。可以清楚地看到，如何轻松地在关联字段中查找值——事实上，就像查字典一样。
- en: The languages that support associative fields usually come with a whole set
    of tools for analyzing and manipulating such fields. For example, functions or
    operators are regularly available to the programmer to extract all keys or all
    values from the field in one fell swoop, or to determine the size of the field,
    that is, the number of key-value pairs it contains.
  id: totrans-130
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 支持关联字段的语言通常配有一整套工具，用于分析和操作这些字段。例如，程序员可以使用常规的函数或操作符来一次性提取所有键或所有值，或者确定字段的大小，即它包含的键值对数量。
- en: 11.1 [3 min]
  id: totrans-131
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 11.1 [3 min]
- en: What is meant by the declaration of variables?
  id: totrans-132
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 变量声明是什么意思？
- en: 11.2 [3 min]
  id: totrans-133
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 11.2 [3 分钟]
- en: Name two advantages of being forced to declare variables.
  id: totrans-134
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 说出声明变量的两个优点。
- en: 11.7 `Objects`
  id: totrans-135
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 11.7 `对象`
- en: In the last two sections, we dealt with fields. Fields allow you to store a
    lot of similar information in an orderly way and to access it again. This is very
    useful in many cases, but often not the easiest or most natural way to deal with
    data.
  id: totrans-136
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在过去的两节中，我们处理了字段。字段让你能够以有序的方式存储大量相似的信息，并且可以再次访问它们。这在许多情况下非常有用，但通常不是处理数据最简单或最自然的方式。
- en: In this section, you will therefore learn about an approach to working with
    related data that is so fundamental that it constitutes a programming paradigm
    of its own. Many programming languages have adopted this approach, in whole or
    in part. Because it shapes many popular languages, such as `C++`, `Java` and `JavaScript`,
    `Python`, and `Kotlin`, it is extremely important in practice.
  id: totrans-137
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在本节中，你将学习一种处理相关数据的方法，这种方法非常基础，甚至构成了一个独立的编程范式。许多编程语言已经采用了这种方法，或多或少都融入了它。由于它塑造了许多流行语言，如`C++`、`Java`、`JavaScript`、`Python`和`Kotlin`，因此在实践中极其重要。
- en: We are talking about `object-oriented programming` (OOP for short). We will
    deal with it quite extensively in this section, and not entirely without ulterior
    motives, since the two programming languages introduced in the third and fourth
    parts of this book also belong to the broad class of `object-oriented languages`.
    In the eyes of not a few contemporaries, `object orientation` is associated with
    attributes such as “difficult to understand” and “complex”. After reading this
    section, however, you will find that such fears are not justified at all.
  id: totrans-138
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们讨论的是`面向对象编程`（简称OOP）。我们将在本节中深入讨论它，并且这一部分并非完全没有动机，因为本书第三和第四部分介绍的两种编程语言也属于`面向对象语言`的广泛类别。在不少当代人的眼中，`面向对象`与“难以理解”和“复杂”这些属性联系在一起。然而，在阅读完本节内容后，你会发现这些担忧完全是没有根据的。
- en: 11.7.1 The World Is Made of Objects
  id: totrans-139
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 11.7.1 世界由对象构成
- en: 'Let’s assume we wanted to program a catalog-like display of products for an
    online store. Each product has a set of properties that we want to display, such
    as: a name, a description, an item number, a manufacturer, a price, and quantity.
    Using the knowledge from the previous sections, we could map each of these properties
    as a separate field/array. Then, for example, there would be an array`itemnumbers`
    and`itemnumbers[187]` would be the item number of the 187th article. If we wanted
    to retrieve the item description for the same item, we would use the array element`descriptions[187]`.'
  id: totrans-140
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 假设我们想为一个在线商店编写一个类似目录的产品展示界面。每个产品都有一组我们希望展示的属性，例如：名称、描述、项目编号、制造商、价格和数量。利用前面章节的知识，我们可以将这些属性映射为单独的字段/数组。例如，会有一个数组`itemnumbers`，`itemnumbers[187]`将是第187个商品的项目编号。如果我们想获取同一商品的描述，我们将使用数组元素`descriptions[187]`。
- en: The leading criterion here is therefore the respective property. The product
    for which we query this property is indicated by the index, in our example, `187`\.
    However, this approach is a little artificial, because in reality we do not normally
    start from the property, but from its carrier.
  id: totrans-141
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里的主要标准因此是各自的属性。我们查询该属性的产品由索引指示，在我们的例子中是`187`。然而，这种方法有点人造，因为实际上我们通常不是从属性开始，而是从它的承载者开始。
- en: 当我们编写我们的目录视图时，我们面临的问题是我们面前有一个`product`，需要显示它的所有相关属性。我们从产品开始，问自己这个产品有哪些属性。于是，我们提取名称、描述、项目编号以及我们希望在目录列表中显示的所有其他属性，并为该特定产品展示这些属性。我们始终从各个可能的角度（其属性）观察同一个`object`，即产品。当你去二手车经销商那里查看他们院子里的待售汽车时也是如此。你查看一辆车，检查模型、颜色、年龄、状况、价格及其他对你评估重要的参数。然后你查看下一辆车，再查看另一辆车。但你总是从一个对象——汽车——开始，查看其各自的特征。
  id: totrans-142
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当我们编写我们的目录视图时，我们面临的问题是我们面前有一个`product`，需要显示它的所有相关属性。我们从产品开始，问自己这个产品有哪些属性。于是，我们提取名称、描述、项目编号以及我们希望在目录列表中显示的所有其他属性，并为该特定产品展示这些属性。我们始终从各个可能的角度（其属性）观察同一个`object`，即产品。当你去二手车经销商那里查看他们院子里的待售汽车时也是如此。你查看一辆车，检查模型、颜色、年龄、状况、价格及其他对你评估重要的参数。然后你查看下一辆车，再查看另一辆车。但你总是从一个对象——汽车——开始，查看其各自的特征。
- en: 你可能已经注意到，这种推理归结为：世界显然不是按属性组织的，而是按对象组织的，无论是产品、汽车、房屋、企业、按钮、电子邮件，还是学生。所有这些物理和非物理对象最终都是属性的总结。从这个意义上说，人或人们所扮演的角色（如“学生”角色）也可以是对象。我们不应对这里的语言选择过于苛刻，尽管起初可能会觉得将客户或同事视为“对象”有些奇怪。但如果我们将对象定义为一组属性，那么很明显，在这个广泛的意义上，人、动物、植物和神也都是“对象”。
  id: totrans-143
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这种推理归结为：世界显然不是按属性组织的，而是按对象组织的，无论是产品、汽车、房屋、企业、按钮、电子邮件，还是学生。所有这些物理和非物理对象最终都是属性的总结。从这个意义上说，人或人们所扮演的角色（如“学生”角色）也可以是对象。我们不应对这里的语言选择过于苛刻，尽管起初可能会觉得将客户或同事视为“对象”有些奇怪。但如果我们将对象定义为一组属性，那么很明显，在这个广泛的意义上，人、动物、植物和神也都是“对象”。
- en: 但如果世界是按对象而非属性组织的，为什么这没有在编程中反映出来？为什么我们在明显关注单个属性的字段中工作，而不是在作为不同属性整体集合的对象中？在1960年代，美国计算机科学家`Alan
    Kay`和其他面向对象编程的先驱们也问过自己这个问题，并因此在真正意义上带来了范式转变。遵循这一新范式的第一种编程语言之一是`Kay`的`Smalltalk`。
  id: totrans-144
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 但如果世界是按对象而非属性组织的，为什么这没有在编程中反映出来？为什么我们在明显关注单个属性的字段中工作，而不是在作为不同属性整体集合的对象中？在1960年代，美国计算机科学家`Alan
    Kay`和其他面向对象编程的先驱们也问过自己这个问题，并因此在真正意义上带来了范式转变。遵循这一新范式的第一种编程语言之一是`Kay`的`Smalltalk`。
- en: 在面向对象编程的概念中，对象处于前景；它体现了这种方法的组织原则。决定我们如何处理数据的不是属性，而是属性的承载者——对象。
  id: totrans-145
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在面向对象编程的概念中，对象处于前景；它体现了这种方法的组织原则。决定我们如何处理数据的不是属性，而是属性的承载者——对象。
- en: 11.7.2 `Classes`
  id: totrans-146
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 11.7.2 `类`
- en: 让我们遵循面向对象的方法，定义一个具有以下属性的对象`product`：
  id: totrans-147
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们遵循面向对象的方法，定义一个具有以下属性的对象`product`：
- en: '`product.name` `product.description` `product.itemnumber` `product.manufacturer`
    `product.price`'
  id: totrans-148
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`product.name` `product.description` `product.itemnumber` `product.manufacturer`
    `product.price`'
- en: 我们通过商店出售的所有产品都有这些属性。为了认识到这些属性都描述了对象“`product`”，我们通过在前面加上`product`来总结它们。
  id: totrans-149
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们通过商店出售的所有产品都有这些属性。为了认识到这些属性都描述了对象“`product`”，我们通过在前面加上`product`来总结它们。
- en: Let us now be a little more precise linguistically. What we have defined there
    is our view of `any` product, it is in a sense the `template for a product`; this
    is what products look like to us, these are their essential characteristics from
    our point of view. Such an abstract template, which describes which properties
    an object has, is called a `class` in object-oriented programming. Each real product
    that we offer has an individual value for each of these properties, for example
    the name “Garden shovel, stainless steel” and a price of 10.99 USD. The actual
    objects whose properties are modeled after our class are called `instances` of
    the class. So, in a way, an instance is the concretization of the abstract idea
    expressed in a class. All our products will have different values for each of
    the properties, so there are as many instances as there are products. But all
    products belong to the same class, they are just products.
  id: totrans-150
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在让我们在语言学上更精确一些。我们在这里定义的是我们对`任何`产品的看法，从某种意义上讲，它是`产品的模板`；这就是我们眼中产品的样子，这些是从我们角度看它们的基本特征。这样一个抽象的模板，描述了一个对象具备哪些属性，在面向对象编程中被称为`类`。我们提供的每一个实际产品，在这些属性上都有不同的取值，例如名称“花园铲，不锈钢”以及价格10.99美元。那些实际的对象，其属性是基于我们的类来建模的，称为该类的`实例`。因此，从某种意义上讲，实例是类中所表达的抽象概念的具体化。我们所有的产品在每个属性上都会有不同的值，所以实例的数量和产品的数量一样多。但所有的产品都属于同一个类，它们都是产品。
- en: 'In the next step, we’ll get a little more formal and define our class as we
    would in a programming language:'
  id: totrans-151
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在下一步中，我们会更加正式地定义我们的类，就像在编程语言中一样：
- en: '`Class` `Product` `Begin` `name : String` `description : String` `itemnumber
    : Integer` `manufacturer : String` `price : DecimalNumber` `End`'
  id: totrans-152
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Class` `Product` `Begin` `name : String` `description : String` `itemnumber
    : Integer` `manufacturer : String` `price : DecimalNumber` `End`'
- en: The properties of the class – we also speak of `attributes` in this context
    – are located between the limiting keywords `Begin` and `End`. This code excerpt
    here is not written in any existing programming language, but is formulated as
    “pseudo-code”, as we will do several times in this part of the book in order to
    illustrate basic principles. The point here is simply to describe, in a formalized
    but easily understood way, what a class definition might look like. Later, you
    will see how class definitions are constructed in some real programming languages
    and will be able to cope with them immediately once you have understood the basic
    concept from this pseudo-code.
  id: totrans-153
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 类的属性——在这个语境中我们也称之为`属性`——位于限制性关键字`Begin`和`End`之间。这里的代码片段并不是用任何现有的编程语言编写的，而是作为“伪代码”来表达的，正如我们在本书的这一部分中多次使用伪代码来说明基本原理。这里的重点仅仅是以一种形式化且易于理解的方式描述类定义可能的样子。之后，你将看到如何在一些真实的编程语言中构建类定义，一旦你理解了这一伪代码中的基本概念，你就能立即应对它们。
- en: 'Now that we have defined which attributes our class should consist of and what
    data type these attributes have, we can create an instance of the class, i.e.,
    a variable that (built along the lines of the class definition) represents a concrete
    product. As soon as the new variable of type `product` is created, we can start
    to adjust its attributes:'
  id: totrans-154
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在我们已经定义了类应包含哪些属性以及这些属性的具体数据类型，我们可以创建一个类的实例，即一个变量，它（按照类定义的方式）代表一个具体的产品。一旦创建了类型为`product`的新变量，我们就可以开始调整它的属性：
- en: '`GardenShovel : Product` `GardenShovel.name = "Garden shovel, stainless steel"`
    `GardenShovel.price = 10.99`'
  id: totrans-155
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`GardenShovel : Product` `GardenShovel.name = "花园铲，不锈钢"` `GardenShovel.price
    = 10.99`'
- en: To access the attributes of the `GardenShovel` instance of our `Product` class,
    we use the dot operator in the form `instance.attribute`. This notation is common
    in many programming languages.
  id: totrans-156
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 要访问我们`Product`类中`GardenShovel`实例的属性，我们使用点运算符，形式为`实例.属性`。这种表示法在许多编程语言中都很常见。
- en: With `Product`，we have created our own data type, which is more complex than
    the data types we learned about in the previous sections, because it stores different
    values. However, we can work with it just as with one of the “built-in” data types
    (such as integers or logical values). For example, we can create variables of
    this type and assign values to them (not to the variable as a whole, but to the
    individual attributes, which are of course elementary variables).
  id: totrans-157
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用`Product`，我们创建了自己的数据类型，它比我们在前几节学习的内建数据类型更复杂，因为它存储了不同的值。然而，我们可以像使用“内建”数据类型（例如整数或逻辑值）一样使用它。例如，我们可以创建该类型的变量并为其赋值（不是为整个变量赋值，而是为各个属性赋值，这些属性当然是基础变量）。
- en: '`11.7.3 Inheritance`'
  id: totrans-158
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`11.7.3 继承`'
- en: 有时候，我们有一些对象是其他对象的特殊案例。例如，书籍是一种特殊的产品。它具有我们产品所拥有的所有属性，包含一个名称（书名）、一个制造商（出版社），当然还有一个价格。此外，它还有一些其他属性，我们也应该在我们的网上商店中展示，例如作者和页数。毕竟，这些信息可能会影响客户的购买决策。
  id: totrans-159
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 有时候，我们有一些对象是其他对象的特殊案例。例如，书籍是一种特殊的产品。它具有我们产品所拥有的所有属性，包含一个名称（书名）、一个制造商（出版社），当然还有一个价格。此外，它还有一些其他属性，我们也应该在我们的网上商店中展示，例如作者和页数。毕竟，这些信息可能会影响客户的购买决策。
- en: 现在，为了将我们的特殊产品“书籍”表示为一个类，面向对象编程中有一个称为`inheritance`的技巧。与这个术语可能暗示的相反，没有人必须死才能继承。然而，基本思想很简单：作为产品的特殊案例，我们的书籍简单地“继承”了产品的所有属性，并且在作者和页数的基础上获得了两个额外的属性。这两个属性使得书籍独特。因此，我们的书籍是一个产品，但并不是每个产品都是书籍。有些产品只有产品的标准属性，而没有作者和页数的特殊属性；这些属性是书籍所独有的。
  id: totrans-160
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在，为了将我们的特殊产品“书籍”表示为一个类，面向对象编程中有一个称为`inheritance`的技巧。与这个术语可能暗示的相反，没有人必须死才能继承。然而，基本思想很简单：作为产品的特殊案例，我们的书籍简单地“继承”了产品的所有属性，并且在作者和页数的基础上获得了两个额外的属性。这两个属性使得书籍独特。因此，我们的书籍是一个产品，但并不是每个产品都是书籍。有些产品只有产品的标准属性，而没有作者和页数的特殊属性；这些属性是书籍所独有的。
- en: 当然，我们可以将书籍具有的额外属性直接包含在`Product`类中。但对于不是书籍的具体实例，我们应该为这些属性赋予什么值呢？如果我们对其他特殊产品类别（例如服装或园艺家具）给予特别处理，会发生什么？这将导致适用于所有产品的属性数量大大增加，而仅适用于单一产品类别，`Product`类会变得非常混乱。
  id: totrans-161
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当然，我们可以将书籍具有的额外属性直接包含在`Product`类中。但对于不是书籍的具体实例，我们应该为这些属性赋予什么值呢？如果我们对其他特殊产品类别（例如服装或园艺家具）给予特别处理，会发生什么？这将导致适用于所有产品的属性数量大大增加，而仅适用于单一产品类别，`Product`类会变得非常混乱。
- en: 使用继承更简单且更优雅。我们创建一个新的类`Book`，它继承上述定义的`Product`类的所有属性，并额外添加页数和作者这两个属性。类`Book`的定义可以如下所示：
  id: totrans-162
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用继承更简单且更优雅。我们创建一个新的类`Book`，它继承了上述定义的`Product`类的所有属性，并额外添加了页数和作者这两个属性。类`Book`的定义可以如下所示：
- en: '`Class Book Inherits Product Begin author : String pages : Integer End`'
  id: totrans-163
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Class Book Inherits Product Begin author : String pages : Integer End`'
- en: 如果将这个类的定义与`Product`类的定义进行比较，您会注意到这里添加了关键字`Inherits`，后面是我们类`Book`要继承的属性的类。我们现在当然可以创建我们类的实例，即具体的变量，并更改它们的属性。
  id: totrans-164
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果将这个类的定义与`Product`类的定义进行比较，您会注意到这里添加了关键字`Inherits`，后面是我们类`Book`要继承的属性的类。我们现在当然可以创建我们类的实例，即具体的变量，并更改它们的属性。
- en: '`Grisham1992 : BookGrisham1992.name = "The Pelican Brief"Grisham1992.price
    = 8.99Grisham1992.author = "John Grisham"Grisham1992.pagenumber = 478`'
  id: totrans-165
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Grisham1992 : BookGrisham1992.name = "The Pelican Brief"Grisham1992.price
    = 8.99Grisham1992.author = "John Grisham"Grisham1992.pagenumber = 478`'
- en: As you can see here, in this code snippet we edit our variable `Grisham1992`
    not only with regard to the special properties of books, namely author and number
    of pages, but also with regard to the standard attributes of products, namely
    name and price. These do not occur explicitly in the definition of the class `Book`。However,
    books inherit these properties from the more general class `Product`，from which
    the class `Book` is derived.
  id: totrans-166
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如您所见，在这段代码中，我们不仅根据书籍的特殊属性（即作者和页数）来编辑变量`Grisham1992`，还根据产品的标准属性（即名称和价格）进行了编辑。这些属性在`Book`类的定义中并没有明确出现。然而，书籍从更一般的类`Product`继承了这些属性，`Book`类就是从`Product`类派生出来的。
- en: Ultimately, we build a `class hierarchy`，with `Product` as the superclass and
    `Book` as the subclass。`Class` hierarchies can of course have much more than two
    levels；for example, we could add novels and encyclopedias as further subclasses
    of books and provide them with special attributes that are not contained in the
    class `book`。In the same way, we could of course extend the hierarchy by modeling
    other product categories besides books (for example, clothing and garden furniture)
    as separate classes that are directly derived from the `Product` class.
  id: totrans-167
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 最终，我们建立了一个`类层次结构`，其中`Product`是超类，`Book`是子类。`类`层次结构当然可以有多个层次；例如，我们可以将小说和百科全书作为书籍的进一步子类，并为它们提供一些不包含在`book`类中的特殊属性。同样，我们当然可以通过将书籍以外的其他产品类别（例如，服装和园艺家具）建模为直接从`Product`类派生出来的单独类，来扩展这个层次结构。
- en: 'Next, let’s take a look at what our two classes, `Product` and `Book`，would
    look like in two real programming languages; we’ll start with `C++`:'
  id: totrans-168
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下我们的两个类，`Product`和`Book`，在两种实际编程语言中会是什么样子；我们先从`C++`开始：
- en: '`class` Product{char designation[30]; char description[200]; long itemnumber;
    char manufacturer[30]; float price;} `class` Book : `public` Product{char author[50];
    int pages;} `// Later in the main program ...` Book grisham1992; Product gardenshovel;
    gardenshovel.name = "Garden shovel, stainless steel"; gardenshovel.price = 10.99;
    grisham1992.name = "The Pelican Brief"; grisham1992.price = 8.99; grisham1992.author
    = "John Grisham"; grisham1992.pages = 478;'
  id: totrans-169
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`class` Product{char designation[30]; char description[200]; long itemnumber;
    char manufacturer[30]; float price;} `class` Book : `public` Product{char author[50];
    int pages;} `// 稍后在主程序中...` Book grisham1992; Product gardenshovel; gardenshovel.name
    = "花园铲， 不锈钢"; gardenshovel.price = 10.99; grisham1992.name = "鹈鹕简报"; grisham1992.price
    = 8.99; grisham1992.author = "约翰·格里isham"; grisham1992.pages = 478;'
- en: Of course, even if you are not familiar with the particular syntax of `C++`，your
    understanding of the concepts of object-oriented programming and our pseudo-code
    will allow you to understand what is happening in this program snippet.
  id: totrans-170
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当然，即使你不熟悉`C++`的特定语法，你对面向对象编程的概念以及我们的伪代码的理解，依然能帮助你理解这个程序片段中发生的事情。
- en: 'Now let’s look at the same thing in`Delphi/Object Pascal`:'
  id: totrans-171
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在让我们看看`Delphi/Object Pascal`中的相同内容：
- en: '`type` TProduct = `Class`(TOBject) `property` Name : String; `property` Description
    : String; `property` ItemNumber: Longint; `property` Manufacturer : String; `property`
    Price : Single; `end`; TBook = `Class`(TProduct) `property` Author : String; `property`
    Pages : Integer; `end`; `// Later in the main program ...` `var` GardenShovel
    : TProduct; Grisham1992 : TBook; GardenShovel.Name = "Garden shovel, stainless
    steel"; GardenShovel.Price = 10.99; Grisham1992.Name = "The Pelican Brief"; Grisham1992.Price
    = 8.99; Grisham1992.Author = "John Grisham"; Grisham1992.Pages = 478;'
  id: totrans-172
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`type` TProduct = `Class`(TOBject) `property` Name : String; `property` Description
    : String; `property` ItemNumber: Longint; `property` Manufacturer : String; `property`
    Price : Single; `end`; TBook = `Class`(TProduct) `property` Author : String; `property`
    Pages : Integer; `end`; `// 稍后在主程序中...` `var` GardenShovel : TProduct; Grisham1992
    : TBook; GardenShovel.Name = "花园铲， 不锈钢"; GardenShovel.Price = 10.99; Grisham1992.Name
    = "鹈鹕简报"; Grisham1992.Price = 8.99; Grisham1992.Author = "约翰·格里isham"; Grisham1992.Pages
    = 478;'
- en: Here we have followed the Delphi-typical notation, that classes (and in general
    all data types defined beyond the basic data types) begin with “T”, our two classes
    are then called accordingly `TProduct` and `TBook`. Behind the keyword `Class`,
    the class from which is inherited is written in brackets. This is the class one
    level higher in the class hierarchy. The interesting thing here is that the class
    `TProduct` also inherits attributes from a higher class, namely from the class
    `TObject`. This class is the highest in the class hierarchy, and all other classes
    are ultimately derived from it.
  id: totrans-173
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这里，我们遵循了典型的Delphi表示法，类（以及一般所有定义的除基本数据类型外的数据类型）都以“T”开头，我们的两个类分别叫做`TProduct`和`TBook`。在`Class`关键字后，继承自的类会用括号写出来，这就是类层级中上一级的类。这里有趣的是，类`TProduct`也从更高一级的类继承了属性，即从`TObject`类继承。这个类是类层级中的最高类，所有其他类最终都是从它派生出来的。
- en: You can see from these examples that class definitions in programming languages
    may have their own peculiarities, but they still have a lot in common. With the
    few basic ideas of object-oriented programming that we have looked at so far,
    you can already understand what the class definitions mean in the respective language
    without a detailed understanding of the programming languages they are written
    in.
  id: totrans-174
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 从这些示例中，你可以看到不同编程语言中的类定义可能有其独特之处，但它们仍然有很多相似之处。通过我们迄今为止了解的几个面向对象编程的基本思想，你已经能够理解各编程语言中类定义的含义，而不需要对它们所用的编程语言有详细的了解。
- en: '`11.7.4 Methods`'
  id: totrans-175
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`11.7.4 方法`'
- en: In the examples of the previous section, we directly changed the attributes,
    i.e., properties of our classes, by assigning values to them. For the “pure doctrine”
    of object-oriented programming, this is sacrilege. According to the “pure doctrine”,
    the attributes may not be edited directly, but only with the help of something
    called `methods`. `Methods` are callable subroutines to which you can pass certain
    values, called `arguments`, and which then process these values in some way, for
    example by assigning the “passed” value to a class property.
  id: totrans-176
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上一节的示例中，我们通过给类的属性赋值，直接修改了我们类的属性。对于面向对象编程的“纯粹教义”来说，这是亵渎。根据“纯粹教义”，属性不能直接编辑，而只能通过所谓的`方法`来进行修改。`方法`是可调用的子程序，你可以向其传递某些值，这些值称为`参数`，然后方法会以某种方式处理这些值，例如将“传递的”值赋给类属性。
- en: 'To make this a bit more concrete, let’s assume that our product class has a
    `setPrice()` method that can be used to edit the price. The method is passed the
    price as an argument, and the method in turn then makes sure that the class property
    `price` is changed accordingly. The class definition would then look like this:'
  id: totrans-177
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为了使这个例子更具体一点，我们假设我们的`Product`类有一个`setPrice()`方法，可以用来编辑价格。该方法将价格作为参数传入，然后方法确保类的`price`属性相应地被更改。类定义看起来会是这样的：
- en: '`Class` `Product` `Begin` `name` : `String` `description` : `String` `itemnumber`
    : `Integer` `manufacturer` : `String` `price` : `DecimalNumber` `setPrice(newprice:
    DecimalNumber)` `End`'
  id: totrans-178
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Class` `Product` `Begin` `name` : `String` `description` : `String` `itemnumber`
    : `Integer` `manufacturer` : `String` `price` : `DecimalNumber` `setPrice(newprice:
    DecimalNumber)` `End`'
- en: 'Our original class has been extended by the method `setPrice()`. This method
    takes as argument `newprice` a decimal/floating point number, namely the price
    we want to set for our product. We could then create a new instance of the `Product`
    class later in the program and initialize the price using the `setPrice()` method,
    here in the example to the price `10.99` USD:'
  id: totrans-179
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们的原始类已经通过`setPrice()`方法进行了扩展。这个方法接受一个参数`newprice`，即我们希望为产品设置的价格，它是一个十进制/浮动点数。然后我们可以在程序的后面创建`Product`类的新实例，并使用`setPrice()`方法初始化价格，下面的例子中，价格为`10.99`美元：
- en: '`GardenShovel` : `Product` `GardenShovel.setPrice(10.99)`'
  id: totrans-180
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`GardenShovel` : `Product` `GardenShovel.setPrice(10.99)`'
- en: Here we see now apparently a substantial difference to the fundamental data
    types, which we became acquainted with so far, such as `integer` or `character
    string` variables. The classes of object-oriented programming not only consist
    of data values, but, with the methods, also contain the tools to process these
    data. But this is only an apparent difference. In fact, even the fundamental data
    types in many object-oriented languages are themselves classes that offer a set
    of methods to the outside world. For example, the `DecimalNumber` class might
    provide a method `round()`; if `price` were a `DecimalNumber` object, that is,
    an instance of the `DecimalNumber` class, then, for example, `price.round(2)`
    would round the value of the variable `price` to two decimal places.
  id: totrans-181
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在我们可以看到与我们到目前为止所熟悉的基本数据类型（如`integer`或`character string`变量）之间的明显区别。面向对象编程中的类不仅包含数据值，还通过方法包含处理这些数据的工具。但这只是一个表面上的区别。事实上，即使是许多面向对象语言中的基本数据类型，本身也是类，它们向外界提供一组方法。例如，`DecimalNumber`类可能提供一个`round()`方法；如果`price`是一个`DecimalNumber`对象，也就是`DecimalNumber`类的一个实例，那么例如`price.round(2)`将把变量`price`的值四舍五入到小数点后两位。
- en: But why so complicated? Why don’t we just stick to assigning values directly
    to the attributes of our class instances? Why is a special method necessary, which
    itself has to be developed? In our example above, we did without it for the sake
    of simplicity and assumed that the method `setPrice()` is already programmed somewhere
    and can be used by us; therefore, a hint (a `prototype`) in the class definition
    that the method should be part of the class was sufficient. But in fact, the code
    behind this method, the code that is executed when the method is called, must
    of course also be developed. So why all the effort just to change a value, which
    we could have done with a simple assignment?
  id: totrans-182
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 那为什么这么复杂呢？为什么我们不能直接给类实例的属性赋值呢？为什么需要一个特殊的方法，而且这个方法还必须自己开发？在上面的例子中，为了简单起见，我们没有使用这个方法，而是假设`setPrice()`方法已经在某个地方编写并可以使用；因此，在类定义中提供一个提示（即`prototype`），表明该方法应该是类的一部分就足够了。但实际上，这个方法背后的代码，即在调用该方法时执行的代码，当然也必须自己开发。那么，为什么为了改变一个值而付出这么大的努力呢？我们本可以通过简单的赋值操作来完成。
- en: Proponents of object-oriented programming would argue that the use of methods
    shields the internal data structure of the class from the outside world, i.e.,
    from the programmer using the class. Programmers don’t have to worry about how
    the various facts are mapped into the class; after all, they don’t edit the class
    attributes directly, but via the methods. The developer of the class could change
    the class attributes, but as long as the methods available to the user of the
    class do not change, the user will not notice the changes. From their point of
    view, everything remains the same. The programmer does not have to rewrite software
    but can continue to work with the existing code without making any changes.
  id: totrans-183
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 面向对象编程的支持者会认为，使用方法能够将类的内部数据结构与外部世界隔离开来，即与使用该类的程序员隔离。程序员无需担心如何将各种数据映射到类中；毕竟，他们并不直接编辑类的属性，而是通过方法进行操作。类的开发者可以更改类的属性，但只要提供给类用户的方法没有变化，用户是不会注意到这些更改的。从他们的角度看，一切保持不变。程序员无需重写软件，而是可以继续使用现有代码而无需进行任何更改。
- en: The advantage of using methods is that the modularization of code and thus the
    division of labor between the developer of the class and the programmer who uses
    the class in his programs is simplified. The developer of the class is responsible
    for the functionality that his class provides via the methods, the programmer
    as the “consumer” of this class only has to call the methods that are always to
    be used in the same way and does not have to worry about their exact functionality.
    This type of programming, in which a `programming interface` is provided externally
    in the form of the methods, makes the programs `more robust`, i.e., less susceptible
    to changes.
  id: totrans-184
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用方法的一个优势是，代码的模块化以及类的开发者与在程序中使用该类的程序员之间的分工变得更简单。类的开发者负责通过方法提供的功能，而作为该类“消费者”的程序员只需调用始终以相同方式使用的方法，无需担心它们的具体功能。这种编程方式通过提供`编程接口`的形式，将外部的方法暴露给程序，能够使程序变得`更稳健`，即不容易受到变化的影响。
- en: 'A second factor that contributes to the robustness of object-oriented programming
    is that methods can naturally ensure that `only permissible operations` are performed.
    Suppose our programmer wanted to assign the value `–10.99` to the attribute `gardenshovel.price`。
    If he can easily assign values to the attribute `price`， he could also assign
    it a negative price. However, this could have unfavorable effects at a later point
    in the program, such as when the customer is supposed to “settle” a negative invoice
    amount and would thus ultimately receive a refund. This is where the methods can
    show their strengths: Our `setPrice()` method could check whether the price passed
    to it as an argument is greater than `0`。 If it is, the attribute `price` would
    be set to that value. Otherwise, that is, if the price is negative, the attribute
    would be set to the value `0`。 In this way, the method would prevent invalid prices,
    such as negative prices, from being set accidentally. By validating the price,
    the method contributes to the stability of the program; in other words, it is
    no longer easy to “upset” the program, it becomes more robust against erroneous
    data entries.'
  id: totrans-185
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 另一个有助于面向对象编程稳健性的因素是，方法可以自然地确保执行`仅允许的操作`。假设我们的程序员想要将值`–10.99`赋给属性`gardenshovel.price`。如果他可以轻松地给属性`price`赋值，他也可以给它赋一个负值。然而，这在程序后续阶段可能会产生不利影响，例如当客户需要“结算”负的发票金额时，客户最终将收到退款。方法在此处可以发挥其优势：我们的`setPrice()`方法可以检查传递给它的价格参数是否大于`0`。如果是，那么属性`price`将被设置为该值。否则，也就是如果价格为负值，则该属性将被设置为`0`。通过这种方式，方法能够防止意外设置无效的价格，比如负值价格。通过验证价格，方法有助于提高程序的稳定性；换句话说，程序不再容易被“破坏”，它变得更具抗错能力。
- en: 'A special method that exists in practically all object-oriented languages is
    the `constructor`。 The constructor is called automatically when a new instance
    of the class is created. It can be used, for example, to initialize certain important
    attributes of the class, either with default values or with values passed as arguments
    to the constructor method. If we were to include such a constructor in our `Product`
    class, our class definition might look something like this:'
  id: totrans-186
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在几乎所有面向对象的语言中都有一个特殊的方法，叫做`构造函数`。构造函数在创建类的新实例时会自动调用。它可以用来初始化类的一些重要属性，可以使用默认值，也可以使用作为参数传递给构造函数的方法。如果我们要在`Product`类中包含这样的构造函数，类定义可能会像这样：
- en: '`Class` `Product` `Begin` `name : String` `description : String` `itemnumber
    : Integer` `manufacturer : String` `price : DecimalNumber` `setPrice(newprice:
    DecimalNumber)` `Product(startprice : DecimalNumber, name : String)` `End`'
  id: totrans-187
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Class` `Product` `Begin` `name : String` `description : String` `itemnumber
    : Integer` `manufacturer : String` `price : DecimalNumber` `setPrice(newprice:
    DecimalNumber)` `Product(startprice : DecimalNumber, name : String)` `End`'
- en: 'What is new is that the class has a constructor method `Product()`。 It is named
    the same as the class itself and takes two arguments, a price and a product name.
    With these two data, the constructor could now initialize the attributes `price`
    and `name`， when a new instance of this class is created. To do this, the constructor
    must of course be called with the two arguments when the instance is created;
    this could look like this, for example:'
  id: totrans-188
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 新增的部分是类有了一个构造函数`Product()`。它的名称与类名相同，并且接受两个参数，价格和产品名称。通过这两个数据，构造函数可以在创建该类的新实例时初始化`price`和`name`这两个属性。为此，当然必须在创建实例时使用这两个参数来调用构造函数；例如，这可能是这样写的：
- en: '`GardenShovel` : `Product(10.99, "Garden shovel, stainless steel")`'
  id: totrans-189
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`GardenShovel` : `Product(10.99, "园艺铲，不锈钢")`'
- en: As you can see, we declare here – as in the previous examples – a variable of
    type `Product`， but this time the constructor is called with the necessary parameters,
    the price and the name.
  id: totrans-190
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在这里声明了一个`Product`类型的变量，和之前的例子一样，但这次构造函数被调用时需要提供价格和名称这两个必要参数。
- en: '`11.7.5 Polymorphism`'
  id: totrans-191
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`11.7.5 多态`'
- en: This term may sound like a disease, but `polymorphism` is by no means a negative
    phenomenon; on the contrary, it is a very practical possibility offered by object-oriented
    programming. `Polymorphism` is closely related to the concept of inheritance.
    You remember that classes can “inherit” their methods and attributes to derived
    classes. In the previous sections, we defined a class `Book` that inherits all
    the properties and methods of the more general class `Product` and can also have
    its own properties and methods that are not available in the “parent class” `Product.`
  id: totrans-192
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这个术语可能听起来像是某种疾病，但`多态`绝对不是负面的现象；相反，它是面向对象编程提供的一种非常实用的功能。`多态`与继承的概念密切相关。你还记得，类可以“继承”其方法和属性给派生类。在前面的章节中，我们定义了一个`Book`类，它继承了更通用的`Product`类的所有属性和方法，同时也可以拥有一些在“父类”`Product`中没有的自己的属性和方法。
- en: Now we could define a method that displays the properties of the product, i.e.,
    creates a kind of product profile. We could put this method in the general class
    `Product`. Thanks to inheritance, it would also be available for the class `Book`
    derived from `Product.` However, the display would ignore the special properties
    of books, such as the author or the number of pages, both of which are attributes
    of the `Book` class. These properties are only part of the `Book` class, not the
    `Product` class, so a display method that we place in the `Product` class naturally
    cannot access these properties. The garden shovel from the previous examples,
    an instance of the general class `Product`, has no number of pages!
  id: totrans-193
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在我们可以定义一个方法来显示产品的属性，即创建一种产品档案。我们可以将这个方法放入通用类`Product`中。通过继承，它也会适用于从`Product`派生出来的`Book`类。然而，显示方法会忽略书籍的特殊属性，比如作者或页数，这些都是`Book`类的属性。这些属性仅是`Book`类的一部分，而不是`Product`类的一部分，因此我们放在`Product`类中的显示方法自然无法访问这些属性。前面例子中的园艺铲子，作为`Product`类的实例，是没有页数属性的！
- en: However, it would be practical if we had a display method that simply returned
    the correct display for each product, no matter what type of product we were dealing
    with. Ideally, we would call the display method `showProduct()`, and it would
    take care of outputting the right information on the screen for each type of product.
  id: totrans-194
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，如果我们有一个显示方法，它可以简单地返回每个产品的正确显示，不论我们处理的是什么类型的产品，那将是很实用的。理想情况下，我们会调用显示方法`showProduct()`，它将自动为每种类型的产品输出正确的信息。
- en: This is exactly what `polymorphism` allows. `Polymorphism` means that classes
    that are derived from each other can have methods with the same name, but they
    all do something different. If the method is then called for a specific object,
    i.e., an instance of a class, the method belonging to the `respective class` is
    automatically executed. In our example, the properties author and number of pages
    would then also be displayed.
  id: totrans-195
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这正是`polymorphism`所允许的。`Polymorphism`意味着从彼此派生的类可以有相同名称的方法，但它们执行的功能各不相同。如果随后为特定对象调用该方法，即类的实例，则自动执行属于`相应类`的方法。在我们的示例中，作者和页数属性也会被显示。
- en: 'Such a polymorphic design of the method `showProduct()` could look like this:'
  id: totrans-196
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这种多态的`showProduct()`方法设计可能如下所示：
- en: '`Class Product Begin` `name : String` `description : String` `itemnumber :
    Integer` `manufacturer : String` `price : DecimalNumber` `showProduct()` `setPrice(newprice:
    DecimalNumber)` `Product(startprice : DecimalNumber, name : String) End` `Class
    Book Inherits Product Begin` `author : String` `pages : Integer` `showProduct()
    End`'
  id: totrans-197
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Class Product Begin` `name : String` `description : String` `itemnumber :
    Integer` `manufacturer : String` `price : DecimalNumber` `showProduct()` `setPrice(newprice:
    DecimalNumber)` `Product(startprice : DecimalNumber, name : String) End` `Class
    Book Inherits Product Begin` `author : String` `pages : Integer` `showProduct()
    End`'
- en: As you can see, both classes, the “parent class” `Product` and the derived “child
    class” `Book`, each have a function `showProduct()`. Which one is executed when
    we call the method depends on whether the object for which we call the method
    is an instance of `Product` or an instance of its derived class `Book`.
  id: totrans-198
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如您所见，两个类，“父类”`Product`和派生的“子类”`Book`，各自都有一个`showProduct()`函数。我们调用该方法时，执行哪个函数取决于我们为其调用方法的对象是`Product`的实例，还是其派生类`Book`的实例。
- en: So, if we declare two objects
  id: totrans-199
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 所以，如果我们声明两个对象
- en: '`GardenShovel : Product` `Grisham1992 : Book`'
  id: totrans-200
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`GardenShovel : Product` `Grisham1992 : Book`'
- en: and then call the method `showProduct()` for each of the two objects,
  id: totrans-201
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然后为每个对象调用`showProduct()`方法，
- en: '`GardenShovel.showProduct()` `Grisham1992.showProduct()`'
  id: totrans-202
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`GardenShovel.showProduct()` `Grisham1992.showProduct()`'
- en: 最终调用了两个不同的方法；对于对象`GardenShovel`，调用了类`Product`的方法，因为`GardenShovel`是其实例；对于对象`Grisham1992`，调用了派生类`Book`的方法，因此`showProduct()`也能正确显示页数和作者。
  id: totrans-203
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 最终调用了两个不同的方法；对于对象`GardenShovel`，调用了类`Product`的方法，因为`GardenShovel`是其实例；对于对象`Grisham1992`，调用了派生类`Book`的方法，因此`showProduct()`也能正确显示页数和作者。
- en: 多态方法的好处在于，我们不必关心`GardenShovel`和`Grisham1992`实际上是什么类型的对象。我们只需固执地调用`showProduct()`方法，所发生的总是针对相关对象类的最佳情况；方法名相同使得这一切成为可能。
  id: totrans-204
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 多态方法的好处在于，我们不必关心`GardenShovel`和`Grisham1992`实际上是什么类型的对象。我们只需固执地调用`showProduct()`方法，所发生的总是针对相关对象类的最佳情况；方法名相同使得这一切成为可能。
- en: 在与多态相关的讨论中，反复出现的一个术语是`overloading`。人们谈到类`Product`的`showProduct()`方法被派生自`Product`的类重载，每个类都有自己的`showProduct()`方法，以最佳考虑其特性。这两个术语很好地描述了这种情况：“多态”指的是同一个方法可以有许多（希腊语`poly`）形式（希腊语`morphía`）；而“重载”描述了同一个函数被赋予多次不同含义的过程。
  id: totrans-205
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在与多态相关的讨论中，反复出现的一个术语是`overloading`。人们谈到类`Product`的`showProduct()`方法被派生自`Product`的类重载，每个类都有自己的`showProduct()`方法，以最佳考虑其特性。这两个术语很好地描述了这种情况：“多态”指的是同一个方法可以有许多（希腊语`poly`）形式（希腊语`morphía`）；而“重载”描述了同一个函数被赋予多次不同含义的过程。
- en: 11.7.6 访问权限
  id: totrans-206
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 11.7.6 访问权限
- en: 为了总结我们对面向对象编程的观察，我们来看看最后一个特性，这再次强调了面向对象编程的动机，即严格分离类的开发与使用。
  id: totrans-207
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为了总结我们对面向对象编程的观察，我们来看看最后一个特性，这再次强调了面向对象编程的动机，即严格分离类的开发与使用。
- en: 有一种方法可以限制对类的属性和方法的访问。具体设计可能因编程语言而异，但通常至少有以下的访问权限梯度：
  id: totrans-208
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 有一种方法可以限制对类的属性和方法的访问。具体设计可能因编程语言而异，但通常至少有以下的访问权限梯度：
- en: '`Private`: 处于此访问限制下的方法和属性只能被同一类的方法使用。它们对外界“不可见”；作为使用类的用户，您无法访问这些方法和属性。然而，您可以调用的方法（如果它不是私有的）可以使用这些方法和属性，但您无法直接这样做。因此，私有方法和属性被保护在外部世界之外。`private`的访问保护非常适合定义不被外部调用但只供类的其他方法使用的辅助变量或辅助方法。'
  id: totrans-209
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`Private`: 处于此访问限制下的方法和属性只能被同一类的方法使用。它们对外界“不可见”；作为使用类的用户，您无法访问这些方法和属性。然而，您可以调用的方法（如果它不是私有的）可以使用这些方法和属性，但您无法直接这样做。因此，私有方法和属性被保护在外部世界之外。`private`的访问保护非常适合定义不被外部调用但只供类的其他方法使用的辅助变量或辅助方法。'
- en: '`Protected`: 被声明为`protected`的方法和属性可以被所属类和派生类使用，但不能被在其程序中使用这些类的程序员使用。'
  id: totrans-210
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`Protected`: 被声明为`protected`的方法和属性可以被所属类和派生类使用，但不能被在其程序中使用这些类的程序员使用。'
- en: '`Public/open`: 方法和属性的访问限制为`public`，可以从任何地方访问，包括自身类、派生类以及类的用户。'
  id: totrans-211
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`Public/open`: 方法和属性的访问限制为`public`，可以从任何地方访问，包括自身类、派生类以及类的用户。'
- en: 'Consider the following extension of our example for clarification: `Class Product
    Begin Public name : String description : String itemnumber : Integer manufacturer
    : String showProduct() setPrice(newprice: DecimalNumber) Product(startprice :
    DecimalNumber, name : String) Private price : DecimalNumber End`'
  id: totrans-212
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '下面是我们示例的扩展以作说明：`Class Product Begin Public name : String description : String
    itemnumber : Integer manufacturer : String showProduct() setPrice(newprice: DecimalNumber)
    Product(startprice : DecimalNumber, name : String) Private price : DecimalNumber
    End`'
- en: Here we have declared the attribute `price` as a private property. The `setPrice()`
    method, on the other hand, is a public method. So, as developers of the class,
    we don’t want anyone to directly edit our attribute `price`. Therefore, we protect
    it as private. However, a method from the same class can access it and change
    its value. `setPrice()` is such a method. It is a public method that can be called
    from outside the class. So a programmer using our class could now edit the attribute
    `price` via the interface method `setPrice()`, but not directly, for example by
    assigning a value.
  id: totrans-213
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里我们已经将属性`price`声明为私有属性。`setPrice()`方法则是公共方法。因此，作为类的开发者，我们不希望有人直接编辑我们的属性`price`。因此，我们将其保护为私有。然而，同一类中的方法可以访问并修改它的值。`setPrice()`就是这样一个方法。它是一个可以从类外部调用的公共方法。因此，使用我们类的程序员现在可以通过接口方法`setPrice()`来编辑`price`属性，但不能直接通过赋值来修改。
- en: In this way, it is very easy to control which parts of classes should be visible
    to the outside and serve as an interface to the functionalities of the class,
    and which should not.
  id: totrans-214
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 通过这种方式，可以很容易地控制哪些类的部分应对外可见并作为类功能的接口，哪些不应该。
- en: '`11.3 [5 min]` Are the following statements true or false?'
  id: totrans-215
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`11.3 [5 min]` 以下陈述是对还是错？'
- en: '`(a)`'
  id: totrans-216
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`(a)`'
- en: Object-oriented programming is the attempt to achieve as “natural” a representation
    of things in the real world as possible.
  id: totrans-217
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 面向对象编程是尽可能以“自然”的方式表示现实世界事物的尝试。
- en: '`(b)`'
  id: totrans-218
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`(b)`'
- en: A method is a function that belongs to a class and can change the attributes
    of this class instance.
  id: totrans-219
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 方法是属于类的函数，可以改变该类实例的属性。
- en: '`(c)`'
  id: totrans-220
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`(c)`'
- en: All attributes of a class instance can be changed directly from the program
    by assignment.
  id: totrans-221
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 类实例的所有属性可以通过赋值直接从程序中更改。
- en: '`(d)`'
  id: totrans-222
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`(d)`'
- en: The use of object-oriented programming makes the program clearer but makes adjustments
    to the program more difficult.
  id: totrans-223
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 使用面向对象编程使得程序更加清晰，但也使得对程序的调整变得更加困难。
- en: '`(e)`'
  id: totrans-224
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`(e)`'
- en: Inheritance means that you can reuse the definition of a class in different
    programs.
  id: totrans-225
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 继承意味着你可以在不同的程序中重复使用类的定义。
- en: '`11.4 [3 min]`'
  id: totrans-226
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`11.4 [3 min]`'
- en: Describe the difference between a class and an instance.
  id: totrans-227
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 描述类与实例之间的区别。
- en: '`11.5 [3 min]`'
  id: totrans-228
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`11.5 [3 min]`'
- en: What are the essential elements of a class definition?
  id: totrans-229
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 类定义的基本元素是什么？
- en: '`11.6 [3 min]`'
  id: totrans-230
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`11.6 [3 min]`'
- en: Why is polymorphism a useful approach in object-oriented programming?
  id: totrans-231
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为什么多态在面向对象编程中是一个有用的方法？
- en: '`11.8 Your Roadmap to Learning a New Programming Language`'
  id: totrans-232
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`11.8 学习新编程语言的路线图`'
- en: When you learn a new programming language …
  id: totrans-233
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当你学习一门新的编程语言时……
- en: 'you’ll discover:'
  id: totrans-234
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你将会发现：
- en: whether the language is case-sensitive for the identifiers, i.e., the names
    of variables and functions,
  id: totrans-235
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 语言是否对标识符区分大小写，即变量和函数的名称，
- en: which basic data types the language offers (especially numbers, strings, logical/truth
    values),
  id: totrans-236
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 语言提供了哪些基本数据类型（特别是数字、字符串、逻辑/布尔值），
- en: whether you have to declare variables, and if so, how to do it
  id: totrans-237
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 语言是否需要声明变量，如果需要，如何声明
- en: how to assign values to variables,
  id: totrans-238
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何为变量赋值，
- en: whether, and if so how, variables can be (explicitly) converted between data
    types and which conversions, if any, are already (implicitly) performed by the
    programming language itself,
  id: totrans-239
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 语言是否，及如何，变量可以（显式地）转换数据类型，编程语言本身是否已经（隐式地）执行了某些转换，
- en: whether the language supports fields of similar variables (`arrays`), and if
    so, how to create fields and access their elements (in particular whether the
    indexing of the field elements starts at `0` or at `1`),
  id: totrans-240
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 语言是否支持类似变量的字段（`数组`），如果支持，如何创建字段并访问它们的元素（特别是字段元素的索引是从`0`开始还是从`1`开始），
- en: whether the language knows associative fields whose values can be accessed with
    keys, and if so, how to create these fields and address their elements,
  id: totrans-241
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 语言是否支持可以通过键访问其值的关联字段，如果支持，如何创建这些字段并访问它们的元素，
- en: which other complex data types are common in the programming language,
  id: totrans-242
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 该语言中其他常见的复杂数据类型有哪些，
- en: whether the language supports object-oriented programming, and if so, how to
    access class attributes and methods, and how to define classes yourself, especially
    how to derive classes from existing classes.
  id: totrans-243
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 语言是否支持面向对象编程，如果支持，如何访问类属性和方法，如何定义类，特别是如何从现有类派生类。
- en: 11.9 Solutions to the Exercises
  id: totrans-244
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 11.9 练习的解决方案
- en: Exercise 11.1
  id: totrans-245
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 11.1
- en: In the languages that require a variable declaration, the variable is registered
    with the interpreter/compiler by the declaration; it reserves the necessary memory
    and, if necessary, assigns an initial value to the variable. After that, the variable
    can be used in the program. When declaring a variable, the identifier (name) of
    the variable and, in some languages, also its data type is specified.
  id: totrans-246
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在需要变量声明的语言中，变量通过声明注册到解释器/编译器；它会为变量预留必要的内存，并在需要时为变量赋初始值。之后，变量可以在程序中使用。声明变量时，会指定变量的标识符（名称）以及在某些语言中，还会指定其数据类型。
- en: Exercise 11.2
  id: totrans-247
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 11.2
- en: The need to declare a variable allows the interpreter/compiler to indicate the
    use of undeclared variables. Because undeclared variables are often the result
    of typos in the program code, this prevents a new variable from being accidentally
    created and worked with, while the variable that should have been accessed remains
    completely unchanged. The program code thus becomes more robust by forcing variables
    to be declared. The same is true if the type is already specified when declaring,
    and this type cannot be changed afterwards. In this case, the interpreter/compiler
    can report an error if the variable is accidentally assigned a value of an “inappropriate”
    type. This also avoids errors and makes the program code more robust.
  id: totrans-248
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 变量声明的需求使得解释器/编译器能够标识未声明变量的使用。由于未声明的变量通常是程序代码中打字错误的结果，这可以防止意外创建并操作新的变量，同时应访问的变量保持完全不变。因此，强制声明变量使得程序代码变得更加健壮。如果声明时已经指定了类型，并且该类型之后不能更改，那么如果意外为变量赋予了“不合适”的类型，解释器/编译器会报告错误。这同样避免了错误，使程序代码更加健壮。
- en: Exercise 11.3
  id: totrans-249
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 11.3
- en: (a)
  id: totrans-250
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: (a)
- en: True.
  id: totrans-251
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 正确。
- en: (b)
  id: totrans-252
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: (b)
- en: True.
  id: totrans-253
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 正确。
- en: (c)
  id: totrans-254
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: (c)
- en: False. In many programming languages, attributes of class instances can be shielded
    from external access by defining them as `private`. These attributes can then
    only be edited by methods of the same class but are practically invisible to the
    outside world and therefore cannot be accessed directly by the programmer.
  id: totrans-255
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 错误。在许多编程语言中，可以通过将类实例的属性定义为`private`来屏蔽外部访问。这些属性只能通过同一类的方法进行编辑，对于外界而言几乎是不可见的，因此程序员无法直接访问这些属性。
- en: (d)
  id: totrans-256
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: (d)
- en: False. Object-oriented programming helps program elements become more independent
    of each other. Because the programmer only addresses the class instance via the
    defined methods (and, if necessary, by directly accessing the attributes), the
    inner workings of the class need not interest him or her any further. Thus, as
    long as the `interface` of the class remains unchanged externally, the developer
    of the class itself can change it internally at will, and the programs based on
    the class remain syntactically correct. Adaptations to the code are facilitated
    by this stronger modularization.
  id: totrans-257
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 错误。面向对象编程有助于使程序元素彼此更加独立。因为程序员只通过定义好的方法（如有需要，还可以直接访问属性）来操作类实例，所以类的内部实现对程序员来说不再是关注点。因此，只要类的`interface`在外部保持不变，类的开发者就可以随意修改内部实现，而基于该类的程序仍然语法正确。这种更强的模块化有助于代码的适配。
- en: (e)
  id: totrans-258
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: (e)
- en: False. Inheritance means that further classes can be derived from a class, which
    “inherits” its methods and attributes. In this way, a class can be extended elegantly,
    especially for more specific uses.
  id: totrans-259
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 错误。继承意味着可以从一个类派生出更多的类，这些类“继承”了其方法和属性。通过这种方式，一个类可以优雅地扩展，特别是用于更具体的用途时。
- en: Exercise 11.4
  id: totrans-260
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 11.4
- en: The class is the abstract definition of an object (or object type) with the
    attributes and methods belonging to objects of this type and acts like a template.
    According to this template, the concrete objects, the class instances, are formed
    and therefore possess as images of the class all its methods and attributes.
  id: totrans-261
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 类是对象（或对象类型）的抽象定义，包含该类型对象的属性和方法，像一个模板一样工作。根据这个模板，具体的对象，即类的实例，得以形成，因此作为类的映像，它们拥有类中的所有方法和属性。
- en: Exercise 11.5
  id: totrans-262
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 11.5
- en: 本质上，类定义由类的标识符（名称）以及属于该类的属性和方法组成。这些可以通过相应的关键字提供访问权限限制（参见►`Sect. [11.7.6]`）。如果该类是从另一个类派生的，那么对“父类”的引用也是类定义的一部分（参见►`Sect.
    [11.7.3]`）。
  id: totrans-263
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 本质上，类定义由类的标识符（名称）以及属于该类的属性和方法组成。这些可以通过相应的关键字提供访问权限限制（参见►`第 11.7.6 节`）。如果该类是从另一个类派生的，那么对“父类”的引用也是类定义的一部分（参见►`第
    11.7.3 节`）。
- en: '`Exercise 11.6`'
  id: totrans-264
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`练习 11.6`'
- en: '`Polymorphism`允许不同类型（`classes`）的对象提供特定的方法。这使得可以将该方法适应于各自类的具体特性。当通过继承创建类层次结构时，这一点尤其有趣。如果现在在这个类层次结构中的某个类的实例上调用该方法，将使用该对象实例类的特殊实现。如果该类没有该方法的特殊实现，则使用同名方法的下一个更高层类的实现。这确保了总是使用最适合该类特性的实现方法，但在必要时可以使用属于更高层类的方法。这意味着不同的对象类型可以被不同地处理，但仍然向外部世界提供相同的接口（即，同名的方法）。程序员不必考虑他或她应该实际调用哪个类的哪个方法；他或她只需为对象实例调用该方法，解释器/编译器会为他或她澄清在这种情况下应该使用哪个方法。'
  id: totrans-265
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`多态`允许不同类型（`类`）的对象提供特定的方法。这使得可以将该方法适应于各自类的具体特性。当通过继承创建类层次结构时，这一点尤其有趣。如果现在在这个类层次结构中的某个类的实例上调用该方法，将使用该对象实例类的特殊实现。如果该类没有该方法的特殊实现，则使用同名方法的下一个更高层类的实现。这确保了总是使用最适合该类特性的实现方法，但在必要时可以使用属于更高层类的方法。这意味着不同的对象类型可以被不同地处理，但仍然向外部世界提供相同的接口（即，同名的方法）。程序员不必考虑他或她应该实际调用哪个类的哪个方法；他或她只需为对象实例调用该方法，解释器/编译器会为他或她澄清在这种情况下应该使用哪个方法。'
