- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024 J. L. Zuckarelli Learn coding with Python and JavaScript
    [https://doi.org/10.1007/978-3-658-42912-6_11](https://doi.org/10.1007/978-3-658-42912-6_11)
  id: totrans-0
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 11. How Do I Store Data to Work With?
  id: totrans-1
  prefs:
  - PREF_H1
  stylish: true
  type: TYPE_NORMAL
- en: Joachim L. Zuckarelli^([1](#Aff2) )(1) München, Germany Overview.
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Programs work with data. These are read in from the user or from files, databases
    or other sources. We will look at exactly how this happens in the following chapter.
    This chapter is about something else: all data must be stored in the computer''s
    memory so that it can be processed. This is done in the form of variables. But
    don''t worry: even if these variables have a lot in common with their namesakes
    from mathematics, you don''t need to delve into the depths of mathematics to understand
    how to work safely with variables when programming.'
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'In this chapter you will learn the following:'
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: What variables are and how to create them.
  id: totrans-5
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: What types of data variables can hold.
  id: totrans-6
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: How to combine many variables of the same kind into variable fields (`arrays`
    and `hashes`).
  id: totrans-7
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: How to combine different variables reflecting the properties of a certain real-world
    object (e.g., a car with the properties `brand`, `maximum speed` and `list price`)
    into one object and how to then manipulate these properties (object-oriented programming
    paradigm).
  id: totrans-8
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 11.1 Variables as Placeholders for Data.
  id: totrans-9
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: Variables are tools with which we record data in programs. As in mathematics,
    variables act as `placeholders` that we can address by their name, as with the
    `identifiers` discussed in ► Chap. [10](474412_1_En_10_Chapter.xhtml). As the
    name suggests, their content is variable, so we can store different data in the
    variable (one after the other), but no matter what the current content of the
    variable may be, it is always accessible via their identifier.
  id: totrans-10
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A variable is comparable to a box that we label. The label, or the name or identifier,
    always remains the same, even if we change the contents of the box. The contents
    of the box should match the label to some extent, otherwise confusion arises.
    It is exactly the same with variables.
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In general, we are quite free in choosing the name of the variable. However,
    as you have already seen in the previous chapter, there are some language-specific
    basic rules that must be observed. These rules usually dictate which characters
    may appear in the name of a variable (certain special characters such as `%` or
    `#` are usually not allowed). In addition, many programming languages also specify
    which characters may or even must appear at the beginning of a variable name.
    In `R`, for example, variable names may not begin with a digit, in `PHP` variable
    names `must` begin with the dollar sign (`$`). However, as you will remember from
    the last chapter, it is important not only to follow these “hard” rules, the violation
    of which will inevitably lead to the compiler or interpreter refusing to obey
    you, but also to name variables meaningfully and `consistently.` Meaningful in
    this context means that you can tell the content or purpose of the variable from
    its name. Consistent means that you ideally always form variable names in the
    same way, for example, always capitalize and lowercase the parts of compound variable
    names in the same way. Let’s say you are developing a web-shop and want to store
    the number of orders a customer placed in the last `12 months` in a variable.
    This variable could be called, for example, `CountOrders12Months`, but also `CntOrd12M`
    or `cntOrd12M` or `Count_Orders_12_Months` or … The possibilities are numerous,
    and there are few limits to creativity. For the readability and comprehensibility
    of the program code, it is important that you think about a system, how you want
    to form variable names, and then follow this system as consistently as possible.
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`11.2 Data Types of Variables`'
  id: totrans-13
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: '`11.2.1 Different Types of Data Require Different Types of Variables`'
  id: totrans-14
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: So far, we haven’t talked about what `kind of information` a variable can hold,
    such as a number or a text. For the compiler or interpreter of your programming
    language, this makes a difference, for at least two reasons.
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: For one thing, the compiler or interpreter of your language must reserve memory
    for the variable. It is obvious that a long text (for example, a street name)
    requires more memory than a number (for example, a house number). If you first
    assign a number to a variable, let’s say the house number `58`, your compiler
    or interpreter then makes sure that enough memory is reserved to store a number.
    If then you assign a long text to the same variable, for example the address `"Times
    Square, Manhattan, NY"`, the space initially reserved is no longer sufficient.
    Additional memory space must be found, possibly at a completely different location
    in memory.
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Secondly, very different operations can be performed with numbers and texts.
    For example, you can multiply a number by another number. With a text, these operations
    make no sense. In the worst case, the program will even crash if you perform an
    operation that is not allowed for the kind of data your variable contains. Therefore,
    it makes sense to check at times whether the data in a variable is of the “right”
    kind, has the right data type, in programming terms.
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The data type of a variable describes what kind of information can be stored
    in it. In this respect, a data type specifies, for example, whether a variable
    should hold `integers`, `fractional numbers`, or `texts`. In practice, however,
    data types differ not only in the type of data they cover. They also differ in
    terms of the range of values or length of information they can hold: A variable
    that is intended for a text and provides 10 characters for it, will store “Peter
    Miller” as “Peter Mill” (the space counts also as a character here). In an `integer`
    variable whose value range is from `0` to `65,535` (that’s a value range you can
    cover with two bytes), you won’t be able to store a negative account balance of
    `–254 USD`. In the same way, an `integer` variable with the value range from `–32,768`
    to `32,767` (which also requires two bytes of memory) will not be able to handle
    an account balance of `50,000 USD`. Data types therefore have different value
    ranges, which – just like the basic type of information for which they are intended
    – limits the data they can hold. In the case of data types for floating-point
    numbers, such as fractional decimal numbers like `3.1415926`, another characteristic
    comes into play in the form of precision, or the number of decimal places. Accuracy
    matters. Whether you receive the gold medal at a skiing or speed skating world
    championship together with a competitor, or come in second behind this competitor,
    may depend on whether the result is measured in hundredths of a second (and both
    athletes have the same result and would therefore both be declared winners) or
    whether thousandths of a second are also taken into account, and a small difference
    between the two times then becomes apparent.'
  id: totrans-18
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`11.2.2 Important Data Types`'
  id: totrans-19
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 'The basic data types are quite similar in most programming languages. Usually
    there are data types for:'
  id: totrans-20
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Integers`'
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: These data types take `integers` such as `–4`, `–3`, `–2`, `0`, `1`, `2`, `3`,
    `4`. Optionally, there are data types that take only positive integers (including
    zero), that is, natural numbers. `Integer` data types in many programming languages
    have a name that includes the word `integer`, or an abbreviation of it. Classical
    names of such data types are `integer` or `int`. For `integer` data types with
    a particularly large value range, i.e., the possibility of storing very large
    numbers, they are also often called `bigint`, `long int` or simply `long`.
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Floating-Point Values`'
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Floating point data types take fractional decimal numbers, such as `1.7` or
    `3.141459`. Of course, integers can also be represented as floating-point numbers,
    e.g., `4` as `4.0`. Accordingly, all integers can also be stored in floating-point
    variables.
  id: totrans-24
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: If this is so, the question naturally arises why one needs integer variables
    at all and does not simply always work with floating-point variables. The reason
    is mainly the larger memory requirement of floating-point values, because they
    must store the fractional part of the decimal point as well as the digits before
    the decimal point, or they have to keep capacity for its storage, even if the
    fractional part after the decimal point is always zero, as is the case for integer
    numbers. The problem is that our compiler or interpreter does not know in advance
    that we only want to store integer values. Therefore, it always reserves as much
    memory as it needs to store a fractional decimal number. If you need a lot of
    such floating-point variables at once, this will result in a noticeably higher
    memory requirement.
  id: totrans-25
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: There are a number of names for floating-point data types in different programming
    languages, such as `real` (for real numbers) or `float`. In most languages there
    is – analogous to `integer` and `long integer` – another floating-point data type,
    which offers higher precision (i.e., more decimal places) and a larger range of
    values. In most cases, names such as `double` or even `long double` already indicate
    the higher precision.
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Characters and Strings
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Individual characters, such as letters, are not dissimilar to integers, because
    every character that the computer understands, i.e., that is part of its `character
    set`, can also be encoded as a number. Well-known character sets are `ASCII` or
    `Unicode`. Although there is a close connection between characters and numbers,
    most programming languages have a special data type for individual characters,
    often with a name based on the word `character`. Accordingly, many languages have
    a character type `char` for individual characters.
  id: totrans-28
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Entire texts are ultimately sequences of characters, or `strings`. Some programming
    languages therefore do not know a separate type for character strings but build
    character strings from a string of individual character variables. Here, a more
    complex data type is created from a simple data type, in which many variables
    of the simple data type are practically connected in series. This kind of series
    connection is called an `array`, a construction we will deal with more intensively
    later.
  id: totrans-29
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Other languages do have a special data type for strings, which is often simply
    called `string`. This somewhat shields the programmer from the nature of the string,
    namely that it consists of different characters strung together. For him, it then
    “feels” as if the text is a single variable and not composed of individual variables
    arranged in a field.
  id: totrans-30
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: However, strings can often contain not only letters, digits and special characters
    (such as punctuation marks, `#, <`, `>`, `*****`, `~`), but also so-called escape
    sequences. These are special control instructions. In practice, the most important
    one marks a line break and is represented as `\n`。The backslash (`\`) tells the
    interpreter or compiler that the following character is not a letter but a control
    statement; the `n` itself stands for `new line`。Thus, the string `"Mr./Mrs.\nFirstName
    Name\nStreet\nZIP City"` would be interpreted as
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Mr/MrsFirstName NameStreetZIP city`'
  id: totrans-32
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Wherever the escape sequence `\n` is encountered, a line break is inserted.
    While the escape sequence marks the position of the line break within the string,
    certain program functions – such as those for outputting strings to the screen
    – “understand” the encoding and implement it accordingly. Besides `\n`，there are
    several other escape sequences, for example `\t` for a tabulator jump. Escape
    sequences solve another common problem: In most programming languages, strings
    are enclosed by single (`''`) or double (`"`) quotes. But what if a string is
    supposed to contain a quote, for example, so how do the quotes need to be `real
    characters` within the string? Consider the following string:'
  id: totrans-33
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`"He said, "I love you!""`'
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'It is enclosed in double quotes, but contains a quote that itself uses double
    quotes. Normally, the interpreter or compiler would refuse to follow us here.
    It would first recognize a string `"He said: "`。However, this is followed (without
    this being understood as a string) by `I love you!` followed by an empty string
    (`""`)。The `I love you!` would probably cause problems, because it will not be
    a valid statement in the respective programming language, so outside of a string
    the interpreter or compiler would try to interpret it as a statement. So what
    to do? Apart from the trivial solution of simply using single quotes for the quote
    inside the string, the “inner” double quotes can also simply be `escaped`，as follows:'
  id: totrans-35
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`"He said: \"I love you!\""`'
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The backslashes tell the interpreter or compiler that the following quotation
    mark should be understood as `part of the string`，not as its delimiter.
  id: totrans-37
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'But what if there should be a backslash in the string? For example, in this
    string:'
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`"\n is an escape sequence."`'
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The escape sequence `\n` would normally lead to an undesired line break within
    the string. Masking by the backslash helps here too, only this time the existing
    backslash itself is masked, because it should be understood as part of the text
    and not as the start of a control statement. So:'
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`"\\n is an escape sequence."`'
  id: totrans-41
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: This string would result in the correct output. Escaping the backslash itself
    is especially important when you code paths on Windows systems, for example `C:\\Home\\My
    source codes`。A common cause of errors is that escaping is forgotten in strings
    like this.
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 转义序列在许多编程语言中使用，例如在`C`、`Python`、`Perl`或`R`中。
  id: totrans-43
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Truth/Logical Values
  id: totrans-44
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 几乎所有编程语言都有一个特殊的数据类型，用于表示语句的真值内容，即`true`或`false`。在这个上下文中，我们通常称之为`boolean`（以19世纪的英语数学家和逻辑学家`George
    Boole`命名）或`logical`变量。与我们迄今为止考虑的数据类型不同，布尔变量仅允许存储两种不同的值：`true`和`false`。这与可以存储`任何`整数的整数变量完全不同。在大多数编程语言中，这两个真值有特殊标识符，通常是`true`和`false`，以便布尔变量可以轻松赋值或比较，而这些赋值和比较在程序代码中也易于阅读。由于有易于理解的标识符`true`和`false`，编程语言通常只存储`1`和`0`作为布尔变量的值。从这个意义上说，布尔变量大多只是整数变量，编译器或解释器负责确保它们仅有两个可能的值，这些值通常可以通过特殊标识符方便地访问，通常只是`true`和`false`。
  id: totrans-45
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在编程语言中，布尔数据类型通常被称为`bool`、`boolean`或`logical`。
  id: totrans-46
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Other Data Types
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 这些数据类型几乎可以在所有现代高级语言中找到，尽管它们的名称、值范围和精度不同。此外，大多数编程语言还有几种其他更复杂的数据类型，通常基于你刚刚了解的简单类型。
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 一些语言，例如，有（至少）一种特殊数据类型用于日期或时间。如果你想存储日期和时间，似乎没有其他选择，只能将天、月、年、小时、分钟和秒作为整数存储，然后将它们“组装”成某种复杂数据类型。这确实是一个常用的解决方案，但还有其他方法。例如，使用UNIX操作系统的系统，其时间从1970年代开始，仅使用一个整数来表示自1970年1月1日0:00
    GMT以来经过的秒数。例如，千年之交，即2000年1月1日0:00，在纽约市对应的Unix时间为946,702,800。这个时间概念也被称为`UNIX Epoch`。因此，日期也可以用一个数字表示，但在许多编程语言中，它被视为一种单独的数据类型，尽管最终它是一个整数。
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: This example also nicely illustrates the role of the value range in data types.
    Systems running on `UNIX` did not have a year 2000 problem. However, they will
    run into trouble for this on Tuesday, January 19, 2038 at 3:14:08 `UTC`. This
    is because the data type used by `UNIX` (at least on the older systems) to store
    the time will then reach the value `2,147,483,647` and thus the limit of its value
    range. This data type cannot store larger numbers. So, what happens one second
    later, at 3:14:09? The date value measured in seconds will jump back to its smallest
    possible value, `–2,147,483,648`。According to `Unix` chronology, this corresponds
    to a time in December 1913。The developers of `Unix`, of course, knew this, but
    accepted it; the year 2038 was still far away from the perspective of the 1970s,
    and data types with a larger value range were not available.
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: But the example shows very well that you have to think about whether the data
    type you intend to use is really sufficient for the intended purpose, or whether
    you need a data type with a larger range of values (if you have one available,
    unlike the `UNIX` developers).
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Date/time is an example of a data type that exists in many languages alongside
    the other data types discussed above. In addition, there are often other data
    types, such as for enumerations. In variables of these types, categorical data
    can be stored, i.e., data that can only have certain distinct values, for example
    the sex of a person, their highest school-leaving qualification, or a car color.
    In this sense, they are like `boolean` variables, except that the number of possible
    values may well be more than two. Often, such `enumerations` (`sets` or `factors`)
    are special data types in a programming language even though “under the hood”
    they are essentially stored as `integers` (each category/value is represented
    by a specific number).
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Date values, strings, and enumerations are all examples of data types that are
    based on simpler data types. When we discussed strings which can be thought of
    as consisting of a sequence of characters you already became acquainted with the
    field as a way of combining variables into a more complex data type. Besides fields,
    we will later take a closer look at another possibility, the core idea of which
    is to combine variables of `different` types into one object. Such an object then
    often represents a real object with its central properties, for example a car,
    which can be described by its age in years (`integer`), its brand (`string`),
    and its color (`enumeration`), among other things.
  id: totrans-53
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '11.2.3 Changing the Data Type: Conversion of Variables'
  id: totrans-54
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 有时，您需要更改变量的数据类型。这称为`converting`变量。例如，假设您为在线书店编写了软件。您的程序的用户刚刚输入了他想购买的书籍数量的信息（通常是一本，但有时可能是两本，一本给自己，一本作为礼物）。在结账页面上，您希望向用户显示他们总共订购了多少本书。如果您将数量读入整数变量，这很简单。然而，如果您使用了字符串变量，这就变得问题重重。您的加法将无法成功。为什么这两个变量之间的差异如此重要？
  id: totrans-55
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 数据类型，如您在前面的章节中所见，是由变量可以持有的值的范围类型定义的，并且（如果适用）还由（浮点）值存储的精度定义。但是还有另一个特征可以区分数据类型：变量的类型可以进行哪些操作的问题。可以对整数进行加法运算是显而易见的。但字符串呢？您能在数学意义上将两个字符串`"apples"`和`"pears"`相加吗？当然不可以。但`"2"`和`"1"`这两个字符串呢？这些可能是我们在线商店示例中两本书的数量。这两个字符串能加在一起吗？答案是，可能让您感到惊讶的是：不能。
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 编译器或解释器处理您的程序代码时，根本不关心变量中到底包含什么。它只是一串字符，对计算机来说完全没有意义。无论字符串包含字母、数字，还是任何特殊字符如美元符号或下划线，都无关紧要。编译器或解释器对内容不感兴趣。因此，字符串不允许进行加法运算。但如果您现在知道通过在线商店网站读取的字符串变量肯定包含数字，您当然还是想对它们进行计算。该怎么办呢？
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 解决此问题的关键是改变变量的类型。许多编程语言提供特殊语句，允许您做到这一点，并执行`explicit type conversion`。然而，一些语言也具有`implicit
    type conversion`。在某种意义上，它们并不像之前描述的那样无知，但如果您想计算例如`"2" + 1`（其中`"2"`是字符串值），它们会仔细查看变量及其内容，并会认识到在我们的示例中，如果将字符串`"2"`转换为数字，则可以进行计算。然后，转换会自动执行，而无需您通过特殊语句干预。
  id: totrans-58
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Another example of this is the following calculation: `TRUE – 1`: Here, an
    integer value is subtracted from a Boolean value. Languages that follow a very
    strict type concept would reject this calculation with an error message. Languages
    that support implicit conversion would recognize that `TRUE` is ultimately (in
    most languages) represented by the value `1`, because it is this that is stored
    internally as the truth value. Thus, the value of `TRUE – 1` can be determined.
    In this sense it is even true: `TRUE – 1 = 0 = FALSE`.'
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Languages that look very strictly at the adherence to the data types, convert
    little implicitly and possibly even allow little explicit conversion, are called
    `strongly typed`. Here the data types of variables play a big role. At the other
    end of the spectrum are languages where the programmer does not have to specify
    the type of the variables, but where the data type always adapts automatically
    by implicit conversion in such a way that the desired operations can be performed
    as far as possible. Such languages are `weaker typed`. In extreme cases, even
    operations that make no sense at all can be performed without an error message:
    The addition `3 + "My name"` (where `3` is a number, `"My name"` is a string)
    would then perhaps simply result in `3`. The type conversion from `"My name"`
    to a number fails, of course, but the programming language is so weakly typed
    that it just “keeps on calculating” as best it can.'
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: What may sound tempting is at the same time dangerous. Because obviously it
    would be bad if the user of our online shop enters the quantity `3` for one book
    and the quantity `"Tom Peterson"` for the other book. We can’t really work with
    this information. In the worst case, our program gets into trouble and produces
    implausible results or even crashes completely. A little more “control” over whether
    the variables are good for the operations you want to perform should not be seen
    as a restriction on your own programming freedom. It is simply an aid to writing
    safer, more stable program code and to detecting errors at an early stage (ideally
    during development and testing, and not at runtime).
  id: totrans-61
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 11.3 Creating and Initializing Variables
  id: totrans-62
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 'In the last section, you saw that variables can be distinguished according
    to their data type, i.e., according to what kind of information they can store
    and what range of values can be covered with them. Now the question arises - how
    do you create a variable in order to be able to work with it. The “birth” of a
    variable is done differently in different programming languages. Roughly, however,
    two types of languages can be distinguished: Those in which you have to create
    a variable explicitly before using it for the first time, and those that create
    the variable automatically as soon as you use it for the first time.'
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Languages of the former kind include `C`, `Visual Basic for Applications (VBA)`,
    and `JavaScript`. Suppose we wanted to assign the value `10` to an integer variable
    called `piececount` in both languages. Before that happens, however, the variable
    must be created. Programmers refer to this as `declaring`, which is the process
    of telling the compiler or interpreter that you want to use this variable from
    now on. The compiler or interpreter then takes over the technical part of variable
    creation.
  id: totrans-64
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The declaration of the variable including the assignment of the value `10`
    would look like this in `C`:'
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`int piececount; piececount = 10;`'
  id: totrans-66
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`int piececount` not only declares a new variable `piececount`, but also specifies
    its type as `int`, which in `C` is the integer data type. After this declaration,
    the compiler knows that there is an integer variable called `piececount`, and
    it can be used in the program from now on. Without the declaration, the assignment
    `piececount = 10` would lead to an error message, with which the compiler points
    out that it does not know the variable `piececount` and thus cannot assign a value
    to it.'
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The same code section in `VBA` would look like this:'
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Dim piececount As Integer piececount = 10`'
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Unlike in `C` (where the declaration was introduced with the type of the variable),
    a special keyword is used here to declare the variable, namely `Dim`, from `to
    dimension`. And that’s actually very good, because what happens when the variable
    is created is that memory is reserved, as much as the data type of the variable
    requires. In this sense, the memory is `dimensioned` according to need.
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Some languages like `JavaScript` require a declaration of variables, but no
    type is specified:'
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`var piececount; piececount = 10;`'
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Here the compiler or interpreter decides based on the use of the variables,
    which data type it needs. By the assignment `piececount = 10` it becomes clear
    that this must be an integer variable. If the variable is later assigned a value
    that requires a different data type, for example by the assignment `piececount
    = "Not specified"`, then the data type of the variable changes accordingly in
    the background without you as the programmer noticing anything. Unlike in `C`
    or `VBA`, the typing is `implicit`. In `C` and `VBA`, on the other hand, the type
    must be specified `explicitly`; this is why we also speak of `explicitly typed`
    programming languages.
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: You may now ask yourself whether a declaration in JavaScript is really that
    useful, since the type of the variable is not specified at all. If the type has
    to be specified, it can be argued that the compiler or interpreter can check whether
    a variable is unintentionally assigned values that it cannot accept due to its
    data type. This additional check provides security and may prevent troublesome
    errors and strange behavior of the program. After the above declaration, the `C`
    compiler will refuse to work with an assignment such as `piececount = "Not specified"`
    and abort with an error message. This way, the programmer is made aware of the
    fact that he has somehow worked inconsistently in the code.
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Does the necessity to declare a variable the way it is done in JavaScript have
    any benefit for the programmer? Or is it simply a chicanery devised by the inventor
    of the language to drive the users of his invention crazy? As you can imagine,
    this is not the case. There is a point to forcing the programmer to register his
    variables, because that way, the compiler or interpreter knows `which variable
    identifiers` are allowed. If you then make a typo, as happened to the author several
    times while writing these lines, and for example write the assignment `pieccount
    = "Not specified"` (note the missing `e`) in your code, the JavaScript interpreter
    will recognize that you are trying to access a variable that does not exist. This
    is because the variable you declared has a different name. This way you will quickly
    get to the root of the problem and be able to fix it. This would be much more
    difficult if the programming language did not require a declaration. Then the
    statement `pieccount = 10` would simply create a new variable called `pieccount`.
    In that case, you’d probably have some trouble determining what’s causing your
    program not to behave the way you want it to. Uncovering the real cause, namely
    that you are actually working with two different variables, is then considerably
    more time-consuming than if the compiler or interpreter already gives you a “hint”.
  id: totrans-75
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: So sometimes it can be quite helpful to accept a stricter regime. This strictness
    makes it easier to detect and locate problems. If your programming language offers
    the possibility to switch to a stricter mode (which can be achieved in `VBA`,
    for example, by a special option that forces variable declaration), you should
    accept this offer, even if it looks like more control and less freedom at first
    glance.
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The strictness that some programming languages impose on their users sometimes
    includes that the declaration of variables is only allowed at the beginning of
    a program, which improves the structure and thus the readability of the code.
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在我们上述的例子中，我们在声明后直接为`variable`赋值。但是如果我们不这样做，但仍然在后面使用该`variable`，例如在屏幕上输出其内容，那么会显示什么呢？换句话说，`variable`“出生”时的值是什么？在过去，`variables`在声明后往往会有一个随机值，即操作系统释放的内存区域中当前存在的值，这个值是由之前使用同一内存区域但没有“清理”的程序留下的残余。因此，对任何程序员来说，一个非常重要的建议是始终在开始时为他的`variables`加载一个值，即`initialize`它们，或给它们一个明确的、已知的内容。这可以防止程序由于“奇怪”的`variable`内容而崩溃或表现得不可预测。
  id: totrans-78
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 今天，大多数编程语言会自动初始化`variables`，数值`variables`初始化为`0`，字符串初始化为空字符串。一些语言甚至对用户未显式初始化的`variables`有一个特殊值，比如在`JavaScript`中的`undefined`。这个值表示该`variable`尚未具有真实的值，因为它还没有被初始化。许多语言还有另一个值，表示用户故意留空该`variable`的值（想想在调查中未回答的问题，例如）。在`JavaScript`中，例如，这个值是`null`（与数字`0`不同），在`Delphi/Object
    Pascal`中是`nil`，在`R`中是`NA`（表示`not available`）。如果`variable`有这样的值，这表明该`variable`确实被使用，只是它不包含显式的值。换句话说：没有值也是一种值！
  id: totrans-79
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 尽管在今天的许多编程语言中，严格来说不再需要初始化，但这是一个好习惯。通常，初始化可以在声明时直接完成，例如在`C`中。我们上面的例子可以简化为：
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`int piececount = 10;`'
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 11.4 不那么变量的：`Constants`
  id: totrans-82
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 另一种语言元素，通常在声明时直接初始化的是`constants`。`Constants`在程序中以特定名称（即其标识符）来表示的值与`variables`相似。然而，与`variables`不同的是，一旦`constants`的值被设定，就不能在程序的后续过程中更改。这保护了`constant`的值不被意外覆盖。通常，`constants`必须在声明时用其（此后称为`constant`）值初始化。以下是来自Pascal的一个例子：
  id: totrans-83
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`const pi = 3.14159;`'
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在`C`中，`constant`声明与`variable`声明看起来是一样的，只是多了`const`关键字：
  id: totrans-85
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`const int pi = 3.14159;`'
  id: totrans-86
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 11.5 变量/数组的有序字段
  id: totrans-87
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: So far, we have always created single variables. However, most programming languages
    also support`arrays` of variables. An array is an ordered collection of variables
    of the same type that can be addressed under the same name. The individual values
    of the field are accessed via an index.
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In the context of our hypothetical online shop example, we could, for example,
    store the click history, i.e., the sequence of products that the customer has
    looked at, in an array. This is important information when it comes to analyzing
    customer behavior in more detail and making tailored suggestions to the customer
    as to which products might also interest him, as is the case with many online
    shops today.
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In this example, our field could be called`history`。In this field, we would
    sequentially store the IDs of the products that the customer has viewed. Let’s
    assume here that these IDs are integer values. Then we have a field of integer
    variables. We can now use an`index` to access the individual`elements` of the
    field. We could access the fifth element in the click history this way through`history[5]`。In
    the square brackets you see the number of the element that is to be accessed,
    in this case the fifth product that our current customer has looked at.
  id: totrans-90
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Of course, we could have implemented the whole thing with single variables:
    Thus, we could have created variables`history1`、`history2`、`history3`、`history4`、`history5`、`history6`，and
    stored the sequence of products under consideration in these variables. However,
    this has some disadvantages. For one thing, in many languages the variables must
    be explicitly declared. If you envision a click history with, say, 30 products,
    you would have a lot of typing to do just to declare the variables in the first
    place. On the other hand, in practically all languages that support fields, there
    are very efficient mechanisms for traversing those fields, namely by moving the
    index that identifies a field element one position at a time. This way you can
    go through the whole field step by step. The whole thing can be solved very elegantly
    from a programming point of view, so that you do not have to write much code.
    It would be much more complex and maintenance-intensive (think of the case where
    you just want to quickly increase the length of the history from 30 to 100 products)
    if you were to work with individual, independent variables.'
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Although virtually all modern high-level languages provide fields, the languages
    differ in one important respect; namely, what the index value of the`first` field
    element is. In many languages, field indices start at 0。Then`history[0]`would
    be the product ID of the first product the user looked at.
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fields/arrays can also be multi-dimensional. In our example, we could store
    the click history of all our visitors in one field; we would use a two-dimensional
    field, which we can think of as a table or matrix. The rows would contain the
    users, and the columns would contain the IDs of the products they viewed. Then
    `history[3][1]` would be the ID that website visitor number 3 looked at first
    (assuming our field indexing starts at 1). To access elements of a field, we now
    need two indexes as coordinates that describe exactly where we want to reach in
    our two-dimensional tableau.
  id: totrans-93
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The dimensionality of fields is, of course, by no means limited to two dimensions.
    We could easily add a third, fourth, fifth dimension. All no problem, as long
    as we still have in mind which index (and thus which dimension) stands for which
    “coordinate” we use to store the information in our field. For example, in addition
    to the user, we could also store the day (from 1 = Monday, to 7 = Sunday) and
    thus have a third dimension. Our field would have the structure `history[day][user][productid]`
    and with `history[2][3][1]` we would get the ID of the first product that user
    3 looked at on Tuesday.
  id: totrans-94
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Without going into it in detail, we have introduced a notation in the past
    paragraphs to access the individual elements of fields with indexes: We put the
    index number in square brackets. This is actually how many programming languages
    do it, but not all: some put the indexes in `round` brackets. However, the possibilities
    of indexing are not exhausted by simply specifying an index number. Many programming
    languages allow further methods of indexing, for example indexing by exclusion:
    Here, not the index or indices of those elements of the field are specified that
    you want to select, but just the other way around, those that you do not want
    to select. This is often done by prefixing the index with a minus sign. `history[–5]`
    would then be the entire field except for the fifth element. In some programming
    languages, however, a negative value means something else, namely that the field
    is indexed from the end. In this case, `history[–5]` would be the fifth element
    `from` the end. Some languages also offer the specification of a whole range of
    indices: so `history[5:9]` would grab the fifth, sixth, seventh, eighth and ninth
    element of the field. A notation in the form `history[from:to]` not only saves
    typing work but makes it easier especially when the selection limits `from` and
    `to` are not yet known, but variables are used in their place whose values are
    first determined by the program (for example, by a user input).'
  id: totrans-95
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The world of fields is relatively colorful across programming languages. However,
    most of them have the following principles in common:'
  id: totrans-96
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Fields are combinations of several single variables (however, there are exceptions
    to this fundamental definition): In the statistical language `R`，one-dimensional
    fields, so-called vectors, are even the standard; a single variable is then only
    a special case of such a vector, namely a vector of length one)。'
  id: totrans-97
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: The variables in a field all have the same type (for example, they are all strings,
    or all numbers)。
  id: totrans-98
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Fields can be one-dimensional or multidimensional。
  id: totrans-99
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Individual elements of the fields can be accessed via a numerical index by specifying
    the element to be selected。
  id: totrans-100
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: When creating a field (if variables have to be declared at all) its dimensions
    as well as the type of the field variable have to be specified。
  id: totrans-101
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Beyond that, however, working with fields can differ greatly in different programming
    languages. We had already learned about some of these differences. In summary,
    among other things, the following questions may well be handled very differently
    in different programming languages：
  id: totrans-102
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Whether the numeric indices start at `0` or at `1`。
  id: totrans-103
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Whether round or square brackets are used in indexing。
  id: totrans-104
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: What indexing options are available beyond simply specifying the element number。
  id: totrans-105
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Whether, and if so, which functions are available to work with fields (for example,
    to determine the length of a field or to delete an element from a field)。
  id: totrans-106
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Which data types are allowed for fields。
  id: totrans-107
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: The maximum size of fields。
  id: totrans-108
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Next, let’s look at how fields are actually declared and used in some programming
    languages. In all cases, we want to create a field of six variables that can hold
    the names of a group of people. We then want to set the second name to `"Sophie"`。
  id: totrans-109
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The whole thing first in `Visual Basic for Application (VBA)`：
  id: totrans-110
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Dim names(6) As String` `names(1) = "Sophie"` The same in JavaScript: `var
    names = [];` `names[1] = "Cathy"`'
  id: totrans-111
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As you can see, in JavaScript the size of the array does not have to be specified
    in advance. The indexing also starts here at `0`。
  id: totrans-112
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: And finally, `Delphi`：
  id: totrans-113
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`var names: array[1..6] of string;` `names[2] = "Cathy";`'
  id: totrans-114
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Here, the value range of the indices can be set explicitly. We set it so that
    it runs from `1` to `6`。 The second element thus has the index `2`。
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Finally, it should be mentioned that in some programming languages string variables
    are understood as fields of individual characters. The individual characters within
    the string can then be accessed by normal indexing. Consider the following examples
    from C and Python; first the C version：
  id: totrans-116
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`char my_name[] = "Thomas";` `printf("Third character: %c", my_name[2]);`'
  id: totrans-117
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Then in `Python`：
  id: totrans-118
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`my_name = "Thomas"` `print("Third character: ", my_name[2])`'
  id: totrans-119
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In both cases we grab the character with index `2`，i.e., the third character
    (because both programming languages start the field indexing at `0`) and display
    it. Both languages understand strings as fields, but `C` is much stricter than
    `Python`。
  id: totrans-120
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`11.6 Associative Fields of Variables/Hashes`'
  id: totrans-121
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: In addition to the classical ordered fields/arrays, some programming languages
    know a second type of fields, the `associative fields`, sometimes also called
    `hashes`, `dictionaries` or `maps`.
  id: totrans-122
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Associative fields consist of an `unordered` set of `key-value pairs`. The key
    can be used to access the respective value. Such key-value pairs could, for example,
    consist of the name of a customer (key) and the order value of his last order
    (value). The entries in an associative field, unlike those in an ordered field/array,
    do not have a natural order; they don’t need one, since the individual elements
    are accessed via a clearly defined key.
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Let’s look at the example of two languages that support associative fields:
    Perl – associative fields are called `hashes` here – and in Python where they
    are called `dictionaries`. First the Perl variant:'
  id: totrans-124
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`my` %`ordervalues` = (`"Thomas_Schultz"` => 43.99,`"Jim_Scott"` => 19.49,`"Mary_McGregor"`
    => 68.99,);`$ordervalues{" Mary_McGregor"}` = 8.99;`print(''Last order of Thomas
    Schultz was: $bestellwerte{" Jim_Scott "}'')`;'
  id: totrans-125
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As you can see, the upper part of the code first creates a new `hash` field
    called `ordervalues` (hash identifiers in Perl are always preceded by the percent
    sign when speaking of the field as a “whole”). The hash field is immediately initialized
    with three key-value pairs. To the left of the operator `=>` is the key, in this
    case the name of the customer, to the right of the operator the last order value.
    Further down in the code, a special element of the hash field is accessed, once
    to change a value, another time to display a value on the screen. As expected,
    access is not made with a numerical index (after all, the elements in the hash
    field are not sorted), but via the key, in this case the customer name.
  id: totrans-126
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Now the same again in Python:'
  id: totrans-127
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`ordervalues` = `{"Thomas_Schulz" : 43.99," Jim_Scott" : 19.49," Mary_McGregor"
    : 68.99,}` `ordervalues[''Mary_McGregor'']` = 8.99 `print("Last order of Thomas
    Schultz was: ", ordervalues[''Thomas_Schultz''])`'
  id: totrans-128
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Even if the exact syntax differs slightly in both languages, the parallels in
    dealing with `hashes` or `dictionaries`, as the associative fields are called
    in Python, cannot be overlooked. It becomes clear how easily values can be looked
    up in an associative field – in fact, like a dictionary.
  id: totrans-129
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The languages that support associative fields usually come with a whole set
    of tools for analyzing and manipulating such fields. For example, functions or
    operators are regularly available to the programmer to extract all keys or all
    values from the field in one fell swoop, or to determine the size of the field,
    that is, the number of key-value pairs it contains.
  id: totrans-130
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 11.1 [3 min]
  id: totrans-131
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: What is meant by the declaration of variables?
  id: totrans-132
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 11.2 [3 min]
  id: totrans-133
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Name two advantages of being forced to declare variables.
  id: totrans-134
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 11.7 `Objects`
  id: totrans-135
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: In the last two sections, we dealt with fields. Fields allow you to store a
    lot of similar information in an orderly way and to access it again. This is very
    useful in many cases, but often not the easiest or most natural way to deal with
    data.
  id: totrans-136
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In this section, you will therefore learn about an approach to working with
    related data that is so fundamental that it constitutes a programming paradigm
    of its own. Many programming languages have adopted this approach, in whole or
    in part. Because it shapes many popular languages, such as `C++`, `Java` and `JavaScript`,
    `Python`, and `Kotlin`, it is extremely important in practice.
  id: totrans-137
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: We are talking about `object-oriented programming` (OOP for short). We will
    deal with it quite extensively in this section, and not entirely without ulterior
    motives, since the two programming languages introduced in the third and fourth
    parts of this book also belong to the broad class of `object-oriented languages`.
    In the eyes of not a few contemporaries, `object orientation` is associated with
    attributes such as “difficult to understand” and “complex”. After reading this
    section, however, you will find that such fears are not justified at all.
  id: totrans-138
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 11.7.1 The World Is Made of Objects
  id: totrans-139
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 'Let’s assume we wanted to program a catalog-like display of products for an
    online store. Each product has a set of properties that we want to display, such
    as: a name, a description, an item number, a manufacturer, a price, and quantity.
    Using the knowledge from the previous sections, we could map each of these properties
    as a separate field/array. Then, for example, there would be an array`itemnumbers`
    and`itemnumbers[187]` would be the item number of the 187th article. If we wanted
    to retrieve the item description for the same item, we would use the array element`descriptions[187]`.'
  id: totrans-140
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The leading criterion here is therefore the respective property. The product
    for which we query this property is indicated by the index, in our example, `187`\.
    However, this approach is a little artificial, because in reality we do not normally
    start from the property, but from its carrier.
  id: totrans-141
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 当我们编写我们的目录视图时，我们面临的问题是我们面前有一个`product`，需要显示它的所有相关属性。我们从产品开始，问自己这个产品有哪些属性。于是，我们提取名称、描述、项目编号以及我们希望在目录列表中显示的所有其他属性，并为该特定产品展示这些属性。我们始终从各个可能的角度（其属性）观察同一个`object`，即产品。当你去二手车经销商那里查看他们院子里的待售汽车时也是如此。你查看一辆车，检查模型、颜色、年龄、状况、价格及其他对你评估重要的参数。然后你查看下一辆车，再查看另一辆车。但你总是从一个对象——汽车——开始，查看其各自的特征。
  id: totrans-142
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 你可能已经注意到，这种推理归结为：世界显然不是按属性组织的，而是按对象组织的，无论是产品、汽车、房屋、企业、按钮、电子邮件，还是学生。所有这些物理和非物理对象最终都是属性的总结。从这个意义上说，人或人们所扮演的角色（如“学生”角色）也可以是对象。我们不应对这里的语言选择过于苛刻，尽管起初可能会觉得将客户或同事视为“对象”有些奇怪。但如果我们将对象定义为一组属性，那么很明显，在这个广泛的意义上，人、动物、植物和神也都是“对象”。
  id: totrans-143
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 但如果世界是按对象而非属性组织的，为什么这没有在编程中反映出来？为什么我们在明显关注单个属性的字段中工作，而不是在作为不同属性整体集合的对象中？在1960年代，美国计算机科学家`Alan
    Kay`和其他面向对象编程的先驱们也问过自己这个问题，并因此在真正意义上带来了范式转变。遵循这一新范式的第一种编程语言之一是`Kay`的`Smalltalk`。
  id: totrans-144
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在面向对象编程的概念中，对象处于前景；它体现了这种方法的组织原则。决定我们如何处理数据的不是属性，而是属性的承载者——对象。
  id: totrans-145
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 11.7.2 `Classes`
  id: totrans-146
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 让我们遵循面向对象的方法，定义一个具有以下属性的对象`product`：
  id: totrans-147
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`product.name` `product.description` `product.itemnumber` `product.manufacturer`
    `product.price`'
  id: totrans-148
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 我们通过商店出售的所有产品都有这些属性。为了认识到这些属性都描述了对象“`product`”，我们通过在前面加上`product`来总结它们。
  id: totrans-149
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Let us now be a little more precise linguistically. What we have defined there
    is our view of `any` product, it is in a sense the `template for a product`; this
    is what products look like to us, these are their essential characteristics from
    our point of view. Such an abstract template, which describes which properties
    an object has, is called a `class` in object-oriented programming. Each real product
    that we offer has an individual value for each of these properties, for example
    the name “Garden shovel, stainless steel” and a price of 10.99 USD. The actual
    objects whose properties are modeled after our class are called `instances` of
    the class. So, in a way, an instance is the concretization of the abstract idea
    expressed in a class. All our products will have different values for each of
    the properties, so there are as many instances as there are products. But all
    products belong to the same class, they are just products.
  id: totrans-150
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'In the next step, we’ll get a little more formal and define our class as we
    would in a programming language:'
  id: totrans-151
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Class` `Product` `Begin` `name : String` `description : String` `itemnumber
    : Integer` `manufacturer : String` `price : DecimalNumber` `End`'
  id: totrans-152
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The properties of the class – we also speak of `attributes` in this context
    – are located between the limiting keywords `Begin` and `End`. This code excerpt
    here is not written in any existing programming language, but is formulated as
    “pseudo-code”, as we will do several times in this part of the book in order to
    illustrate basic principles. The point here is simply to describe, in a formalized
    but easily understood way, what a class definition might look like. Later, you
    will see how class definitions are constructed in some real programming languages
    and will be able to cope with them immediately once you have understood the basic
    concept from this pseudo-code.
  id: totrans-153
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Now that we have defined which attributes our class should consist of and what
    data type these attributes have, we can create an instance of the class, i.e.,
    a variable that (built along the lines of the class definition) represents a concrete
    product. As soon as the new variable of type `product` is created, we can start
    to adjust its attributes:'
  id: totrans-154
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`GardenShovel : Product` `GardenShovel.name = "Garden shovel, stainless steel"`
    `GardenShovel.price = 10.99`'
  id: totrans-155
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: To access the attributes of the `GardenShovel` instance of our `Product` class,
    we use the dot operator in the form `instance.attribute`. This notation is common
    in many programming languages.
  id: totrans-156
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: With `Product`，we have created our own data type, which is more complex than
    the data types we learned about in the previous sections, because it stores different
    values. However, we can work with it just as with one of the “built-in” data types
    (such as integers or logical values). For example, we can create variables of
    this type and assign values to them (not to the variable as a whole, but to the
    individual attributes, which are of course elementary variables).
  id: totrans-157
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`11.7.3 Inheritance`'
  id: totrans-158
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 有时候，我们有一些对象是其他对象的特殊案例。例如，书籍是一种特殊的产品。它具有我们产品所拥有的所有属性，包含一个名称（书名）、一个制造商（出版社），当然还有一个价格。此外，它还有一些其他属性，我们也应该在我们的网上商店中展示，例如作者和页数。毕竟，这些信息可能会影响客户的购买决策。
  id: totrans-159
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 现在，为了将我们的特殊产品“书籍”表示为一个类，面向对象编程中有一个称为`inheritance`的技巧。与这个术语可能暗示的相反，没有人必须死才能继承。然而，基本思想很简单：作为产品的特殊案例，我们的书籍简单地“继承”了产品的所有属性，并且在作者和页数的基础上获得了两个额外的属性。这两个属性使得书籍独特。因此，我们的书籍是一个产品，但并不是每个产品都是书籍。有些产品只有产品的标准属性，而没有作者和页数的特殊属性；这些属性是书籍所独有的。
  id: totrans-160
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 当然，我们可以将书籍具有的额外属性直接包含在`Product`类中。但对于不是书籍的具体实例，我们应该为这些属性赋予什么值呢？如果我们对其他特殊产品类别（例如服装或园艺家具）给予特别处理，会发生什么？这将导致适用于所有产品的属性数量大大增加，而仅适用于单一产品类别，`Product`类会变得非常混乱。
  id: totrans-161
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 使用继承更简单且更优雅。我们创建一个新的类`Book`，它继承上述定义的`Product`类的所有属性，并额外添加页数和作者这两个属性。类`Book`的定义可以如下所示：
  id: totrans-162
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Class Book Inherits Product Begin author : String pages : Integer End`'
  id: totrans-163
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 如果将这个类的定义与`Product`类的定义进行比较，您会注意到这里添加了关键字`Inherits`，后面是我们类`Book`要继承的属性的类。我们现在当然可以创建我们类的实例，即具体的变量，并更改它们的属性。
  id: totrans-164
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Grisham1992 : BookGrisham1992.name = "The Pelican Brief"Grisham1992.price
    = 8.99Grisham1992.author = "John Grisham"Grisham1992.pagenumber = 478`'
  id: totrans-165
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As you can see here, in this code snippet we edit our variable `Grisham1992`
    not only with regard to the special properties of books, namely author and number
    of pages, but also with regard to the standard attributes of products, namely
    name and price. These do not occur explicitly in the definition of the class `Book`。However,
    books inherit these properties from the more general class `Product`，from which
    the class `Book` is derived.
  id: totrans-166
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Ultimately, we build a `class hierarchy`，with `Product` as the superclass and
    `Book` as the subclass。`Class` hierarchies can of course have much more than two
    levels；for example, we could add novels and encyclopedias as further subclasses
    of books and provide them with special attributes that are not contained in the
    class `book`。In the same way, we could of course extend the hierarchy by modeling
    other product categories besides books (for example, clothing and garden furniture)
    as separate classes that are directly derived from the `Product` class.
  id: totrans-167
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Next, let’s take a look at what our two classes, `Product` and `Book`，would
    look like in two real programming languages; we’ll start with `C++`:'
  id: totrans-168
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`class` Product{char designation[30]; char description[200]; long itemnumber;
    char manufacturer[30]; float price;} `class` Book : `public` Product{char author[50];
    int pages;} `// Later in the main program ...` Book grisham1992; Product gardenshovel;
    gardenshovel.name = "Garden shovel, stainless steel"; gardenshovel.price = 10.99;
    grisham1992.name = "The Pelican Brief"; grisham1992.price = 8.99; grisham1992.author
    = "John Grisham"; grisham1992.pages = 478;'
  id: totrans-169
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Of course, even if you are not familiar with the particular syntax of `C++`，your
    understanding of the concepts of object-oriented programming and our pseudo-code
    will allow you to understand what is happening in this program snippet.
  id: totrans-170
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Now let’s look at the same thing in`Delphi/Object Pascal`:'
  id: totrans-171
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`type` TProduct = `Class`(TOBject) `property` Name : String; `property` Description
    : String; `property` ItemNumber: Longint; `property` Manufacturer : String; `property`
    Price : Single; `end`; TBook = `Class`(TProduct) `property` Author : String; `property`
    Pages : Integer; `end`; `// Later in the main program ...` `var` GardenShovel
    : TProduct; Grisham1992 : TBook; GardenShovel.Name = "Garden shovel, stainless
    steel"; GardenShovel.Price = 10.99; Grisham1992.Name = "The Pelican Brief"; Grisham1992.Price
    = 8.99; Grisham1992.Author = "John Grisham"; Grisham1992.Pages = 478;'
  id: totrans-172
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Here we have followed the Delphi-typical notation, that classes (and in general
    all data types defined beyond the basic data types) begin with “T”, our two classes
    are then called accordingly `TProduct` and `TBook`. Behind the keyword `Class`,
    the class from which is inherited is written in brackets. This is the class one
    level higher in the class hierarchy. The interesting thing here is that the class
    `TProduct` also inherits attributes from a higher class, namely from the class
    `TObject`. This class is the highest in the class hierarchy, and all other classes
    are ultimately derived from it.
  id: totrans-173
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: You can see from these examples that class definitions in programming languages
    may have their own peculiarities, but they still have a lot in common. With the
    few basic ideas of object-oriented programming that we have looked at so far,
    you can already understand what the class definitions mean in the respective language
    without a detailed understanding of the programming languages they are written
    in.
  id: totrans-174
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`11.7.4 Methods`'
  id: totrans-175
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: In the examples of the previous section, we directly changed the attributes,
    i.e., properties of our classes, by assigning values to them. For the “pure doctrine”
    of object-oriented programming, this is sacrilege. According to the “pure doctrine”,
    the attributes may not be edited directly, but only with the help of something
    called `methods`. `Methods` are callable subroutines to which you can pass certain
    values, called `arguments`, and which then process these values in some way, for
    example by assigning the “passed” value to a class property.
  id: totrans-176
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'To make this a bit more concrete, let’s assume that our product class has a
    `setPrice()` method that can be used to edit the price. The method is passed the
    price as an argument, and the method in turn then makes sure that the class property
    `price` is changed accordingly. The class definition would then look like this:'
  id: totrans-177
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Class` `Product` `Begin` `name` : `String` `description` : `String` `itemnumber`
    : `Integer` `manufacturer` : `String` `price` : `DecimalNumber` `setPrice(newprice:
    DecimalNumber)` `End`'
  id: totrans-178
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Our original class has been extended by the method `setPrice()`. This method
    takes as argument `newprice` a decimal/floating point number, namely the price
    we want to set for our product. We could then create a new instance of the `Product`
    class later in the program and initialize the price using the `setPrice()` method,
    here in the example to the price `10.99` USD:'
  id: totrans-179
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`GardenShovel` : `Product` `GardenShovel.setPrice(10.99)`'
  id: totrans-180
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Here we see now apparently a substantial difference to the fundamental data
    types, which we became acquainted with so far, such as `integer` or `character
    string` variables. The classes of object-oriented programming not only consist
    of data values, but, with the methods, also contain the tools to process these
    data. But this is only an apparent difference. In fact, even the fundamental data
    types in many object-oriented languages are themselves classes that offer a set
    of methods to the outside world. For example, the `DecimalNumber` class might
    provide a method `round()`; if `price` were a `DecimalNumber` object, that is,
    an instance of the `DecimalNumber` class, then, for example, `price.round(2)`
    would round the value of the variable `price` to two decimal places.
  id: totrans-181
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: But why so complicated? Why don’t we just stick to assigning values directly
    to the attributes of our class instances? Why is a special method necessary, which
    itself has to be developed? In our example above, we did without it for the sake
    of simplicity and assumed that the method `setPrice()` is already programmed somewhere
    and can be used by us; therefore, a hint (a `prototype`) in the class definition
    that the method should be part of the class was sufficient. But in fact, the code
    behind this method, the code that is executed when the method is called, must
    of course also be developed. So why all the effort just to change a value, which
    we could have done with a simple assignment?
  id: totrans-182
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Proponents of object-oriented programming would argue that the use of methods
    shields the internal data structure of the class from the outside world, i.e.,
    from the programmer using the class. Programmers don’t have to worry about how
    the various facts are mapped into the class; after all, they don’t edit the class
    attributes directly, but via the methods. The developer of the class could change
    the class attributes, but as long as the methods available to the user of the
    class do not change, the user will not notice the changes. From their point of
    view, everything remains the same. The programmer does not have to rewrite software
    but can continue to work with the existing code without making any changes.
  id: totrans-183
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The advantage of using methods is that the modularization of code and thus the
    division of labor between the developer of the class and the programmer who uses
    the class in his programs is simplified. The developer of the class is responsible
    for the functionality that his class provides via the methods, the programmer
    as the “consumer” of this class only has to call the methods that are always to
    be used in the same way and does not have to worry about their exact functionality.
    This type of programming, in which a `programming interface` is provided externally
    in the form of the methods, makes the programs `more robust`, i.e., less susceptible
    to changes.
  id: totrans-184
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'A second factor that contributes to the robustness of object-oriented programming
    is that methods can naturally ensure that `only permissible operations` are performed.
    Suppose our programmer wanted to assign the value `–10.99` to the attribute `gardenshovel.price`。
    If he can easily assign values to the attribute `price`， he could also assign
    it a negative price. However, this could have unfavorable effects at a later point
    in the program, such as when the customer is supposed to “settle” a negative invoice
    amount and would thus ultimately receive a refund. This is where the methods can
    show their strengths: Our `setPrice()` method could check whether the price passed
    to it as an argument is greater than `0`。 If it is, the attribute `price` would
    be set to that value. Otherwise, that is, if the price is negative, the attribute
    would be set to the value `0`。 In this way, the method would prevent invalid prices,
    such as negative prices, from being set accidentally. By validating the price,
    the method contributes to the stability of the program; in other words, it is
    no longer easy to “upset” the program, it becomes more robust against erroneous
    data entries.'
  id: totrans-185
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'A special method that exists in practically all object-oriented languages is
    the `constructor`。 The constructor is called automatically when a new instance
    of the class is created. It can be used, for example, to initialize certain important
    attributes of the class, either with default values or with values passed as arguments
    to the constructor method. If we were to include such a constructor in our `Product`
    class, our class definition might look something like this:'
  id: totrans-186
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Class` `Product` `Begin` `name : String` `description : String` `itemnumber
    : Integer` `manufacturer : String` `price : DecimalNumber` `setPrice(newprice:
    DecimalNumber)` `Product(startprice : DecimalNumber, name : String)` `End`'
  id: totrans-187
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'What is new is that the class has a constructor method `Product()`。 It is named
    the same as the class itself and takes two arguments, a price and a product name.
    With these two data, the constructor could now initialize the attributes `price`
    and `name`， when a new instance of this class is created. To do this, the constructor
    must of course be called with the two arguments when the instance is created;
    this could look like this, for example:'
  id: totrans-188
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`GardenShovel` : `Product(10.99, "Garden shovel, stainless steel")`'
  id: totrans-189
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As you can see, we declare here – as in the previous examples – a variable of
    type `Product`， but this time the constructor is called with the necessary parameters,
    the price and the name.
  id: totrans-190
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`11.7.5 Polymorphism`'
  id: totrans-191
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: This term may sound like a disease, but `polymorphism` is by no means a negative
    phenomenon; on the contrary, it is a very practical possibility offered by object-oriented
    programming. `Polymorphism` is closely related to the concept of inheritance.
    You remember that classes can “inherit” their methods and attributes to derived
    classes. In the previous sections, we defined a class `Book` that inherits all
    the properties and methods of the more general class `Product` and can also have
    its own properties and methods that are not available in the “parent class” `Product.`
  id: totrans-192
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Now we could define a method that displays the properties of the product, i.e.,
    creates a kind of product profile. We could put this method in the general class
    `Product`. Thanks to inheritance, it would also be available for the class `Book`
    derived from `Product.` However, the display would ignore the special properties
    of books, such as the author or the number of pages, both of which are attributes
    of the `Book` class. These properties are only part of the `Book` class, not the
    `Product` class, so a display method that we place in the `Product` class naturally
    cannot access these properties. The garden shovel from the previous examples,
    an instance of the general class `Product`, has no number of pages!
  id: totrans-193
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: However, it would be practical if we had a display method that simply returned
    the correct display for each product, no matter what type of product we were dealing
    with. Ideally, we would call the display method `showProduct()`, and it would
    take care of outputting the right information on the screen for each type of product.
  id: totrans-194
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: This is exactly what `polymorphism` allows. `Polymorphism` means that classes
    that are derived from each other can have methods with the same name, but they
    all do something different. If the method is then called for a specific object,
    i.e., an instance of a class, the method belonging to the `respective class` is
    automatically executed. In our example, the properties author and number of pages
    would then also be displayed.
  id: totrans-195
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Such a polymorphic design of the method `showProduct()` could look like this:'
  id: totrans-196
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Class Product Begin` `name : String` `description : String` `itemnumber :
    Integer` `manufacturer : String` `price : DecimalNumber` `showProduct()` `setPrice(newprice:
    DecimalNumber)` `Product(startprice : DecimalNumber, name : String) End` `Class
    Book Inherits Product Begin` `author : String` `pages : Integer` `showProduct()
    End`'
  id: totrans-197
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As you can see, both classes, the “parent class” `Product` and the derived “child
    class” `Book`, each have a function `showProduct()`. Which one is executed when
    we call the method depends on whether the object for which we call the method
    is an instance of `Product` or an instance of its derived class `Book`.
  id: totrans-198
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: So, if we declare two objects
  id: totrans-199
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`GardenShovel : Product` `Grisham1992 : Book`'
  id: totrans-200
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: and then call the method `showProduct()` for each of the two objects,
  id: totrans-201
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`GardenShovel.showProduct()` `Grisham1992.showProduct()`'
  id: totrans-202
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 最终调用了两个不同的方法；对于对象`GardenShovel`，调用了类`Product`的方法，因为`GardenShovel`是其实例；对于对象`Grisham1992`，调用了派生类`Book`的方法，因此`showProduct()`也能正确显示页数和作者。
  id: totrans-203
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 多态方法的好处在于，我们不必关心`GardenShovel`和`Grisham1992`实际上是什么类型的对象。我们只需固执地调用`showProduct()`方法，所发生的总是针对相关对象类的最佳情况；方法名相同使得这一切成为可能。
  id: totrans-204
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在与多态相关的讨论中，反复出现的一个术语是`overloading`。人们谈到类`Product`的`showProduct()`方法被派生自`Product`的类重载，每个类都有自己的`showProduct()`方法，以最佳考虑其特性。这两个术语很好地描述了这种情况：“多态”指的是同一个方法可以有许多（希腊语`poly`）形式（希腊语`morphía`）；而“重载”描述了同一个函数被赋予多次不同含义的过程。
  id: totrans-205
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 11.7.6 访问权限
  id: totrans-206
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 为了总结我们对面向对象编程的观察，我们来看看最后一个特性，这再次强调了面向对象编程的动机，即严格分离类的开发与使用。
  id: totrans-207
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 有一种方法可以限制对类的属性和方法的访问。具体设计可能因编程语言而异，但通常至少有以下的访问权限梯度：
  id: totrans-208
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Private`: 处于此访问限制下的方法和属性只能被同一类的方法使用。它们对外界“不可见”；作为使用类的用户，您无法访问这些方法和属性。然而，您可以调用的方法（如果它不是私有的）可以使用这些方法和属性，但您无法直接这样做。因此，私有方法和属性被保护在外部世界之外。`private`的访问保护非常适合定义不被外部调用但只供类的其他方法使用的辅助变量或辅助方法。'
  id: totrans-209
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`Protected`: 被声明为`protected`的方法和属性可以被所属类和派生类使用，但不能被在其程序中使用这些类的程序员使用。'
  id: totrans-210
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`Public/open`: 方法和属性的访问限制为`public`，可以从任何地方访问，包括自身类、派生类以及类的用户。'
  id: totrans-211
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 'Consider the following extension of our example for clarification: `Class Product
    Begin Public name : String description : String itemnumber : Integer manufacturer
    : String showProduct() setPrice(newprice: DecimalNumber) Product(startprice :
    DecimalNumber, name : String) Private price : DecimalNumber End`'
  id: totrans-212
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Here we have declared the attribute `price` as a private property. The `setPrice()`
    method, on the other hand, is a public method. So, as developers of the class,
    we don’t want anyone to directly edit our attribute `price`. Therefore, we protect
    it as private. However, a method from the same class can access it and change
    its value. `setPrice()` is such a method. It is a public method that can be called
    from outside the class. So a programmer using our class could now edit the attribute
    `price` via the interface method `setPrice()`, but not directly, for example by
    assigning a value.
  id: totrans-213
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In this way, it is very easy to control which parts of classes should be visible
    to the outside and serve as an interface to the functionalities of the class,
    and which should not.
  id: totrans-214
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`11.3 [5 min]` Are the following statements true or false?'
  id: totrans-215
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`(a)`'
  id: totrans-216
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Object-oriented programming is the attempt to achieve as “natural” a representation
    of things in the real world as possible.
  id: totrans-217
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '`(b)`'
  id: totrans-218
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: A method is a function that belongs to a class and can change the attributes
    of this class instance.
  id: totrans-219
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '`(c)`'
  id: totrans-220
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: All attributes of a class instance can be changed directly from the program
    by assignment.
  id: totrans-221
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '`(d)`'
  id: totrans-222
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: The use of object-oriented programming makes the program clearer but makes adjustments
    to the program more difficult.
  id: totrans-223
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '`(e)`'
  id: totrans-224
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Inheritance means that you can reuse the definition of a class in different
    programs.
  id: totrans-225
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '`11.4 [3 min]`'
  id: totrans-226
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Describe the difference between a class and an instance.
  id: totrans-227
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`11.5 [3 min]`'
  id: totrans-228
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: What are the essential elements of a class definition?
  id: totrans-229
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`11.6 [3 min]`'
  id: totrans-230
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Why is polymorphism a useful approach in object-oriented programming?
  id: totrans-231
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`11.8 Your Roadmap to Learning a New Programming Language`'
  id: totrans-232
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: When you learn a new programming language …
  id: totrans-233
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'you’ll discover:'
  id: totrans-234
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: whether the language is case-sensitive for the identifiers, i.e., the names
    of variables and functions,
  id: totrans-235
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: which basic data types the language offers (especially numbers, strings, logical/truth
    values),
  id: totrans-236
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: whether you have to declare variables, and if so, how to do it
  id: totrans-237
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: how to assign values to variables,
  id: totrans-238
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: whether, and if so how, variables can be (explicitly) converted between data
    types and which conversions, if any, are already (implicitly) performed by the
    programming language itself,
  id: totrans-239
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: whether the language supports fields of similar variables (`arrays`), and if
    so, how to create fields and access their elements (in particular whether the
    indexing of the field elements starts at `0` or at `1`),
  id: totrans-240
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: whether the language knows associative fields whose values can be accessed with
    keys, and if so, how to create these fields and address their elements,
  id: totrans-241
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: which other complex data types are common in the programming language,
  id: totrans-242
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: whether the language supports object-oriented programming, and if so, how to
    access class attributes and methods, and how to define classes yourself, especially
    how to derive classes from existing classes.
  id: totrans-243
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 11.9 Solutions to the Exercises
  id: totrans-244
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: Exercise 11.1
  id: totrans-245
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In the languages that require a variable declaration, the variable is registered
    with the interpreter/compiler by the declaration; it reserves the necessary memory
    and, if necessary, assigns an initial value to the variable. After that, the variable
    can be used in the program. When declaring a variable, the identifier (name) of
    the variable and, in some languages, also its data type is specified.
  id: totrans-246
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Exercise 11.2
  id: totrans-247
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The need to declare a variable allows the interpreter/compiler to indicate the
    use of undeclared variables. Because undeclared variables are often the result
    of typos in the program code, this prevents a new variable from being accidentally
    created and worked with, while the variable that should have been accessed remains
    completely unchanged. The program code thus becomes more robust by forcing variables
    to be declared. The same is true if the type is already specified when declaring,
    and this type cannot be changed afterwards. In this case, the interpreter/compiler
    can report an error if the variable is accidentally assigned a value of an “inappropriate”
    type. This also avoids errors and makes the program code more robust.
  id: totrans-248
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Exercise 11.3
  id: totrans-249
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: (a)
  id: totrans-250
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: True.
  id: totrans-251
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: (b)
  id: totrans-252
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: True.
  id: totrans-253
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: (c)
  id: totrans-254
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: False. In many programming languages, attributes of class instances can be shielded
    from external access by defining them as `private`. These attributes can then
    only be edited by methods of the same class but are practically invisible to the
    outside world and therefore cannot be accessed directly by the programmer.
  id: totrans-255
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: (d)
  id: totrans-256
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: False. Object-oriented programming helps program elements become more independent
    of each other. Because the programmer only addresses the class instance via the
    defined methods (and, if necessary, by directly accessing the attributes), the
    inner workings of the class need not interest him or her any further. Thus, as
    long as the `interface` of the class remains unchanged externally, the developer
    of the class itself can change it internally at will, and the programs based on
    the class remain syntactically correct. Adaptations to the code are facilitated
    by this stronger modularization.
  id: totrans-257
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: (e)
  id: totrans-258
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: False. Inheritance means that further classes can be derived from a class, which
    “inherits” its methods and attributes. In this way, a class can be extended elegantly,
    especially for more specific uses.
  id: totrans-259
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: Exercise 11.4
  id: totrans-260
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The class is the abstract definition of an object (or object type) with the
    attributes and methods belonging to objects of this type and acts like a template.
    According to this template, the concrete objects, the class instances, are formed
    and therefore possess as images of the class all its methods and attributes.
  id: totrans-261
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Exercise 11.5
  id: totrans-262
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 本质上，类定义由类的标识符（名称）以及属于该类的属性和方法组成。这些可以通过相应的关键字提供访问权限限制（参见►`Sect. [11.7.6]`）。如果该类是从另一个类派生的，那么对“父类”的引用也是类定义的一部分（参见►`Sect.
    [11.7.3]`）。
  id: totrans-263
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Exercise 11.6`'
  id: totrans-264
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Polymorphism`允许不同类型（`classes`）的对象提供特定的方法。这使得可以将该方法适应于各自类的具体特性。当通过继承创建类层次结构时，这一点尤其有趣。如果现在在这个类层次结构中的某个类的实例上调用该方法，将使用该对象实例类的特殊实现。如果该类没有该方法的特殊实现，则使用同名方法的下一个更高层类的实现。这确保了总是使用最适合该类特性的实现方法，但在必要时可以使用属于更高层类的方法。这意味着不同的对象类型可以被不同地处理，但仍然向外部世界提供相同的接口（即，同名的方法）。程序员不必考虑他或她应该实际调用哪个类的哪个方法；他或她只需为对象实例调用该方法，解释器/编译器会为他或她澄清在这种情况下应该使用哪个方法。'
  id: totrans-265
  prefs: []
  stylish: true
  type: TYPE_NORMAL
