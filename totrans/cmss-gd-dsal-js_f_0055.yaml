- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following exercises provide you with the opportunity to practice analyzing
    algorithms. The solutions to these exercises are found in the section [​*Chapter
    5*​](f_0210.xhtml#optimizing.code.with.and.without.big.o.solutions).
  prefs: []
  type: TYPE_NORMAL
- en: Use Big O notation to describe the time complexity of an algorithm that takes
    4N + 16 steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Big O notation to describe the time complexity of an algorithm that takes
    2N².
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use Big O notation to describe the time complexity of the following function,
    which returns the sum of all numbers of an array after the numbers have been doubled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ doubleThenSum(array) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**const**​ doubledArray = []; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**for**​ (​**const**​ number ​**of**​ array) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | doubledArray.push(number * 2); |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**let**​ sum = 0; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**for**​ (​**const**​ number ​**of**​ doubledArray) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | sum += number; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**return**​ sum; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Use Big O notation to describe the time complexity of the following function,
    which accepts an array of strings and prints each string in multiple cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ multipleCases(array) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**for**​ (​**const**​ string ​**of**​ array) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | console.log(string.toUpperCase()); |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | console.log(string.toLowerCase()); |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​*// capitalizes first letter:*​ |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | console.log(string[0].toUpperCase() + string.slice(1)); |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: The next function iterates over an array of numbers. As it does so, it focuses
    on every other number while ignoring the numbers in between. For each “focus number,”
    the function proceeds to print out every number from the array—one at a time—after
    being added to the focus number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is this function’s efficiency in terms of Big O notation?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ everyOther(array) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**for**​ (​**const**​ [index, number] ​**of**​ array.entries()) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**if**​ (index % 2 === 0) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**for**​ (​**const**​ otherNumber ​**of**​ array) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | console.log(number + otherNumber); |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Copyright © 2024, The Pragmatic Bookshelf.
  prefs: []
  type: TYPE_NORMAL
