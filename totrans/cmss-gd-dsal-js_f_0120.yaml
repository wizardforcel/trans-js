- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following exercises provide you with the opportunity to practice with dynamic
    programming. The solutions to these exercises are found in the section [​*Chapter
    12*​](f_0217.xhtml#dynamic.programming.solutions).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function accepts an array of numbers and returns the sum, as
    long as a particular number doesn’t bring the sum above 100\. If adding a particular
    number will make the sum higher than 100, that number is ignored. However, this
    function makes unnecessary recursive calls. Fix the code to eliminate the unnecessary
    recursion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ addUntil100(array) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**if**​ (array.length === 0) { ​**return**​ 0; } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**if**​ (array[0] + addUntil100(array.slice(1)) > 100) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**return**​ addUntil100(array.slice(1)); |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } ​**else**​ { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**return**​ array[0] + addUntil100(array.slice(1)); |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: The following function uses recursion to calculate the Nth number from a mathematical
    sequence known as the Golomb sequence. It’s terribly inefficient, though! Use
    memoization to optimize it. (You don’t have to understand how the Golomb sequence
    works to do this exercise.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ golomb(n) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**if**​ (n === 1) { ​**return**​ 1; } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**return**​ 1 + golomb(n - golomb(golomb(n - 1))); |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Here is a solution to the unique paths problem from an exercise in the previous
    chapter. (Sorry, it’s a bit of a spoiler if you haven’t tried doing that exercise
    yet.) Use memoization to improve its efficiency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ uniquePaths(rows, columns) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**if**​ (rows === 1 &#124;&#124; columns === 1) { |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**return**​ 1; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ​**return**​ uniquePaths(rows - 1, columns) + uniquePaths(rows, columns
    - 1); |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | } |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Copyright © 2024, The Pragmatic Bookshelf.
  prefs: []
  type: TYPE_NORMAL
