- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Big O in Everyday Code
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, you learned how to use Big O notation to express the
    time complexity of code. As you’ve seen, quite a few details go into Big O analysis.
    In this chapter, we’ll use everything you’ve learned so far to analyze the efficiency
    of practical code samples that might be found in real-world codebases.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the efficiency of our code is the first step in optimizing it. After
    all, if we don’t know how fast our code is, how would we know if our modifications
    would make it faster?
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, once we know how our code is categorized in terms of Big O notation,
    we can make a judgment call as to whether it may need optimization in the first
    place. For example, an algorithm that is O(N²) is generally considered to be a
    slow algorithm. So if we’ve determined that our algorithm falls into such a category,
    we should take pause and wonder if there are ways to optimize it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, O(N²) may be the best we can do for a given problem. However, knowing
    that our algorithm is considered slow can signal to us to dig deeper and analyze
    whether faster alternatives are available.
  prefs: []
  type: TYPE_NORMAL
- en: In the future chapters of this book, you’re going to learn many techniques for
    optimizing our code for speed. But the first step of optimization is being able
    to determine how fast our code currently is.
  prefs: []
  type: TYPE_NORMAL
- en: So let’s begin.
  prefs: []
  type: TYPE_NORMAL
