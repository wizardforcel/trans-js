- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024 J. L. Zuckarelli Learn coding with Python and JavaScript
    [`https://doi.org/10.1007/978-3-658-42912-6_22`](https://doi.org/10.1007/978-3-658-42912-6_22)
  id: totrans-0
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`22. User Interfaces: How Do I Input and Output Data?`'
  id: totrans-1
  prefs:
  - PREF_H1
  stylish: true
  type: TYPE_NORMAL
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1)München, Germany Overview
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: We have dealt extensively with the organization of data in the program, namely
    the variables and objects used. Now is the time to talk about how data can be
    received from and output back to the user. To this end, in this chapter we will
    first deal with the simplest way of input and output, namely via the `console`.
    After that, we’ll give our programs a much more appealing look with `graphical
    user interfaces` (GUIs). Not only will we take a closer look at working with GUIs
    using a complete application example, but you will also have the opportunity to
    program your own first GUI application as part of an exercise. Finally, we turn
    to working with `files`, which is of course extremely important in practice.
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'In this chapter you will learn:'
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: How to output information to the console and how to query the user in the console
  id: totrans-5
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: how to use the Python library `tkinter` to provide your program with a graphical
    user interface
  id: totrans-6
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: what controls are available to you, how they can be configured, placed and arranged
    on the interface
  id: totrans-7
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: how you can react in your program code to events that the user triggers via
    the interface (for example, when clicking on a button)
  id: totrans-8
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: how to read data from and write data to files.
  id: totrans-9
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`22.1 Input and Output in the Console`'
  id: totrans-10
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: Already in the previous chapters we have seen the two most important functions
    that are used to input and output data in the Python console, `input()` and `print()`.
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Input`'
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`input(prompt)` displays a prompt and lets the user enter input from the keyboard,
    completing the input by pressing the `<RETURN>` or `<ENTER>` key. `input()` then
    returns the input as a return value, and always as a string. This is important,
    particularly if you expect the input to be numbers that you can use in calculations
    later. In this case, you must first explicitly convert the return value of `input()`
    to a number, as we did in ► Sect. `21.5`.'
  id: totrans-13
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Output`'
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The most important tool for outputting information is the`print()` function.
    It can be used to print one or more objects. If more than one object is to be
    printed, the optional string argument`sep` determines how the individual objects
    are separated from each other in the output; by default, this is done with a space
    character. The optional`end` argument controls what is printed at the end of the
    output; unless otherwise specified with`end`，a line break is placed at the end
    of the output. The line break is represented by an escape sequence`''\n''` (for
    *new line*), which we already learned about in ► Sect. [11.​2.​2](474412_1_En_11_Chapter.xhtml#Sec4)
    in connection with strings. Of course, we can also use these escape sequences
    directly in strings that we want to output: Consider the following small program
    as an example:'
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`user = input(''Username: '') pwd = input(''Password: '') print(''Welcome,
    '', user, ''!\nYour password is: '', pwd)` Here we read a username and password
    from the user and then output a total of four objects:'
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The string`'Welcome, '`
  id: totrans-17
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: The string variable`user`
  id: totrans-18
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 'The string`''!\n Your password is:''` (Attention: This string contains a line
    break after the exclamation mark!)'
  id: totrans-19
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: The string variable`pwd`.
  id: totrans-20
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 'If you call the program now and enter`peter` and`889X!z5` as username and password,
    you get the following output: Welcome, `peter` !Your password is: `889X!z5`'
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The space between the username`peter` and the exclamation mark is a bit unattractive.
    It is due to the default value of the separator argument`sep`，which is a space.
    Because of this, the two objects to be output, the variable`user` and the string
    beginning with the exclamation mark, are separated by a space. To avoid such problems,
    it is recommended to control the output of whitespace itself and set the argument`sep`
    to “empty string”, so that no separator is output by the`print()` function itself.
    The call to`print()`could then be like this:'
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`print(''Welcome, '', user, ''!\nYour password is: '', pwd, sep = '''')`'
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: If you compare this with the call above, you will see that we have inserted
    a space wherever a space is to be output and have provided an empty string as`sep`
    argument. Please note that the`sep` argument must always be called with its name,
    otherwise the`print()` function does not know whether the last string still belongs
    to the objects to be output or whether it has a special meaning, i.e. it already
    represents the *next argument of* the function, as in our case. So, we call`sep`
    as a *keyword argument*. More on this in ► Sect. [23.​1.​2](474412_1_En_23_Chapter.xhtml#Sec3).
  id: totrans-24
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Of course, the objects that are printed with `print()` do not have to be strings
    only. In fact, you can use `print()` to print practically any object, and even
    include objects of different types, i.e., different classes, in one and the same
    `print()` call. This applies to classes that you have defined yourself. But how
    can this work? How does `print()` know how to display an object of type `Product`
    from ► Sect. [21.​7](474412_1_En_21_Chapter.xhtml#Sec23), for example? The answer
    is simple: Classes in Python can have a special function `__str__()`. It returns
    a string representation of the object and is called by `print()` when an object
    of that class is to be output. As the developer of the class, you can specify
    how objects of your class should be represented. All you have to do is define
    a `__str__()` method. We will look at an example of this in ► Sect. [23.​2](474412_1_En_23_Chapter.xhtml#Sec6).'
  id: totrans-25
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 22.1`[5 min]`
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Specify three different ways to output the three string expressions `'First
    line'`, `'Second line'` and `'Third line'` in three consecutive lines.
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 22.2`Graphical User Interfaces with Tkinter`
  id: totrans-28
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 22.2.1`Overview`
  id: totrans-29
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: Programs on the command line or in the Python console are not everyone’s cup
    of tea. Especially if you develop software for non-tech-savvy end users, you simply
    can’t get around graphical user interfaces. Therefore, in this section we will
    look at how to design graphical user interfaces in Python with manageable effort,
    and how to back them up with program functionality. There are a number of ways
    to design graphical user interfaces in Python. With the `Streamlit` library, for
    example, you can use Python to create dynamic web pages that can also be hosted
    on web servers. In this chapter, we will concentrate on applications that run
    locally on a client, e.g. your computer.
  id: totrans-30
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Using the example of a graphical calculator, you will see that with only a few
    lines of code you can write a useful, fully functional program with an attractive
    interface that does not force the user to sit in front of a black console and
    stubbornly follow the given program flow. The chapter concludes with an exercise
    in which you will develop your own simple text editor that allows you to open,
    edit, and save text files.
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 有许多不同的库和框架用于开发图形界面。它们中的许多都是跨平台的，这意味着您用它们开发的程序可以在不同的计算机（有时是移动）操作系统上运行。我们将使用的一个常用库是`tkinter`。方便的是，它是Python的标准库，因此我们不需要安装额外的东西。`tkinter`是基于`Tk`的，这是一种用于图形用户界面的跨平台库，最初是在1990年代初期用一种名为`Tcl`的编程语言开发的。`Tcl`主要因`Tk`库而流行。这是因为它不仅适用于Tcl本身，而且适用于大量其他编程语言，包括Python。
  id: totrans-32
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Python提供了一个名为`tkinter`的包，它最终是一种与`Tk`的“连接”。要使用`Tk`库，Python调用一个Tcl解释器，该解释器也是标准Python安装的一部分。因此，实际上，您间接地使用了另一种编程语言，但您不需要理解Tcl语法或自己调用Tcl解释器。相反，您可以在Python中工作，并使用常规的Python语法。在必要时，Python会将您的语句“翻译”成Tcl代码并调用Tcl解释器。关于`Tk`的实用之处在于，一旦您理解了这个库的工作原理，您可以快速在支持`Tk`的其他编程语言中开发自己的图形用户界面——而这些语言有不少——而不会遇到任何重大转换困难。
  id: totrans-33
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在下一部分中，我们将编写一个简单的`Hello World`程序，该程序将在屏幕上打开一个窗口。之后，我们将仔细查看用户界面的各种图形控件，即`widgets`，如按钮、输入框和复选框。之后，我们只需再缺少两个组件。我们需要将这些元素按我们希望的方式排列在界面上，以便获得所需的界面外观。最后，我们必须将控件与背后的程序代码连接起来，以便它们能对用户的操作做出适当反应。这使我们拥有编写具有适当图形界面的Python程序所需的一切，比如我们将在`tkinter`介绍结束时开发的计算器。但让我们先从小事开始！
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 22.2.2 Hello Tkinter!
  id: totrans-35
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 创建一个新的Python文件，包含以下程序代码并运行该程序：
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`from tkinter import win = Tk() win.title(''Hello World Program'') win.geometry(''900x500'')
    win.mainloop()` 一扇窗口打开，外观类似于◘ 图 [22.1](#Fig1)。![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig1_HTML.jpg)'
  id: totrans-37
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 窗口中显示的文本为“Hello world program”的截图。
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 图 22.1
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 一个`Hello World`程序与`tkinter`
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 窗口仍然非常空，但在接下来的部分中这一点将很快改变。
  id: totrans-41
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: If you take a closer look at the code, you will notice that it starts with an
    `import` statement。这是必要的以使模块 `tkinter` 可用。You should not worry about the exact
    structure of the `import` statement at this point, because we will deal with the
    import from modules in more detail in ► Sect. [23.​3](474412_1_En_23_Chapter.xhtml#Sec7)。At
    this point, it is sufficient to know that the `import` statement makes the classes
    of the module `tkinter`，in particular the class `Tk`，usable for our program。
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: We create an instance of this class `Tk` in our program, namely the object `win`，the
    main window of our application。With the methods `title('titletext')` and `geometry('dimensions')`
    we set two important properties，the title of the window and its size in pixels。Then,
    using the `mainloop()` method, we display the window on the screen and start event
    processing；our program can now react to user actions。Our first `tkinter` program
    is complete！Simple, isn’t it？However, the user can still do little with our graphical
    interface。So, we need control elements that allow the user to make inputs and
    trigger actions。These controls are called `*widgets*` in `Tk/tkinter`。We will
    deal with them in the next section。
  id: totrans-43
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 22.2.3 Graphical Controls (Widgets)
  id: totrans-44
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: In this section we will look at a number of important widgets。Using the first
    widget, the button, as an example, you will see how widgets are created and how
    their properties are adjusted when they are created (or even later)。
  id: totrans-45
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 22.2.3.1 Buttons (Class `Button`)
  id: totrans-46
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: Buttons are built into `tkinter` as the class `Button`。They are used to let
    the user of the program trigger actions。Like all widgets, they can be easily created
    using their constructor method。The program from the previous section extended
    by this constructor call then looks like this：
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`from tkinter import win = Tk() win.title(''Hello World Program'') win.geometry(''900x500'')
    mybutton = Button(win, text = ''Press me'') mybutton.pack() win.mainloop()`'
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The `Button()` constructor method receives as function arguments the window
    in which we want to place the button, in our case `win`。Options for the design
    of the button can be specified; in our example, we label the button “Press me”
    with the help of the option `text`。Of course, we can still change the button’s
    properties `*after*` we have created the button。However, the properties are not
    simply editable class attributes of the `Button` class, but are changed with a
    special method called `config()`。Like the constructor, the `config()` method expects
    key-value pairs, consisting of the name of the option to be modified as a key
    and the value to be assigned to it。So, for example, if we wanted to change the
    width of our button, we would have to adjust the `width` option as follows：
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`mybutton.config(width = 50)`'
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The same can be done with the option`text`，i.e., the label of the button。
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'A second way to modify options is to access them like a dictionary, whose keys
    are the option names:'
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`mybutton[''width''] = 50`'
  id: totrans-53
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The question now is what setting options are available? To find out, you should
    take a look at the help of the class `tkinter`. To do this, you must first import
    the `Button` class (or just all classes, as we do below) from the `tkinter` module
    into the console (remember: your Python programs and the console do not use the
    same namespace; the fact that you already have a Python program that imports the
    module does not mean that you can also use the module in the console. So, before
    calling the help function, you still have to execute an `import` statement in
    the console):'
  id: totrans-54
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` from `tkinter` import `>>>` help(`Button`)'
  id: totrans-55
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Right at the top of the help text that appears is the following information:'
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '| STANDARD OPTIONS || activebackground, activeforeground, anchor, | background,
    bitmap, borderwidth, cursor, | disabledforeground, font, foreground | highlightbackground,
    highlightcolor, | highlightthickness, image, justify, | padx, pady, relief, repeatdelay,
    | repeatinterval, takefocus, text, | textvariable, underline, wraplength || WIDGET-SPECIFIC
    OPTIONS || command, compound, default, height, | overrelief, state, width'
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: So, as you can see, on the one hand there are `standard options` common to most
    widgets, on the other hand there are special options available only for buttons.
    Unfortunately, the help lacks a description of what setting each option controls,
    and how these options are used. Also, the “official” documentation of the `tkinter`
    package (► [https://​docs.​python.​org/​3/​library/​tk.​html](https://docs.python.org/3/library/tk.html))
    is of rather limited use, especially for beginners. However, there are numerous
    pages on the Internet where the features are explained in an understandable way,
    currently for example ► [https://​www.​tutorialspoint.​com/​python/​tk_​button.​htm](https://www.tutorialspoint.com/python/tk_button.htm).
  id: totrans-58
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: ◘ Table [22.1](#Tab1) shows an overview of some of the options that most, if
    not all, widgets have. This table also explains procedures for encoding colors
    and working with font formatting that can be used in many places in `tkinter`.
    Table 22.1
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Standard properties of `tkinter` widgets
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '| Option | Type | Meaning |'
  id: totrans-61
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-62
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `activebackground/activeforeground` | `Str` | Color of the control (background)
    or the text on it (foreground) when the control is activated (for in our case,
    by clicking on the button) Like all colors in `tkinter`, you can either specify
    one of the many predefined color constants (for example `''green''` or `''purple''`;
    you can quickly find lists of these color constants on the internet), or a red-green-blue
    (RGB) coded value of the form `''#RRGGBB''`, where `RR`, `GG`, and `BB` represent
    the hexadecimal (!) coded red, green, and blue parts of the color, respectively.
    It is best to use one of the many converters on the internet to convert the decimal
    values to the hexadecimal system. The value for red (R = 255, G = 0, B = 0) would
    thus become `''#FF0000''`, because `FF` represents the number 255 in the hexadecimal
    number system |'
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `background/foreground` | `Str` | Default color of the control (background)
    or the text on it (foreground) |'
  id: totrans-64
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `border` | `Int` | Thickness of the border of the control in pixels (`border=0`
    means no border) |'
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `cursor` | `Str` | The shape of the mouse cursor when the mouse pointer is
    over the control; examples are `''hand2''` (hand), `''watch''` (hourglass), `''cross''`
    (cross), `''left_ptr''` (“normal” mouse pointer with top left tip). There are
    also lists on the internet that specify the possible pointer characteristics |'
  id: totrans-66
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `font` | `Font` | The font formatting of the control; if you want to deviate
    from the default font, you must add an additional `import` statement and then
    create a new `Font` object using the `Font()` constructor: `from tkinter.font
    import font = Font(family = ''Times'', size = 36, weight = ''bold'', underline
    = 1)` After that, the new `Font` object `font` can be assigned to the `font` option
    of the control: `mybutton[''font''] = font` The `family` is a font identifier
    (e.g. `Helvetica`, `Courier`). The `weight` distinguishes between `''bold''` and
    `''normal''`. In addition, you can use the `slant` option, which is not used in
    the above example, to set the text to italic or not italic (`''normal''`). `overstrike`,
    which can take the values 1 and 0 (or `True` and `False`) just like `underline`,
    is used to strike through the text You can make changes to your `Font` object
    using the `config()` method, just as you can with controls: `font.config(weight
    = ''normal'')` Changes you make in this way automatically affect *all* controls
    to whose `font` option you originally assigned the now changed `Font` object |'
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `padx`, `pady` | `int` | Indentation of the text (or an image) on the control
    left/right (`padx`) or top/bottom (`pady`) |'
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `relief` | `str` | 3D representation of the control. Possible values here
    are: `''raised''` (protruding, the default value), `''sunken''` (deepened), `''flat''`,
    `''groove''` (deepened border) and `''ridge''` (simple border, otherwise flat)
    |'
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `text` | `str` | Labeling of the control |'
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_TB
- en: ◘ Table [22.2](#Tab2) then lists some of the `special` button options. In the
    following sections on the other widgets, you will find such a table with the most
    important specific properties for exactly this widget. Table 22.2
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Special properties of the button widget
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '| Option | Type | Meaning |'
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `command` | `function` | Function that is executed when the user clicks on
    the button. We will take a closer look at this event handling in ► Sect. [22.2.5](#Sec19)
    |'
  id: totrans-75
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `default` | `int` | If `default = 1`, then the button is the default button
    (triggered when the user presses the `<ENTER>` key) |'
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `height/width` | `int` | Height/width of the button. Specified in letter
    heights if text is displayed on the button, in pixels if an image is displayed.
    If not specified at all, width and height are calculated automatically |'
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `state` | `str` | Button can be set to either ''`normal`'' (clickable) or
    ''`disabled`'' (grayed out). If the button is currently clicked, `state` takes
    the value ''`active`'' |'
  id: totrans-78
  prefs: []
  stylish: true
  type: TYPE_TB
- en: 'We have just seen options that partly behave like a dictionary. Therefore,
    you can also use the `keys()` method to read the keys and thus the names of the
    options. If, after creating the widget instance, you include in your program code
    the statement `print(mybuttons.keys())` you will see the names of the available
    options in the (run) console when you run the program. If you call the `config()`
    method with no arguments, you will get back the entire dictionary with all name-value
    pairs. You can also have this output: `options = switch.config()` `print(options)`'
  id: totrans-79
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Often, the lowercase string option values such as ''`sunken`'' for the `relief`
    option can also be controlled with the help of a predefined, then capitalized
    constant, in our example `SUNKEN`. In the following, however, we will regularly
    work with the strings instead of the constants. If you want to work with the constants,
    look for the file `constants.py` in the `tkinter` directory of your hard disk.
    The constants are defined there. To use them, add the following import statement
    to your program:'
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`from tkinter.constants import *`'
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: So far, we haven’t even talked about the call to the `pack()` method that we
    snuck into our program. This statement makes the button visible on the screen
    in the first place (comment out the line and see what happens when you run the
    program again!). Making it visible is closely related to the arrangement of the
    widgets on the graphical interface. We will look at this in more detail in ► Sect.
    [22.2.4](#Sec15). At this point, all we need to do is call `pack()` to display
    our control on the interface.
  id: totrans-82
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 22.2.3.2 Menus (Class `Menu`)
  id: totrans-83
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 'Menus can be designed very easily with `tkinter`。To do this, we first create
    a new menu bar for our window, i.e., the `Tk` object `win` in the example above.
    The menu bar is represented in `tkinter` by the class `Menu`。The window to which
    the menu bar is to belong is already passed as an argument to the call of the
    constructor of this class. Conversely, we explicitly assign the new menu bar to
    the window with the help of the menu option of the `Tk` object, so that it is
    visible later:'
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`menubar_top = Menu(win)` `win.config(menu = menubar_top)`'
  id: totrans-85
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'As you already know, instead of calling the `Tk` object’s `config()` method
    in the last statement, we could have taken advantage of the practical fact that
    `tkinter` widgets work partly like dictionaries, and their options can therefore
    be accessed as well, like the key-value pairs of a dictionary. Accordingly, we
    could have written:'
  id: totrans-86
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`win[''menu''] = menubar_top`'
  id: totrans-87
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Now, your application has a menu bar, but it is not yet displayed when you
    start the program in this state. First, we have to add the individual pull-down
    menus, which will then be expandable and collapsible for the user. These pull-down
    menus are also objects of the `Menu` class, which we can create by calling the
    class constructor. This time, however, we don’t attach the new (pull-down) menus
    directly to the window `win`，but to our existing menu bar `menubar_top`:'
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`file_menu = Menu(menubar_top, tearoff = 0)`'
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The option `tearoff=0` causes the menu to be “bolted” to the window. If you
    omit this option or set it to `tearoff=1`，the first entry in your menu will be
    a dashed line. If you click on this entry, the menu detaches itself from its anchoring
    and is displayed in its own window, which can be moved around the screen at will
    (try it out!); a behavior that you would normally want to disable.
  id: totrans-90
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Now we can start adding new command items to the menu with `add_command(label
    = label)`:'
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`file_menu.add_command(label = ''Open...'')file_menu.add_command(label = ''Save'')file_menu.add_separator()file_menu.add_command(label
    = ''Close'')`'
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Using the `add_separator()` function of the `Menu` object we create a horizontal
    separator in the menu to structure our menu items more clearly. In addition to
    `add_command()` and `add_separator()`，there are two other types of menu items,
    `add_checkbutton()` and `add_radiobutton()`。Both allow the user to make a setting,
    as in the following example. The current setting (whether the menu option is currently
    selected or not) can be read at any time from the variable passed as the option
    `variable` to the `add_checkbutton()` function.
  id: totrans-93
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`file_menu.add_checkbutton(label = ''Auto save'', variable = auto_save)`'
  id: totrans-94
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'So far, our menu—unlike the individual menu items—has no display name at all.
    We change this by calling the function `add_cascade()` of the menu bar object,
    which also ensures that the menu is actually displayed as a pull-down menu on
    our menu bar:'
  id: totrans-95
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`menubar_top.add_cascade(label = ''File'', menu = file_menu)`'
  id: totrans-96
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: If you now start the program like this, a program window will open that has
    a menu bar with a “File” menu. Analogously, we could of course now place more
    pull-down menus on the menu bar.
  id: totrans-97
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The `add_...()` functions like `add_command()` can be called with numerous
    options, many of which can be found in ◘ Table [22.1](#Tab1). For example:'
  id: totrans-98
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`file_menu.add_command(label = ''Save'', background=''#FF0000'')` adds a menu
    item “Save” with a red background, the statement `file_menu.add_command(label
    = ''Save'', state=''disabled'')` shows a deactivated (grayed out) menu item. Of
    course, you can still modify your menu `after` you have created it. With `delete(index_from,
    index_to)` you can delete menu items by their numeric indices. With `entryconfig(index,
    option=value)` you change an `option` (for example `state` to enable/disable)
    for the menu item defined by `index`. You can query the options with `entrycget(index,
    option)`。Thus, to display the label (option `label`) of the second menu item,
    you can use the statement `print(file_menu.entrycget(1, ''label''))` (the indexes
    start, as always in Python, at 0!).'
  id: totrans-99
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: If you want to insert a menu entry later, use the functions `insert_...(index,
    option)`, where `...` stands for the respective element (e.g. `command`, `separator`,
    `checkbox`), just as with `add_...()`。The entry is then inserted `after` the entry
    specified by `index`。
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Our menu is now quite pretty to look at, but it has no functionality: clicking
    on a menu command does not trigger any action. This is because in our calls to
    `add_command()` of the pull-down menu object `file_menu`, we omitted the important
    `command` option, which allows us to specify a function to be called whenever
    the user clicks on the menu item. In this function we would then place the part
    of the program code that should be behind the menu item. We will deal with these
    event handlers in more detail in ► Sect. [22.2.5](#Sec19). At this point here
    we will concentrate entirely on creating a visually appealing interface.'
  id: totrans-101
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Dealing with a menu in `tkinter` is, as you can see, not complicated at all,
    but it requires several different steps. Therefore, here again is the overview
    what you have to do to provide your program with a menu:'
  id: totrans-102
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-103
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: Create the menu bar using the constructor `menubar = Menu(window)`。
  id: totrans-104
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-105
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: 'Add the menu bar to the window: `window[''menu''] = menubar`。'
  id: totrans-106
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-107
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: 'Create a new pull-down menu that you want to place on the menu bar: `pd_menu
    = Menu(menubar)`。'
  id: totrans-108
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '4.'
  id: totrans-109
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: 'Add menu items, i.e. commands (with `add_command()`), preference options (with
    `add_checkbox()` or `add_radiobutton()`) or separators (`add_separator()`) to
    the new pull-down menu, for example: `pd_menu.add_command(label = ''Title of command'')`.
    Note that later, to add functionality to the menu item, we will include the `command
    = event_function` option at this point.'
  id: totrans-110
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '5.'
  id: totrans-111
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: 'Attach your new pull-down menu to the menu bar and assign a title that will
    be visible in the menu bar: `menubar.add_cascade(label = ''Title of menu'', menu
    = pd_menu)`.'
  id: totrans-112
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: In this section, we’ve looked at creating an application menu as the main menu
    in your program. However, the `Menu` object can also be used to open pop-up/context
    menus anywhere in your window thanks to the `post(x, y)` function, but this is
    beyond the brief introduction to `tkinter` in this section.
  id: totrans-113
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 22.2.3.3 Input Fields (Classes `Entry` and `ScrolledText`)
  id: totrans-114
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 'Single-Line Entry: `Entry`'
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Input fields are used to accept text input from the user. In `tkinter`, a distinction
    is made between single-line (widget class `Entry`) and multi-line text input (widget
    class `ScrolledText`). We will take a closer look at both in this section.
  id: totrans-116
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The widget of type `Entry` can be created very easily with the constructor and
    assigned to the window, in our example still to the `Tk` object `win`.
  id: totrans-117
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`myentry = Entry(win)` `myentry.pack()`'
  id: totrans-118
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As with the button before, we call the `pack()` method to display the control
    in our window. In ► Sect. [22.2.4](#Sec15) we will look at how we can influence
    the arrangement of the controls in the window in more detail.
  id: totrans-119
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In ◘ Table [22.3](#Tab3) you will find an overview of the most important properties
    of the widget, which you can access in the usual way either by dictionary indexing
    `input['option']` or (but then only by writing) by `input.configure(option=value)`.Table
    22.3
  id: totrans-120
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Special properties of the `Entry` widget
  id: totrans-121
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '| Option | Type | Meaning |'
  id: totrans-122
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `justify` | `str` | Alignment of the text in the entry field, `''left''`
    (left-aligned, the default), `''center''` (centered) or `''right''` (right-aligned)
    |'
  id: totrans-124
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `selectbackground` | `str` | Background color of text selections |'
  id: totrans-125
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `selectforeground` | `str` | Font color of text selections |'
  id: totrans-126
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `show` | `str` | Character that is displayed (instead of the entered character);
    can be used for password entries, for example |'
  id: totrans-127
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `width` | `int` | Width of the entry field (in characters, not pixels) |'
  id: totrans-128
  prefs: []
  stylish: true
  type: TYPE_TB
- en: 'You can use the `get()` method at any time to retrieve the text that is currently
    in the `Entry` field, for example:'
  id: totrans-129
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`my_text = input.get()`'
  id: totrans-130
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Of course, you can also edit the text. This is done with the help of the `insert(index,
    string)` method. `index` specifies the text position (starting at 0) where you
    want to insert, `string` specifies the text to be inserted. So, at the beginning
    you can start with
  id: totrans-131
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`input.insert(0, ''A first text in the input field.'')`可以预设输入字段的文本。你可以简单地在`insert()`方法中指定`''end''`、`''insert''`或`''anchor''`，而不是使用真实的位置索引。这样文本会插入到末尾（`''end''`）、当前位置（`''insert''`）或当前选择的开头（如果当前有选择，则插入在开头，否则直接在文本开头）。例如，你可以使用语句`input.insert(''end'',
    ''End of text.'')`来将文本追加到末尾。同样，你可以使用`delete(*****from_index*****,** ***to_index*****)`方法删除文本。如果你省略可选参数`to_index`，只会删除索引为`from_index`的字符。'
  id: totrans-132
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 使用`icursor(*****index*****)`可以将光标放置在文本中的特定位置，更确切地说，是在指定的`index`字符之后。然而，请注意，在`tkinter`中字符计数是从1开始的，这与Python的习惯不同。如果你将数字0指定为`index`，则光标会放在第一个字符之前。这种计数方法适用于所有使用字符索引的地方。
  id: totrans-133
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 为了使光标在文本中实际可见，你必须给予控件焦点，即使它成为你窗口中当前活动的控件。你可以像对待所有其他小部件一样，使用`focus()`方法做到这一点。
  id: totrans-134
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 最后，方法`selection_range(*****from_index*****,** ***to_index*****)`允许你选择文本。同样，你可以使用`insert()`中已知的特殊常量`'end'`、`'insert'`和`'anchor'`。你可以使用`selection_get()`查询当前选中的文本，方法`selection_present()`在文本被选中时返回`True`。
  id: totrans-135
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Entry`还允许你使用剪贴板。你可以使用方法`clipboard_append(*****text*****)`将文本添加到剪贴板；使用`clipboard_get()`检索剪贴板的内容，使用`clipoard_clear()`清空剪贴板。'
  id: totrans-136
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 多行输入：`ScrolledText`
  id: totrans-137
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 如果要编辑更长的文本，小部件`ScrolledText`是一个不错的选择。要使用它，必须首先从`tkinter`包的`scrolledtext`模块中导入类`ScrolledText`：
  id: totrans-138
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`from` tkinter.scrolledtext `import` ScrolledText'
  id: totrans-139
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在许多方面，`ScrolledText`小部件的行为与`Entry`小部件完全相同。你所学到的关于`Entry`的内容大部分可以直接应用于`ScrolledText`（区别在于`justify`和`show`选项、`icursor()`方法和插入位置`'anchor'`不可用）。
  id: totrans-140
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 由于`ScrolledText`允许多行输入，因此文本位置也可以按照行/列方案进行定位是合乎逻辑的。例如，如果我们想删除从第二行第五个字符开始的所有文本，可以使用下面的方法调用。如果之前使用构造方法`ScrolledText()`创建的小部件命名为`st`：
  id: totrans-141
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`st.delete(2.4,''end'')`'
  id: totrans-142
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 请注意，在`Entry`中有一个单一索引的位置，现在出现了一个分数：`2.4`。然而，这个数字是一个编码的行/列规范。它表示：第二行，第五个字符。因此，尽管在行内字符从0开始计数（`4`因此指的是第五个字符），我们在`tkinter`中已经习惯的行计数从1开始！`2.4`因此指的是`第二`行，但指的是`第五`个字符。
  id: totrans-143
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`ScrolledText`小部件比`Entry`小部件强大得多。例如，它本身允许使用`edit_undo()`和`edit_redo()`方法来撤销或重做编辑操作（该小部件的`undo`选项必须事先设置为`True`）。`ScrolledText`还允许您为文本区域分配名称（称为`tags`），然后使用`tags`访问和编辑文本区域。这样，您可以例如以不同的颜色突出显示不同的文本区域。因此，如果您想开发一个具有语法高亮功能的文本编辑器，`ScrolledText`小部件不是一个坏的起点。'
  id: totrans-144
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 22.2.3.4 文本输出（标签）
  id: totrans-145
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 标签是显示在应用程序窗口中的静态文本。它们通常不提供用户任何交互选项，而是用于显示信息或描述控件的功能（如果这些控件没有自己的标签，例如按钮）。
  id: totrans-146
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 您可以如下创建并显示标签小部件：
  id: totrans-147
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`label = Label(win, text = ''Here is a fixed text'')` `label.pack()` ◘ 表 [22.4](#Tab4)
    显示了一些标签的重要属性。此外，当然还有大多数小部件提供的标准属性，这些属性列在◘ 表 [22.1](#Tab1)中，而标签最显著的特性无疑是`text`选项，即在标签上显示的文本。在示例中，我们在调用构造函数时直接设置了文本，但当然，像所有其他属性一样，它也可以通过`label.configure(text
    =` `new_text` `)`或`label[''text''] =` `new_text`轻松更改。'
  id: totrans-148
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Label`小部件的特殊属性'
  id: totrans-149
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '| 选项 | 类型 | 说明 |'
  id: totrans-150
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-151
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| **anchor** | **str** | 文本的位置和方向。使用方位词的英文缩写进行描述，例如`''ne''`表示*东北*，即右上角；可能的规格包括：`''n''`（顶部中心）、`''ne''`（右上角）、`''e''`（右中心）、`''se''`（右下角）、`''s''`（底部）、`''sw''`（左下角）、`''w''`（左中心）、`''nw''`（左上角）以及另外的`''center''`（水平和垂直居中）
    |'
  id: totrans-152
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| **width** | **int** | 标签的宽度（以字符为单位）。如果未指定，标签的宽度将足够容纳要添加的文本 |'
  id: totrans-153
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| **wraplength** | **int** | 标签中文本被换行的字符数。如果未指定，则不会换行 |'
  id: totrans-154
  prefs: []
  stylish: true
  type: TYPE_TB
- en: 22.2.3.5 `Check Buttons`和`Radio Buttons`
  id: totrans-155
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: '`Check`按钮（或`checkbox`）和`radio`按钮用于给用户提供多种设置/选项的选择。`checkbox`允许用户选择多个不同的设置/选项，而`radio`按钮仅允许用户一次选择一个设置/选项。'
  id: totrans-156
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Check`按钮和`radio`按钮在`tkinter`中由同名类表示。让我们首先创建两个`radio`按钮：'
  id: totrans-157
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`selection_var = IntVar()` `selection_opt1 = Radiobutton(win, text = ''Option
    One'', variable = selection_var, value = 1)` `selection_opt2 = Radiobutton(win,
    text = ''Option Two'', variable = selection_var, value = 2)` `selection_opt1.pack()`
    `selection_opt2.pack()`'
  id: totrans-158
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 首先，考虑`radio`按钮本身的构造函数调用：在这里，像往常一样，我们首先将我们的窗口对象`win`（类型为`Tk`）传递给`radio`按钮，并显示作为选择选项的文本。除此之外，还有两个参数，`variable`和`value`。
  id: totrans-159
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 对于`variable`参数，我们将一个变量`selection_var`赋值给它，`selection_var`是在代码段开始时创建的，作为`IntVar`类的实例。`IntVar`是`tkinter`附带的几个特殊变量类之一。它不仅仅是一个普通的`int`变量。这个变量的特别之处在于，当我们将它赋值给`radio`按钮构造函数的`variable`参数时，它始终反映我们的`radio`按钮集的当前状态，即指示当前选择了哪个`radio`按钮选项。我们通过`Radionbutton()`的`value`参数定义`selection_var`在选择特定`radio`按钮时所取的值。因此，如果用户点击“Option
    Two”`radio`按钮，`selection_var`的值为2。如果用户点击“Option One”，`selection_var`的值为1。`IntVar
    selection_var`会在`radio`按钮的选择状态变化时自动更新。
  id: totrans-160
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 这非常方便；但是，在查询值时需要记住一个特殊之处：如果你执行`print(selection_var)`，则会在运行控制台输出以下内容：`PY_VAR0`
  id: totrans-161
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 但这不是变量的值。这是因为`selection_var`不是一个普通的`int`变量。我们必须使用它的`get()`方法查询它的值，尽管这需要一些适应。以下语句将成功：
  id: totrans-162
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`print(selection_var.get())`'
  id: totrans-163
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 类似地，有一个方法`set()`，可以改变`IntVar`变量的值。由于我们通过构造函数`Radiobutton()`的`variable`参数将变量`selection_var`链接到单选按钮，这也改变了单选按钮之间的选择。
  id: totrans-164
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`selection_var.set(2)`我们会自动选择分配值为2的单选按钮，即“左侧”单选按钮。相同的效果可以通过调用相应单选按钮实例的`select()`方法来实现：`select_left.select()`'
  id: totrans-165
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 因为我们将`IntVar`变量`selection_var`作为`variable`选项`to both radio buttons`，`tkinter`知道这两个单选按钮属于同一组，因此只能`one
    of them`被选中。所以请务必将相同的变量作为`variable`选项分配给属于同一“选择组”的单选按钮！
  id: totrans-166
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Check buttons`的功能与单选按钮非常相似，当然不同的是，这里可以同时选择多个复选框，因为这两个复选框可以彼此独立选择。而对于单选按钮，如果按钮1被选中，按钮2就不能被选中，两个复选按钮则不再只有两种状态，而是四种不同的状态（两者都选中、都不选中、只选中第一个按钮、只选中第二个按钮）；一个的状态因此不再依赖于另一个按钮的状态。因此，你还需要两个不同的`IntVar`变量作为构造函数`Checkbutton()`的`variable`参数：'
  id: totrans-167
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`selection_var1 = IntVar()` `selection_var2 = IntVar()` `selection_opt1 = Checkbutton(win,
    text = ''Option One'', variable = selection_var1)` `selection_opt2 = Checkbutton(win,
    text = ''Option Two'', variable = selection_var2)` `selection_opt1.pack()` `selection_opt2.pack()`'
  id: totrans-168
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 你可能已经注意到，在`Checkbutton()`构造函数中，我们不再有`value`参数。默认情况下，状态变量`variable`在复选框被选中时取值`True`，未被选中时取值`False`。不过，使用可选参数或控件选项`onvalue`和`offvalue`，如果需要，可以更改此值。
  id: totrans-169
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: ◘ 表[22.5](#Tab5)给出了`Radiobutton`和`Checkbutton`类型的控件最重要的特殊属性的概述，超出了◘ 表[22.1](#Tab1)中列出的标准选项。
  id: totrans-170
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Checkbutton`和`Radiobutton`控件的特殊属性'
  id: totrans-171
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '| 选项 | 类型 | 意义 |'
  id: totrans-172
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-173
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `indicatoron` | `Bool` | If `False`，then instead of the circular (for radio
    buttons) or square (for check buttons) selection element, a real button is displayed
    that looks pressed down when the radio button/check button is selected |'
  id: totrans-174
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `selectcolor` | `str` | Background color of the circular (for radio buttons)
    or square (for check buttons) selection element |'
  id: totrans-175
  prefs: []
  stylish: true
  type: TYPE_TB
- en: 22.2.3.6 Selection Lists (`Listbox`)
  id: totrans-176
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 'Selection lists, represented by the `tkinter` class `Listbox`，allow a (single
    or multiple) selection from an enumeration of text entries. After creating a list
    box using the `Listbox()` class constructor and displaying the list box in the
    window using the `pack()` method:'
  id: totrans-177
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`mylistbox = Listbox(win)` `mylistbox.pack()` we can start adding items to
    the list box. To do this, we use the `insert(index, entry, ...)` method: `mylistbox.insert(''end'',
    ''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'')`'
  id: totrans-178
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`insert()` has some similarities to the `Entry` widget method of the same name:
    `index` first specifies the numeric index of the element to be inserted *after*;
    as with `Entry`’s `insert()` method, the value `''end''` can also be specified,
    which ensures that the entries are added to the end of the list. The list can
    also be extended by several entries at the same time. Please note that the indexing
    of the list entries starts at 0, as is typical for Python (unlike the indexing
    of the characters for the `Entry` widgets, but just like the “column indexing”
    for the multiline `ScrolledText` widgets).'
  id: totrans-179
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Also analogous to `Entry`，you can delete list entries from the list box with
    the method `delete(index_from, index_to)`。In the case of the `Entry` widget, this
    method had removed individual characters from the contents of the `Entry` field,
    i.e., a string and thus a “character list”.
  id: totrans-180
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: By calling the method `selection_set(index_from, index_to)`，you select entries
    in the list box as if the user had selected them.
  id: totrans-181
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In both `delete()` and `selection_set()`，`index_to` is an optional argument,
    i.e. an argument that can be omitted when calling the method.
  id: totrans-182
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Just as you can use `selection_set()` to select one (or more) entries, you can
    apply `selection_includes(index)` to check whether the element of the list denoted
    by `index` is currently selected.
  id: totrans-183
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Finally, with `selection_clear()` you can clear the current selection in the
    list box.
  id: totrans-184
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: You determine the number of list entries using the `length()` method, while
    `get(index_from, index_to)` allows you to read the text entry of one or more entries.
    If you use the optional argument `index_to` and thus specify a range, you get
    a `tuple` with the text entries of the specified list entries as return values.
  id: totrans-185
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: ◘ Table [22.6](#Tab6) lists some important options that you can customize in
    the now familiar ways for the `Listbox` widget. Table 22.6
  id: totrans-186
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Special properties of the `Listbox` widget
  id: totrans-187
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '| Option | Type | Meaning |'
  id: totrans-188
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-189
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `activestyle` | `str` | Specifies how the active entry, that is, the selected
    entry that currently has the focus, should be visually highlighted; possible values
    are `underline` (text underlined), `dotbox` (outline with dotted line), and `none`
    (no highlighting), where `underline` is the default value |'
  id: totrans-190
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `height` | `int` | The height of the list box but measured in entries rather
    than pixels; the default value is 10\. If you have more than the number of entries
    set in `height` and want to ensure that the entry at the `index` position is displayed,
    you can call the `see(index)` method; it scrolls the list box so that the `index`
    entry is visible in any case |'
  id: totrans-191
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `selectmode` | `str` | Specifies how many entries can be selected at the
    same time and how they must be related; possible specifications are: `single`
    (one entry can be selected by clicking on the entry), `browse` (one entry can
    be selected by clicking or moving the mouse with the mouse button pressed), `multiple`
    (several entries can be selected, clicking on an entry sets the selection if it
    wasn’t selected before or removes it if it was already selected) and `extended`
    (several entries can be selected by clicking while holding down the <CTRL> or
    <SHIFT> key); the default value is `multiple`, which is somewhat unusual for Windows
    users |'
  id: totrans-192
  prefs: []
  stylish: true
  type: TYPE_TB
- en: 'In addition, you can of course work with the standard options that we looked
    at in ◘ Table [22.1](#Tab1). Many of these properties can also be applied to `individual
    items` in the list box. To do this, use the `itemconfig(index, option=value)`
    method. For example, to give the third item a greenish background, you can execute
    the following statement: `mylistbox.itemconfig(2, background=''#ED5036'')`'
  id: totrans-193
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'In ◘ Table [22.6](#Tab6) you will once again find cases of options which can
    take one of several values, for example `activestyle`. In view of the rather difficult
    documentation situation with `tkinter`, the question naturally arises which expressions
    are permissible at all. You still don’t know what the individual values do, but
    you can quickly find out by trial and error. So, the important thing in the first
    step would be to understand what options you have in the first place. There is
    a simple trick for this: You provoke an error. To do this, consider the following
    code:'
  id: totrans-194
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`mylistbox[''activestyle''] = ''xxx''`'
  id: totrans-195
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Here we are trying to assign the value `xxx` to the `activestyle` option, which
    likely is not a valid expression for this option. If we run a program with this
    statement, we get an error message, but that is exactly what we are trying to
    achieve in this case. In our example we get:'
  id: totrans-196
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Traceback (most recent call last):` `File "C:/Users/MyUser/Desktop/Documents/tkinter_hello_world.py",
    line 138, in <module>` `names[''activestyle'']=''xxx''` `File "C:\Users\MyUser\AppData\Local\Programs\Python\Python37-32\lib\tkinter\__init__.py",
    line 1489, in __setitem__` `self.configure({key: value})` `File "C:\Users\MyUser\AppData\Local\Programs\Python\Python37-32\lib\tkinter\__init__.py",
    line 1482, in configure` `return self._configure(''configure'', cnf, kw)` `File
    "C:\Users\MyUser\AppData\Local\Programs\Python\Python37-32\lib\tkinter\__init__.py",
    line 1473, in _configure` `self.tk.call(_flatten((self._w, cmd)) + self._options(cnf))`
    `_tkinter.TclError: bad activestyle "xxx": must be dotbox, none, or underline`'
  id: totrans-197
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The crucial part here is in the last line. There, the error message lists the
    possible values, which can now be easily tried out.
  id: totrans-198
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`22.2.3.7 Message/Decision Dialogs (Class messagebox)`'
  id: totrans-199
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 有时你想以某种方式提醒用户，让他们注意到你的消息。或者你可能想强迫用户做出立即决策，比如在保存文件时是否覆盖它。在所有这些情况下，`message box`是一个不错的选择。
  id: totrans-200
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: You create a message box with the help of the `tkinter` module `messagebox`。因为`messagebox`与我们迄今为止遇到的大多数控件不同，它“打包”在自己的模块中（与`ScrolledText`一样），我们必须首先导入它包含的类。我们在这里简单使用星号通配符来导入`messagebox`模块中包含的所有类：
  id: totrans-201
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`from tkinter.messagebox import *`'
  id: totrans-202
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Then, using the `showinfo(title, message)`，`showwarning(title, message)` 和 `showerror(title,
    message)`函数，我们可以显示一个消息框，根据消息类型（信息、警告或错误）每个都有不同的图标。这里是一个警告消息的示例：
  id: totrans-203
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`showwarning(''Attention'',''The entered age must be greater than 0.'')`'
  id: totrans-204
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: You can also customize the design of the message boxes by specifying additional
    options when calling the respective function. Possible options are `icon`（应该显示哪个图标？），`type`（应该显示哪些按钮？）和
    `default`（哪个按钮应该预选，以便在用户按下<ENTER>键时触发）。
  id: totrans-205
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The `icon` option can take the values `''info''`, `''warning''`, `''error''`
    and `''question''`. The first three are the icons also used by the functions `showinfo()`,
    `showwarning()` and `showerror()`, while `''question''` displays a question mark
    icon. Like the icons, the combination of buttons available to the user can be
    specified using constants, in this case `''ok''` (*okay* button), `''okcancel''`
    (*okay* and *cancel*), `''yesno''` (*yes* and *no*), `''yesnocancel''` (*yes*,
    *no* and *cancel*), `''retrycancel''` (*retry* and *cancel*) and `''abortretryignore''`
    (*cancel*, *retry* and *ignore*). So, for example, if we wanted to display a small
    dialog asking the user if he wants to overwrite a file and offering him *Yes*,
    *No* and *Cancel* buttons, we could create a suitable message box like this:'
  id: totrans-206
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`feedback = showwarning(''Confirmation'', ''Do you really want to overwrite
    the file?'', icon=''question'', type=''yesnocancel'', default=''yes'')print(feedback)`'
  id: totrans-207
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: You can see from this example that although we are using the `showwarning()`
    function, which by default displays an exclamation mark as an icon, we can override
    the default behavior by specifying the `icon` option.
  id: totrans-208
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The function returns the value as a lowercase string containing the label of
    the button that was clicked, in our example `'yes'`, `'no'` or `'cancel'`. This
    function value is important in order to be able to react to the user’s input accordingly.
  id: totrans-209
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Unlike the controls we looked at in the previous sections, the message box is
    not a class that we need to create an instance of. Rather, it is simply a function
    that is contained in the `messagebox` module. It’s much the same with the file
    dialogs, which we’ll look at in the next section.
  id: totrans-210
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 22.2.3.8 File Open/File Save Dialogs
  id: totrans-211
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: If you want to let the user select a file to open or to save something to, the
    `tkinter` module `filedialog` allows you to easily use the well known standard
    dialogs “Open file” and “Save file as” in your own programs.
  id: totrans-212
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'First, we need to import the module. For the sake of simplicity, we import
    all classes and functions contained in the module, just as we did with the `messagebox`
    module in the previous section:'
  id: totrans-213
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`from tkinter.filedialog import *`'
  id: totrans-214
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'After that, the `askopenfilename()` or `asksaveasfilename()` functions can
    be used to call the dialogs for opening or saving files. In the following example
    we select a file to open and print the result in the (run-)console:'
  id: totrans-215
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`filename = askopenfilename(defaultextension=''txt'', filetypes=[(''Text files'',
    ''*.txt''), (''All files'', ''*.*'')], title=''Open file...'', initialdir=''C:\\Windows'')print(filename)`'
  id: totrans-216
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The functions return the name (including the path) of the selected file. If
    the user cancels the dialog without selecting a file or entering a file name,
    an empty string is returned. As you can see from the example above, you can control
    the behavior of the dialog with some options. `filetypes` is a list (note the
    enclosing square brackets!) of tuples, each consisting of a description and a
    file extension; the user can then preselect the file types thus defined. The `title`
    option controls the dialog title; `initialdir` is the directory whose contents
    should be displayed by default when the dialog opens; the backslash (`\`) as part
    of the pathname must be written twice, a single backslash would be interpreted
    by Python as an attempt to escape the character behind it; if you are not familiar
    with escaping, go back to ► Sect. [11.​2.​2](474412_1_En_11_Chapter.xhtml#Sec4).
  id: totrans-217
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'By the way: You may have wondered in the last section, with the `messagebox`
    module, why we don’t actually work with classes here, as with the other widgets,
    but instead call functions like `showwarning()` or `askopenfilename()`. The answer
    is: Because it’s easiest for us that way! These functions create the necessary
    class instances in the background. Since we’re only interested in the results,
    in this case the filenames, and don’t really want to work with the dialog (class)
    instances themselves, it’s sufficient that an appropriate function provides us
    with the filename and saves us the trouble of creating instances of the necessary
    classes ourselves and working with them. The situation is different, of course,
    with the other widgets, which are permanently present in our application window
    and with which we also want to work later.'
  id: totrans-218
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`22.2.3.9 Other Widgets`'
  id: totrans-219
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: In addition to the widgets we have looked at in the previous sections, there
    are a number of other controls that you can use when designing your program interface,
    for example `Canvas` (drawing area), `Spinbox` (input field with up-down arrows
    to adjust the value), `Treeview` (hierarchical display of elements; import from
    module `tkinter.ttk` module), `Notebook` (display of controls on tabs/tabs; also
    in `tkinter.ttk` module), `Progressbar` (in `tkinter.ttk` module), just to name
    a few. For working with images, which can be added to many controls (e.g., menu
    items, buttons) or used as background (e.g., of the main application window),
    there is also the class `PhotoImage`.
  id: totrans-220
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 正如您所看到的，`tkinter`还有很多东西值得探索！唯一的缺点是相对较差的文档，至少对于上述提到的`tkinter.ttk`模块的小部件而言。有较多或少足够的“官方”文档（目前可用地址为►
    [https://​docs.​python.​org/​3/​library/​tkinter.​ttk.​html](https://docs.python.org/3/library/tkinter.ttk.html)）。不过，通常进行自己的互联网搜索往往是最佳选择。幸运的是，您通常可以快速找到所需的内容，因为许多程序员在您之前已经有过类似的问题！
  id: totrans-221
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 22.2.4 控件的排列（几何管理器）
  id: totrans-222
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 在前面的部分中，我们认识了一些控制元素，允许用户通过界面控制程序。为了构建一个视觉上吸引人且易于使用的界面，各种控制元素必须放置在它们应该在界面上的位置。
  id: totrans-223
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 为了在表面上安排控件，`tkinter`提供了三种*几何管理器*，我们将在接下来的部分中更详细地处理它们。这三者都遵循不同的基本原则来定义控件在表面上的位置。根据您应用程序最适合的定位方式，您可以选择相关的几何管理器。
  id: totrans-224
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 三个几何管理器是：
  id: totrans-225
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Pack`：`Pack`简单地将控件一个接一个地放置，或者一个在另一个下面。在前面的部分中，我们已经通过调用小部件的`pack()`方法来使用这个几何管理器。这使得小部件一个在另一个下面被放置，并将它们居中于可用空间。'
  id: totrans-226
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`Grid`：`Grid`心理上将表面上的可用空间划分为行和列的网格，并允许控件放置在该网格的每个“单元格”中。`Grid`非常适合构建复杂的表面，并且应该足以满足大多数目的。'
  id: totrans-227
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`Place`：`Place`根据其*绝对*“坐标”位置来定位元素，这些坐标以像素为单位，或*相对*（以窗口宽度/高度的比例来测量）于窗口的左上角。'
  id: totrans-228
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 22.2.4.1 `Pack`
  id: totrans-229
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 当我们仔细查看各种小部件时，我们使用了`pack()`方法以确保这些小部件实际显示在我们的程序界面上。然而，这些小部件不仅被显示出来，而且当然也在窗口中同时定位，一个在另一个下面。这正是几何管理器`Pack`所做的：顾名思义，它“打包”各种控件，可以是垂直的“堆叠”（这是默认方向），也可以是水平的“行”。元素在表面上出现的位置主要取决于其前驱在堆叠（在垂直对齐的情况下）或行（在水平对齐的情况下）中的大小。
  id: totrans-230
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 举个例子，假设我们有一个用于输入密码的程序界面：
  id: totrans-231
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`from` `tkinter` `import` `win = Tk()win.title(''Demonstration of the Geometry
    Managers'')win.geometry(''500x100'')prompt = Label(win, text = ''Please enter
    your password:'')pwd = Entry(win)login = Button(win, text = ''Login'')pwd[''show'']
    = ''*''pwd[''width''] = 20pwd.focus()`'
  id: totrans-232
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'We create three widgets: a `label` called `prompt` to display a prompt, an
    entry field `pwd` to hold the password, and a login button to confirm the password
    entry. We then configure the entry field `pwd` to hide the password input and
    display only asterisks for the characters entered. We also set its width to 20
    characters and assign it focus so that the user can start typing directly. Next,
    as before, we call the `pack()` method to let the `pack` Geometry Manager place
    the widgets on the surface. To make sure that the controls are displayed next
    to each other and not—as would happen by default—below each other, we call `pack()`
    with the option `side`，which accepts the constants `''left''`，`''right''` and
    `''bottom''` as values for the direction of the widget positioning in addition
    to the default value `''top''`：'
  id: totrans-233
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`prompt.pack(side = ''left'')pwd.pack(side = ''left'')login.pack(side = ''left'')win.mainloop()You
    can see the result in ◘ Fig. [22.2](#Fig2). The widgets are now right next to
    each other. With the option `padx` (and vertically `pady`) we can add some spacing
    (`padding`) to the left and right of each widget, for example with:![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig2_HTML.jpg)'
  id: totrans-234
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of a window titled, demonstration of the Geometry Managers. A password
    field is given below with a login button placed right next to it.
  id: totrans-235
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fig. 22.2
  id: totrans-236
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Arrangement of the widgets with `pack(side = LEFT)`
  id: totrans-237
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`pwd.pack(side = ''left'', padx = 5)`'
  id: totrans-238
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Two other important options can be used to control the behavior of `pack()`
    in even more detail: `expand`，which can take the values `1` and `0` or `True`
    and `False`，determines whether the `pack` Geometry Manager should use the full
    width it has available. In our example，this is the entire window width. If we
    were to change the default setting for all three widgets and tell `pack()` to
    use the full width with `expand=1`，i.e.'
  id: totrans-239
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`prompt.pack(side = ''left'', expand = 1)pwd.pack(side = ''left'', expand =
    1)login.pack(side = ''left'', expand = 1)the result looks as in ◘ Fig. [22.3](#Fig3).![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig3_HTML.jpg)'
  id: totrans-240
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of a window titled, demonstration of the Geometry Managers. A password
    field is given below with a login button placed at a distance from it.
  id: totrans-241
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fig. 22.3
  id: totrans-242
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Arrangement of widgets with `expand` option
  id: totrans-243
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: This still “packs” the widgets, but each widget has more space. Within the space
    available to each widget, the control is centered by default, but this can easily
    be adjusted with the specifications`'n'`,`'ne'`,`'e'`,`'se'`,`'s'`,`'sw'`,`'w'`,`'nw'`,
    and`'center'` (default) of the additional `anchor` option. These options are the
    same as for the `Label` widget (see ◘ Table [22.4](#Tab4)).
  id: totrans-244
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Also, we can tell`pack()` to maximally expand the widgets in the space available
    to them, which is useful for some purposes, but often looks rather strange. To
    do this, we set the `fill` option to one of the constants`'x'` (expand horizontally),`'y'`
    (expand vertically), or`'both'` (expand both horizontally and vertically). This
    is exactly what happens in the following example with the input field, which we
    let expand in the horizontal direction, and the button, which we let expand in
    both directions to take up the available space, resulting in the interface seen
    in ◘ Fig. [22.4](#Fig4):![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig4_HTML.jpg)
  id: totrans-245
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of a window titled, demonstration of the Geometry Managers. An
    elongated password field is given below with a login button placed at a distance
    from it.
  id: totrans-246
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fig. 22.4
  id: totrans-247
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Arrangement of the widgets with different options
  id: totrans-248
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`prompt.pack(side = ''left'', fill = ''x'', anchor = ''w'')` `pwd.pack(side
    = ''left'', expand = 1, fill = ''x'', padx = 5, anchor = ''w'')` `login.pack(side
    = ''left'', expand = 1, fill = ''both'', anchor = ''w'')`'
  id: totrans-249
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As this example shows, you will usually have to play around with the `pack`
    options `side`,`fill`,`expand`,`anchor` and `padx/pady` until you have found a
    good layout. With a little experience, you can implement a surface structure that
    you have sketched on paper or digitally.
  id: totrans-250
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 22.2.4.2 Grid
  id: totrans-251
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: While `Pack` tries to “pack” the controls side by side, the `grid` Geometry
    Manager sees the application window as a `grid` of `rows` and `columns`. Controls
    can be freely positioned within the grid. The individual “cells” in the grid are
    addressed using the Python-typical indices starting at 0.
  id: totrans-252
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Consider the password input example used in the last section:'
  id: totrans-253
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`from tkinter import` `win = Tk()` `win.title(''Demonstration of the Geometry
    Managers'')` `win.geometry(''500x100'')` `prompt = Label(win, text = ''Please
    enter your password:'')` `pwd = Entry(win)` `login = Button(win, text = ''Login'')`
    `pwd[''show''] = ''*''` `pwd[''width''] = 20` `pwd.focus()`'
  id: totrans-254
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'In the next step, we use the `grid(row =` `row`, `column =` `column)` method
    to position the prompt and the input field next to each other, with the login
    button below the input field:'
  id: totrans-255
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`prompt.grid(row = 0, column = 0)` `pwd.grid(row = 0, column = 1)` `login.grid(row
    = 1, column = 1)` `win.mainloop()` The result is shown in ◘ Fig. [22.5](#Fig5).![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig5_HTML.jpg)'
  id: totrans-256
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of a window titled, demonstration of the Geometry Managers. A password
    field is given with a login button placed below it.
  id: totrans-257
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fig. `22.5`
  id: totrans-258
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Arrangement of the widgets with `grid()`.
  id: totrans-259
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As you can see, the input field and the button are displayed in the same column,
    namely column 1 (i.e., the second column). The Geometry Manager sizes the cells
    so that the widgets just fit into them. Within the cells, the controls are centered
    by default (vertically, and—as you can see in the example of the button—horizontally).
  id: totrans-260
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: However, the alignment of widgets within their cells can be easily influenced
    using the `sticky` option. As seen several times before, `sticky` is a compass
    direction specification. `sticky = 'w'` therefore means that the widget should
    be aligned “in the west”, i.e., on the left edge of the cell. At the same time,
    the cardinal directions can also be used to adjust the width of the widget so
    that, if it were smaller than the cell, it would still fill it completely. For
    example, `sticky = 'we'` causes the widget in its cell, whose width is determined
    by the wider input field in the row above it, to extend “from west to east”, i.e.,
    over the entire width of the cell.
  id: totrans-261
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: You can see the result in ◘ Fig. [`22.6`](#Fig6).![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig6_HTML.jpg)
  id: totrans-262
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of a window titled, demonstration of the Geometry Managers. A password
    field is given with a login button placed right below it.
  id: totrans-263
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fig. `22.6`
  id: totrans-264
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Arrangement of the widgets with `grid()` and the option `sticky = 'we'` for
    the button.
  id: totrans-265
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Sometimes, however, this is not enough, and you want a widget to span multiple
    columns or multiple rows. In this case, the `rowspan` and `columnspan` options
    help, specifying the number of rows or columns spanned respectively. With
  id: totrans-266
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`login.grid(row = 1, column = 0, sticky = ''we'', columnspan = 3)` our button
    would extend from the left edge of the prompt to the right edge of the input field.
    The `padx` and `pady` options, already known from `pack()` , allow you to specify
    a left/right and top/bottom spacing, respectively, which generally equalizes the
    display somewhat, as can be seen in the example in ◘ Fig. [`22.7`](#Fig7), where
    `padx` and `pady` values of 5 were used.![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig7_HTML.jpg)'
  id: totrans-267
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of a window titled, demonstration of the Geometry Managers. A password
    field is given with a login button placed below it at a distance.
  id: totrans-268
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fig. `22.7`
  id: totrans-269
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Arrangement of the widgets with `grid()` and the options `padx` and `pady`.
  id: totrans-270
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The total size of the grid in your application window depends on where you have
    placed the widgets positioned furthest out. In our example, the grid has two columns
    and two rows; if we were to place a widget to the right of the input field using
    `widget.grid(row = 0, column = 2)` , a third column would be added. Grid is a
    very popular Geometry Manager because it allows you to design effective surfaces
    with little effort, while providing intuitive positioning. The example in ► Sect.
    [`22.2.6`](#Sec20), where we develop a full `tkinter` application, will also use
    `Grid`.
  id: totrans-271
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`22.2.4.3 Place`'
  id: totrans-272
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: The third, last and probably least frequently used Geometry Manager in practice
    is `Place`. `Place` is used to place widgets either at an absolute position specified
    by `x` and `y` coordinates using the `x` and `y` arguments, or at a relative position.
    Relative means that the position relative to the upper left corner of the window
    is measured as a percentage of the window width or height. The statement
  id: totrans-273
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`login.place(relx = 0.5, rely = 0.5)` positions the `login` button exactly
    in the middle of the window, namely after 50% of the window width (`relx`) and
    50% of the window height (`rely`) from the upper left corner of the window. More
    precisely: The `upper left corner` of the button is placed there. With the `anchor`
    option, already known from `pack()`，another corner can also be specified as the
    “anchor” of the positioning. Again, the corner is specified by geographical directions,
    for example `''se''` for the southeastern, i.e., the lower right corner. The size
    of the widgets can also be specified, either absolutely with the help of the `width`
    and `height` options, or by a relative size specification. In this case, `relwidth`
    and `relheight` can be used to specify a width or height as a percentage of the
    window width or height.'
  id: totrans-274
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The advantage of specifying relative positioning and sizes is that the position
    and size of the widgets adapt when the window size changes, an effect that can
    also be achieved with the Geometry Managers `pack` and `grid` (although a bit
    more tedious with the latter), but this is not the case when using `place` with
    absolute position specifications.
  id: totrans-275
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 22.2.5 Events
  id: totrans-276
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: The Command Option of the `tkinter` Widgets
  id: totrans-277
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: So far, we have put together responsive interfaces, but they are largely without
    function. Nothing happens when you click on one of our buttons or menu items.
    That will change now.
  id: totrans-278
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Some widgets, such as `Button` or `Menu`，bring with them the ability to specify
    a function that will be called whenever the control is “triggered” by the user.
    Consider the following simple example of the now well-known conversion between
    Kelvin and degrees Celsius. A small converter with a graphical interface might
    look like this:'
  id: totrans-279
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`from` `tkinter` `import` `def convert():lb_result[''text''] = ''Conversion
    result: '' + str(round(float(en_kelvin.get()) - 273.15, 2)) + '' °C.''`def closeapp():quit()win
    = Tk()win.title(''Kelvin-Celsius Conversion'')win.geometry(''400x150'')menu_top
    = Menu(win)win.config(menu = menu_top)actionmenu = Menu(menu_top, tearoff = 0)actionmenu.add_command(label
    = ''Convert'', command = convert)actionmenu.add_separator()actionmenu.add_command(label
    = ''Close'', command = closeapp)menu_top.add_cascade(label = ''Action'', menu
    = actionmenu)lb_input = Label(text = ''Temperature in Kelvin:'')en_kelvin = Entry()bt_convert
    = Button(win, text = ''Convert'', command = convert)lb_result = Label(width =
    30)lb_result.pack()en_kelvin.pack()bt_convert.pack(pady = 10)lb_result.pack(pady
    = 10)win.mainloop()`用户界面的程序如图`◘ Fig. [22.8](#Fig8)`所示。![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig8_HTML.jpg)'
  id: totrans-280
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 窗口截图标题为“Kelvin-Celsius conversion”。输入字段下方有一个转换按钮。
  id: totrans-281
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Fig. 22.8`'
  id: totrans-282
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Kelvin to Celsius converter`'
  id: totrans-283
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 与前面的部分相比，这一次我们在调用按钮构造方法`Button()`时使用了`command`选项来添加菜单项`add_command()`。`command`选项被赋值为一个函数，称为`event
    handler`或`callback function`，每当用户触发该控件时，该函数会被自动调用。例如，如果我们的“Convert”按钮被点击，`convert()`函数会被自动调用。我们在程序中较早之前定义了`convert()`函数（函数定义必须在赋值给`command`选项之前）；它简单地执行转换并在`lb_result`标签上打印结果。注意，在将事件处理函数分配给`command`选项时，函数名后面没有指定圆括号。这是因为`command`选项仅仅传递函数`object`；你会记得在Python中，函数也是对象——只有在定义函数（如你将看到的）或调用函数时，我们才需要包括圆括号，而不是当我们指的是函数对象本身时。
  id: totrans-284
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Binding Event Handlers `tkinter` knows another, much more powerful way to react
    to events. This is done with the help of the widget method `bind()`. With the
    statement `bt_convert.bind(''<button-1>'', convert)` we could have achieved the
    same effect as with the `command` option in the `Button()` constructor above.
    The `bind(event, eventhandler_function)` method binds an event handler function
    to an event. Henceforth, our event processing `mainloop()` watches to see if the
    event is triggered and calls the event handler function if it is. The string `''<Button-1>''`
    represents the event that the left/primary mouse button (“Button 1”) is pressed
    (the right mouse button, by the way, would be `''<Button-3>''`, `''<Button-2>''`
    the middle mouse button). Besides these button events, there are a variety of
    such events to which we can bind event handlers; here are some examples:'
  id: totrans-285
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`<DoubleButton-1>`: Double click with the left mouse button.'
  id: totrans-286
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`<Enter>` and `<Leave>`: The user has entered the area of the control with
    the mouse pointer or the mouse pointer has left the area of the control.'
  id: totrans-287
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`a`, `b`, `c`, ...: The respective letter was pressed.'
  id: totrans-288
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`<Key>`: `Any` letter was pressed.'
  id: totrans-289
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`<F1>`, ...: The respective function key was triggered.'
  id: totrans-290
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`<Escape>`, `<BackSpace>` (remove), `<Delete>`, `<Tab>` (tabulator), `<Return>`
    (Return or Enter), `<Shift_L>` (Shift), `<Control_L>` (Ctrl), `<Alt_L>` (Alt),
    `<End>`, `<Home>`, `<Left>` (left arrow), `<Up>` (Up arrow), `<Right>` (Right
    arrow), `<Down>` (Down arrow), `<Print>`, `<Insert>`: The respective special key
    was pressed.'
  id: totrans-291
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 'Key combinations can also be represented with this method: If, for example,
    you want to bind a function to the event that `<CTRL>` and `S` were pressed simultaneously,
    you can simply specify `''<Control_L>S''` as the event.'
  id: totrans-292
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the event handlers that we bind to an event with
    `bind()`. These functions are automatically passed an argument of type `Event`.
    Accordingly, we have to adapt our previous event handlers, which we assigned to
    the `command` option of our button, for example, because these event handlers
    do not require any argument. The change is marginal, but avoids a runtime error:'
  id: totrans-293
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`def` convert(ev = `None`):`lb_result[''text'']` = ''Conversion result: ''
    `+` str(round(float(`en_kelvin.get()`) - 273.15, 2)) `+` '' °C.'''
  id: totrans-294
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: We don’t need to do anything with the `Event` object `ev` but the event handler
    function must provide the argument. By giving the argument a default value (namely
    `None`), we also make the function callable for the `command` option of our menu
    item “Convert”, because it calls the event handler `without` an argument. So,
    the event handler has to cope with being called with an argument as well as with
    the argument being omitted.
  id: totrans-295
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'But what is the content of this event object? The event object provides some
    information about the event, especially:'
  id: totrans-296
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`x`, `y`：鼠标位置（相对于窗口左上角）触发事件的位置（对于点击事件特别重要）。'
  id: totrans-297
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`widget`：触发事件的小部件。'
  id: totrans-298
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`char`：被按下的字符键（对于`<Key>`事件尤其重要）。'
  id: totrans-299
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 顺便提一下：您还可以直接将事件绑定到应用程序窗口，在我们的案例中是`Tk`对象`win`。如果某个小部件触发了事件，系统会首先自动检查该小部件是否绑定了事件处理程序。如果没有，则会检查“下一个更高”的对象，在我们的案例中是应用程序窗口，是否有此事件的事件处理程序。从这个意义上说，事件处理程序的存在是从“具体到一般”进行检查的；事件处理程序形成了一种层级结构。
  id: totrans-300
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 22.2.6 示例：计算器应用程序
  id: totrans-301
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 在本节中，我们将使用`tkinter`开发一个简单的计算器。计算器应能处理四种基本算术运算，并允许将计算结果复制到剪贴板。您可以在◘图`[22.9](#Fig9)`中查看结果。![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig9_HTML.jpg)
  id: totrans-302
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 一个计算器应用程序窗口的截图。下面是一个输入框，数字为`96.54`，并有一个数字键盘和数学运算符。
  id: totrans-303
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 图`22.9`
  id: totrans-304
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 计算器应用程序的界面
  id: totrans-305
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 现在让我们逐步查看代码：
  id: totrans-306
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '1`from`tkinter`import`2`from`tkinter.font`import`3`from`functools`import`456`#
    Define eventhandler functions for buttons`7`def`digit_operator_press(digit_operator):`8`display[''text'']
    = display[''text''] + digit_operator`91011`def`delete_press():`12`display[''text'']
    = ''''`131415`def`copy_press():`16`win.clipboard_clear()`17`win.clipboard_append(display[''text''])`181920`def`plusminus_press():`21`display[''text'']
    = ''-'' + display[''text'']`222324`def`equal_press():`25`display[''text''] = str(eval(display[''text'']))`262728`#
    Define eventhandler for <ENTER> key`29`def`enter_press(ev):`30`equal_press()`313233`#
    Create application window`34`win = Tk()`35`win[''background''] = ''#000000''`36`win.title(''Calculator'')`37`win.geometry(''268x470'')`38`win.resizable(height=False,
    width=False)`3940`# Define fonts for button and display`41`digit_font = Font(family
    = ''Arial'', size = 18)`42`display_font = Font(family = ''Arial'', size = 24,`43`weight
    = ''bold'')`4445`# Create the display`46`display = Label(text = '''',`47`background
    = ''#000000'',`48`foreground = ''#00FF00'')`49`display[''width''] = 1350`display[''font'']
    = display_font`51`display[''height''] = 252`display[''anchor''] = ''e''`5354`#
    Define buttons`55`delete_op = Button(win,`56`text = ''Delete'',`57`width = 9,`58`height
    = 1,`59`font = digit_font,`60`foreground = ''#FFFFFF'',`61`background = ''#4C4E4F'',`62`command
    = delete_press)`63`plusminus_op = Button(win,`64`text = ''+/-'',`65`width = 4,`66`height
    = 1,`67`font = digit_font,`68`foreground = ''#FFFFFF'',`69`background = ''#4C4E4F'',`70`command
    = plusminus_press)`71`copy_op = Button(win,`72`text = ''Copy'',`73`width = 4,`74`height
    = 1,`75`font = digit_font,`76`foreground = ''#FFFFFF'',`77`background = ''#4C4E4F'',`78`command
    = copy_press)`79`digit1 = Button(win,`80`text = ''1'',`81`width = 4,`82`height
    = 2,`83`font = digit_font,`84`command = partial(digit_operator_press,''1''))`85`digit2
    = Button(win,`86`text = ''2'',`87`width = 4,`88`height = 2,`89`font = digit_font,`90`command
    = partial(digit_operator_press, ''2''))`91`digit3 = Button(win,`92`text = ''3'',`93`width
    = 4,`94`height = 2,`95`font = digit_font,`96`command = partial(digit_operator_press,
    ''3''))`97`digit4 = Button(win,`98`text = ''4'',`99`width = 4,`100`height = 2,`101`font
    = digit_font,`102`command = partial(digit_operator_press, ''4''))`103`digit5 =
    Button(win,`104`text = ''5'',`105`width = 4,`106`height = 2,`107`font = digit_font,`108`command
    = partial(digit_operator_press, ''5''))`109`digit6 = Button(win,`110`text = ''6'',`111`width
    = 4,`112`height = 2,`113`font = digit_font,`114`command = partial(digit_operator_press,
    ''6''))`115`digit7 = Button(win,`116`text = ''7'',`117`width = 4,`118`height =
    2,`119`font = digit_font,`120`command = partial(digit_operator_press, ''7''))`121`digit8
    = Button(win,`122`text = ''8'',`123`width = 4,`124`height = 2,`125`font = digit_font,`126`command
    = partial(digit_operator_press, ''8''))`127`digit9 = Button(win,`128`text = ''9'',`129`width
    = 4,`130`height = 2,`131`font = digit_font,`132`command = partial(digit_operator_press,
    ''9''))`133`digit0 = Button(win,`134`text = ''0'',`135`width = 9,`136`height =
    2,`137`font = digit_font,`138`command = partial(digit_operator_press, ''0''))`139`divide_op
    = Button(win,`140`text = ''/'',`141`width = 4,`142`height = 2,`143`font = digit_font,`144`foreground
    = ''#FFFFFF'',`145`background = ''#10a605'',`146`command = partial(digit_operator_press,
    '' / ''))`147`multiply_op = Button(win,`148`text = ''*'',`149`width = 4,`150`height
    = 2,`151`font = digit_font,`152`foreground = ''#FFFFFF'',`153`background = ''#10a605'',`154`command
    = partial(digit_operator_press, '' * ''))`155`minus_op = Button(win,`156`text
    = ''-'',`157`width = 4,`158`height = 2,`159`font = digit_font,`160`foreground
    = ''#FFFFFF'',`161`background = ''#10a605'',`162`command = partial(digit_operator_press,
    '' - ''))`163`plus_op = Button(win,`164`text = ''+'',`165`width = 4,`166`height
    = 2,`167`font = digit_font,`168`foreground = ''#FFFFFF'',`169`background = ''#10a605'',`170`command
    = partial(digit_operator_press,'' + ''))`171`point_op = Button(win,`172`text =
    '','',`173`width = 4,`174`height = 2,`175`font = digit_font,`176`command = partial(digit_operator_press,
    ''.''))`177`equal_op = Button(win,`178`text = ''='',`179`width = 10,`180`height
    = 1,`181`font = digit_font,`182`foreground = ''#FFFFFF'',`183`background = ''#0570A6'',`184`command
    = equal_press)`185186`# Define eventhandler for Enter key`187`win.bind(''<Return>'',
    enter_press)`188189`# Place buttons on interface`190`display.grid(row = 0, column
    = 0, columnspan = 5,`191`sticky = ''news'')`192`delete_op.grid(row = 1, column
    = 0, columnspan = 2,`193`sticky = ''news'')`194`plusminus_op.grid(row = 1, column
    = 2, sticky = ''news'')`195`copy_op.grid(row = 1, column = 4, sticky = ''news'')`196`digit1.grid(row
    = 2, column = 0, sticky = ''news'')`197`digit2.grid(row = 2, column = 1, sticky
    = ''news'')`198`digit3.grid(row = 2, column = 2, sticky = ''news'')`199`digit4.grid(row
    = 3, column = 0, sticky = ''news'')`200`digit5.grid(row = 3, column = 1, sticky
    = ''news'')`201`digit6.grid(row = 3, column = 2, sticky = ''news'')`202`digit7.grid(row
    = 4, column = 0, sticky = ''news'')`203`digit8.grid(row = 4, column = 1, sticky
    = ''news'')`204`digit9.grid(row = 4, column = 2, sticky = ''news'')`205`digit0.grid(row
    = 5, column = 0, columnspan = 2,`206`sticky = ''news'')`207`point_op.grid(row
    = 5, column = 2, sticky = ''news'')`208`divide_op.grid(row = 2, column = 4, sticky
    = ''news'')`209`multiply_op.grid(row = 3, column = 4, sticky = ''news'')`210`minus_op.grid(row
    = 4, column = 4, sticky = ''news'')`211`plus_op.grid(row = 5, column = 4, sticky
    = ''news'')`212`equal_op.grid(row = 6, column = 0, columnspan = 5,`213`sticky
    = ''news'')`214215`# Event loop`216`win.mainloop()`Lines 1–3: Import'
  id: totrans-307
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: We first import all classes from the `tkinter` module. Furthermore, the “display”
    of our calculator will use a special font, so we also import everything from the
    `font` module. We need the last import statement to make the event functions that
    are supposed to react to the user’s digit input a bit simpler. More about this
    shortly.
  id: totrans-308
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Lines 6–30: Event Handler Functions for Buttons'
  id: totrans-309
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: These are the event functions that react to the different user actions. We’ll
    go into these functions in a little more detail at the end, but first we want
    to look at the interface. With knowledge of the interface, it is also easier to
    understand how the event handlers work.
  id: totrans-310
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Lines 33–38: Window of the Application'
  id: totrans-311
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Our calculator should have a black background and a fixed window size that cannot
    be changed by the user.
  id: totrans-312
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Lines 40–52: Fonts and Display'
  id: totrans-313
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Next, we define two fonts, `digits_font` for the digits on the calculator keys,
    and `display_font` for the display on the calculator. The display itself has a
    green foreground and a black background color. With `display['anchor'] = 'e'`
    we align its content “east”，i.e., right aligned.
  id: totrans-314
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Lines 54–184: Create the Buttons'
  id: totrans-315
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Next, we create the buttons for our window `win`，which are characterized by
    a number of properties, namely their label (`text`), their `width` and `height`
    in text characters, the `font`，the `foreground` and `background` color, and the
    event handler (`command`) that is called when the user clicks on the button.
  id: totrans-316
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: For the event handlers, we use a little trick to avoid having to write a separate
    event handler for each of the 10 digits and each arithmetic operator. We have
    defined only one event handler named `digit_operator_press()`，which we call with
    one argument, namely the respective digit or the respective operator. But the
    option `command` of the `tkinter button` object must be passed a function object,
    not a call to a function with arguments. Therefore, we use the `partial` function
    from the `functools` module to create a function object in which the argument
    is already “baked in”. Since the return value of `partial()` is an object not
    unlike the `function` object, but which already contains the argument value, we
    can use this return value as the value for the `command` option of our buttons.
  id: totrans-317
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Lines 186–187: Event Handler for the `<ENTER>` Key'
  id: totrans-318
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: To make it possible to trigger the computation not only by clicking the equals
    sign button on the interface, but also by pressing `<ENTER>` on the keyboard,
    we bind an event handler (lines 29–30) to the event of pressing `<ENTER>`，which
    does nothing but call the event handler that is triggered when the equals sign
    button is pressed (lines 24–25). We still need to separate the two event handlers,
    because the event handler that processes the button press is passed an event object
    as an argument by default, which we must accept even if we don’t process it at
    all.
  id: totrans-319
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'With that in mind, let’s take a quick look at the other event handlers:'
  id: totrans-320
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`digit_operator_press()`（第6–8行）：事件处理程序将被点击的数字或算术运算符作为参数传递。按下的按钮的值简单地附加到显示区域中现有的内容上。'
  id: totrans-321
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`delete_press()`（第11–12行）：清空显示区域的内容。'
  id: totrans-322
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`copy_press()`（第15–17行）：首先清空剪贴板，然后将显示区域的当前内容追加到剪贴板中。`clipboard_clear()`和`clipboard_append()`这两个函数用于此目的，它们都由`Tk`类方便地提供，因此也可以用于我们的窗口对象`win`。'
  id: totrans-323
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`plusminus_press()`（第20–21行）：当按下加减按钮时，我们简单地在当前显示内容前面添加一个减号。严格来说，我们应该检查是否已经存在一个减号，然后将其移除。但就像处理其他输入一样（例如，我们不检查用户是否连续输入两个运算符），我们在这一点上让自己轻松一些，并依赖用户的常识。'
  id: totrans-324
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`equal_press()`（第24–25行）：这是之前提到的事件处理程序，当用户请求计算结果时被调用。在这里，我们使用`eval()`函数，它会评估一个Python表达式并返回其结果。在我们的案例中，Python表达式就是用户输入并显示在计算器显示区域的数字和运算符的序列。然而，`eval()`也可以用于执行作为字符串参数传递的完全任意的Python代码。'
  id: totrans-325
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 第189–213行：将按钮放置在界面上。
  id: totrans-326
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 现在我们只需要将显示区域和按钮放置在界面上。为此，我们需要`grid`几何管理器，因此我们使用`grid()`方法来为各个控件指定它们在网格中的位置，具体通过指定它们的`row`和`column`号。通过`columnspan`选项，我们可以使某些元素横向扩展跨越多个网格单元，例如显示区域。通过`sticky`选项的值`news`（`north
    + east + west + south`），我们指定各自网格单元中的元素应完全扩展，即填充整个单元。
  id: totrans-327
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 第215–216行：事件循环。
  id: totrans-328
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 使用`mainloop()`我们开始处理计算器的事件。从现在起，用户界面会通过调用相应的事件处理程序来响应用户的输入。
  id: totrans-329
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 22.3 处理文件
  id: totrans-330
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 在Python中处理文件非常简单。这个过程分为三个步骤，和大多数其他编程语言类似：
  id: totrans-331
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-332
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: 文件被打开（可能在第一时间被创建）。
  id: totrans-333
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-334
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: 文件被处理（它被读取、写入或追加）。
  id: totrans-335
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-336
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: 文件在所有工作完成后关闭。
  id: totrans-337
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: 'Opening FilesA file is represented by a `file object`。We create such a file
    object with the help of the standard Python function `open(filepath, mode)`。The
    argument `mode` describes the editing mode in which the file is to be opened。Possible
    values of the mode are:'
  id: totrans-338
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`"w"`: The file is opened for `writing`。The file pointer is set to the beginning
    of the file。Any existing contents of the file are completely replaced。If the file
    does not yet exist, it will be newly created。Reading from the file in this mode
    is not possible。'
  id: totrans-339
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`"a"`: The file is opened for `appending`。The file pointer is placed at the
    end of the file。Contents that are written to the file are appended to it。Reading
    from the file is not possible in this mode。'
  id: totrans-340
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`"r"`: The file is opened for `reading`。The file pointer is set to the beginning
    of the file。Writing to the file is not possible in this mode。'
  id: totrans-341
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`"r+"`: The file is opened for reading `and` writing。'
  id: totrans-342
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 'Note that if you are working on a Windows system, you must `escape` the backslashes
    that separate the path components in the path specification with another backslash,
    otherwise Python will regard them as an attempt to escape the `following character`
    and thus assign a special control function to it (if you are no longer familiar
    with escaping, go back and review ► Sect. [11.​2.​2](474412_1_En_11_Chapter.xhtml#Sec4))。For
    example, if we wanted to open the file `test.txt` in the directory `C:\Programming`
    for writing, we would first have the function `open()` create a corresponding
    file object (which we call `file` here for simplicity): `file = open("C:\\Programming\\test.txt",
    "w")`'
  id: totrans-343
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'This object has a number of properties that allow us to better understand its
    character: `file.name` gives us the file name as a full path specification, `file.mode`
    the mode in which we opened the file。Furthermore, whether the file is readable
    and/or writable can be determined with the methods `file.readable()` and `file.writable()`，which
    return a `bool` value each。'
  id: totrans-344
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Editing the File
  id: totrans-345
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: To `write` to the file, the file object provides the methods `write(text)` and
    `writelines(lines)`。
  id: totrans-346
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`write()` simply writes `a` string to the file, without a trailing newline
    unless `text` contains the escape sequence `\n` at the end (for example, `"This
    is a newline\n text"`)。'
  id: totrans-347
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`writelines()`, in contrast, writes `several` strings that are passed as an
    array; the name of the function is somewhat misleading, because `writelines()`
    also does not write a newline at the end of each string。So, if you want a line
    break after each string, you have to add it yourself：'
  id: totrans-348
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`lines = ["line 1\n", "line 2\n"]file.writelines(lines)`'
  id: totrans-349
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The write methods each return the number of characters written as a function
    value。
  id: totrans-350
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'To *read* from a file the functions `read()`， `readline()` and `readlines()`
    are available. `read()` reads the *entire* file contents and returns it as a string.
    With an optional argument, a *certain number of characters* (measured from the
    current position of the file pointer) can be read. The file pointer starts at
    the beginning of the file and moves accordingly with each read operation. Consider
    the following example file:'
  id: totrans-351
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Line number oneOne more lineLast line
  id: totrans-352
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: With `read(3)`， after opening the file (the file pointer is then at the beginning
    of the file)， we would first read the string `"Lin"`。 After that, the file pointer
    is on the `"e"` of `"line"`。 Another `read(19)` would then return the next 19
    characters, i.e. `"e number one\nOne mo"`。 Note that the line break also counts
    as a character, and as *exactly one* character (although it is represented as
    an escape sequence in the form `\n` with two characters). After this reread, the
    file pointer is now on `"r"` of `"more"`。
  id: totrans-353
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The `readline()` and `readlines()` functions proceed differently than `read()`;
    they read in one or more *lines* respectively. `readline()` always reads in exactly
    the next line, while `readlines()` reads in all lines or the number of lines passed
    as an optional argument, returning an *array of strings.* The `readline()` and
    `readlines(1)` method calls thus differ in that the result of the `readline()`
    call results in a `str` value, while `readlines()` returns an array, which in
    this case contains only a single string as an element.
  id: totrans-354
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: If the file pointer is not at the beginning of a line, but in the middle of
    a line, as after the call to `read(3)` above, then `readline()` and `readlines()`
    read from the character on which the file pointer is currently located. The beginning
    of the line (in our example, the first three characters already read with `read()`)
    is then no longer read.
  id: totrans-355
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: When reading, you can use `seek(*****characterindex*****)` to set the file pointer
    to the character specified by `characterindex`， counting from the beginning of
    the file. The current position of the file pointer is returned by the `tell()`
    method of the file object.
  id: totrans-356
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'By the way: If you open the file in `"r+"` mode (read *and* write), you can
    actually use the same file object for both operations. However, writing is always
    done at the end of the file, reading at the current position of the file pointer,
    which behaves the same way as when opening the file in `"r"` mode.'
  id: totrans-357
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Close the File
  id: totrans-358
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'After editing the file, close it with the `***file*****.close()` method. The
    file object will continue to exist, but its property `***file*****.closed` will
    now take the value `True`， indicating that the object is not available for reading
    or writing any more. However, since the file object still carries the path to
    the file as its `name` property, you can simply “reactivate” it:'
  id: totrans-359
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`file = open(file.name, "r")` 22.2 [15 min]'
  id: totrans-360
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Write a program that queries the user for the name of a file (with its complete
    path). A certain percentage (specified by the user) of the file content is then
    to be displayed as a preview. Line breaks shall be removed from the preview display
    so that the display is as compact as possible.
  id: totrans-361
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '22.4 Exercise: Development of a Simple Text Editor'
  id: totrans-362
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: The following exercise combines many of the things you have learned in this
    chapter to develop a useful little application.
  id: totrans-363
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The task is to program a simple text editor with `tkinter`. This should allow
    you to create new files or open existing files, and then edit and save the files
    again, either under the current name or a new name. Also, the user should be able
    to copy text to the clipboard and paste it from the clipboard. The commands of
    the editor shall be selectable via a menu as well as via a button bar.
  id: totrans-364
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: You will want to use the `ScrolledText` widget from the `tkinter` module `scrolledtext`.
    Therefore, make sure you include the line `from tkinter.scrolledtext import ScrolledText`
    in your imports even if you import the rest of the `tkinter` widgets with `from
    tkinter import *`.
  id: totrans-365
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Test your program extensively!
  id: totrans-366
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The estimated time to complete this task is 120 min. You should have a quiet
    space to focus on this piece of development work. If the task still seems too
    challenging, do not spend hours trying to develop the editor yourself, but read
    the code in the sample solution and try to understand it, at first without referring
    to the explanatory notes in the solution.
  id: totrans-367
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 22.5 Summary
  id: totrans-368
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to input and output data via the console.
    We also looked at how graphical user interfaces can be implemented in Python to
    allow the user to interact with your program conveniently.
  id: totrans-369
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Be sure to take the following points from this chapter:'
  id: totrans-370
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In the Python console, you can always print objects using the built-in Python
    function `print(object)`.
  id: totrans-371
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Information can be requested from the user using the `input(prompt)` method,
    which always returns the user input as a string (so the user input must be converted
    if necessary).
  id: totrans-372
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Graphical user interfaces (GUIs) can be easily implemented with the `tkinter`
    library, which is part of the standard Python package.
  id: totrans-373
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: A `tkinter` program always consists of creating a `Tk` object using the constructor
    function of the same name, creating and configuring the controls (widgets), defining
    the arrangement of the controls (using a Geometry Manager) and starting event
    processing (method `mainloop()` of the `Tk` object).
  id: totrans-374
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: The most important controls (widgets) for graphical user interfaces in `tkinter`
    are `Button`, `Menu`, `Entry` (text input), `Label` (text display), `Checkbutton`
    (multiple selection of options), `Radiobutton` (single selection of options) and
    `Listbox` (list-like display of text entries with single or multiple selection).
  id: totrans-375
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 'Important standard dialogs that can be used from within `tkinter` (more specifically,
    the `tkinter` module `filedialog`) are: `messagebox` (with several variants that
    differ in the displayed icons and buttons) for displaying text messages; and `askopenfilename()`
    and `asksaveasfilename()` for querying file paths when opening or saving files.'
  id: totrans-376
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: The widgets are configured via options; some options (but not their values!)
    are common to almost all widgets (for example, the `background` color and the
    `font`), others are specific to the particular control.
  id: totrans-377
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: All widgets have the `config(*****option*** **=** ***value*****, ...)` method,
    which can be used to set the values of the options. In addition, the options can
    be accessed in the form `widget['option']` as if they were a dictionary.
  id: totrans-378
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Widgets are arranged on the program surface with the help of a Geometry Manager;
    `tkinter` has three such arrangement tools with `pack` (arrange directly next
    to/below each other), `grid` (arrange along an imaginary grid) and `place` (arrange
    by specifying coordinates relative to a reference point), that can be called with
    the standard methods `pack()`, `grid()` and `place()` of each widget.
  id: totrans-379
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: To read and write data from or to files, the file in question is first opened
    with the built-in Python function `open(*****filename*****, **mode**)`; this returns
    a `File` object.
  id: totrans-380
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Modes for editing files are `r` (read), `w` (write), `a` (append), and `r+`
    (read and write).
  id: totrans-381
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: The methods `read()` and `readlines()` as well as `write()` and `writelines()`
    of the `File` object can be used to read from or write to the file.
  id: totrans-382
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: The `close()` method of the `File` object closes the file again after processing
    is complete.
  id: totrans-383
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 22.6 Solutions to the Exercises
  id: totrans-384
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 'Exercise 22.1 `# First option: Three print()-commands (each automatically #
    ending with \n) print(''First line'') print(''Second line'') print(''Third line'')
    # Second option: One string, lines separated by the \n escape # sequence. print(''First
    line\nSecond line\nThird line'') # Third option: Output of three string objects,
    using the \n # escape sequence as separator. print(''First line'', ''Second line'',
    ''Third line'', sep = ''\n'')` Exercise 22.2'
  id: totrans-385
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The program could look like this:'
  id: totrans-386
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`filename = input("Please enter a filename (incl. path): ") percent = input("Percent
    of content to be previewed " + "(whole number, e.g. 10 for 10%): ") previewfile
    = open(filename, "r") contents = previewfile.read() previewfile.close() content
    = contents.replace("\n", "") length_total = len(content) length_preview = int(length_total
    * int(percent) / 100) print("### Preview: ", length_preview, " characters of ",
    length_total, "characters ###") print(content[0:length_preview], "\n####\n")`'
  id: totrans-387
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The file is first opened in read mode (`"r"`) and its entire contents are read
    with `read()`. After that, the file can be closed again, because the string variable
    `content` now contains the entire file content, and we will only continue to work
    with this content. After we have cleaned line breaks from the content by removing
    the escape sequence `\n` with the string method `replace()`, we select the desired
    number of characters in the last statement, which we have previously calculated
    from the preview percentage specified by the user, and display them on the screen.
    When selecting characters from the string, it is important to ensure that the
    selection limits are integers. We achieve this by using `int()` to store the result
    as an integer variable when calculating the preview length.
  id: totrans-388
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Programming Task `Text Editor` Many variants are of course possible in the development
    of the text editor. The user interface of the solution presented here can be seen
    in ◘ `Fig. [22.10](#Fig10).` ![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig10_HTML.jpg)
  id: totrans-389
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of a window titled, `My personal text editor`. It has buttons on
    top of the window such as `new`, `open`, and `save`. Three lines are given in
    the field below with the text, `line number one`, `one more line`, and `last line`,
    respectively.
  id: totrans-390
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Fig. 22.10`'
  id: totrans-391
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`User interface` of our text editor'
  id: totrans-392
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The code looks like this:'
  id: totrans-393
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '1 **from** tkinter **import** *2 **from** tkinter.filedialog **import** *3
    **from** tkinter.scrolledtext **import** ScrolledText45 *# Define event handler
    functions for buttons and menus*67 **def** new_press():8 **global** filename9
    text.delete(1.0, ''end'')10 filename = ''''11 status[''text''] = ''Unsaved new
    file''121314 **def** open_press():15 **global** filename16 fname = askopenfilename(defaultextension
    = ''txt'',17 filetypes = [(''Text Files'', ''*.txt''),18 (''All Files'', ''*.*''),],19
    title = ''Open....'',20 initialdir = ''C:\\Windows'')21 textfile = open(fname,
    ''r'')22 text.delete(1.0, ''end'')23 text.insert(1.0, textfile.read())24 textfile.close()2526
    status[''text''] = ''File "'' + fname + ''" opened.''27 filename = fname282930
    **def** saveas_press():31 **global** filename32 fname = asksaveasfilename(defaultextension
    = ''txt'',33 filetypes = [(''Text Files'', ''*.txt''),34 (''All Files'', ''*.*''),],35
    title = ''Save File As...'',36 initialdir = ''C:\\Windows'')37 textfile = open(fname,
    ''w'')38 textfile.write(text.get(1.0, ''end''))39 textfile.close()4041 status[''text'']
    = ''File "'' + fname + ''" saved.''42 filename = fname434445 **def** save_press():46
    **global** filename47 textfile = open(filename, ''w'')48 textfile.write(text.get(1.0,
    ''end''))49 textfile.close()5051 status[''text''] = ''File "'' + filename + ''"
    saved.''525354 **def** copy_press():55 selection = text.selection_get()56 text.clipboard_clear()57
    text.clipboard_append(selection)585960 **def** paste_press():61 text.insert(text.index(''insert''),
    text.clipboard_get())626364 **def** copy_press_key(event):65 copy_press()666768
    **def** paste_press_key(event):69 paste_press()707172 **def** quit_press():73
    win.quit()747576 *# Create application window*77 win = Tk()78 win.title(''My Personal
    Text Editor'')79 win.geometry(''760x490'')80 win.resizable(height = True, width
    = True)818283 # Set up the menu84 menubar = Menu(win)85 win.config(menu = menubar)8687
    file_menu = Menu(menubar, tearoff=0)88 edit_menu = Menu(menubar, tearoff=0)8990
    menubar.add_cascade(label = ''File'', menu = file_menu)91 menubar.add_cascade(label
    = ''Edit'', menu = edit_menu)9293 file_menu.add_command(label = ''New'',94 command
    = new_press)95 file_menu.add_command(label = ''Open...'',96 command = open_press)97
    file_menu.add_command(label = ''Save'',98 command = save_press)99 file_menu.add_command(label
    = ''Save As...'',100 command = saveas_press)101 file_menu.add_separator()102 file_menu.add_command(label
    = ''Quit'',103 command = quit_press)104105 edit_menu.add_command(label =''Copy'',106
    command = copy_press)107 edit_menu.add_command(label =''Paste'',108 command =
    paste_press)109110111 # Create the control elements112 new_button = Button(win,113
    text = ''New'',114 height = 3,115 width = 16,116 command = new_press)117 open_button
    = Button(win,118 text = ''Open...'',119 height = 3,120 width = 16,121 command
    = open_press)122 save_button = Button(win,123 text = ''Save'',124 height =3,125
    width = 16,126 command = save_press)127 saveas_button = Button(win,128 text =
    ''Save As...'',129 height = 3,130 width = 16,131 command = saveas_press)132 seplabel
    = Label(win,133 text='''',134 height =3,135 width= 3)136 copy_button = Button(win,137
    text = ''Copy'',138 height = 3,139 width = 16,140 command = copy_press)141 paste_button
    = Button(win,142 text = ''Paste'',143 height = 3,144 width = 16,145 command =
    paste_press)146147 text = ScrolledText(win)148 text.bind(''<Control-c>'', copy_press_key)149
    text.bind(''<Control-v>'', paste_press_key)150151152 *# Set up the status bar*153
    status = Label(win,154 text = ''No file openend.'',155 anchor = ''w'',156 background
    = ''#FFEFC4'')157 filename = ''''158159160 *# Place buttons on surface*161 new_button.grid(row
    = 0, column = 0, sticky = ''news'')162 open_button.grid(row = 0, column = 1, sticky
    = ''news'')163 save_button.grid(row = 0, column = 2, sticky = ''news'')164 saveas_button.grid(row
    = 0, column = 3, sticky = ''news'')165166 seplabel.grid(row = 0, column= 4, sticky
    = ''news'')167 copy_button.grid(row = 0, column = 5, sticky = ''news'')168 paste_button.grid(row
    = 0, column = 6, sticky = ''news'')169170 text.grid(row = 1, column = 0, columnspan
    = 7, pady = 10,171 sticky = ''news'')172173 status.grid(row = 2, column = 0, columnspan
    = 7,174 sticky = ''news'')175176177 *# Event loop*178 win.mainloop()Lines 5–73:
    Eventhandler Functions for Buttons and Menus'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: We’ll take a closer look at how event handlers work below once it’s clear which
    components will make up the interface.
  id: totrans-395
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Lines 76–80: `Application Window`'
  id: totrans-396
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The window `win` is created and scaled as a `Tk` object. It should be resizable
    for the user.
  id: totrans-397
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Lines 83–108: `Menu Setup`'
  id: totrans-398
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A new menu bar is created for the `win` window and two drop-down menus, `file_menu`
    and `edit_menu` are placed on the bar. The menu items are then gradually added
    to the menus.
  id: totrans-399
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Lines 111–149: `Creating the Remaining Controls`'
  id: totrans-400
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: This is where the buttons and the text input field are created. In addition,
    event handlers are bound to two events of the text input field to process the
    pressing of the key combinations `<CTRL>+<C>` (copy) and `<CTRL>+<V>` (paste).
  id: totrans-401
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Lines 152–157: `Preparing the Status Bar`'
  id: totrans-402
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: We create a label as a yellowish colored status bar, on which the name of the
    currently opened file is displayed.
  id: totrans-403
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Lines 160–174: `Placing the Controls on the Interface`'
  id: totrans-404
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The controls are arranged on the user interface using the `grid` Geometry Manager,
    in such a way that they fully fill their respective “grid cells” (`sticky = 'news'`，i.e.,
    `north east west south`).
  id: totrans-405
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Lines 177–178: `Event Loop`'
  id: totrans-406
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`mainloop()` starts event processing for our editor. This makes the user interface
    react to the user’s input.'
  id: totrans-407
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Event Handlers` (Lines 5–73)'
  id: totrans-408
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`new_press()`: Creates a file by first deleting the contents of the `ScrolledText`
    field; deletes from line 1 (line numbering starts at 1 for text widgets in `tkinter`)，column
    0 (column numbering starts at 0) to the end. Instead of the string `''end''` the
    constant `END` could have been used.'
  id: totrans-409
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: The global variable `filename`，to which we secure access with the statement
    `global filename` (otherwise a `local` variable with the same name would be created
    within `new_press()`) is reinitialized with an empty string and the text of the
    status bar is updated.
  id: totrans-410
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '`open_press()`: Here we use the `askopenfilename()` function to retrieve the
    path to the file we want to open. After that, the file is opened in read mode
    with `open()` and the content read from it with `read()` is put into our text
    field before the file is closed again with `close()`.'
  id: totrans-411
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`save_as_press()` and `save_press()`: For save, we basically do the same as
    for open; however, the file is opened in write mode so that the `write()` method
    can write the text on the editor that we get using the `get()` method of the `ScrolledText`
    widget. In `save_as_press()`，we ask for the filename using `tkinter`’s `asksaveasfilename()`
    function, and for `save_press()`，we save the file using the name we’re already
    using. So, this can only work if a file has been opened or the content of the
    `ScrolledText` widget has already been saved to a file.'
  id: totrans-412
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`copy_press()`和`paste_press()`，`copy_press_key()`和`paste_press_key()`：在复制文本时，我们首先使用`ScrolledText`小部件的`selection_get()`方法确定文本选择的内容，然后使用`clipboard_clear()`清空剪贴板，最后使用`clipboard_append()`方法将要复制的文本插入剪贴板。'
  id: totrans-413
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 在插入文本时，我们首先确定当前插入位置，即在我们的`ScrolledText`小部件中的光标位置，使用`index('insert')`，然后获取剪贴板内容，使用`clipboard_get()`将其插入到该位置。
  id: totrans-414
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: The `copy_press_key()`和`paste_press_key()`函数是我们绑定到按键事件的（第148/149行），它们调用我们之前讨论的事件处理程序，但它们是必要的，因为通过`bind()`绑定到事件的事件处理程序作为参数传递了一个事件对象。因此，这些事件处理程序必须提供一个参数，而我们通过`command`选项绑定到按钮和菜单项的事件处理程序则不需要任何参数。
  id: totrans-415
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
