- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024J. L. ZuckarelliLearn coding with Python and JavaScript
    [https://doi.org/10.1007/978-3-658-42912-6_22](https://doi.org/10.1007/978-3-658-42912-6_22)
  prefs: []
  type: TYPE_NORMAL
- en: '22. User Interfaces: How Do I Input and Output Data?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1)München, GermanyOverview
  prefs: []
  type: TYPE_NORMAL
- en: We have dealt extensively with the organization of data in the program, namely
    the variables and objects used. Now is the time to talk about how data can be
    received from and output back to the user. To this end, in this chapter we will
    first deal with the simplest way of input and output, namely via the *console*.
    After that, we’ll give our programs a much more appealing look with *graphical
    user* *interfaces* (GUIs). Not only will we take a closer look at working with
    GUIs using a complete application example, but you will also have the opportunity
    to program your own first GUI application as part of an exercise. Finally, we
    turn to working with *files*, which is of course extremely important in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to output information to the console and how to query the user in the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how to use the Python library **tkinter** to provide your program with a graphical
    user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: what controls are available to you, how they can be configured, placed and arranged
    on the interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how you can react in your program code to events that the user triggers via
    the interface (for example, when clicking on a button)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how to read data from and write data to files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.1 Input and Output in the Console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Already in the previous chapters we have seen the two most important functions
    that are used to input and output data in the Python console, **input()** and
    **print()**.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs: []
  type: TYPE_NORMAL
- en: '**input(*****prompt*****)** displays a prompt and lets the user enter input
    from the keyboard, completing the input by pressing the <RETURN> or <ENTER> key.
    **input()** then returns the input as a return value, and always as a string.
    This is important, particularly if you expect the input to be numbers that you
    can use in calculations later. In this case, you must first explicitly convert
    the return value of **input()** to a number, as we did in ► Sect. [21.​5](474412_1_En_21_Chapter.xhtml#Sec12).'
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important tool for outputting information is the **print()** function.
    It can be used to print one or more objects. If more than one object is to be
    printed, the optional string argument **sep** determines how the individual objects
    are separated from each other in the output; by default, this is done with a space
    character. The optional **end** argument controls what is printed at the end of
    the output; unless otherwise specified with **end**, a line break is placed at
    the end of the output. The line break is represented by an escape sequence, **\n**
    (for *new line*), which we already learned about in ► Sect. [11.​2.​2](474412_1_En_11_Chapter.xhtml#Sec4)
    in connection with strings. Of course, we can also use these escape sequences
    directly in strings that we want to output: Consider the following small program
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'user = input(''Username: '')pwd = input(''Password: '')print(''Welcome,'' user,
    ''!\nYour password is:'', pwd)Here we read a username and password from the user
    and then output a total of four objects:'
  prefs: []
  type: TYPE_NORMAL
- en: The string **'Welcome, '**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string variable **user**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The string **''!\n Your password is:''** (Attention: This string contains a
    line break after the exclamation mark!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string variable **pwd**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you call the program now and enter **peter** and **889X!z5** as user name
    and password, you get the following output:Welcome, peter !Your password is: 889X!z5'
  prefs: []
  type: TYPE_NORMAL
- en: 'The space between the username **peter** and the exclamation mark is a bit
    unattractive. It is due to the default value of the separator argument **sep**,
    which is a space. Because of this, the two objects to be output, the variable
    **user** and the string beginning with the exclamation mark, are separated by
    a space. To avoid such problems, it is recommended to control the output of whitespace
    itself and set the argument **sep** to “empty string”, so that no separator is
    output by the **print()** function itself. The call to **print()** could then
    be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(''Welcome, '' user, ''!\nYour password is: '', pwd, sep = '''')'
  prefs: []
  type: TYPE_NORMAL
- en: If you compare this with the call above, you will see that we have inserted
    a space wherever a space is to be output and have provided an empty string as
    **sep** argument. Please note that the **sep** argument must always be called
    with its name, otherwise the **print()** function does not know whether the last
    string still belongs to the objects to be output or whether it has a special meaning,
    i.e. it already represents the *next argument of* the function, as in our case.
    So, we call **sep** as a *keyword argument*. More on this in ► Sect. [23.​1.​2](474412_1_En_23_Chapter.xhtml#Sec3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the objects that are printed with **print()** do not have to be
    strings only. In fact, you can use **print()** to print practically any object,
    and even include objects of different types, i.e., different classes, in one and
    the same **print()** call. This applies to classes that you have defined yourself.
    But how can this work? How does **print()** know how to display an object of type
    **Product** from ► Sect. [21.​7](474412_1_En_21_Chapter.xhtml#Sec23), for example?
    The answer is simple: Classes in Python can have a special function **__str__()**.
    It returns a string representation of the object and is called by **print()**
    when an object of that class is to be output. As the developer of the class, you
    can specify how objects of your class should be represented. All you have to do
    is define a **__str__()** method. We will look at an example of this in ► Sect.
    [23.​2](474412_1_En_23_Chapter.xhtml#Sec6).'
  prefs: []
  type: TYPE_NORMAL
- en: 22.1 [5 min]
  prefs: []
  type: TYPE_NORMAL
- en: Specify three different ways to output the three string expressions **'First
    line'**, **'Second line'** and **'Third line'** in three consecutive lines.
  prefs: []
  type: TYPE_NORMAL
- en: 22.2 Graphical User Interfaces with Tkinter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 22.2.1 Overview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Programs on the command line or in the Python console are not everyone’s cup
    of tea. Especially if you develop software for non-tech-savvy end users, you simply
    can’t get around graphical user interfaces. Therefore, in this section we will
    look at how to design graphical user interfaces in Python with manageable effort,
    and how to back them up with program functionality. There are a number of ways
    to design graphical user interfaces in Python. With the *Streamlit* library, for
    example, you can use Python to create dynamic web pages that can also be hosted
    on web servers. In this chapter, we will concentrate on applications that run
    locally on a client, e.g. your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Using the example of a graphical calculator, you will see that with only a few
    lines of code you can write a useful, fully functional program with an attractive
    interface that does not force the user to sit in front of a black console and
    stubbornly follow the given program flow. The chapter concludes with an exercise
    in which you will develop your own simple text editor that allows you to open,
    edit, and save text files.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different libraries and frameworks for developing graphical interfaces.
    Many of them are cross-platform, which means that the programs you develop with
    them run on different computer (and sometimes mobile) operating systems. A commonly
    used library that we will work with is **tkinter**. Conveniently, it comes standard
    with Python, so we don’t need to install anything extra. **tkinter** is based
    on **Tk**, a cross-platform library for graphical user interfaces that was originally
    developed in the early 1990s in a programming language called *Tcl*. Tcl has become
    popular mainly because of the **Tk** library. This is because it is not only available
    for Tcl itself, but also for a large number of other programming languages, including
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides a package called **tkinter**, which is ultimately a kind of
    “connection” to **Tk**. To use the **Tk** library, Python calls a Tcl interpreter,
    which is also part of the standard Python installation. So, in effect, you are
    indirectly working with another programming language, but you don’t need to understand
    Tcl syntax or call the Tcl interpreter yourself to do so. Instead, you can work
    in Python and use the usual Python syntax. Where necessary, Python then “translates”
    your statements into Tcl code and calls the Tcl interpreter. The practical thing
    about **Tk** is that once you understand how this library works, you can quickly
    develop your own graphical user interfaces in other programming languages that
    support **Tk**—and there are quite a few of them—without any major conversion
    difficulties.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will write a simple *Hello World* program that opens
    a window on the screen. After that, we will take a closer look at the various
    graphical controls of the user interface, the *widgets*, such as buttons, input
    fields and checkboxes. After that, we will only be missing two more components.
    We need to arrange these elements on the interface the way we want them to be
    in order to get the desired interface appearance. And finally, we must wire the
    controls to the program code behind them, so that they react appropriately to
    the user’s actions. This gives us everything we need to write Python programs
    with a proper graphical interface, such as the calculator we will develop at the
    end of our introduction to **tkinter**. But let’s start small first!
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.2 Hello Tkinter!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new Python file with the following program code and run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**from** tkinter **import** *win = Tk()win.title(''Hello World Program'')win.geometry(''900x500'')win.mainloop()A
    window opens that looks something like ◘ Fig. [22.1](#Fig1).![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig1_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a window with text that reads, Hello world program.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 22.1
  prefs: []
  type: TYPE_NORMAL
- en: A *Hello World* program with **tkinter**
  prefs: []
  type: TYPE_NORMAL
- en: The window is still very empty, but that will change quickly in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: If you take a closer look at the code, you will notice that it starts with an
    **import** statement. This is necessary to make the module **tkinter** available.
    You should not worry about the exact structure of the **import** statement at
    this point, because we will deal with the import from modules in more detail in
    ► Sect. [23.​3](474412_1_En_23_Chapter.xhtml#Sec7). At this point, it is sufficient
    to know that the **import** statement makes the classes of the module **tkinter**,
    in particular the class **Tk**, usable for our program.
  prefs: []
  type: TYPE_NORMAL
- en: We create an instance of this class **Tk** in our program, namely the object
    **win**, the main window of our application. With the methods **title(*****titletext*****)**
    and **geometry(*****dimensions*****)** we set two important properties, the title
    of the window and its size in pixels. Then, using the **mainloop()** method, we
    display the window on the screen and start event processing; our program can now
    react to user actions. Our first **tkinter** program is complete! Simple, isn’t
    it? However, the user can still do little with our graphical interface. So, we
    need control elements that allow the user to make inputs and trigger actions.
    These controls are called *widgets* in **Tk/tkinter**. We will deal with them
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.3 Graphical Controls (Widgets)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section we will look at a number of important widgets. Using the first
    widget, the button, as an example, you will see how widgets are created and how
    their properties are adjusted when they are created (or even later).
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.3.1 Buttons (Class Button)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Buttons are built into **tkinter** as the class **Button**. They are used to
    let the user of the program trigger actions. Like all widgets, they can be easily
    created using their constructor method. The program from the previous section
    extended by this constructor call then looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**from** tkinter **import** *win = Tk()win.title(''Hello World Program'')win.geometry(''900x500'')mybutton
    = Button(win, text = ''Press me'')mybutton.pack()win.mainloop()'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Button()** constructor method receives as function arguments the window
    in which we want to place the button, in our case **win**. Options for the design
    of the button can be specified; in our example, we label the button “Press me”
    with the help of the option **text**. Of course, we can still change the button’s
    properties *after* we have created the button. However, the properties are not
    simply editable class attributes of the **Button** class, but are changed with
    a special method called **config()**. Like the constructor, the **config()** method
    expects key-value pairs, consisting of the name of the option to be modified as
    a key and the value to be assigned to it. So, for example, if we wanted to change
    the width of our button, we would have to adjust the **width** option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: mybutton.config(width = 50)
  prefs: []
  type: TYPE_NORMAL
- en: The same can be done with the option **text**, i.e., the label of the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second way to modify options is to access them like a dictionary, whose keys
    are the option names:'
  prefs: []
  type: TYPE_NORMAL
- en: mybutton['width'] = 50
  prefs: []
  type: TYPE_NORMAL
- en: 'The question now is what setting options are available? To find out, you should
    take a look at the help of the class **tkinter**. To do this, you must first import
    the **Button** class (or just all classes, as we do below) from the **tkinter**
    module into the console (remember: your Python programs and the console do not
    use the same namespace; the fact that you already have a Python program that imports
    the module does not mean that you can also use the module in the console. So,
    before calling the help function, you still have to execute an **import** statement
    in the console):'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** from tkinter import ***>>>** help(Button)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right at the top of the help text that appears is the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| STANDARD OPTIONS|| activebackground, activeforeground, anchor,| background,
    bitmap, borderwidth, cursor,| disabledforeground, font, foreground| highlightbackground,
    highlightcolor,| highlightthickness, image, justify,| padx, pady, relief, repeatdelay,|
    repeatinterval, takefocus, text,| textvariable, underline, wraplength|| WIDGET-SPECIFIC
    OPTIONS|| command, compound, default, height,| overrelief, state, width'
  prefs: []
  type: TYPE_NORMAL
- en: So, as you can see, on the one hand there are *standard options* common to most
    widgets, on the other hand there are special options available only for buttons.
    Unfortunately, the help lacks a description of what setting each option controls,
    and how these options are used. Also, the “official” documentation of the **tkinter**
    package (► [https://​docs.​python.​org/​3/​library/​tk.​html](https://docs.python.org/3/library/tk.html))
    is of rather limited use, especially for beginners. However, there are numerous
    pages on the Internet where the features are explained in an understandable way,
    currently for example ► [https://​www.​tutorialspoint.​com/​python/​tk_​button.​htm](https://www.tutorialspoint.com/python/tk_button.htm).
  prefs: []
  type: TYPE_NORMAL
- en: ◘ Table [22.1](#Tab1) shows an overview of some of the options that most, if
    not all, widgets have. This table also explains procedures for encoding colors
    and working with font formatting that can be used in many places in **tkinter**.Table
    22.1
  prefs: []
  type: TYPE_NORMAL
- en: Standard properties of **tkinter** widgets
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Type | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **activebackground/activeforeground** | **Str** | Color of the control (background)
    or the text on it (foreground) when the control is activated (for in our case,
    by clicking on the button)*Like all colors* in **tkinter**, you can either specify
    one of the many predefined color constants (for example **''green''** or **''purple''**;
    you can quickly find lists of these color constants on the internet), or a red-green-blue
    (RGB) coded value of the form **''#RRGGBB''**, where **RR**, **GG**, and **BB**
    represent the hexadecimal (!) coded red, green, and blue parts of the color, respectively.
    It is best to use one of the many converters on the internet to convert the decimal
    values to the hexadecimal system. The value for red (R = 255, G = 0, B = 0) would
    thus become **''#FF0000''**, because **FF** represents the number 255 in the hexadecimal
    number system |'
  prefs: []
  type: TYPE_TB
- en: '| **background/foreground** | **Str** | Default color of the control (background)
    or the text on it (foreground) |'
  prefs: []
  type: TYPE_TB
- en: '| **border** | **Int** | Thickness of the border of the control in pixels (**border=0**
    means no border) |'
  prefs: []
  type: TYPE_TB
- en: '| **cursor** | **Str** | The shape of the mouse cursor when the mouse pointer
    is over the control; examples are **''hand2''** (hand), **''watch''** (hourglass),
    **''cross''** (cross), **''left_ptr''** (“normal” mouse pointer with top left
    tip). There are also lists on the internet that specify the possible pointer characteristics
    |'
  prefs: []
  type: TYPE_TB
- en: '| **font** | **Font** | The font formatting of the control; if you want to
    deviate from the default font, you must add an additional **import** statement
    and then create a new **Font** object using the **Font()** constructor:**from**
    **tkinter.font** **import** ***font = Font(family = ''Times'', size = 36, weight
    = ''bold'', underline = 1)**After that, the new **Font** object **font** can be
    assigned to the **font** option of the control:**mybutton[''font''] = font**The
    **family** is a font identifier (e.g. **Helvetica**, **Courier**). The **weight**
    distinguishes between **''bold''** and **''normal''**. In addition, you can use
    the **slant** option, which is not used in the above example, to set the text
    to italic or not italic (''**normal''**). **overstrike**, which can take the values
    1 and 0 (or **True** and **False**) just like **underline**, is used to strike
    through the textYou can make changes to your **Font** object using the **config()**
    method, just as you can with controls:font.config(weight = ''normal'')Changes
    you make in this way automatically affect *all* controls to whose **font** option
    you originally assigned the now changed **Font** object |'
  prefs: []
  type: TYPE_TB
- en: '| **padx**, **pady** | **int** | Indentation of the text (or an image) on the
    control left/right (**padx**) or top/bottom (**pady**) |'
  prefs: []
  type: TYPE_TB
- en: '| **relief** | **str** | 3D representation of the control. Possible values
    here are: **''raised''** (protruding, the default value), **''sunken''** (deepened),
    **''flat''**, **''groove''** (deepened border) and **''ridge''** (simple border,
    otherwise flat) |'
  prefs: []
  type: TYPE_TB
- en: '| **text** | **str** | Labeling of the control |'
  prefs: []
  type: TYPE_TB
- en: ◘ Table [22.2](#Tab2) then lists some of the *special* button options. In the
    following sections on the other widgets, you will find such a table with the most
    important specific properties for exactly this widget.Table 22.2
  prefs: []
  type: TYPE_NORMAL
- en: Special properties of the button widget
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Type | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **command** | **function** | Function that is executed when the user clicks
    on the button. We will take a closer look at this event handling in ► Sect. [22.2.5](#Sec19)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **default** | **int** | If **default = 1**, then the button is the default
    button (triggered when the user presses the <ENTER> key) |'
  prefs: []
  type: TYPE_TB
- en: '| **height/width** | **int** | Height/width of the button. Specified in letter
    heights if text is displayed on the button, in pixels if an image is displayed.
    If not specified at all, width and height are calculated automatically |'
  prefs: []
  type: TYPE_TB
- en: '| **state** | **str** | Button can be set to either ''**normal''** (clickable)
    or **''disabled''** (grayed out). If the button is currently clicked, **state**
    takes the value ''**active''** |'
  prefs: []
  type: TYPE_TB
- en: We have just seen options that partly behave like a dictionary. Therefore, you
    can also use the **keys()** method to read the keys and thus the names of the
    options. If, after creating the widget instance, you include in your program code
    the statementprint(mybuttons.keys())you will see the names of the available options
    in the (run) console when you run the program. If you call the **config()** method
    with no arguments, you will get back the entire dictionary with all name-value
    pairs. You can also have this output:options = switch.config()print(options)
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, the lowercase string option values such as **''sunken''** for the **relief**
    option can also be controlled with the help of a predefined, then capitalized
    constant, in our example **SUNKEN**. In the following, however, we will regularly
    work with the strings instead of the constants. If you want to work with the constants,
    look for the file **constants.py** in the **tkinter** directory of your hard disk.
    The constants are defined there. To use them, add the following import statement
    to your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**from** tkinter.constants **import** *'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we haven’t even talked about the call to the **pack()** method that
    we snuck into our program. This statement makes the button visible on the screen
    in the first place (comment out the line and see what happens when you run the
    program again!). Making it visible is closely related to the arrangement of the
    widgets on the graphical interface. We will look at this in more detail in ► Sect.
    [22.2.4](#Sec15). At this point, all we need to do is call **pack()** to display
    our control on the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.3.2 Menus (Class Menu)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Menus can be designed very easily with **tkinter**. To do this, we first create
    a new menu bar for our window, i.e., the **Tk** object **win** in the example
    above. The menu bar is represented in **tkinter** by the class **Menu**. The window
    to which the menu bar is to belong is already passed as an argument to the call
    of the constructor of this class. Conversely, we explicitly assign the new menu
    bar to the window with the help of the menu option of the **Tk** object, so that
    it is visible later:'
  prefs: []
  type: TYPE_NORMAL
- en: menubar_top = Menu(win)win.config(menu = menubar_top)
  prefs: []
  type: TYPE_NORMAL
- en: 'As you already know, instead of calling the **Tk** object’s **config()** method
    in the last statement, we could have taken advantage of the practical fact that
    **tkinter** widgets work partly like dictionaries, and their options can therefore
    be accessed as well, like the key-value pairs of a dictionary. Accordingly, we
    could have written:'
  prefs: []
  type: TYPE_NORMAL
- en: win['menu'] = menubar_top
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, your application has a menu bar, but it is not yet displayed when you
    start the program in this state. First, we have to add the individual pull-down
    menus, which will then be expandable and collapsible for the user. These pull-down
    menus are also objects of the **Menu** class, which we can create by calling the
    class constructor. This time, however, we don’t attach the new (pull-down) menus
    directly to the window **win**, but to our existing menu bar **menubar_top**:'
  prefs: []
  type: TYPE_NORMAL
- en: file_menu = Menu(menubar_top, tearoff = 0)
  prefs: []
  type: TYPE_NORMAL
- en: The option **tearoff=0** causes the menu to be “bolted” to the window. If you
    omit this option or set it to **tearoff=1**, the first entry in your menu will
    be a dashed line. If you click on this entry, the menu detaches itself from its
    anchoring and is displayed in its own window, which can be moved around the screen
    at will (try it out!); a behavior that you would normally want to disable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start adding new command items to the menu with **add_command(*****label
    = label*****)**:'
  prefs: []
  type: TYPE_NORMAL
- en: file_menu.add_command(label = 'Open...')file_menu.add_command(label = 'Save')file_menu.add_separator()file_menu.add_command(label
    = 'Close')
  prefs: []
  type: TYPE_NORMAL
- en: Using the **add_separator()** function of the **Menu** object we create a horizontal
    separator in the menu to structure our menu items more clearly. In addition to
    **add_command()** and **add_separator()**, there are two other types of menu items,
    **add_checkbutton()** and **add_radiobutton()**. Both allow the user to make a
    setting, as in the following example. The current setting (whether the menu option
    is currently selected or not) can be read at any time from the variable passed
    as the option **variable** to the **add_checkbutton()** function.
  prefs: []
  type: TYPE_NORMAL
- en: file_menu.add_checkbutton(label = 'Auto save', variable = auto_save)
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, our menu—unlike the individual menu items—has no display name at all.
    We change this by calling the function **add_cascade()** of the menu bar object,
    which also ensures that the menu is actually displayed as a pull-down menu on
    our menu bar:'
  prefs: []
  type: TYPE_NORMAL
- en: menubar_top.add_cascade(label = 'File', menu = file_menu)
  prefs: []
  type: TYPE_NORMAL
- en: If you now start the program like this, a program window will open that has
    a menu bar with a “File” menu. Analogously, we could of course now place more
    pull-down menus on the menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **add_...()** functions like **add_command()** can be called with numerous
    options, many of which can be found in ◘ Table [22.1](#Tab1). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: file_menu.add_command(label = 'Save', background='#FF0000')adds a menu item
    “Save” with a red background, the statementfile_menu.add_command(label = 'Save',
    state='disabled')shows a deactivated (grayed out) menu item.Of course, you can
    still modify your menu *after* you have created it. With **delete(*****index_from*****,**
    ***index_to*****)** you can delete menu items by their numeric indices. With **entryconfig(*****index*****,**
    ***option*****=*****value*****)** you change an **option** (for example **state**
    to enable/disable) for the menu item defined by **index**. You can query the options
    with **entrycget(*****index*****,** ***option*****)**. Thus, to display the label
    (option **label**) of the second menu item, you can use the statementprint(file_menu.entrycget(1,
    'label'))(the indexes start, as always in Python, at 0!).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to insert a menu entry later, use the functions **insert_...(*****index*****,**
    ***option*****)**, where **...** stands for the respective element (e.g. **command**,
    **separator**, **checkbox**), just as with **add_...()**. The entry is then inserted
    *after* the entry specified by **index**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our menu is now quite pretty to look at, but it has no functionality: clicking
    on a menu command does not trigger any action. This is because in our calls to
    **add_command()** of the pull-down menu object **file_menu**, we omitted the important
    **command** option, which allows us to specify a function to be called whenever
    the user clicks on the menu item. In this function we would then place the part
    of the program code that should be behind the menu item. We will deal with these
    event handlers in more detail in ► Sect. [22.2.5](#Sec19). At this point here
    we will concentrate entirely on creating a visually appealing interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dealing with a menu in **tkinter** is, as you can see, not complicated at all,
    but it requires several different steps. Therefore, here again is the overview
    what you have to do to provide your program with a menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the menu bar using the constructor ***menubar*** **= Menu(*****window*****)**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the menu bar to the window: ***window*****[''menu''] = menubar**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new pull-down menu that you want to place on the menu bar: ***pd_menu***
    **= Menu(*****menubar*****)**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add menu items, i.e. commands (with **add_command()**), preference options
    (with ***add_checkbox()*** or ***add_radiobutton()***) or separators (***add_separator()***)
    to the new pull-down menu, for example: ***pd_menu*****.add_command(label = ''*****Title
    of command*****'')**. Note that later, to add functionality to the menu item,
    we will include the **command =** ***event_function*** option at this point.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attach your new pull-down menu to the menu bar and assign a title that will
    be visible in the menu bar: **menubar.add_cascade(label = ''*****Title of menu*****'',
    menu =** ***pd_menu*****)**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, we’ve looked at creating an application menu as the main menu
    in your program. However, the **Menu** object can also be used to open pop-up/context
    menus anywhere in your window thanks to the **post(x, y)** function, but this
    is beyond the brief introduction to **tkinter** in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.3.3 Input Fields (Classes Entry and ScrolledText)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Single-Line Entry: Entry'
  prefs: []
  type: TYPE_NORMAL
- en: Input fields are used to accept text input from the user. In **tkinter**, a
    distinction is made between single-line (widget class **Entry**) and multi-line
    text input (widget class **ScrolledText**). We will take a closer look at both
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The widget of type **Entry** can be created very easily with the constructor
    and assigned to the window, in our example still to the **Tk** object **win**.
  prefs: []
  type: TYPE_NORMAL
- en: myentry = Entry(win)myentry.pack()
  prefs: []
  type: TYPE_NORMAL
- en: As with the button before, we call the **pack()** method to display the control
    in our window. In ► Sect. [22.2.4](#Sec15) we will look at how we can influence
    the arrangement of the controls in the window in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: In ◘ Table [22.3](#Tab3) you will find an overview of the most important properties
    of the widget, which you can access in the usual way either by dictionary indexing
    **input['*****option'*****]** or (but then only by writing) by **input.configure(*****option*****=*****value*****)**.Table
    22.3
  prefs: []
  type: TYPE_NORMAL
- en: Special properties of the Entry widget
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Type | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **justify** | **str** | Alignment of the text in the entry field, **''left''**
    (left-aligned, the default), **''center''** (centered) or **''right''** (right-aligned)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **selectbackground** | **str** | Background color of text selections |'
  prefs: []
  type: TYPE_TB
- en: '| **selectforeground** | **str** | Font color of text selections |'
  prefs: []
  type: TYPE_TB
- en: '| **show** | **str** | Character that is displayed (instead of the entered
    character); can be used for password entries, for example |'
  prefs: []
  type: TYPE_TB
- en: '| **width** | **int** | Width of the entry field (in characters, not pixels)
    |'
  prefs: []
  type: TYPE_TB
- en: 'You can use the **get()** method at any time to retrieve the text that is currently
    in the Entry field, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: my_text = input.get()
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can also edit the text. This is done with the help of the **insert(*****index*****,**
    ***string*****)** method. **index** specifies the text position (starting at 0)
    where you want to insert, **string** specifies the text to be inserted. So, at
    the beginning you can start with
  prefs: []
  type: TYPE_NORMAL
- en: input.insert(0, 'A first text in the input field.')to preset the input field
    with a text. Instead of a real position index, you can simply specify **'end'**,
    **'insert'**, or **'anchor' in** the **insert()** method. Then the text is inserted
    at the end (**'end'**), at the current cursor position (**'insert'**), or at the
    beginning of the current selection (if there is currently an selection, otherwise
    simply at the beginning of the text). In this way, you can use the statementinput.insert('end',
    'End of text.')for example, to append text to the end. Similarly, you can delete
    text by using the **delete(*****from_index*****,** ***to_index*****)** method.
    If you omit the optional argument **to_index**, only the character with the index
    **from_index** is removed.
  prefs: []
  type: TYPE_NORMAL
- en: With **icursor(*****index*****)** you can place the cursor at a certain position
    in the text, more precisely, *behind* the character specified by **index**. Note,
    however, that the counting of characters in **tkinter** starts at 1, which is
    not typical for Python. If you specify the number 0 as **index**, you place the
    cursor *in front of* the first character. This counting method applies everywhere
    where character indices are used.
  prefs: []
  type: TYPE_NORMAL
- en: In order for the cursor to actually be visible in the text, you must give the
    control focus, i.e., make it the currently active control in your window. You
    can do this, as with all other widgets, with the **focus()** method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the method **selection_range(*****from_index*****,** ***to_index*****)**
    allows you to select text. Again, you can work with the special constants **'end'**,
    **'insert'** and **'anchor'** known from **insert()**. You can query the currently
    selected text with **selection_get()**, the method **selection_present()** returns
    **True** if a text is selected.
  prefs: []
  type: TYPE_NORMAL
- en: '**Entry** also allows you to work with the clipboard. You can add text to the
    clipboard using the method **clipboard_append(*****text*****)**; retrieve the
    contents of the clipboard using **clipboard_get()**, and clear the clipboard using
    **clipoard_clear()**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiline Input: ScrolledText'
  prefs: []
  type: TYPE_NORMAL
- en: 'If longer texts are to be edited, the widget **ScrolledText** is a good choice.
    To use it, the class **ScrolledText** must first be imported from the **scrolledtext**
    module of the **tkinter** package:'
  prefs: []
  type: TYPE_NORMAL
- en: '**from** tkinter.scrolledtext **import** ScrolledText'
  prefs: []
  type: TYPE_NORMAL
- en: In many ways, the **ScrolledText** widget behaves exactly like the **Entry**
    widget. Most of what you have learned about **Entry** can be applied directly
    to **ScrolledText** (differences are that the **justify** and **show** options,
    the **icursor()** method and the insertion position **'anchor'** are not available).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since **ScrolledText** allows multi-line input, it is only logical that text
    positions can also be addressed in accordance with a line/column scheme. For example,
    if we wanted to delete all text starting from the fifth character in the second
    line, this could be done with the method call below. If the widget previously
    created with the constructor method **ScrolledText()** is named **st**:'
  prefs: []
  type: TYPE_NORMAL
- en: st.delete(2.4,'end')
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that where there was a single index at **Entry**, there now appears
    to be a fractional number: 2.4\. However, this number is a coded row/column specification.
    It says: Second line, fifth character. So, while within a line the characters
    are counted starting from 0 (and 4 thus refers to the fifth character), as we
    are already used to from **Entry**, the line count in **tkinter** starts at 1!
    2.4 thus refers to the *second* line, but the *fifth* character.'
  prefs: []
  type: TYPE_NORMAL
- en: The **ScrolledText** widget is much more powerful than the **Entry** widget.
    For example, it inherently allows undoing or redoing of editing operations using
    the methods **edit_undo()** and **edit_redo()** (the **undo** option of the widget
    must be set to **True** beforehand). **ScrolledText** also allows you to assign
    names to text areas (called *tags*) and then access and edit the text areas using
    the *tags*. This way you can, for example, color different text areas differently.
    So, if you want to develop a text editor with syntax highlighting, the **ScrolledText**
    widget is not a bad starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.3.4 Text Outputs (Label)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Labels are static texts that are displayed in the application window. They usually
    do not offer the user any interaction options but are used to display information
    or to describe the function of controls if these do not have their own labels
    (such as buttons).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create and display a label widget as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: label = Label(win, text = 'Here is a fixed text')label.pack()◘ Table [22.4](#Tab4)
    shows some important properties of labels. In addition, there are of course the
    standard properties provided by most widgets, which are listed in ◘ Table [22.1](#Tab1)
    and whose most significant feature for labels is certainly the **text** option,
    i.e., the text that is displayed on the label. In the example, we have set the
    text directly when calling the constructor, but of course, like all other properties,
    it can easily be changed later with **label.configure(text =** ***new_text*****)
    or with label['text'] =** ***new_text***.Table 22.4
  prefs: []
  type: TYPE_NORMAL
- en: Special properties of the Label widget
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Type | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **anchor** | **str** | Position and orientation of the text. It is described
    using the English abbreviations of the cardinal points, for example **''ne''**
    for *northeast*, i.e. top right; possible specifications are therefore: **''n''**
    (top center), **''ne''** (top right), ''e'' (right center), ''se'' (bottom right),
    ''s'' (bottom), **''sw''** (bottom left), **''w''** (left center), **''nw''**
    (top left) and additionally **''center''** (horizontally and vertically center)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **width** | **int** | Width of the label in characters. If not specified,
    the label is made wide enough to fit the text to be added |'
  prefs: []
  type: TYPE_TB
- en: '| **wraplength** | **int** | Number of characters after which the text on the
    label is to be wrapped. If not specified, there will be no wrapping |'
  prefs: []
  type: TYPE_TB
- en: 22.2.3.5 Check Buttons and Radio Buttons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Check buttons (or checkboxes) and radio buttons are used to give the user a
    choice of several settings/options. While checkboxes allow the user to select
    several different settings/options, radio buttons only allow the user to select
    one setting/option at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check buttons and radio buttons are represented in **tkinter** by classes with
    the same names. Let’s first create two radio buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: selection_var = IntVar()selection_opt1 = Radiobutton(win, text = 'Option One',variable
    = selection_var, value = 1)selection_opt2 = Radiobutton(win, text = 'Option Two',variable
    = selection_var, value = 2)selection_ opt1.pack()selection_ opt2.pack()
  prefs: []
  type: TYPE_NORMAL
- en: 'First, consider the constructor calls of the radio buttons themselves: Here,
    as usual, we first pass our window object **win** (of type **Tk**), to which the
    radio button should belong, and a text to be displayed as a selection option.
    Beyond that, however, there are two more arguments, **variable** and **value**.'
  prefs: []
  type: TYPE_NORMAL
- en: To the **variable** argument, we assign a variable **selection_var**, which
    we created at the beginning of the code section, as an instance of the class **IntVar**.
    **IntVar** is one of several special variable classes that **tkinter** comes with.
    It is not simply an ordinary **int** variable. The special thing about this variable,
    after we assign it to the **variable** argument of the radio button constructor,
    is that it always reflects the current state of our radio button set, that is,
    it indicates which radio button option is currently selected. We define the value
    that **selection_var** takes when a particular radio button is selected via the
    **value** argument of **Radionbutton()**. So, if the user clicks on the “Option
    Two” radio button, **selection_var** has a value of 2\. If the user clicks on
    “Option One”, **selection_var** takes a value of 1\. The **IntVar selection_var**
    is automatically updated as soon as the selection situation of the radio button
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very convenient; however, there is one peculiarity to keep in mind
    when querying the value: If you execute theprint(selection_var)the following is
    output to the Run console:PY_VAR0'
  prefs: []
  type: TYPE_NORMAL
- en: 'But this is not the value of the variable. This is because **selection_var**
    is not a normal **int** variable. We have to query its value with its **get()**
    method, even though this takes some getting used to. The following statement leads
    to success:'
  prefs: []
  type: TYPE_NORMAL
- en: print(selection_var.get())
  prefs: []
  type: TYPE_NORMAL
- en: Analogously, there is a method **set()**, with which the value of the **IntVar**
    variable can be changed. Since we have linked the variable **selection_var** to
    the radio button via the argument **variable** of the constructor **Radiobutton()**,
    this also changes the selection among the radio buttons. With
  prefs: []
  type: TYPE_NORMAL
- en: selection_var.set(2)we automatically select the radio button whose assigned
    value is 2, i.e. the “Left” radio button. The same could be achieved by calling
    the method **select()** of the respective radio button instance:select_left.select()
  prefs: []
  type: TYPE_NORMAL
- en: Because we assigned our **IntVar** variable **selection_var** as **variable**
    option *to both radio buttons*, **tkinter** knows that these two radio buttons
    belong together and therefore only *one of them* may be selected at a time. So
    always make sure to assign the same variable as **variable** option to radio buttons
    that belong to the same “selection group”!
  prefs: []
  type: TYPE_NORMAL
- en: '*Check buttons* function very similarly to radio buttons, with the difference,
    of course, that here several checkboxes can be selected at the same time, because
    the two checkboxes can be selected independently of each other. Whereas with radio
    buttons it was clear that if button 1 is selected, button 2 cannot also be selected,
    with two check buttons there are no longer just two, but four different states
    (both selected, none selected, only the first button selected, only the second
    button selected); the state of one therefore no longer depends on the state of
    the other button. Accordingly, you also need two different **IntVar** variables
    as **variable** arguments of the constructor **Checkbutton()**:'
  prefs: []
  type: TYPE_NORMAL
- en: selection_var1 = IntVar()selection_var2 = IntVar()selection_opt1 = Checkbutton(win,
    text = 'Option One',variable = selection_var1)selection_opt2 = Checkbutton(win,
    text = 'Option Two',variable = selection_var2)selection_ opt1.pack()selection_
    opt2.pack()
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that with the **Checkbutton()** constructor, we no longer
    have a **value** argument here. By default, the status variable **variable** takes
    the value **True** if the check button is selected, and **False** if it is not.
    However, with the optional arguments or widget options **onvalue** and **offvalue**,
    this can be changed if needed.
  prefs: []
  type: TYPE_NORMAL
- en: ◘ Table [22.5](#Tab5) gives an overview of the most important special properties
    of widgets of the types **Radiobutton** and **Checkbutton**, beyond the standard
    options listed in ◘ Table [22.1](#Tab1).Table 22.5
  prefs: []
  type: TYPE_NORMAL
- en: Special properties of the **Checkbutton** and **Radiobutton** widgets
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Type | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **indicatoron** | **Bool** | If **False**, then instead of the circular (for
    radio buttons) or square (for check buttons) selection element, a real button
    is displayed that looks pressed down when the radio button/check button is selected
    |'
  prefs: []
  type: TYPE_TB
- en: '| **selectcolor** | **str** | Background color of the circular (for radio buttons)
    or square (for check buttons) selection element |'
  prefs: []
  type: TYPE_TB
- en: 22.2.3.6 Selection Lists (Listbox)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Selection lists, represented by the **tkinter** class **Listbox**, allow a
    (single or multiple) selection from an enumeration of text entries. After creating
    a list box using the **Listbox()** class constructor and displaying the list box
    in the window using the **pack()** method:'
  prefs: []
  type: TYPE_NORMAL
- en: mylistbox = Listbox(win)mylistbox.pack()we can start adding items to the list
    box. To do this, we use the **insert(*****index*****,** ***entry*****,*****...*****)**
    method:mylistbox.insert('end', 'Beverly', 'Thomas', 'Marc','Jimmy', 'Cathy')
  prefs: []
  type: TYPE_NORMAL
- en: '**insert()** has some similarities to the **Entry** widget method of the same
    name: ***index*** first specifies the numeric index of the element to be inserted
    *after*; as with **Entry**’s **insert()** method, the value **''end''** can also
    be specified, which ensures that the entries are added to the end of the list.
    The list can also be extended by several entries at the same time. Please note
    that the indexing of the list entries starts at 0, as is typical for Python (unlike
    the indexing of the characters for the **Entry** widgets, but just like the “column
    indexing” for the multiline **ScrolledText** widgets).'
  prefs: []
  type: TYPE_NORMAL
- en: Also analogous to **Entry**, you can delete list entries from the list box with
    the method **delete(*****index_from*****,** ***index_to*****)**. In the case of
    the **Entry** widget, this method had removed individual characters from the contents
    of the **Entry** field, i.e., a string and thus a “character list”.
  prefs: []
  type: TYPE_NORMAL
- en: By calling the method **selection_set(*****index_from*****,** ***index_to*****)**,
    you select entries in the list box as if the user had selected them.
  prefs: []
  type: TYPE_NORMAL
- en: In both **delete()** and **selection_set()**, ***index_to*** is an optional
    argument, i.e. an argument that can be omitted when calling the method.
  prefs: []
  type: TYPE_NORMAL
- en: Just as you can use **selection_set()** to select one (or more) entries, you
    can apply **selection_includes(*****index*****)** to check whether the element
    of the list denoted by ***index*** is currently selected.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, with **selection_clear()** you can clear the current selection in the
    list box.
  prefs: []
  type: TYPE_NORMAL
- en: You determine the number of list entries using the **length()** method, while
    **get(*****index_from*****,** ***index_to*****)** allows you to read the text
    entry of one or more entries. If you use the optional argument ***index_to***
    and thus specify a range, you get a *tuple* with the text entries of the specified
    list entries as return values.
  prefs: []
  type: TYPE_NORMAL
- en: ◘ Table [22.6](#Tab6) lists some important options that you can customize in
    the now familiar ways for the **Listbox** widget.Table 22.6
  prefs: []
  type: TYPE_NORMAL
- en: Special properties of the **Listbox** widget
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Type | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **activestyle** | **str** | Specifies how the active entry, that is, the
    selected entry that currently has the focus, should be visually highlighted; possible
    values are **''underline''** (text underlined), **''dotbox''** (outline with dotted
    line), and **''none''** (no highlighting), where **''underline''** is the default
    value |'
  prefs: []
  type: TYPE_TB
- en: '| **height** | **int** | The height of the list box but measured in entries
    rather than pixels; the default value is 10\. If you have more than the number
    of entries set in **height** and want to ensure that the entry at the ***index***
    position is displayed, you can call the **see(*****index*****)** method; it scrolls
    the list box so that the ***index*** entry is visible in any case |'
  prefs: []
  type: TYPE_TB
- en: '| **selectmode** | **str** | Specifies how many entries can be selected at
    the same time and how they must be related; possible specifications are: **''single''**
    (one entry can be selected by clicking on the entry), **''browse''** (one entry
    can be selected by clicking or moving the mouse with the mouse button pressed),
    **''multiple''** (several entries can be selected, clicking on an entry sets the
    selection if it wasn’t selected before or removes it if it was already selected)
    and **''extended''** (several entries can be selected by clicking while holding
    down the <CTRL> or <SHIFT> key); the default value is **''multiple''**, which
    is somewhat unusual for Windows users |'
  prefs: []
  type: TYPE_TB
- en: In addition, you can of course work with the standard options that we looked
    at in ◘ Table [22.1](#Tab1). Many of these properties can also be applied to *individual
    items* in the list box. To do this, use the **itemconfig(*****index*****, option=*****value*****)**
    method. For example, to give the third item a greenish background, you can execute
    the following statement:mylistbox.itemconfig(2, background='#ED5036')
  prefs: []
  type: TYPE_NORMAL
- en: 'In ◘ Table [22.6](#Tab6) you will once again find cases of options which can
    take one of several values, for example **activestyle**. In view of the rather
    difficult documentation situation with **tkinter**, the question naturally arises
    which expressions are permissible at all. You still don’t know what the individual
    values do, but you can quickly find out by trial and error. So, the important
    thing in the first step would be to understand what options you have in the first
    place. There is a simple trick for this: You provoke an error. To do this, consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: mylistbox['activestyle'] = 'xxx'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we are trying to assign the value **''xxx''** to the **activestyle** option,
    which likely is not a valid expression for this option. If we run a program with
    this statement, we get an error message, but that is exactly what we are trying
    to achieve in this case. In our example we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Traceback (most recent call last):****File "C:/Users/MyUser/Desktop/Documents/tkinter_hello_world.py",
    line 138, in <module>.****names[''activestyle'']=''xxx''****File "C:\Users\MyUser\AppData\Local\Programs\Python\Python37-32\lib\tkinter\__init__.py",
    line 1489, in __setitem__.****self.configure({key: value})****File "C:\Users\MyUser\AppData\Local\Programs\Python\Python37-32\lib\tkinter\__init__.py",
    line 1482, in configure****return self._configure(''configure'', cnf, kw)****File"C:\Users\MyUser\AppData\Local\Programs\Python\Python37-32\lib\tkinter\__init__.py",
    line 1473, in _configure****self.tk.call(_flatten((self._w, cmd)) + self._options(cnf))****_tkinter.TclError:
    bad activestyle "xxx": must be dotbox, none, or underline**'
  prefs: []
  type: TYPE_NORMAL
- en: The crucial part here is in the last line. There, the error message lists the
    possible values, which can now be easily tried out.
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.3.7 Message/Decision Dialogs (Class messagebox)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you want to alert the user to something, in a way that forces them
    to take note of your message. Or you may want to force the user to make an immediate
    decision, such as whether or not to overwrite a file when saving it. In all these
    cases, a *message box* is the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'You create a message box with the help of the **tkinter** module **messagebox**.
    Because the **messagebox**, unlike most of the other controls we’ve encountered
    so far, is “packaged” in its own module (as is **ScrolledText**), we must first
    import the classes it contains. We’ll make it easy here and just use the star
    wildcard to import all the classes contained in the **messagebox** module:'
  prefs: []
  type: TYPE_NORMAL
- en: '**from** tkinter.messagebox **import** *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, using the **showinfo(*****title*****,** ***message*****)**, **showwarning(*****title*****,**
    ***message*****)** and **showerror(*****title*****,** ***message*****)** functions,
    we can display a message box, each with a different icon depending on the type
    of message (information, warning or error). Here is an example of a warning message:'
  prefs: []
  type: TYPE_NORMAL
- en: showwarning('Attention','The entered age must be greater than 0.')
  prefs: []
  type: TYPE_NORMAL
- en: You can also customize the design of the message boxes by specifying additional
    options when calling the respective function. Possible options are **icon** (which
    icon should be displayed?), **type** (which buttons should be displayed?) and
    **default** (which button should be preselected so that it is triggered when the
    user presses the <ENTER> key).
  prefs: []
  type: TYPE_NORMAL
- en: 'The **icon** option can take the values **''info''**, **''warning''**, **''error''**
    and **''question''**. The first three are the icons also used by the functions
    **showinfo()**, **showwarning()** and **showerror()**, while **''question''**
    displays a question mark icon. Like the icons, the combination of buttons available
    to the user can be specified using constants, in this case **''ok''** (*okay*
    button), **''okcancel''** (*okay* and *cancel*), **''yesno''** (*yes* and *no*),
    **''yesnocancel''** (*yes*, *no* and *cancel*), **''retrycancel''** (*retry* and
    *cancel*) and **''abortretryignore''** (*cancel*, *retry* and *ignore*). So, for
    example, if we wanted to display a small dialog asking the user if he wants to
    overwrite a file and offering him *Yes*, *No* and *Cancel* buttons, we could create
    a suitable message box like this:'
  prefs: []
  type: TYPE_NORMAL
- en: feedback = showwarning('Confirmation', 'Do you really want to overwrite the
    file?', icon = 'question', type = 'yesnocancel', default = 'yes')print(feedback)
  prefs: []
  type: TYPE_NORMAL
- en: You can see from this example that although we are using the **showwarning()**
    function, which by default displays an exclamation mark as an icon, we can override
    the default behavior by specifying the **icon** option.
  prefs: []
  type: TYPE_NORMAL
- en: The function returns the value as a lowercase string containing the label of
    the button that was clicked, in our example **'yes'**, **'no'** or **'cancel'**.
    This function value is important in order to be able to react to the user’s input
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the controls we looked at in the previous sections, the message box is
    not a class that we need to create an instance of. Rather, it is simply a function
    that is contained in the **messagebox** module. It’s much the same with the file
    dialogs, which we’ll look at in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.3.8 File Open/File Save Dialogs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want to let the user select a file to open or to save something to, the
    **tkinter** module **filedialog** allows you to easily use the well known standard
    dialogs “Open file” and “Save file as” in your own programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the module. For the sake of simplicity, we import
    all classes and functions contained in the module, just as we did with the **messagebox**
    module in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '**from** tkinter.filedialog **import** *'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, the **askopenfilename()** or **asksaveasfilename()** functions
    can be used to call the dialogs for opening or saving files. In the following
    example we select a file to open and print the result in the (run-)console:'
  prefs: []
  type: TYPE_NORMAL
- en: filename = askopenfilename(defaultextension='txt',filetypes=[('Text files',
    '*.txt'), ('All files', '*.*')], title='Open file...',initialdir='C:\\Windows')print(filename)
  prefs: []
  type: TYPE_NORMAL
- en: The functions return the name (including the path) of the selected file. If
    the user cancels the dialog without selecting a file or entering a file name,
    an empty string is returned. As you can see from the example above, you can control
    the behavior of the dialog with some options. **filetypes** is a list (note the
    enclosing square brackets!) of tuples, each consisting of a description and a
    file extension; the user can then preselect the file types thus defined. The **title**
    option controls the dialog title; **initialdir** is the directory whose contents
    should be displayed by default when the dialog opens; the backslash (**\**) as
    part of the pathname must be written twice, a single backslash would be interpreted
    by Python as an attempt to escape the character behind it; if you are not familiar
    with escaping, go back to ► Sect. [11.​2.​2](474412_1_En_11_Chapter.xhtml#Sec4).
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way: You may have wondered in the last section, with the **messagebox**
    module, why we don’t actually work with classes here, as with the other widgets,
    but instead call functions like **showwarning()** or **askopenfilename()**. The
    answer is: Because it’s easiest for us that way! These functions create the necessary
    class instances in the background. Since we’re only interested in the results,
    in this case the filenames, and don’t really want to work with the dialog (class)
    instances themselves, it’s sufficient that an appropriate function provides us
    with the filename and saves us the trouble of creating instances of the necessary
    classes ourselves and working with them. The situation is different, of course,
    with the other widgets, which are permanently present in our application window
    and with which we also want to work later.'
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.3.9 Other Widgets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the widgets we have looked at in the previous sections, there
    are a number of other controls that you can use when designing your program interface,
    for example **Canvas** (drawing area), **Spinbox** (input field with up-down arrows
    to adjust the value), **Treeview** (hierarchical display of elements; import from
    module **tkinter.ttk** module), **Notebook** (display of controls on tabs/tabs;
    also in **tkinter.ttk** module), **Progressbar** (in **tkinter.ttk** module),
    just to name a few. For working with images, which can be added to many controls
    (e.g., menu items, buttons) or used as background (e.g., of the main application
    window), there is also the class **PhotoImage**.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there is still a lot to discover with **tkinter**! The only
    downside is the relatively poor documentation, at least for the above-mentioned
    widgets from the **tkinter.ttk** module. There is more a or less sufficient “official”
    documentation (currently available at ► [https://​docs.​python.​org/​3/​library/​tkinter.​ttk.​html](https://docs.python.org/3/library/tkinter.ttk.html)).
    Beyond that, however, your own internet research is often the best option. Fortunately,
    you can usually find what you are looking for quickly, as many programmers before
    you have already had similar questions!
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.4 Arrangement of the Controls (Geometry Managers)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous sections, we got to know a number of control elements that allow
    the user to control the program via the interface. To construct an interface that
    is visually appealing and easy to use, the various control elements must be placed
    on the interface where they should be.
  prefs: []
  type: TYPE_NORMAL
- en: To arrange the controls on the surface, **tkinter** offers three *Geometry Managers*,
    which we will deal with in more detail in the following sections. Each of the
    three follows a different basic principle of how the position of the controls
    on the surface is defined. Depending on what positioning will be the most suitable
    for your application, you can select the relevant Geometry Manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three Geometry Managers are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pack**: **Pack** simply places the controls one next to the other, or one
    below the other. In the previous sections, we have already worked with this Geometry
    Manager by calling the widgets’ **pack()** method. This caused the widgets to
    be placed one below the other, centering them in the available space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grid**: **Grid** mentally divides the available space on the surface into
    a grid of rows and columns and allows controls to be placed in each “cell” of
    this grid. **Grid** is well suited for constructing complex surfaces and should
    suffice for most purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Place**: **Place** positions elements according to their *absolute* “coordinates”,
    which are measured in pixels, or *relative* (measured in proportions of the window
    width/height) to the upper left corner of the window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.2.4.1 Pack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we took a closer look at the various widgets, we used the **pack()** method
    to ensure that these widgets were actually displayed on our program interface.
    However, the widgets were not only displayed, but of course also positioned in
    the window at the same time, one below the other. And that is exactly what the
    Geometry Manager **Pack** does: As the name suggests, it “packs” the various controls
    together, either vertically as a “stack” (which is the default orientation) or
    also horizontally as a “row”. Exactly where an element appears on the surface
    then depends primarily on how large its predecessors are in the stack (in the
    case of vertical alignment) or the row (in the case of horizontal alignment).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s consider a program interface that is used to enter a password:'
  prefs: []
  type: TYPE_NORMAL
- en: '**from** tkinter **import** *win = Tk()win.title(''Demonstration of the Geometry
    Managers'')win.geometry(''500x100'')prompt = Label(win, text = ''Please enter
    your password:'')pwd = Entry(win)login = Button(win, text = ''Login'')pwd[''show'']
    = ''*''pwd[''width''] = 20pwd.focus()'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create three widgets: a **label** called **prompt** to display a prompt,
    an entry field **pwd** to hold the password, and a login button to confirm the
    password entry. We then configure the entry field **pwd** to hide the password
    input and display only asterisks for the characters entered. We also set its width
    to 20 characters and assign it focus so that the user can start typing directly.
    Next, as before, we call the **pack()** method to let the **pack** Geometry Manager
    place the widgets on the surface. To make sure that the controls are displayed
    next to each other and not—as would happen by default—below each other, we call
    **pack()** with the option **side**, which accepts the constants **''left''**,
    **''right''** and **''bottom''** as values for the direction of the widget positioning
    in addition to the default value **''top''**:'
  prefs: []
  type: TYPE_NORMAL
- en: prompt.pack(side = 'left')pwd.pack(side = 'left')login.pack(side = 'left')win.mainloop()You
    can see the result in ◘ Fig. [22.2](#Fig2). The widgets are now right next to
    each other. With the option **padx** (and vertically **pady**) we can add some
    spacing (*padding*) to the left and right of each widget, for example with:![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig2_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a window titled, demonstration of the Geometry Managers. A password
    field is given below with a login button placed right next to it.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 22.2
  prefs: []
  type: TYPE_NORMAL
- en: Arrangement of the widgets with **pack(side = LEFT)**
  prefs: []
  type: TYPE_NORMAL
- en: pwd.pack(side = 'left', padx = 5)
  prefs: []
  type: TYPE_NORMAL
- en: 'Two other important options can be used to control the behavior of **pack()**
    in even more detail: **expand**, which can take the values **1** and **0** or
    **True** and **False**, determines whether the **pack** Geometry Manager should
    use the full width it has available. In our example, this is the entire window
    width. If we were to change the default setting for all three widgets and tell
    **pack()** to use the full width with **expand=1**, i.e.'
  prefs: []
  type: TYPE_NORMAL
- en: prompt.pack(side = 'left', expand = 1)pwd.pack(side = 'left', expand = 1)login.pack(side
    = 'left', expand = 1)the result looks as in ◘ Fig. [22.3](#Fig3).![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig3_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a window titled, demonstration of the Geometry Managers. A password
    field is given below with a login button placed at a distance from it.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 22.3
  prefs: []
  type: TYPE_NORMAL
- en: Arrangement of widgets with **expand** option
  prefs: []
  type: TYPE_NORMAL
- en: This still “packs” the widgets, but each widget has more space. Within the space
    available to each widget, the control is centered by default, but this can easily
    be adjusted with the specifications **'n'**, **'ne'**, **'e'**, **'se'**, **'s'**,
    **'sw'**, **'w'**, **'nw'**, and **'center'** (default) of the additional **anchor**
    option. These options are the same as for the **Label** widget (see ◘ Table [22.4](#Tab4)).
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can tell **pack()** to maximally expand the widgets in the space available
    to them, which is useful for some purposes, but often looks rather strange. To
    do this, we set the **fill** option to one of the constants **'x'** (expand horizontally),
    **'y'** (expand vertically), or **'both'** (expand both horizontally and vertically).
    This is exactly what happens in the following example with the input field, which
    we let expand in the horizontal direction, and the button, which we let expand
    in both directions to take up the available space, resulting in the interface
    seen in ◘ Fig. [22.4](#Fig4):![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig4_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a window titled, demonstration of the Geometry Managers. An
    elongated password field is given below with a login button placed at a distance
    from it.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 22.4
  prefs: []
  type: TYPE_NORMAL
- en: Arrangement of the widgets with different options
  prefs: []
  type: TYPE_NORMAL
- en: prompt.pack(side = 'left', fill = 'x', anchor = 'w')pwd.pack(side = 'left',
    expand = 1, fill = 'x', padx = 5, anchor = 'w')login.pack(side = 'left', expand
    = 1, fill = 'both', anchor = 'w')
  prefs: []
  type: TYPE_NORMAL
- en: As this example shows, you will usually have to play around with the pack options
    **side**, **fill**, **expand**, **anchor** and **padx/pady** until you have found
    a good layout. With a little experience, you can implement a surface structure
    that you have sketched on paper or digitally.
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.4.2 Grid
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While Pack tries to “pack” the controls side by side, the **grid** Geometry
    Manager sees the application window as a *grid* of *rows* and *columns*. Controls
    can be freely positioned within the grid. The individual “cells” in the grid are
    addressed using the Python-typical indices starting at 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the password input example used in the last section:'
  prefs: []
  type: TYPE_NORMAL
- en: '**from** tkinter **import** *win = Tk()win.title(''Demonstration of the Geometry
    Managers'')win.geometry(''500x100'')prompt = Label(win, text = ''Please enter
    your password:'')pwd = Entry(win)login = Button(win, text = ''Login'')pwd[''show'']
    = ''*''pwd[''width''] = 20pwd.focus()'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, we use the **grid(row =** ***row*****, column =** ***column*****)**
    method to position the prompt and the input field next to each other, with the
    login button below the input field:'
  prefs: []
  type: TYPE_NORMAL
- en: prompt.grid(row = 0, column = 0)pwd.grid(row = 0, column = 1)login.grid(row
    = 1, column = 1)win.mainloop()The result is shown in ◘ Fig. [22.5](#Fig5).![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig5_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a window titled, demonstration of the Geometry Managers. A password
    field is given with a login button placed below it.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 22.5
  prefs: []
  type: TYPE_NORMAL
- en: Arrangement of the widgets with **grid()**
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the input field and the button are displayed in the same column,
    namely column 1 (i.e., the second column). The Geometry Manager sizes the cells
    so that the widgets just fit into them. Within the cells, the controls are centered
    by default (vertically, and—as you can see in the example of the button—horizontally).
  prefs: []
  type: TYPE_NORMAL
- en: However, the alignment of widgets within their cells can be easily influenced
    using the **sticky** option. As seen several times before, **sticky** is a compass
    direction specification. **sticky = 'w'** therefore means that the widget should
    be aligned “in the west”, i.e., on the left edge of the cell. At the same time,
    the cardinal directions can also be used to adjust the width of the widget so
    that, if it were smaller than the cell, it would still fill it completely. For
    example, **sticky = 'we'** causes the widget in its cell, whose width is determined
    by the wider input field in the row above it, to extend “from west to east”, i.e.,
    over the entire width of the cell.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the result in ◘ Fig. [22.6](#Fig6).![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig6_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a window titled, demonstration of the Geometry Managers. A password
    field is given with a login button placed right below it.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 22.6
  prefs: []
  type: TYPE_NORMAL
- en: Arrangement of the widgets with grid() and the option sticky = ‘we’ for the
    button
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, this is not enough, and you want a widget to span multiple
    columns or multiple rows. In this case, the **rowspan** and **columnspan** options
    help, specifying the number of rows or columns spanned respectively. With
  prefs: []
  type: TYPE_NORMAL
- en: login.grid(row = 1, column = 0, sticky = 'we', columnspan = 3)our button would
    extend from the left edge of the prompt to the right edge of the input field.The
    **padx** and **pady** options, already known from **pack()**, allow you to specify
    a left/right and top/bottom spacing, respectively, which generally equalizes the
    display somewhat, as can be seen in the example in ◘ Fig. [22.7](#Fig7), where
    **padx** and **pady** values of 5 were used.![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig7_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a window titled, demonstration of the Geometry Managers. A password
    field is given with a login button placed below it at a distance.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 22.7
  prefs: []
  type: TYPE_NORMAL
- en: Arrangement of the widgets with **grid()** and the options **padx** and **pady**
  prefs: []
  type: TYPE_NORMAL
- en: The total size of the grid in your application window depends on where you have
    placed the widgets positioned furthest out. In our example, the grid has two columns
    and two rows; if we were to place a widget to the right of the input field using
    **widget.grid(row = 0, column = 2)**, a third column would be added. Grid is a
    very popular Geometry Manager because it allows you to design effective surfaces
    with little effort, while providing intuitive positioning. The example in ► Sect.
    [22.2.6](#Sec20), where we develop a full **tkinter** application, will also use
    **Grid**.
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.4.3 Place
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The third, last and probably least frequently used Geometry Manager in practice
    is **Place**. **Place** is used to place widgets either at an absolute position
    specified by **x** and **y** coordinates using the x and y arguments, or at a
    relative position. Relative means that the position relative to the upper left
    corner of the window is measured as a percentage of the window width or height.
    The statement
  prefs: []
  type: TYPE_NORMAL
- en: 'login.place(relx = 0.5, rely = 0.5)positions the **login** button exactly in
    the middle of the window, namely after 50% of the window width (**relx**) and
    50% of the window height (**rely**) from the upper left corner of the window.
    More precisely: The *upper left corner* of the button is placed there. With the
    **anchor** option, already known from **pack()**, another corner can also be specified
    as the “anchor” of the positioning. Again, the corner is specified by geographical
    directions, for example **''se''** for the southeastern, i.e., the lower right
    corner. The size of the widgets can also be specified, either absolutely with
    the help of the **width** and **height** options, or by a relative size specification.
    In this case, **relwidth** and **relheight** can be used to specify a width or
    height as a percentage of the window width or height.'
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of specifying relative positioning and sizes is that the position
    and size of the widgets adapt when the window size changes, an effect that can
    also be achieved with the Geometry Managers **pack** and **grid** (although a
    bit more tedious with the latter), but this is not the case when using **place**
    with absolute position specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.5 Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Command Option of the tkinter Widgets
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have put together responsive interfaces, but they are largely without
    function. Nothing happens when you click on one of our buttons or menu items.
    That will change now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some widgets, such as **Button** or **Menu**, bring with them the ability to
    specify a function that will be called whenever the control is “triggered” by
    the user. Consider the following simple example of the now well-known conversion
    between Kelvin and degrees Celsius. A small converter with a graphical interface
    might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**from** tkinter **import** ***def** convert():lb_result[''text''] = ''Conversion
    result: '' + \str(round(float(en_kelvin.get()) - 273.15, 2)) + '' °C.''**def**
    closeapp():quit()win = Tk()win.title(''Kelvin-Celsius Conversion'')win.geometry(''400x150'')menu_top
    = Menu(win)win.config(menu = menu_top)actionmenu = Menu(menu_top, tearoff = 0)actionmenu.add_command(label
    = ''Convert'', command = convert)actionmenu.add_separator()actionmenu.add_command(label
    = ''Close'', command = closeapp)menu_top.add_cascade(label = ''Action'', menu
    = actionmenu)lb_input = Label(text = ''Temperature in Kelvin:'')en_kelvin = Entry()bt_convert
    = Button(win, text = ''Convert'', command = convert)lb_result = Label(width =
    30)lb_result.pack()en_kelvin.pack()bt_convert.pack(pady = 10)lb_result.pack(pady
    = 10)win.mainloop()The user interface of the program is shown in ◘ Fig. [22.8](#Fig8).![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig8_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a window titled, Kelvin-Celsius conversion. An input field is
    given with a convert button placed below it.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 22.8
  prefs: []
  type: TYPE_NORMAL
- en: Kelvin to Celsius converter
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the previous sections, this time we used the **command** option
    when calling the button constructor method **Button()** to add menu items with
    **add_command()**. The **command** option is assigned a function, called an *event
    handler* or *callback function*, that is automatically called whenever the control
    is triggered by the user. For example, if our “Convert” button is clicked, the
    **convert()** function is automatically called. We defined the **convert()** function
    earlier in the program (the function definition must *precede* the assignment
    to the **command** option in the program source code); it simply performs the
    conversion and prints the result on the **lb_result** label. Note that when assigning
    the event handler function to the **command** option, no round brackets are specified
    after the function name. This is because the **command** option is simply passed
    the function *object*; you’ll recall that in Python, functions are also objects—only
    when defining a function (as you’ll see below) or calling a function would we
    need to include the round brackets, but not when we mean the function object itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Binding Event Handlers**tkinter** knows another, much more powerful way to
    react to events. This is done with the help of the widget method **bind()**. With
    the statementbt_convert.bind(''<button-1>'', convert)we could have achieved the
    same effect as with the **command** option in the **Button()** constructor above.
    The **bind(*****event*****,** ***eventhandler_function*****)** method binds an
    event handler function to an event. Henceforth, our event processing **mainloop()**
    watches to see if the event is triggered and calls the event handler function
    if it is. The string **''<Button-1>''** represents the event that the left/primary
    mouse button (“Button 1”) is pressed (the right mouse button, by the way, would
    be **''<Button-3>''**, **''<Button-2>''** the middle mouse button). Besides these
    button events, there are a variety of such events to which we can bind event handlers;
    here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**<DoubleButton-1>**: Double click with the left mouse button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<Enter>** and **<Leave>**: The user has entered the area of the control with
    the mouse pointer or the mouse pointer has left the area of the control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**a**, **b**, **c**, ...: The respective letter was pressed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<Key>**: *Any* letter was pressed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<F1>**, ...: The respective function key was triggered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<Escape>**, **<BackSpace>** (remove), **<Delete>**, **<Tab>** (tabulator),
    **<Return>** (Return or Enter), **<Shift_L>** (Shift), **<Control_L>** (Ctrl),
    **<Alt_L>** (Alt), **<End>**, **<Home>**, **<Left>** (left arrow), **<Up>** (Up
    arrow), **<Right>** (Right arrow), **<Down>** (Down arrow), **<Print>**, **<Insert>**:
    The respective special key was pressed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Key combinations can also be represented with this method: If, for example,
    you want to bind a function to the event that <CTRL> and <S> were pressed simultaneously,
    you can simply specify **''<Control_L>S''** as the event.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the event handlers that we bind to an event with
    **bind()**. These functions are automatically passed an argument of type **Event**.
    Accordingly, we have to adapt our previous event handlers, which we assigned to
    the **command** option of our button, for example, because these event handlers
    do not require any argument. The change is marginal, but avoids a runtime error:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def** convert(ev = **None**):lb_result[''text''] = ''Conversion result: ''
    \+ str(round(float(en_kelvin.get()) - 273.15, 2)) + '' °C.'''
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to do anything with the **Event** object **ev** but the event
    handler function must provide the argument. By giving the argument a default value
    (namely **None**), we also make the function callable for the **command** option
    of our menu item “Convert”, because it calls the event handler *without* an argument.
    So, the event handler has to cope with being called with an argument as well as
    with the argument being omitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what is the content of this event object? The event object provides some
    information about the event, especially:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x**,**y**: The mouse position (relative to the upper left corner of the window)
    where the event was triggered (interesting for click events).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**widget**: The widget that triggered the event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**char**: The pressed character key (interesting especially for the **<Key>**
    event).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the way: You can also bind events directly to the application window, in
    our case to the **Tk** object **win**. If an event is triggered for a widget,
    the system first automatically checks whether an event handler is bound to this
    event for the respective widget. If this is not the case, it is checked whether
    the “next higher” object, in our case the application window, has an event handler
    for this event. In this sense, the existence of event handlers is checked from
    the “specific to the general”; the event handlers form a hierarchy, so to speak.'
  prefs: []
  type: TYPE_NORMAL
- en: '22.2.6 Example: Calculator Application'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section we will develop a simple calculator using **tkinter**. The calculator
    should handle the four basic arithmetic operations and allow copying the result
    of calculations to the clipboard. You can see the result in ◘ Fig. [22.9](#Fig9).![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig9_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a Calculator application window. An input field with the number
    96.54 is given below with a numeric keypad and mathematical operators.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 22.9
  prefs: []
  type: TYPE_NORMAL
- en: The interface of the calculator application
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the code step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '1 **from** tkinter **import** *2 **from** tkinter.font **import** *3 **from**
    functools **import** *456 *# Define eventhandler functions for buttons*7 **def**
    digit_operator_press(digit_operator):8 display[''text''] = display[''text''] +
    digit_operator91011 **def** delete_press():12 display[''text''] = ''''131415 **def**
    copy_press():16 win.clipboard_clear()17 win.clipboard_append(display[''text''])181920
    **def** plusminus_press():21 display[''text''] = ''-'' + display[''text'']222324
    **def** equal_press():25 display[''text''] = str(eval(display[''text'']))262728
    *# Define eventhandler for <ENTER> key*29 **def** enter_press(ev):30 equal_press()313233
    *# Create application window*34 win = Tk()35 win[''background''] = ''#000000''36
    win.title(''Calculator'')37 win.geometry(''268x470'')38 win.resizable(height=False,
    width=False)3940 *# Define fonts for button and display*41 digit_font = Font(family
    = ''Arial'', size = 18)42 display_font = Font(family = ''Arial'', size = 24,43
    weight = ''bold'')4445 *# Create the display*46 display = Label(text = '''',47
    background = ''#000000'',48 foreground = ''#00FF00'')49 display[''width''] = 1350
    display[''font''] = display_font51 display[''height''] = 252 display[''anchor'']
    = ''e''5354 *# Define buttons*55 delete_op = Button(win,56 text = ''Delete'',57
    width = 9,58 height = 1,59 font = digit_font,60 foreground = ''#FFFFFF'',61 background
    = ''#4C4E4F'',62 command = delete_press)63 plusminus_op = Button(win,64 text =
    ''+/-'',65 width = 4,66 height = 1,67 font = digit_font,68 foreground = ''#FFFFFF'',69
    background = ''#4C4E4F'',70 command = plusminus_press)71 copy_op = Button(win,72
    text = ''Copy'',73 width = 4,74 height = 1,75 font = digit_font,76 foreground
    = ''#FFFFFF'',77 background = ''#4C4E4F'',78 command = copy_press)79 digit1 =
    Button(win,80 text = ''1'',81 width = 4,82 height = 2,83 font = digit_font,84
    command = partial(digit_operator_press,''1''))85 digit2 = Button(win,86 text =
    ''2'',87 width = 4,88 height = 2,89 font = digit_font,90 command = partial(digit_operator_press,
    ''2''))91 digit3 = Button(win,92 text = ''3'',93 width = 4,94 height = 2,95 font
    = digit_font,96 command = partial(digit_operator_press, ''3''))97 digit4 = Button(win,98
    text = ''4'',99 width = 4,100 height = 2,101 font = digit_font,102 command = partial(digit_operator_press,
    ''4''))103 digit5 = Button(win,104 text = ''5'',105 width = 4,106 height = 2,107
    font = digit_font,108 command = partial(digit_operator_press, ''5''))109 digit6
    = Button(win,110 text = ''6'',111 width = 4,112 height = 2,113 font = digit_font,114
    command = partial(digit_operator_press, ''6''))115 digit7 = Button(win,116 text
    = ''7'',117 width = 4,118 height = 2,119 font = digit_font,120 command = partial(digit_operator_press,
    ''7''))121 digit8 = Button(win,122 text = ''8'',123 width = 4,124 height = 2,125
    font = digit_font,126 command = partial(digit_operator_press, ''8''))127 digit9
    = Button(win,128 text = ''9'',129 width = 4,130 height = 2,131 font = digit_font,132
    command = partial(digit_operator_press, ''9''))133 digit0 = Button(win,134 text
    = ''0'',135 width = 9,136 height = 2,137 font = digit_font,138 command = partial(digit_operator_press,
    ''0''))139 divide_op = Button(win,140 text = ''/'',141 width = 4,142 height =
    2,143 font = digit_font,144 foreground = ''#FFFFFF'',145 background = ''#10a605'',146
    command = partial(digit_operator_press, '' / ''))147 multiply_op = Button(win,148
    text = ''*'',149 width = 4,150 height = 2,151 font = digit_font,152 foreground
    = ''#FFFFFF'',153 background = ''#10a605'',154 command = partial(digit_operator_press,
    '' * ''))155 minus_op = Button(win,156 text = ''-'',157 width = 4,158 height =
    2,159 font = digit_font,160 foreground = ''#FFFFFF'',161 background = ''#10a605'',162
    command = partial(digit_operator_press, '' - ''))163 plus_op = Button(win,164
    text = ''+'',165 width = 4,166 height = 2,167 font = digit_font,168 foreground
    = ''#FFFFFF'',169 background = ''#10a605'',170 command = partial(digit_operator_press,''
    + ''))171 point_op = Button(win,172 text = '','',173 width = 4,174 height = 2,175
    font = digit_font,176 command = partial(digit_operator_press, ''.''))177 equal_op
    = Button(win,178 text = ''='',179 width = 10,180 height = 1,181 font = digit_font,182
    foreground = ''#FFFFFF'',183 background = ''#0570A6'',184 command = equal_press)185186
    *# Define eventhandler for Enter key*187 win.bind(''<Return>'', enter_press)188189
    *# Place buttons on interface*190 display.grid(row = 0, column = 0, columnspan
    = 5,191 sticky = ''news'')192 delete_op.grid(row = 1, column = 0, columnspan =
    2,193 sticky = ''news'')194 plusminus_op.grid(row = 1, column = 2, sticky = ''news'')195
    copy_op.grid(row = 1, column = 4, sticky = ''news'')196 digit1.grid(row = 2, column
    = 0, sticky = ''news'')197 digit2.grid(row = 2, column = 1, sticky = ''news'')198
    digit3.grid(row = 2, column = 2, sticky = ''news'')199 digit4.grid(row = 3, column
    = 0, sticky = ''news'')200 digit5.grid(row = 3, column = 1, sticky = ''news'')201
    digit6.grid(row = 3, column = 2, sticky = ''news'')202 digit7.grid(row = 4, column
    = 0, sticky = ''news'')203 digit8.grid(row = 4, column = 1, sticky = ''news'')204
    digit9.grid(row = 4, column = 2, sticky = ''news'')205 digit0.grid(row = 5, column
    = 0, columnspan = 2,206 sticky = ''news'')207 point_op.grid(row = 5, column =
    2, sticky = ''news'')208 divide_op.grid(row = 2, column = 4, sticky = ''news'')209
    multiply_op.grid(row = 3, column = 4, sticky = ''news'')210 minus_op.grid(row
    = 4, column = 4, sticky = ''news'')211 plus_op.grid(row = 5, column = 4, sticky
    = ''news'')212 equal_op.grid(row = 6, column = 0, columnspan = 5,213 sticky =
    ''news'')214215 *# Event loop*216 win.mainloop()Lines 1–3: Import Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: We first import all classes from the **tkinter** module. Furthermore, the “display”
    of our calculator will use a special font, so we also import everything from the
    **font** module. We need the last import statement to make the event functions
    that are supposed to react to the user’s digit input a bit simpler. More about
    this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 6–30: Event Handler Functions for Buttons'
  prefs: []
  type: TYPE_NORMAL
- en: These are the event functions that react to the different user actions. We’ll
    go into these functions in a little more detail at the end, but first we want
    to look at the interface. With knowledge of the interface, it is also easier to
    understand how the event handlers work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 33–38: Window of the Application'
  prefs: []
  type: TYPE_NORMAL
- en: Our calculator should have a black background and a fixed window size that cannot
    be changed by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 40–52: Fonts and Display'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define two fonts, **digits_font** for the digits on the calculator
    keys, and **display_font** for the display on the calculator. The display itself
    has a green foreground and a black background color. With **display['anchor']
    = 'e'** we align its content “east”, i.e., right aligned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 54–184: Create the Buttons'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create the buttons for our window **win**, which are characterized
    by a number of properties, namely their label (**text**), their **width** and
    **height** in text characters, the **font**, the **foreground** and **background**
    color, and the event handler (**command**) that is called when the user clicks
    on the button.
  prefs: []
  type: TYPE_NORMAL
- en: For the event handlers, we use a little trick to avoid having to write a separate
    event handler for each of the 10 digits and each arithmetic operator. We have
    defined only one event handler named **digit_operator_press()**, which we call
    with one argument, namely the respective digit or the respective operator. But
    the option **command** of the **tkinter button** object must be passed a function
    object, not a call to a function with arguments. Therefore, we use the **partial**
    function from the **functools** module to create a function object in which the
    argument is already “baked in”. Since the return value of **partial()** is an
    object not unlike the **function** object, but which already contains the argument
    value, we can use this return value as the value for the **command** option of
    our buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 186–187: Event Handler for the <ENTER> Key'
  prefs: []
  type: TYPE_NORMAL
- en: To make it possible to trigger the computation not only by clicking the equals
    sign button on the interface, but also by pressing <ENTER> on the keyboard, we
    bind an event handler (lines 29–30) to the event of pressing <ENTER>, which does
    nothing but call the event handler that is triggered when the equals sign button
    is pressed (lines 24–25). We still need to separate the two event handlers, because
    the event handler that processes the button press is passed an event object as
    an argument by default, which we must accept even if we don’t process it at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, let’s take a quick look at the other event handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**digit_operator_press()** (lines 6–8): The event handler is passed the clicked
    digit or arithmetic operator as an argument. The value of the pressed button is
    simply appended to the existing display content in the display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**delete_press()** (lines 11–12): Clears the contents of the display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**copy_press()** (lines 15–17): First clears the clipboard, then appends to
    the clipboard the current contents of the display. The functions **clipboard_clear()**
    and **clipboard_append()** are used for this purpose, both of which are conveniently
    provided by the **Tk** class and are therefore also available for our window object
    **win**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**plusminus_press()** (lines 20–21): When the plus/minus button is pressed,
    we simply prepend a minus to the current display content. Strictly speaking, we
    would have to check if there is already a minus and then remove it. But just as
    with the other inputs (for example, we don’t check whether the user enters two
    operators in a row), we make it easy for ourselves at this point and rely on the
    common sense of the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**equal_press()** (lines 24–25): This is the event handler mentioned earlier,
    which is called when the user requests the result of the calculation. Here we
    use the **eval()** function, which evaluates a Python expression and returns its
    result. In our case, the Python expression is simply the sequence of numbers and
    operators entered by the user and displayed in our calculator display. However,
    **eval()** can also be used to execute completely arbitrary Python code passed
    as a string argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lines 189–213: Placing the Buttons on the Interface'
  prefs: []
  type: TYPE_NORMAL
- en: Now we just need to place the display and the buttons on the surface. To do
    this, we need the **grid** Geometry Manager, so we use the **grid()** method to
    assign the individual controls their place in the grid by specifying their **row**
    and **column** number. With the **columnspan** option, we make some elements extend
    horizontally across more than one cell of the grid, for example the display. With
    the value **news** (*north + east + west + south*) of the **sticky** option we
    specify that the elements in their respective grid cell should extend completely,
    i.e., fill the cell completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 215–216: Event Loop'
  prefs: []
  type: TYPE_NORMAL
- en: With **mainloop()** we start the event processing for our calculator. From now
    on, the user interface reacts to the user’s input by calling the corresponding
    event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 22.3 Working with Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Working with files is very simple in Python. It is done in three steps, not
    unlike most other programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The file is opened (possibly created in the first place)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The file is processed (it is read from it, written to it or appended to it)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The file is closed after all work is completed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Opening FilesA file is represented by a *file object*. We create such a file
    object with the help of the standard Python function **open(*****filepath*****,**
    ***mode*****)**. The argument **mode** describes the editing mode in which the
    file is to be opened. Possible values of the mode are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**"w"**: The file is opened for *writing*. The file pointer is set to the beginning
    of the file. Any existing contents of the file are completely replaced. If the
    file does not yet exist, it will be newly created. Reading from the file in this
    mode is not possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**"a"**: The file is opened for *appending*. The file pointer is placed at
    the end of the file. Contents that are written to the file are appended to it.
    Reading from the file is not possible in this mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**"r"**: The file is opened for *reading*. The file pointer is set to the beginning
    of the file. Writing to the file is not possible in this mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**"r+"**: The file is opened for reading *and* writing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that if you are working on a Windows system, you must *escape* the backslashes
    that separate the path components in the path specification with another backslash,
    otherwise Python will regard them as an attempt to escape the *following character*
    and thus assign a special control function to it (if you are no longer familiar
    with escaping, go back and review ► Sect. [11.​2.​2](474412_1_En_11_Chapter.xhtml#Sec4)).
    For example, if we wanted to open the file **test.txt** in the directory **C:\Programming**
    for writing, we would first have the function **open()** create a corresponding
    file object (which we call **file** here for simplicity):file = open("C:\\Programming\\test.txt",
    "w")
  prefs: []
  type: TYPE_NORMAL
- en: 'This object has a number of properties that allow us to better understand its
    character: file.name gives us the file name as a full path specification, **file.mode**
    the mode in which we opened the file. Furthermore, whether the file is readable
    and/or writable can be determined with the methods **file.readable()** and **file.writable()**,
    which return a **bool** value each.'
  prefs: []
  type: TYPE_NORMAL
- en: Editing the File
  prefs: []
  type: TYPE_NORMAL
- en: To *write* to the file, the file object provides the methods **write(*****text*****)**
    and **writelines(*****lines*****)**.
  prefs: []
  type: TYPE_NORMAL
- en: '**write()** simply writes *a* string to the file, without a trailing newline
    unless **text** contains the escape sequence **\n** at the end (for example, **"This
    is a newline\n text"**).'
  prefs: []
  type: TYPE_NORMAL
- en: '**writelines()**, in contrast, writes *several* strings that are passed as
    an array; the name of the function is somewhat misleading, because **writelines()**
    also does not write a newline at the end of each string. So, if you want a line
    break after each string, you have to add it yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: lines = ["line 1\n", "line 2\n"]file.writelines(lines)
  prefs: []
  type: TYPE_NORMAL
- en: The write methods each return the number of characters written as a function
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To *read* from a file the functions **read()**, **readline()** and **readlines()**
    are available. **read()** reads the *entire* file contents and returns it as a
    string. With an optional argument, a *certain number of characters* (measured
    from the current position of the file pointer) can be read. The file pointer starts
    at the beginning of the file and moves accordingly with each read operation. Consider
    the following example file:'
  prefs: []
  type: TYPE_NORMAL
- en: Line number oneOne more lineLast line
  prefs: []
  type: TYPE_NORMAL
- en: With **read(3)**, after opening the file (the file pointer is then at the beginning
    of the file), we would first read the string **"Lin"**. After that, the file pointer
    is on the **"e"** of **"line"**. Another **read(19)** would then return the next
    19 characters, i.e. **"e number one\nOne mo"**. Note that the line break also
    counts as a character, and as *exactly one* character (although it is represented
    as an escape sequence in the form **\n** with two characters). After this reread,
    the file pointer is now on **"r"** of **"more"**.
  prefs: []
  type: TYPE_NORMAL
- en: The **readline()** and **readlines()** functions proceed differently than **read()**;
    they read in one or more *lines* respectively. **readline()** always reads in
    exactly the next line, while **readlines()** reads in all lines or the number
    of lines passed as an optional argument, returning an *array of strings.* The
    **readline()** and **readlines(1)** method calls thus differ in that the result
    of the **readline()** call results in a **str** value, while **readlines()** returns
    an array, which in this case contains only a single string as an element.
  prefs: []
  type: TYPE_NORMAL
- en: If the file pointer is not at the beginning of a line, but in the middle of
    a line, as after the call to **read(3)** above, then **readline()** and **readlines()**
    read from the character on which the file pointer is currently located. The beginning
    of the line (in our example, the first three characters already read with **read()**)
    is then no longer read.
  prefs: []
  type: TYPE_NORMAL
- en: When reading, you can use **seek(*****characterindex*****)** to set the file
    pointer to the character specified by **characterindex**, counting from the beginning
    of the file. The current position of the file pointer is returned by the **tell()**
    method of the file object.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way: If you open the file in **"r+"** mode (read *and* write), you can
    actually use the same file object for both operations. However, writing is always
    done at the end of the file, reading at the current position of the file pointer,
    which behaves the same way as when opening the file in **"r"** mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Close the File
  prefs: []
  type: TYPE_NORMAL
- en: 'After editing the file, close it with the ***file*****.close()** method. The
    file object will continue to exist, but its property ***file*****.closed** will
    now take the value **True**, indicating that the object is not available for reading
    or writing any more. However, since the file object still carries the path to
    the file as its **name** property, you can simply “reactivate” it:'
  prefs: []
  type: TYPE_NORMAL
- en: file = open(file.name, "r")22.2 [15 min]
  prefs: []
  type: TYPE_NORMAL
- en: Write a program that queries the user for the name of a file (with its complete
    path). A certain percentage (specified by the user) of the file content is then
    to be displayed as a preview. Line breaks shall be removed from the preview display
    so that the display is as compact as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '22.4 Exercise: Development of a Simple Text Editor'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following exercise combines many of the things you have learned in this
    chapter to develop a useful little application.
  prefs: []
  type: TYPE_NORMAL
- en: The task is to program a simple text editor with **tkinter**. This should allow
    you to create new files or open existing files, and then edit and save the files
    again, either under the current name or a new name. Also, the user should be able
    to copy text to the clipboard and paste it from the clipboard. The commands of
    the editor shall be selectable via a menu as well as via a button bar.
  prefs: []
  type: TYPE_NORMAL
- en: You will want to use the **ScrolledText** widget from the **tkinter** module
    **scrolledtext**. Therefore, make sure you include the line**from** tkinter.scrolledtext
    **import** ScrolledTextin your imports even if you import the rest of the **tkinter**
    widgets with **from tkinter import ***.
  prefs: []
  type: TYPE_NORMAL
- en: Test your program extensively!
  prefs: []
  type: TYPE_NORMAL
- en: The estimated time to complete this task is 120 min. You should have a quiet
    space to focus on this piece of development work. If the task still seems too
    challenging, do not spend hours trying to develop the editor yourself, but read
    the code in the sample solution and try to understand it, at first without referring
    to the explanatory notes in the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 22.5 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to input and output data via the console.
    We also looked at how graphical user interfaces can be implemented in Python to
    allow the user to interact with your program conveniently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to take the following points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Python console, you can always print objects using the built-in Python
    function **print(*****object*****)**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information can be requested from the user using the **input(*****prompt*****)**
    method, which always returns the user input as a string (so the user input must
    be converted if necessary).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphical user interfaces (GUIs) can be easily implemented with the **tkinter**
    library, which is part of the standard Python package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **tkinter** program always consists of creating a **Tk** object using the
    constructor function of the same name, creating and configuring the controls (widgets),
    defining the arrangement of the controls (using a Geometry Manager) and starting
    event processing (method **mainloop()** of the **Tk** object).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important controls (widgets) for graphical user interfaces in **tkinter**
    are **Button**, **Menu**, **Entry** (text input), **Label** (text display), **Checkbutton**
    (multiple selection of options), **Radiobutton** (single selection of options)
    and **Listbox** (list-like display of text entries with single or multiple selection).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Important standard dialogs that can be used from within **tkinter** (more specifically,
    the **tkinter** module **filedialog**) are: **messagebox** (with several variants
    that differ in the displayed icons and buttons) for displaying text messages;
    and **askopenfilename()** and **asksaveasfilename()** for querying file paths
    when opening or saving files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The widgets are configured via options; some options (but not their values!)
    are common to almost all widgets (for example, the **background** color and the
    **font**), others are specific to the particular control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All widgets have the **config(*****option*** **=** ***value*****, ...)** method,
    which can be used to set the values of the options. In addition, the options can
    be accessed in the form **widget['option']** as if they were a dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Widgets are arranged on the program surface with the help of a Geometry Manager;
    **tkinter** has three such arrangement tools with **pack** (arrange directly next
    to/below each other), **grid** (arrange along an imaginary grid) and **place**
    (arrange by specifying coordinates relative to a reference point), that can be
    called with the standard methods **pack()**, **grid()** and **place()** of each
    widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To read and write data from or to files, the file in question is first opened
    with the built-in Python function **open(*****filename*****,** ***mode*****)**;
    this returns a **File** object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modes for editing files are **r** (read), **w** (write), **a** (append), and
    **r+** (read and write).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The methods **read()** and **readlines()** as well as **write()** and **writelines()**
    of the **File** object can be used to read from or write to the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **close()** method of the **File** object closes the file again after processing
    is complete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.6 Solutions to the Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise 22.1*# First option: Three print()-commands (each automatically #
    # ending with \n)*print(''First line'')print(''Second line'')print(''Third line'')*#
    Second option: One string, lines separated by the \n escape**# sequence.*print(''First
    line\nSecond line\nThird line'')*# Third option: Output of three string objects,
    using the \n**# escape sequence as separator.*print(''First line'', ''Second line'',
    ''Third line'', sep = ''\n'')Exercise 22.2'
  prefs: []
  type: TYPE_NORMAL
- en: 'The program could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'filename = input("Please enter a filename (incl. path): ")percent = input("Percent
    of content to be previewed " +"(whole number, e.g. 10 for 10%): ")previewfile
    = open(filename, "r")contents = previewfile.read()previewfile.close()content =
    contents.replace("\n", "")length_total = len(content)length_preview = int(length_total
    * int(percent) / 100)print("### Preview: ", length_preview, " characters of ",length_total,
    "characters ###")print(content[0:length_preview], "\n####\n")'
  prefs: []
  type: TYPE_NORMAL
- en: The file is first opened in read mode (**"r"**) and its entire contents are
    read with **read()**. After that, the file can be closed again, because the string
    variable **content** now contains the entire file content, and we will only continue
    to work with this content. After we have cleaned line breaks from the content
    by removing the escape sequence **\n** with the string method **replace()**, we
    select the desired number of characters in the last statement, which we have previously
    calculated from the preview percentage specified by the user, and display them
    on the screen. When selecting characters from the string, it is important to ensure
    that the selection limits are integers. We achieve this by using **int()** to
    store the result as an integer variable when calculating the preview length.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Task Text EditorMany variants are of course possible in the development
    of the text editor. The user interface of the solution presented here can be seen
    in ◘ Fig. [22.10](#Fig10).![](../images/474412_1_En_22_Chapter/474412_1_En_22_Fig10_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a window titled, My personal text editor. It has buttons on
    top of the window such as new, open, and save. Three lines are given in the field
    below with the text, line number one, one more line, and last line, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 22.10
  prefs: []
  type: TYPE_NORMAL
- en: User interface of our text editor
  prefs: []
  type: TYPE_NORMAL
- en: 'The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '1 **from** tkinter **import** *2 **from** tkinter.filedialog **import** *3
    **from** tkinter.scrolledtext **import** ScrolledText45 *# Define event handler
    functions for buttons and menus*67 **def** new_press():8 **global** filename9
    text.delete(1.0, ''end'')10 filename = ''''11 status[''text''] = ''Unsaved new
    file''121314 **def** open_press():15 **global** filename16 fname = askopenfilename(defaultextension
    = ''txt'',17 filetypes = [(''Text Files'', ''*.txt''),18 (''All Files'', ''*.*''),],19
    title = ''Open....'',20 initialdir = ''C:\\Windows'')21 textfile = open(fname,
    ''r'')22 text.delete(1.0, ''end'')23 text.insert(1.0, textfile.read())24 textfile.close()2526
    status[''text''] = ''File "'' + fname + ''" opened.''27 filename = fname282930
    **def** saveas_press():31 **global** filename32 fname = asksaveasfilename(defaultextension
    = ''txt'',33 filetypes = [(''Text Files'', ''*.txt''),34 (''All Files'', ''*.*''),],35
    title = ''Save File As...'',36 initialdir = ''C:\\Windows'')37 textfile = open(fname,
    ''w'')38 textfile.write(text.get(1.0, ''end''))39 textfile.close()4041 status[''text'']
    = ''File "'' + fname + ''" saved.''42 filename = fname434445 **def** save_press():46
    **global** filename47 textfile = open(filename, ''w'')48 textfile.write(text.get(1.0,
    ''end''))49 textfile.close()5051 status[''text''] = ''File "'' + filename + ''"
    saved.''525354 **def** copy_press():55 selection = text.selection_get()56 text.clipboard_clear()57
    text.clipboard_append(selection)585960 **def** paste_press():61 text.insert(text.index(''insert''),
    text.clipboard_get())626364 **def** copy_press_key(event):65 copy_press()666768
    **def** paste_press_key(event):69 paste_press()707172 **def** quit_press():73
    win.quit()747576 *# Create application window*77 win = Tk()78 win.title(''My Personal
    Text Editor'')79 win.geometry(''760x490'')80 win.resizable(height = True, width
    = True)818283 # Set up the menu84 menubar = Menu(win)85 win.config(menu = menubar)8687
    file_menu = Menu(menubar, tearoff=0)88 edit_menu = Menu(menubar, tearoff=0)8990
    menubar.add_cascade(label = ''File'', menu = file_menu)91 menubar.add_cascade(label
    = ''Edit'', menu = edit_menu)9293 file_menu.add_command(label = ''New'',94 command
    = new_press)95 file_menu.add_command(label = ''Open...'',96 command = open_press)97
    file_menu.add_command(label = ''Save'',98 command = save_press)99 file_menu.add_command(label
    = ''Save As...'',100 command = saveas_press)101 file_menu.add_separator()102 file_menu.add_command(label
    = ''Quit'',103 command = quit_press)104105 edit_menu.add_command(label =''Copy'',106
    command = copy_press)107 edit_menu.add_command(label =''Paste'',108 command =
    paste_press)109110111 # Create the control elements112 new_button = Button(win,113
    text = ''New'',114 height = 3,115 width = 16,116 command = new_press)117 open_button
    = Button(win,118 text = ''Open...'',119 height = 3,120 width = 16,121 command
    = open_press)122 save_button = Button(win,123 text = ''Save'',124 height =3,125
    width = 16,126 command = save_press)127 saveas_button = Button(win,128 text =
    ''Save As...'',129 height = 3,130 width = 16,131 command = saveas_press)132 seplabel
    = Label(win,133 text='''',134 height =3,135 width= 3)136 copy_button = Button(win,137
    text = ''Copy'',138 height = 3,139 width = 16,140 command = copy_press)141 paste_button
    = Button(win,142 text = ''Paste'',143 height = 3,144 width = 16,145 command =
    paste_press)146147 text = ScrolledText(win)148 text.bind(''<Control-c>'', copy_press_key)149
    text.bind(''<Control-v>'', paste_press_key)150151152 *# Set up the status bar*153
    status = Label(win,154 text = ''No file openend.'',155 anchor = ''w'',156 background
    = ''#FFEFC4'')157 filename = ''''158159160 *# Place buttons on surface*161 new_button.grid(row
    = 0, column = 0, sticky = ''news'')162 open_button.grid(row = 0, column = 1, sticky
    = ''news'')163 save_button.grid(row = 0, column = 2, sticky = ''news'')164 saveas_button.grid(row
    = 0, column = 3, sticky = ''news'')165166 seplabel.grid(row = 0, column= 4, sticky
    = ''news'')167 copy_button.grid(row = 0, column = 5, sticky = ''news'')168 paste_button.grid(row
    = 0, column = 6, sticky = ''news'')169170 text.grid(row = 1, column = 0, columnspan
    = 7, pady = 10,171 sticky = ''news'')172173 status.grid(row = 2, column = 0, columnspan
    = 7,174 sticky = ''news'')175176177 *# Event loop*178 win.mainloop()Lines 5–73:
    Eventhandler Functions for Buttons and Menus'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll take a closer look at how event handlers work below once it’s clear which
    components will make up the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 76–80: Application Window'
  prefs: []
  type: TYPE_NORMAL
- en: The window **win** is created and scaled as a **Tk** object. It should be resizable
    for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 83–108: Menu Setup'
  prefs: []
  type: TYPE_NORMAL
- en: A new menu bar is created for the **win** window and two drop-down menus, **file_menu**
    and **edit_menu** are placed on the bar. The menu items are then gradually added
    to the menus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 111–149: Creating the Remaining Controls'
  prefs: []
  type: TYPE_NORMAL
- en: This is where the buttons and the text input field are created. In addition,
    event handlers are bound to two events of the text input field to process the
    pressing of the key combinations <CTRL>+<C> (copy) and <CTRL>+<V> (paste).
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 152–157: Preparing the Status Bar'
  prefs: []
  type: TYPE_NORMAL
- en: We create a label as a yellowish colored status bar, on which the name of the
    currently opened file is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 160–174: Placing the Controls on the Interface'
  prefs: []
  type: TYPE_NORMAL
- en: The controls are arranged on the user interface using the **grid** Geometry
    Manager, in such a way that they fully fill their respective “grid cells” (**sticky
    = 'news'**, i.e., *north east west south*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 177–178: Event Loop'
  prefs: []
  type: TYPE_NORMAL
- en: '**mainloop()** starts event processing for our editor. This makes the user
    interface react to the user’s input.'
  prefs: []
  type: TYPE_NORMAL
- en: Event Handlers (Lines 5–73)
  prefs: []
  type: TYPE_NORMAL
- en: '**new_press()**: Creates a file by first deleting the contents of the **ScrolledText**
    field; deletes from line 1 (line numbering starts at 1 for text widgets in **tkinter**),
    column 0 (column numbering starts at 0) to the end. Instead of the string **''end''**
    the constant **END** could have been used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The global variable **filename**, to which we secure access with the statement
    **global filename** (otherwise a *local* variable with the same name would be
    created within **new_press()**!) is reinitialized with an empty string and the
    text of the status bar is updated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**open_press()**: Here we use the **askopenfilename()** function to retrieve
    the path to the file we want to open. After that, the file is opened in read mode
    with **open()** and the content read from it with **read()** is put into our text
    field before the file is closed again with **close()**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**save_as_press()** and **save_press()**: For save, we basically do the same
    as for open; however, the file is opened in write mode so that the **write()**
    method can write the text on the editor that we get using the **get()** method
    of the **ScrolledText** widget. In **save_as_press()**, we ask for the filename
    using **tkinter**’s **asksaveasfilename()** function, and for **save_press()**,
    we save the file using the name we’re already using. So, this can only work if
    a file has been opened or the content of the **ScrolledText** widget has already
    been saved to a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**copy_press()** and **paste_press()**, **copy_press_key()** and **paste_press_key()**:
    When copying text, we first determine the contents of the text selection using
    the **selection_get()** method of the **ScrolledText** widget, then clear the
    clipboard using **clipboard_clear()**, and then insert the text to be copied to
    the clipboard using the **clipboard_append()** method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When inserting text, we first determine the current insert, i.e. cursor position
    in our **ScrolledText** widget with **index('insert')** and then get the clipboard
    content with **clipboard_get()** to insert it at this position.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The **copy_press_key()** and **paste_press_key()** functions that we bound to
    the keystroke events (lines 148/149) call the event handlers we discussed earlier,
    but they are necessary because the event handlers bound to an event using **bind()**
    are passed an event object as an argument. These event handlers must therefore
    provide an argument, while the event handlers we bound to buttons and menu items
    using the **command** option must have no arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
