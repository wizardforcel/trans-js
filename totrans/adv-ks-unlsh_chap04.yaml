- en: Closures
  id: totrans-0
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 闭包
- en: Closure is one of the fundamental topics in JavaScript and can be tricky to
    understand for beginners. It is a powerful feature, and developing a good understanding
    of this topic is essential. In this module, we will take a deeper look at what
    closures are and how they work.
  id: totrans-1
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 闭包是 JavaScript 中的基本主题之一，对于初学者来说可能比较难以理解。它是一个强大的特性，深入理解这一主题是至关重要的。在本模块中，我们将更深入地探讨闭包是什么以及它们是如何工作的。
- en: What is a closure?
  id: totrans-2
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 什么是闭包？
- en: 'The closure is a combination of the following two things:'
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 闭包是以下两个事物的组合：
- en: A `Function`
  id: totrans-4
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 一个 `Function`
- en: A reference to the environment/scope in which that function is created
  id: totrans-5
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 对于创建该函数的环境/作用域的引用
- en: 'In other words, whenever we define a function in JavaScript, that function
    saves a reference to the environment in which it was created. This is what’s referred
    to as a closure: a function along with a reference to the environment in which
    it is created.'
  id: totrans-6
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 换句话说，每当我们在 JavaScript 中定义一个函数时，该函数会保存一个对其创建环境的引用。这被称为闭包：一个函数以及对其创建环境的引用。
- en: Closures allow a nested function to access the declarations inside the containing
    function, even after the execution of the containing function has ended.
  id: totrans-7
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 闭包允许嵌套函数访问包含函数内部的声明，即使包含函数的执行已经结束。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s a Replit of the code above:'
  id: totrans-9
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是上述代码的一个 Replit：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/Example1”>`'
  id: totrans-10
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/Example1”>`'
- en: How does the `innerFn`, function returned by `outerFn`, have access to the `outerVar`
    variable declared in `outerFn` even after the “outerFn” execution is complete?
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 返回的 `innerFn` 函数是如何访问在 `outerFn` 中声明的 `outerVar` 变量的，即使在“outerFn”执行完成后？
- en: The above code works because JavaScript functions always create closures when
    they are created. In some programming languages, a function’s locally defined
    variables only exist for the duration of that function’s execution; when a function’s
    execution ends, variables defined in its local scope are destroyed. But that’s
    not the case in JavaScript, as is evident from the code example above. So, how
    do closures work?
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上述代码之所以有效，是因为 JavaScript 函数在创建时总是会创建闭包。在某些编程语言中，函数的局部变量仅在该函数执行期间存在；当函数执行结束时，其局部作用域中定义的变量会被销毁。但在
    JavaScript 中并非如此，这从上面的代码示例中可以明显看出。那么，闭包是如何工作的呢？
- en: How do closures work?
  id: totrans-13
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 闭包是如何工作的？
- en: To understand how closures work, we need to understand how JavaScript resolves
    the scope of any identifier.
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 要理解闭包是如何工作的，我们需要理解 JavaScript 如何解析任何标识符的作用域。
- en: 'Although we had a detailed discussion on scope in an earlier module dedicated
    to the topic of scope, let us once again briefly go over how the lexical scope
    is resolved. Consider the following code example:'
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 尽管我们在之前的一个模块中详细讨论了作用域，但我们还是简单回顾一下词法作用域是如何解析的。考虑以下代码示例：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s a Replit of the code above:'
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是上述代码的一个 Replit：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/Example2”>`'
  id: totrans-18
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/Example2”>`'
- en: When the `learnJavaScript` function is invoked to log the value of the `isReading`
    variable, the JavaScript first needs to identify where it is defined. The first
    place where JavaScript will search is the local scope of the `learnJavaScript`
    function because this is where a reference to the `isReading` variable was found.
  id: totrans-19
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当调用 `learnJavaScript` 函数以记录 `isReading` 变量的值时，JavaScript 首先需要识别该变量的定义位置。JavaScript
    首先搜索的地方是 `learnJavaScript` 函数的局部作用域，因为在这里找到了对 `isReading` 变量的引用。
- en: As the `isReading` variable is not defined in the local scope of the `learnJavaScript`
    function, JavaScript will search for this variable in the outer scope, which in
    this case is the global scope. JavaScript will find the declaration of the `isReading`
    variable in the global scope, so it will get its value and pass it to the `console.log`
    function so that it can be logged to the console.
  id: totrans-20
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 由于 `isReading` 变量没有在 `learnJavaScript` 函数的局部作用域中定义，JavaScript 将在外部作用域中搜索该变量，在此情况下是全局作用域。JavaScript
    会在全局作用域中找到 `isReading` 变量的声明，因此会获取其值并将其传递给 `console.log` 函数，以便将其记录到控制台。
- en: 'Let us take a look at another code example that involves a nested function:'
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们看一个涉及嵌套函数的代码示例：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s a Replit of the code above:'
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是上述代码的一个 Replit：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/Example3”>`'
  id: totrans-24
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/Example3”>`'
- en: In this code example, we have a nested function, `stepsToLearnJavaScript`, that
    logs the value of a variable defined in the global scope. If JavaScript hasn’t
    already determined the scope of the `isReading` variable, how will it find its
    declaration? Recall the scope chain!
  id: totrans-25
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们有一个嵌套函数 `stepsToLearnJavaScript`，它记录了在全局作用域中定义的变量的值。如果 JavaScript
    还没有确定 `isReading` 变量的作用域，它将如何找到它的声明？回想一下作用域链！
- en: JavaScript will need to traverse the scope chain to find the declaration of
    the `isReading` variable. As in the earlier example, the declaration is first
    searched in the current scope, which in this case is the local scope of the `stepsToLearnJavaScript`
    function. If the current scope doesn’t contain the declaration JavaScript is looking
    for, the search is sequentially expanded to the outer scopes. In our example,
    the `stepsToLearnJavaScript` function doesn’t contain the declaration of the `isReading`
    variable, so the search is moved to the outer scope, which in this case is the
    local scope of the `learnJavaScript` function. The declaration doesn’t exist in
    this scope either; JavaScript traverses to the outer scope of the `learnJavaScript`
    function scope. The outer scope now is the global scope.
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: JavaScript 将需要遍历作用域链以找到 `isReading` 变量的声明。与之前的示例一样，首先在当前作用域中搜索声明，在本例中是 `stepsToLearnJavaScript`
    函数的局部作用域。如果当前作用域中没有 JavaScript 正在寻找的声明，搜索将顺序扩展到外部作用域。在我们的示例中，`stepsToLearnJavaScript`
    函数中没有 `isReading` 变量的声明，因此搜索移向外部作用域，而在本例中是 `learnJavaScript` 函数的局部作用域。这个作用域中也不存在该声明；JavaScript
    继续向外部作用域遍历，当前外部作用域是全局作用域。
- en: In the code example above, the variable declaration is found in the global scope,
    so the search for the variable declaration will be stopped when the search reaches
    the global scope. But what will happen if we remove the variable declaration from
    the above code example?
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上面的代码示例中，变量声明是在全局作用域中找到的，因此当搜索达到全局作用域时，变量声明的搜索将被停止。但是如果我们从上述代码示例中删除变量声明，会发生什么呢？
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here’s a Replit of the code above:'
  id: totrans-29
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是上面代码的 Replit：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/Example4”>`'
  id: totrans-30
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/Example4”>`'
- en: 'Now, the `stepsToLearnJavaScript` function is logging an undeclared variable.
    Now, what will happen when the search for the variable declaration reaches the
    global scope? At this point, JavaScript will do one of the following two things:'
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在，`stepsToLearnJavaScript` 函数正在记录一个未声明的变量。那么，当搜索变量声明达到全局作用域时，会发生什么呢？此时，JavaScript
    将执行以下两件事之一：
- en: throw an error if the code is in strict mode
  id: totrans-32
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果代码在严格模式下，将抛出错误
- en: declare a global variable for you in non-strict mode (recall “implicit globals”
    in the scope module)
  id: totrans-33
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 在非严格模式下为您声明一个全局变量（回顾一下作用域模块中的“隐式全局”）
- en: How are different scopes linked?
  id: totrans-34
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 不同的作用域是如何链接的？
- en: At this point, we know how the scope is resolved, and the different scopes are
    linked together, forming a chain that is known as the “scope chain.” But have
    you wondered how different scopes are linked? It can’t be magic; some mechanism
    must link different scopes together. How does JavaScript determine the outer scope
    of the current scope?
  id: totrans-35
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 此时，我们知道作用域是如何解析的，不同的作用域是如何连接在一起的，形成了一个称为“作用域链”的链条。但你有没有想过不同的作用域是如何连接的？这不可能是魔法；一定有某种机制将不同的作用域连接在一起。JavaScript
    如何确定当前作用域的外部作用域？
- en: 'Let us revisit one of the code examples presented earlier in this lesson:'
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们回顾一下本课之前展示的代码示例：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s a Replit of the code above:'
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是上面代码的 Replit：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/Example5”>`'
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/Example5”>`'
- en: We know that when the `learnJavaScript` function is invoked, the local scope
    of this function is linked to the global scope, but how? The answer is the hidden
    internal slot named `[[[Environment]]]`(https://tc39.es/ecma262/#table-internal-slots-of-ecmascript-function-objects).
    This `[[Environment]]` internal slot exists on the functions, and it contains
    a reference to the outer scope/environment. In other words, this internal slot
    contains a reference to the scope on which the containing function has `closed
    over` or formed a “closure.”
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们知道，当 `learnJavaScript` 函数被调用时，这个函数的局部作用域与全局作用域是连接在一起的，但这是如何实现的呢？答案是一个名为 `[[[Environment]]]`
    的隐藏内部槽位（[https://tc39.es/ecma262/#table-internal-slots-of-ecmascript-function-objects](https://tc39.es/ecma262/#table-internal-slots-of-ecmascript-function-objects)）。这个
    `[[Environment]]` 内部槽位存在于函数中，并且包含对外部作用域/环境的引用。换句话说，这个内部槽位包含了包含函数“闭合”或形成“闭包”的作用域的引用。
- en: '`:::info`'
  id: totrans-41
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`:::info`'
- en: 'There are many [hidden internal slots](https://stackoverflow.com/questions/33075262/what-is-an-internal-slot-of-an-object-in-javascript)
    mentioned in the ECMAScript specification. The specification uses these hidden
    internal slots to define the required behavior. These hidden internal slots, just
    like abstract operations, may or may not be actual things that are implemented
    by the different JavaScript engines.  '
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '在 ECMAScript 规范中提到了许多 [隐藏内部槽](https://stackoverflow.com/questions/33075262/what-is-an-internal-slot-of-an-object-in-javascript)。规范利用这些隐藏内部槽来定义所需的行为。这些隐藏内部槽，和抽象操作一样，可能并不是由不同
    JavaScript 引擎实际实现的东西。  '
- en: ':::  '
  id: totrans-43
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: ':::  '
- en: 'In the code example above, when the `learnJavaScript` function is created,
    as it is created in the global scope, a reference to the global environment is
    saved in the internal `[[Environment]]` slot of the function object. Later, when
    the function is called, a new environment is created for the execution of the
    code inside the function. This environment (local scope of the function) is linked
    to the global environment by getting a value that is saved in the `[[Environment]]`
    slot of the `learnJavaScript` function and saving it in an internal slot named
    `[[[OuterEnv]]]`(https://tc39.es/ecma262/#sec-environment-records). Each environment
    object has an internal slot that contains a reference to the outer environment.  '
  id: totrans-44
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '在上面的代码示例中，当 `learnJavaScript` 函数被创建时，由于它是在全局作用域中创建的，因此对全局环境的引用被保存在函数对象的内部 `[[Environment]]`
    槽中。稍后，当函数被调用时，会为函数内部代码的执行创建一个新的环境。这个环境（函数的局部作用域）通过获取保存在 `learnJavaScript` 函数的
    `[[Environment]]` 槽中的值并将其保存在名为 `[[[OuterEnv]]]` 的内部槽中，从而与全局环境相链接（https://tc39.es/ecma262/#sec-environment-records）。每个环境对象都有一个内部槽，包含对外部环境的引用。  '
- en: 'The linkage of scopes in the above example can be conceptually visualized in
    the image below:  '
  id: totrans-45
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '上述示例中作用域的链接可以在下面的图像中概念性地可视化：  '
- en: '![scope linkage](images/missing.png)  '
  id: totrans-46
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![作用域链接](images/missing.png)'
- en: '`scope linkage`  '
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`作用域链接`  '
- en: 'Let’s revisit one of the earlier examples from this lesson that involved a
    nested function:  '
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '让我们回顾一下本课中涉及嵌套函数的早期示例：  '
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here’s a Replit of the code above:  '
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '这里是上面代码的 Replit：  '
- en: '<ReplitEmbed src=”https://replit.com/@newlineauthors/Example6”>  '
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '<ReplitEmbed src=”https://replit.com/@newlineauthors/Example6”>  '
- en: 'In this code example, we have three different environments:  '
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '在这个代码示例中，我们有三个不同的环境：  '
- en: 'The global environment  '
  id: totrans-53
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '全球环境  '
- en: 'The local environment of the `learnJavaScript` function (created when the function
    is invoked)  '
  id: totrans-54
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`learnJavaScript` 函数的局部环境（在函数被调用时创建）  '
- en: 'The local environment of the `stepsToLearnJavaScript` function (created when
    the function is invoked)  '
  id: totrans-55
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`stepsToLearnJavaScript` 函数的局部环境（在函数被调用时创建）  '
- en: 'The linkage between different scopes can be visualized in the image below:  '
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '不同作用域之间的链接可以在下面的图像中可视化：  '
- en: '![scope linkage](images/module_05----lesson_05.01----public----assets----closure-scope-linkage-2.png)  '
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![作用域链接](images/module_05----lesson_05.01----public----assets----closure-scope-linkage-2.png)  '
- en: '`scope linkage`  '
  id: totrans-58
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`作用域链接`  '
- en: Hopefully, the above two code examples and images have clarified how different
    scopes are linked together, forming a scope chain. This scope chain is traversed
    by the JavaScript engine, if needed, to resolve the scope of any identifier.
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '希望以上两个代码示例和图像能够阐明不同作用域是如何链接在一起，形成作用域链的。这个作用域链在需要时由 JavaScript 引擎遍历，以解析任何标识符的作用域。  '
- en: 'This linkage between different environments, i.e., the scope chain, is what
    makes closures possible in JavaScript. Due to this scope chain, a nested function
    can still access variables from the outer function even after the execution of
    the outer function has ended. This outer environment is kept in memory as long
    as the inner function has a reference to it.  '
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '这种不同环境之间的链接，即作用域链，使得 JavaScript 中的闭包成为可能。由于这个作用域链，嵌套函数即使在外部函数执行结束后，仍然可以访问外部函数的变量。只要内部函数有对外部环境的引用，外部环境就会保留在内存中。  '
- en: 'Now, let us revisit the first code example in this lesson, which involves invoking
    a nested function from a different scope than the one it is defined in.  '
  id: totrans-61
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '现在，让我们回顾一下本课中的第一个代码示例，该示例涉及从与定义该嵌套函数不同的作用域中调用嵌套函数。  '
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s a Replit of the code above:  '
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '这里是上面代码的 Replit：  '
- en: '<ReplitEmbed src=”https://replit.com/@newlineauthors/Example7”>  '
  id: totrans-64
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '<ReplitEmbed src=”https://replit.com/@newlineauthors/Example7”>  '
- en: 'Hopefully, you can now explain how the nested function has access to the `outerVar`
    variable, even after the completion of the `outerFn` execution.  '
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '希望你现在能够解释为什么嵌套函数在 `outerFn` 执行完成后仍然能够访问 `outerVar` 变量。  '
- en: The `inner` function has a reference to the local scope of the `outerFn` function,
    saved in its `[[Environment]]` internal slot. When the `inner` function is returned
    from the `outerFn` function, although the `outerFn` execution has ended, the `inner`
    function still has a reference to the local scope of the `outerFn`. When the `inner`
    function is invoked, the value of the `[[Environment]]` slot of the `inner` function
    is saved in the `[[OuterEnv]]` internal slot of the environment created for the
    execution of the `inner` function.
  id: totrans-66
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`inner`函数对`outerFn`函数的局部作用域有一个引用，保存在其`[[Environment]]`内部槽中。当从`outerFn`函数返回`inner`函数时，尽管`outerFn`的执行已经结束，`inner`函数仍然保留对`outerFn`局部作用域的引用。当调用`inner`函数时，`inner`函数的`[[Environment]]`槽的值会保存在为执行`inner`函数创建的环境的`[[OuterEnv]]`内部槽中。'
- en: To summarize, every time a JavaScript function is created, a closure is formed,
    which allows that function to access the scope chain that was in effect when that
    function was defined. Each time a function is created, JavaScript saves the reference
    to the surrounding environment of the function in the internal `[[Environment]]`
    slot on the function object. When that function is called, a new environment is
    created for that function call, and JavaScript saves the value of `[[Environment]]`
    slot on the function in the `[[OuterEnv]]` slot of the environment object.
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 总结来说，每当创建一个JavaScript函数时，都会形成一个闭包，这使得该函数可以访问在其定义时有效的作用域链。每次创建函数时，JavaScript都会在函数对象的内部`[[Environment]]`槽中保存对函数周围环境的引用。当调用该函数时，会为该函数调用创建一个新的环境，并且JavaScript会将函数的`[[Environment]]`槽的值保存在环境对象的`[[OuterEnv]]`槽中。
- en: It is a common misconception among beginners that closures are only formed when
    any function returns a nested function. But that is not the case.
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 初学者常常误以为闭包仅在任何函数返回嵌套函数时才会形成，但事实并非如此。
- en: Every time a function is created in JavaScript, it forms a closure over the
    environment in which that function was created. Forming a closure is a fancy way
    of saying that when a function is created, it saves a reference to the environment
    in which it was created.
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 每次在JavaScript中创建函数时，它都会在创建该函数时形成对环境的闭包。形成闭包是指当函数被创建时，它保存了对创建时环境的引用。
- en: 'What is the cause of this misconception? It is because of the following two
    reasons:'
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这种误解的原因是什么？主要有以下两个原因：
- en: Many online resources introduce the concept of closures with code examples containing
    a function that returns a nested function.
  id: totrans-71
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 许多在线资源通过包含返回嵌套函数的函数的代码示例来介绍闭包的概念。
- en: Closures are only noticeable when a function is invoked from a different scope
    than the one it is defined in.
  id: totrans-72
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 只有当函数从与其定义不同的作用域中调用时，闭包才会显而易见。
- en: Most functions are usually invoked from the same scope in which they are defined.
    This makes the closures go unnoticed. It is only when a function is invoked from
    a different scope than the one it is defined in that closures become noticeable.
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 大多数函数通常是在其定义的相同作用域中被调用的。这使得闭包不易察觉。只有当函数从与其定义不同的作用域中被调用时，闭包才会变得显而易见。
- en: In the following code example, a function is defined and invoked from the global
    scope, so a closure formed by the function is unnoticeable.
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，从全局作用域定义并调用了一个函数，因此由该函数形成的闭包不易察觉。
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can see the code above in this `Replit`:'
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在这个`Replit`中看到上面的代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/closure-misconception-example1”>`'
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/closure-misconception-example1">`'
- en: Unlike the code example above, in the following code example, closure is noticeable
    as the nested `greet` function has access to the `greetMsg` parameter of the containing
    `createGreeting` function even after the completion of the `createGreeting` function.
    The closure is noticeable because the `greet` function is invoked from a different
    scope than the one it is defined in. The `greet` function is defined in the local
    scope of the `createGreeting` function, but it is invoked from the global scope.
  id: totrans-78
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与上面的代码示例不同，在下面的代码示例中，闭包是显而易见的，因为嵌套的`greet`函数在`createGreeting`函数完成后仍然可以访问其`greetMsg`参数。闭包之所以明显，是因为`greet`函数是从与其定义不同的作用域中调用的。`greet`函数在`createGreeting`函数的局部作用域中定义，但它是从全局作用域中调用的。
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here’s a `Replit` of the code above:'
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是上面代码的一个`Replit`：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/closure-misconception-example2”>`'
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/closure-misconception-example2">`'
- en: What output do you expect from the following code example?
  id: totrans-82
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You might expect the following output:'
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Although the above output seems reasonable, it is not the output we get from
    the code example above. The actual output is as shown below:'
  id: totrans-86
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is the output of the code example above in a `Replit`:'
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/closures-in-loops-example1”>`'
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: If this output surprised you, then this lesson is for you. Even if it didn’t,
    do you understand the reasons behind this output? In this lesson, we will explore
    what causes this problem, also known as the “`closures in loop`” problem, and
    how we can fix it.
  id: totrans-90
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: What causes this problem?
  id: totrans-91
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: The code example above suffers from this infamous “`closures in loop`” problem
    because the callback function of each `setTimeout` forms a closure over the `same`
    variable `i`。As there are a total of three loop iterations in our example, `setTimeout`
    is called three times, so we have three callback functions, all having a closure
    over the `same` variable `i`。
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The callback function of each `setTimeout` call is invoked `after` the loop
    execution has completed. The value of variable `i` after the last iteration of
    the loop is “`4`”，and because each callback function of the “`setTimeout`” has
    a closure over the `same` variable `i`，all three of them see “`4`” as the value
    of the `i`。This is the reason they all log “`4`” on the console.
  id: totrans-93
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The scope linkage for the code example above can be visualized in the image
    below:'
  id: totrans-94
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '![scope linkage](images/module_05----lesson_05.03----public----assets----closure-in-loop-problem.png)'
  id: totrans-95
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: scope linkage
  id: totrans-96
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: It is important to note that functions form closures over variables, not their
    values. Closure over variables implies that each function logs the `latest` value
    of the variable it has closed over; if functions formed closure over values rather
    than variables, they would log the snapshot of the value in effect when the closure
    was formed.
  id: totrans-97
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In our example, if the closure was over the values of `i` instead of the `i`
    variable, then each callback would have logged the value of `i` that was in effect
    in the iteration in which that callback was created. This means we would have
    gotten the expected output, i.e., `1 2 3` instead of `4 4 4`。But as is evident
    from the output of the code example, closures are formed over variables. As a
    result, each callback function of `setTimeout` has a closure over the variable
    `i`，and when each callback is executed, it sees the latest value of `i`。
  id: totrans-98
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: How to resolve this problem?
  id: totrans-99
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: Now that we understand what the “`closures in loop`” problem is and what causes
    it, let us discuss how this problem was tackled before `ES2015`。
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Pre-`ES2015` solution
  id: totrans-101
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: Before the introduction of `ES2015`，also known as `ES6`，one way to solve this
    problem was to use an [`IIFE (Immediately Invoked Function Expression)`](https://developer.mozilla.org/en-US/docs/Glossary/IIFE)。The
    following code example shows how using an `IIFE` resolves this problem.
  id: totrans-102
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 这是上述代码示例在Replit中的输出：
  id: totrans-104
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/closures-in-loops-example2">`'
  id: totrans-105
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 使用IIFE如何解决这个问题？
  id: totrans-106
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 回想一下，问题是由于不同回调对*同一个*变量的闭包造成的。但通过使用IIFE，我们可以在每次迭代中将`i`的值作为参数传递给IIFE。这个参数（`counter`）随后在`setTimeout`函数的回调函数中使用。这解决了问题，因为`counter`参数被每个回调函数闭包所封闭，并且在每次迭代中都会创建一个新的IIFE，以及新的`setTimeout`回调函数。每个IIFE的新实例都会传递一个新的`i`值，即在第一次迭代中为“1”，第二次迭代中为“2”，依此类推。因此，现在，通过使用IIFE，每个回调函数都有一个不同的`counter`变量的闭包。
  id: totrans-107
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 下面的图片帮助可视化上述代码示例中的作用域链（为了简单起见，函数对象未在下面的图片中显示）：
  id: totrans-108
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '![scope linkage](images/module_05----lesson_05.03----public----assets----closure-problem-pre-es6-solution.png)'
  id: totrans-109
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: '`scope linkage`'
  id: totrans-110
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 尽管`setTimeout`函数的回调日志记录了`counter`变量，但它们仍然可以访问`i`变量。如果我们同时记录`counter`和`i`会怎样？输出会如何变化？
  id: totrans-111
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 以上代码示例的输出可以在下面的Replit中查看：
  id: totrans-113
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/closures-in-loops-example3">`'
  id: totrans-114
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 每个回调都对*不同*实例的`counter`变量有一个闭包，但它们仍然共享来自全局作用域的*同一个*变量`i`。结果，它们记录了`i`的最新值，即“4”。
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`ES2015 solution`'
  id: totrans-116
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: ES2015引入了块级作用域的变量和常量，分别使用`let`和`const`关键字。我们可以通过将原始代码示例中的`var`关键字替换为`let`关键字，简单地解决“循环中的闭包”问题。
  id: totrans-117
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 这是上述代码示例在Replit中的输出：
  id: totrans-119
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/closures-in-loops-example4">`'
  id: totrans-120
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 使用`let`关键字解决了这个问题，因为与每个回调函数闭包于*同一个*变量`i`不同，`let`是块级作用域，导致每次循环迭代都有一个*不同*的`i`变量副本。这是解决“循环中的闭包”问题的关键思路。每次迭代都有自己的*独立*副本的`i`变量，这意味着在每次迭代中创建的`setTimeout`回调闭包于那个特定迭代的`i`变量副本。
  id: totrans-121
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在我们的代码示例中，我们有三次循环迭代和`i`变量的独立副本，每个副本仅限于特定的循环迭代。尽管看似我们只有一个`i`变量，但在幕后，每次迭代都有自己的`i`变量副本。
  id: totrans-122
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'To understand how each iteration gets its own copy of variable `i`，the following
    steps explain how the above code is executed:'
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Before the execution of the `for` loop starts，an environment object (let’s call
    it `initEnv`) is created，and it contains the variables declared in the initialization
    part of the `for` loop. In our case，we have only one variable，`i`，so the `initEnv`
    environment object contains a copy of variable `i`。This environment object is
    linked to the outer environment by saving a reference to the outer environment
    in the `[[OuterEnv]]` internal slot. The outer environment，in this case，is the
    global environment.
  id: totrans-124
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: To start the first iteration of the `for` loop，a new environment object is created
    (let’s call it `iter1Env`). This environment object also gets the global environment
    as its outer environment. The variable `i` is copied into this newly created `iter1Env`
    object by copying it from the `initEnv` object (created in step 1).
  id: totrans-125
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: The loop condition `i <= 3` is `true`，so the body of the loop is executed as
    part of the first iteration of the loop. The callback function for the `setTimeout`
    is created，saving a reference to the environment object of the first loop iteration
    `iter1Env` (created in step 2) in the internal `[[Environment]]` slot of the callback
    function. After that，the callback function is passed to the `setTimeout` function
    as an argument to be executed later.
  id: totrans-126
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: 'The first iteration has been completed. The following image shows the linkage
    between different environments created so far:'
  id: totrans-127
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '![`closue` in loop - iteration 1](images/module_05----lesson_05.03----public----assets----closure-loop-iter-1.png)'
  id: totrans-128
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_IMG
- en: '`closue` in loop - iteration 1'
  id: totrans-129
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: Now，to start the second iteration，a new environment object is created (let’s
    call it `iter2Env`). The variable `i` is copied from the `initEnv` environment
    object (created in step 1)，but the value of `i` in `iter2Env` is the value of
    `i` in `iter1Env` (created in step 2). The value of `i` in `iter2Env` is then
    incremented due to the increment part (`i++`) of the `for` loop.
  id: totrans-130
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: As in the previous iteration，a new callback function is created，and the reference
    to the `iter2Env` is saved in its `[[Environment]]` internal slot. The callback
    function is then passed to the `setTimeout` function as an argument.
  id: totrans-131
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: This process is repeated for the third and final iteration of the loop.
  id: totrans-132
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: 'The following diagram shows how different environments are linked together
    after three iterations of the loop:'
  id: totrans-133
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '![`closue` in loop - all iterations](images/module_05----lesson_05.03----public----assets----closure-loop-iter.png)'
  id: totrans-134
  prefs: []
  stylish: true
  type: TYPE_IMG
- en: '`closue` in loop - all iterations'
  id: totrans-135
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Hopefully, the final diagram clarifies why using the `let` keyword solves the
    “closures in loop” problem. As each environment object created for each iteration
    of the loop has its `separate` copy of the variable `i`, the closure of each callback
    created in different iterations of the loop forms a closure over a separate copy
    of the variable `i`. As a result, they log the value they have closed over, giving
    us the expected output, i.e., `1 2 3` .
  id: totrans-136
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: With the recent additions to the JavaScript language, it is now possible to
    have [private fields and methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields)
    in JavaScript. However, before these changes were introduced in the language,
    closures were the go-to option for hiding data from public access. In object-oriented
    programming terminology, this is referred to as “data hiding” and “encapsulation”.
  id: totrans-137
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Following is an example of how we can have private variables and methods using
    closures:'
  id: totrans-138
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code inside the`IIFE` is executed, and an object is returned from the`IIFE`
    that is assigned to the `bank` variable. The object returned only contains the
    data that needs to be accessible from outside the`IIFE` . The code that is meant
    to be private is not returned; as a result, that data remains private, limited
    to the boundary walls of the`IIFE` . However, thanks to closures, publicly exposed
    data that is returned from the`IIFE` can still access the private data inside
    the`IIFE` .
  id: totrans-140
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-141
  prefs:
  - PREF_H5
  stylish: true
  type: TYPE_NORMAL
- en: '[Emulating private methods with closures - (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#emulating_private_methods_with_closures)'
  id: totrans-142
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
