- en: '`Asynchronous JavaScript`'
  id: totrans-0
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`异步 JavaScript`'
- en: 在本模块中，我们将涵盖`JavaScript`中的异步编程。我们将学习异步编程意味着什么，以及在`JavaScript`中传统上是如何做到的。我们还将讨论传统处理异步代码的方法存在的问题，以及`ES2015`中引入的承诺如何改变我们处理异步代码的方式。我们将详细讨论承诺，并学习简化使用承诺的`async-await`语法。
  id: totrans-1
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在本模块中，我们将涵盖`JavaScript`中的异步编程。我们将学习异步编程意味着什么，以及在`JavaScript`中传统上是如何做到的。我们还将讨论传统处理异步代码的方法存在的问题，以及`ES2015`中引入的承诺如何改变我们处理异步代码的方式。我们将详细讨论承诺，并学习简化使用承诺的`async-await`语法。
- en: 异步是什么意思？
  id: totrans-2
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 异步是什么意思？
- en: 在编程的上下文中，“异步”意味着程序启动一个潜在的长时间运行任务，并可以在该任务在后台执行时自由进行其他任务。关键点在于，程序不必等待长时间运行的任务完成；它可以自由执行其他任务。一旦任务完成，程序将收到通知并呈现任务的结果。
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在编程的上下文中，“异步”意味着程序启动一个潜在的长时间运行任务，并可以在该任务在后台执行时自由进行其他任务。关键点在于，程序不必等待长时间运行的任务完成；它可以自由执行其他任务。一旦任务完成，程序将收到通知并呈现任务的结果。
- en: 由于传统同步编程存在的问题，因此需要异步编程。在同步程序中，每条指令都是按顺序一个接一个地执行的。指令按程序中出现的顺序执行。因此，同步程序更容易推理，但它们也存在异步编程所解决的问题。
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 由于传统同步编程存在的问题，因此需要异步编程。在同步程序中，每条指令都是按顺序一个接一个地执行的。指令按程序中出现的顺序执行。因此，同步程序更容易推理，但它们也存在异步编程所解决的问题。
- en: 同步程序的问题在于，一个潜在的长时间运行任务会阻塞程序的执行，直到其完成。这会导致性能差、用户体验差以及资源利用效率低等问题。
  id: totrans-5
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 同步程序的问题在于，一个潜在的长时间运行任务会阻塞程序的执行，直到其完成。这会导致性能差、用户体验差以及资源利用效率低等问题。
- en: 尽管异步程序解决了同步程序所呈现的问题，但异步程序也带来了自己的一系列挑战，如错误处理、管理共享状态和资源、协调程序不同部分之间的关系等。
  id: totrans-6
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 尽管异步程序解决了同步程序所呈现的问题，但异步程序也带来了自己的一系列挑战，如错误处理、管理共享状态和资源、协调程序不同部分之间的关系等。
- en: '`Asynchronous JavaScript`'
  id: totrans-7
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`异步 JavaScript`'
- en: 在我们深入探讨如何在`JavaScript`中编写异步代码以及它如何在幕后处理之前，让我们先退一步，看看如果我们执行一些长时间运行的代码（如以下示例中的循环），我们在`JavaScript`中面临的问题。
  id: totrans-8
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在我们深入探讨如何在`JavaScript`中编写异步代码以及它如何在幕后处理之前，让我们先退一步，看看如果我们执行一些长时间运行的代码（如以下示例中的循环），我们在`JavaScript`中面临的问题。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 你可以在这个`Replit`中查看上面的代码：
  id: totrans-10
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在这个`Replit`中查看上面的代码：
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/overview-example1">`'
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/overview-example1">`'
- en: '`JavaScript`是一种单线程语言，这有其优缺点。`JavaScript`开发者通常不必担心多线程程序所带来的问题，比如[`race conditions`](https://stackoverflow.com/questions/34510/what-is-a-race-condition)和[`deadlocks`](https://stackoverflow.com/questions/34512/what-is-a-deadlock)。然而，单线程的限制在上面的代码示例中显而易见。'
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`JavaScript`是一种单线程语言，这有其优缺点。`JavaScript`开发者通常不必担心多线程程序所带来的问题，比如[`竞争条件`](https://stackoverflow.com/questions/34510/what-is-a-race-condition)和[`死锁`](https://stackoverflow.com/questions/34512/what-is-a-deadlock)。然而，单线程的限制在上面的代码示例中显而易见。'
- en: 上面的代码示例旨在模拟一些大约需要3秒钟才能完成的长时间运行的代码。在这3秒钟内，执行我们JavaScript代码的主线程被阻塞；在这3秒钟内没有其他代码执行。如果这段JavaScript代码附加到HTML文件并在浏览器中执行，UI将冻结，直到循环结束。
  id: totrans-13
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上面的代码示例旨在模拟一些大约需要3秒钟才能完成的长时间运行的代码。在这3秒钟内，执行我们JavaScript代码的主线程被阻塞；在这3秒钟内没有其他代码执行。如果这段JavaScript代码附加到HTML文件并在浏览器中执行，UI将冻结，直到循环结束。
- en: 要查看冻结的UI效果，可以尝试将上述JavaScript代码添加到一个名为`index.js`的文件中，并将其附加到包含以下HTML的HTML文件中：
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 要查看冻结的UI效果，可以尝试将上述JavaScript代码添加到一个名为`index.js`的文件中，并将其附加到包含以下HTML的HTML文件中：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 您可以在这个Replit中看到上面的代码：
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 您可以在这个Replit中看到上面的代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/overview-example2”>`'
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/overview-example2">`'
- en: 在初始页面加载时，您会注意到按钮在几秒钟内不可点击。UI会保持冻结，直到JavaScript代码执行完成，特别是长时间运行的循环。
  id: totrans-18
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在初始页面加载时，您会注意到按钮在几秒钟内不可点击。UI会保持冻结，直到JavaScript代码执行完成，特别是长时间运行的循环。
- en: 这在Web应用程序中提供了糟糕的用户体验。单线程对我们在主线程中使用JavaScript所能做的施加了严格的限制。
  id: totrans-19
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这在Web应用程序中提供了糟糕的用户体验。单线程对我们在主线程中使用JavaScript所能做的施加了严格的限制。
- en: 现在，JavaScript引擎足够强大，能够以非常好的速度执行代码；引擎旨在高度优化JavaScript代码，以尽可能高效地执行它。不过，仍然需要注意，主线程不应被任何可能需要很长时间才能使延迟变得明显的代码阻塞。
  id: totrans-20
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在，JavaScript引擎足够强大，能够以非常好的速度执行代码；引擎旨在高度优化JavaScript代码，以尽可能高效地执行它。不过，仍然需要注意，主线程不应被任何可能需要很长时间才能使延迟变得明显的代码阻塞。
- en: :::info
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: :::info
- en: JavaScript还允许我们在另一个线程中执行一些代码，与主线程独立，使用`[web workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)`。
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: JavaScript还允许我们在另一个线程中执行一些代码，与主线程独立，使用`[网络工作者](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)`。
- en: '::::'
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '::::'
- en: 接下来，让我们讨论使用回调编写异步代码的传统方式。我们还将讨论使用回调时的问题。
  id: totrans-24
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论使用回调编写异步代码的传统方式。我们还将讨论使用回调时的问题。
- en: 使用回调函数处理异步代码一直是JavaScript中编写异步代码的传统方式。回调函数是作为参数传递给另一个函数的函数，旨在在某个异步操作完成后调用。接收回调函数作为参数的函数通常会使用异步操作的结果或在异步操作失败时的错误来调用回调函数。
  id: totrans-25
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用回调函数处理异步代码一直是JavaScript中编写异步代码的传统方式。回调函数是作为参数传递给另一个函数的函数，旨在在某个异步操作完成后调用。接收回调函数作为参数的函数通常会使用异步操作的结果或在异步操作失败时的错误来调用回调函数。
- en: 类似HTTP请求的操作是异步的，但它们并不是由JavaScript处理的。我们编写的代码启动异步操作；在客户端JavaScript的情况下，实际的异步操作由浏览器处理，而在NodeJS运行时的情况下，则由后台线程或操作系统本身处理。
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 类似HTTP请求的操作是异步的，但它们并不是由JavaScript处理的。我们编写的代码启动异步操作；在客户端JavaScript的情况下，实际的异步操作由浏览器处理，而在NodeJS运行时的情况下，则由后台线程或操作系统本身处理。
- en: 简单来说，异步操作在后台（JavaScript领域之外）进行，而与此同时，其他事情可以在主线程（JavaScript领域）中执行。
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 简单来说，异步操作在后台（JavaScript领域之外）进行，而与此同时，其他事情可以在主线程（JavaScript领域）中执行。
- en: 当异步操作完成时，我们的JavaScript代码会收到通知，导致执行我们在启动异步操作时提供的回调函数。
  id: totrans-28
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当异步操作完成时，我们的JavaScript代码会收到通知，导致执行我们在启动异步操作时提供的回调函数。
- en: This is how JavaScript gets around its limitation of a single thread. The asynchronous
    operations are actually handled by the runtime (`browser`, `NodeJS`, etc.). In
    the meantime, JavaScript can do other things.
  id: totrans-29
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这就是JavaScript如何绕过单线程限制的方式。异步操作实际上是由运行时（`浏览器`、`NodeJS`等）处理的。与此同时，JavaScript可以做其他事情。
- en: 'The following code example shows the use of a callback function by sending
    an HTTP request to a fake REST API:'
  id: totrans-30
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下代码示例展示了通过发送HTTP请求到一个假REST API来使用回调函数：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can run the code above in the Replit below:'
  id: totrans-32
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 您可以在下面的Replit中运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/callbacks-example1” />`'
  id: totrans-33
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/callbacks-example1" />`'
- en: A callback function passed to the `addEventListener` method handles the result
    of the HTTP request.
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 传递给`addEventListener`方法的回调函数处理HTTP请求的结果。
- en: Different DOM events, for example, the click event, are also handled asynchronously
    using the callback functions. A callback is registered as an event handler and
    is invoked later whenever the event is triggered.
  id: totrans-35
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 不同的DOM事件，例如点击事件，也使用回调函数异步处理。回调作为事件处理程序注册，并在事件触发时稍后调用。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Similarly, different timer functions like `setTimeout` are also provided with
    a callback function that is intended to be invoked after the specified amount
    of time has elapsed.
  id: totrans-37
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 同样，不同的定时器函数如 `setTimeout` 也提供了一个回调函数，旨在在指定时间过后被调用。
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can run the code above in the Replit below:'
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的 Replit 中运行上面的代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/callbacks-example3” />`'
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/callbacks-example3” />`'
- en: There is a common misconception that the callback provided to `setTimeout` is
    invoked exactly after the specified amount of time has passed. The time we specify
    when invoking `setTimeout` is the `minimum` amount of time after which the provided
    callback will be invoked.
  id: totrans-41
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个常见的误解是提供给 `setTimeout` 的回调函数会在指定的时间过后立即被调用。我们在调用 `setTimeout` 时指定的时间是调用提供的回调函数后**最少**需要的时间。
- en: 'In the code example provided above, we have specified 2 seconds (`2000` milliseconds)
    as the time after which the callback should be invoked. But the callback will
    not be invoked exactly after 2 seconds. Imagine a scenario where we also have
    a long-running loop that takes approximately 4 seconds to run. As we discussed
    in the previous lesson, JavaScript is single-threaded, so a long-running loop
    will block the main thread, which means that the callback function provided to
    `setTimeout` cannot be executed until the loop ends. The following code example
    demonstrates this scenario:'
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上面的代码示例中，我们指定了 2 秒（`2000` 毫秒）作为回调函数应该被调用的时间。但是，回调函数不会在正好 2 秒后被调用。想象一下，如果我们还有一个运行时间较长的循环，约需
    4 秒才能完成。正如我们在上一课中讨论的，JavaScript 是单线程的，因此一个长时间运行的循环会阻塞主线程，这意味着提供给 `setTimeout`
    的回调函数在循环结束之前无法执行。以下代码示例演示了这种情况：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can run the code above in the Replit below:'
  id: totrans-44
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的 Replit 中运行上面的代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/callbacks-example4” />`'
  id: totrans-45
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/callbacks-example4” />`'
- en: The above code example shows that the `setTimeout` callback or the callback
    provided to the `setInterval` function may not be invoked after the specified
    time has passed; some other code can block them from being invoked after the specified
    time.
  id: totrans-46
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上面的代码示例显示 `setTimeout` 的回调或提供给 `setInterval` 函数的回调可能不会在指定时间后被调用；其他代码可能会阻塞它们的调用。
- en: JavaScript is single-threaded; only one thing can execute at a time on the main
    thread. Currently, executing code cannot be interrupted to execute some other
    code, like the callback function of `setTimeout` in the code example above.
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: JavaScript 是单线程的；主线程一次只能执行一件事。目前，正在执行的代码无法中断以执行其他代码，比如上面代码示例中的 `setTimeout`
    的回调函数。
- en: The callback functions are at the heart of asynchronous code in JavaScript.
    Using callbacks works, but they also come with problems.
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 回调函数是 JavaScript 中异步代码的核心。使用回调函数是可行的，但也带来了一些问题。
- en: Problems with callbacks
  id: totrans-49
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 回调函数的问题
- en: Using the traditional way of using callbacks to handle asynchronous code presents
    multiple problems that make it hard to use callbacks effectively.
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用传统的回调方法处理异步代码会出现多种问题，使得有效使用回调变得困难。
- en: Callback hell
  id: totrans-51
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 回调地狱
- en: 'Imagine a scenario where multiple asynchronous operations need to start sequentially
    because each operation depends on the result of the previous operation. To handle
    such a scenario, we have to nest callbacks, which, depending on the number of
    asynchronous operations, can lead to code that is hard to read and maintain. The
    following code example shows this in action:'
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 想象一下，如果多个异步操作需要按顺序启动，因为每个操作依赖于上一个操作的结果。为了解决这种情况，我们必须嵌套回调，这根据异步操作的数量，可能导致代码难以阅读和维护。以下代码示例展示了这一点：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is what’s referred to as the `Callback Hell` or the `Pyramid of Doom` because
    the nesting at each level creates a structure that looks like a pyramid.
  id: totrans-54
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这被称为 `回调地狱` 或 `厄运金字塔`，因为每一层的嵌套创建了一个看起来像金字塔的结构。
- en: 'Looking at the code example above, it is not hard to imagine that it will get
    harder to read as more operations are added to the sequence of asynchronous operations.
    Not only is it hard to read, but it is also hard to maintain and refactor. Note
    that the code example above does not include any error handling; add that to the
    code above, and you will have the following:'
  id: totrans-55
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 看上面的代码示例，很容易想象，随着更多操作被添加到异步操作序列中，代码会变得越来越难以阅读。不仅难以阅读，而且难以维护和重构。请注意，上面的代码示例不包括任何错误处理；将其添加到上面的代码中，你将得到以下结果：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code above fits its name: “`Callback Hell`”. No one wants to deal with
    such a code. It is hard to reason about. We will see in later lessons in this
    module how the same code can be rewritten using `promises` and `async-await` syntax
    to make it more readable and maintainable.'
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上述代码符合其名称：“`Callback Hell`”。没有人愿意处理这样的代码。很难推理。在本模块的后续课程中，我们将看到如何使用`promises`和`async-await`语法重写相同的代码，使其更易读和易维护。
- en: Error handling
  id: totrans-58
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 错误处理
- en: Writing error handling code using callbacks, as shown above, is not a pleasant
    experience. As shown in the code above, we need to handle errors in each callback,
    which can lead to duplication of error handling logic. There is no central place
    where we can catch and handle errors for all the asynchronous operations.
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用回调编写错误处理代码，如上所示，体验并不愉快。如上代码所示，我们需要在每个回调中处理错误，这可能导致错误处理逻辑的重复。没有一个中央地方可以捕获和处理所有异步操作的错误。
- en: In this lesson, we discussed how callbacks are used to write asynchronous code
    in JavaScript. Though there are better alternatives like `promises` and `async-await`
    that solve the problems with callbacks discussed above, callbacks are still commonly
    used. Although `promises` solve the problems with callbacks, they still use callbacks,
    but in a more manageable way that helps us avoid the `callback hell`.
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在本课程中，我们讨论了如何使用回调在JavaScript中编写异步代码。尽管有更好的替代方法，如`promises`和`async-await`来解决上述回调的问题，但回调仍然普遍使用。尽管`promises`解决了回调的问题，但它们仍然使用回调，但以一种更可管理的方式，帮助我们避免“回调地狱”。
- en: As we know already, the JavaScript language is single-threaded. Long-running
    code on the main thread can block the thread; in the case of browsers, blocking
    the main thread means that browsers cannot respond to user interactions and cannot
    render changes on the UI. This is why the screen freezes when some long-running
    code blocks the main thread. In the case of `NodeJs`, in the context of application
    servers, blocking the main thread means that the server cannot handle the incoming
    `HTTP` requests until the main thread is unblocked.
  id: totrans-61
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们已经知道，JavaScript语言是单线程的。在主线程上运行时间长的代码可以阻塞线程；在浏览器的情况下，阻塞主线程意味着浏览器无法响应用户交互，并且无法渲染UI的更改。这就是为什么当某些长时间运行的代码阻塞主线程时屏幕会冻结。在`NodeJs`的情况下，在应用服务器的上下文中，阻塞主线程意味着服务器无法处理进入的`HTTP`请求，直到主线程解除阻塞。
- en: To get around the limitation of a single thread where JavaScript code executes,
    as discussed in the previous lesson, any asynchronous operation is handled in
    the background, and in the meantime, the main thread can do other things.
  id: totrans-62
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 要解决JavaScript代码执行的单线程限制，在上一课程中已经讨论过，任何异步操作都在后台处理，与此同时，主线程可以做其他事情。
- en: 像`HTTP`请求这样的异步操作由浏览器在后台处理，当`HTTP`请求完成时，我们的`JavaScript`代码会使用我们在开始`HTTP`请求时提供的回调执行。同样，其他异步操作（如`NodeJS`中的文件处理）也是如此。每个`NodeJS`中的异步操作都由`NodeJS`的内部线程池或操作系统本身处理。
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 像`HTTP`请求这样的异步操作由浏览器在后台处理，当`HTTP`请求完成时，我们的`JavaScript`代码会使用我们在开始`HTTP`请求时提供的回调执行。同样，其他异步操作（如`NodeJS`中的文件处理）也是如此。每个`NodeJS`中的异步操作都由`NodeJS`的内部线程池或操作系统本身处理。
- en: 如果我们将主线程视为“JavaScript世界”，那么异步操作实际上发生在JavaScript世界之外。一旦操作完成，要重新回到JavaScript世界，就需要使用回调，这些回调被调用以执行`JavaScript`代码，以响应操作成功完成或失败。
  id: totrans-64
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果我们将主线程视为“JavaScript世界”，那么异步操作实际上发生在JavaScript世界之外。一旦操作完成，要重新回到JavaScript世界，就需要使用回调，这些回调被调用以执行`JavaScript`代码，以响应操作成功完成或失败。
- en: 简而言之，我们编写的代码在主线程上执行，仅仅是启动异步操作。主线程不需要等待操作完成，而是可以自由地做其他事情。异步操作在执行我们`JavaScript`代码的环境的后台中处理。这个环境可以是浏览器或像`NodeJS`这样的运行时。但是，如何将执行从后台带回到执行我们代码的主线程呢？这就是`event
    loop`进入画面的地方。
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 简而言之，我们编写的代码在主线程上执行，仅仅是启动异步操作。主线程不需要等待操作完成，而是可以自由地做其他事情。异步操作在执行我们`JavaScript`代码的环境的后台中处理。这个环境可以是浏览器或像`NodeJS`这样的运行时。但是，如何将执行从后台带回到执行我们代码的主线程呢？这就是`event
    loop`进入画面的地方。
- en: 什么是事件循环？
  id: totrans-66
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 什么是事件循环？
- en: '`JavaScript`中的事件循环是一个抽象概念，旨在使其他人更容易理解。本课将旨在创建对事件循环的扎实理解。'
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`JavaScript`中的事件循环是一个抽象概念，旨在使其他人更容易理解。本课将旨在创建对事件循环的扎实理解。'
- en: 事件循环帮助以非阻塞的方式执行异步操作。当后台中的异步操作完成以执行我们在启动异步操作时提供的`JavaScript`回调时，需要将其推入调用堆栈。
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 事件循环帮助以非阻塞的方式执行异步操作。当后台中的异步操作完成以执行我们在启动异步操作时提供的`JavaScript`回调时，需要将其推入调用堆栈。
- en: '`The call stack`是一个堆栈数据结构，用于跟踪当前正在执行的代码。每个函数调用都作为一个堆栈帧被添加到堆栈中。当函数执行结束时，该帧会从堆栈中弹出。'
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`The call stack`是一个堆栈数据结构，用于跟踪当前正在执行的代码。每个函数调用都作为一个堆栈帧被添加到堆栈中。当函数执行结束时，该帧会从堆栈中弹出。'
- en: 让我们通过以下代码示例理解事件循环：
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们通过以下代码示例理解事件循环：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 您可以在下面的`Replit`中运行上面的代码：
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 您可以在下面的`Replit`中运行上面的代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/event-loop-example1”
    />`'
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/event-loop-example1”
    />`'
- en: 上面的代码在`setTimeout`的回调中记录“after setTimeout”在“hello world”之前。以下步骤解释了上面的代码是如何执行的：
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上面的代码在`setTimeout`的回调中记录“after setTimeout”在“hello world”之前。以下步骤解释了上面的代码是如何执行的：
- en: 要执行代码，会创建一个任务并将其推入调用堆栈。这通常被称为“全局执行上下文”。
  id: totrans-75
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 要执行代码，会创建一个任务并将其推入调用堆栈。这通常被称为“全局执行上下文”。
- en: 一旦代码执行开始，第一件事就是调用`setTimeout`函数，传入一个将在大约2秒后被调用的回调。调用`setTimeout`会在后台启动一个计时器，该计时器将在我们代码示例中的2秒后到期。在此期间，主线程继续执行代码，而不是等待计时器到期。这就是为什么“after
    setTimeout”在“hello world”之前被记录的原因。
  id: totrans-76
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 一旦代码执行开始，第一件事就是调用`setTimeout`函数，传入一个将在大约2秒后被调用的回调。调用`setTimeout`会在后台启动一个计时器，该计时器将在我们代码示例中的2秒后到期。在此期间，主线程继续执行代码，而不是等待计时器到期。这就是为什么“after
    setTimeout”在“hello world”之前被记录的原因。
- en: Next, the `console.log` is executed, logging “after setTimeout” on the console.
  id: totrans-77
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，执行`console.log`，在控制台上记录“after setTimeout”。
- en: 'At this point, the synchronous execution of our code has ended. As a result,
    the task created (step 1) to execute the code is popped off the call stack. Now,
    JavaScript is ready to execute any scheduled callbacks. This point is important:
    `no asynchronous callback can be invoked until the synchronous execution of the
    code has ended`. Remember, only one thing executes at a time on the main thread,
    and the currently executing code cannot be interrupted.'
  id: totrans-78
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 此时，我们代码的同步执行已结束。因此，为执行代码而创建的任务（步骤 1）从调用栈中弹出。现在，JavaScript 准备好执行任何已调度的回调。这个点很重要：`在代码的同步执行结束之前，无法调用任何异步回调`。请记住，主线程一次只能执行一件事，并且当前执行的代码不能被中断。
- en: After the synchronous execution ends, let us assume that by this time the timer
    has expired (in reality, our code execution will end long before 2 seconds). As
    soon as the timer expires, a task is enqueued in a `task queue` to execute the
    callback of `setTimeout`. The `task queue` is where different tasks are queued
    until they can be pushed onto the call stack and executed.
  id: totrans-79
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 在同步执行结束后，假设此时定时器已经到期（实际上，我们的代码执行将在2秒之前结束）。一旦定时器到期，一个任务被排入`任务队列`以执行`setTimeout`的回调。`任务队列`是不同任务排队的地方，直到它们可以被推入调用栈并执行。
- en: The `event loop` is the entity that processes the tasks in the `task queue`
    and pushes each of them to the call stack to execute them. Tasks are processed
    in the order they are enqueued in the `task queue`. In our case, there is only
    one task in the `task queue`. This task is pushed onto the call stack, but the
    `event loop` only pushes the tasks onto the call stack if the call stack is empty.
    In our case, the call stack is empty, so the callback of `setTimeout` can be executed.
    As a result, “hello world” is logged on the console.
  id: totrans-80
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`事件循环`是处理`任务队列`中任务并将每个任务推送到调用栈以执行的实体。任务按照它们在`任务队列`中排队的顺序进行处理。在我们的例子中，`任务队列`中只有一个任务。这个任务被推入调用栈，但`事件循环`只有在调用栈为空时才会将任务推入调用栈。在我们的例子中，调用栈为空，因此可以执行`setTimeout`的回调。因此，“hello
    world”被记录在控制台上。'
- en: The role of the `event loop`, as described in the above steps, is to process
    the tasks in the `task queue` if the call stack is empty and there are one or
    more tasks in the `task queue` waiting to be executed. So, the `event loop` is
    an entity that allows asynchronous code to be executed in JavaScript in a non-blocking
    manner. The `event loop` can be thought of as a loop that continuously checks
    if there are any tasks waiting to be executed.
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`事件循环`的作用，如上述步骤所述，是在调用栈为空且`任务队列`中有一个或多个等待执行的任务时处理`任务队列`中的任务。因此，`事件循环`是一个允许异步代码以非阻塞方式在JavaScript中执行的实体。可以将`事件循环`视为一个不断检查是否有等待执行的任务的循环。'
- en: 'The `event loop` is what connects the two worlds: the “JavaScript world”, where
    our code executes, and the “background world”, where the asynchronous operations
    are actually executed.'
  id: totrans-82
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`事件循环`连接了两个世界：“JavaScript世界”，即我们的代码执行的地方，以及“后台世界”，即异步操作实际执行的地方。'
- en: 'The above steps can be visualized in the following image:'
  id: totrans-83
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上述步骤可以在以下图像中可视化：
- en: '![function parameter scope](images/module_09----lesson_09.03----public----assets----__event-loop-visualization.gif)'
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_IMG
  zh: '![函数参数作用域](images/module_09----lesson_09.03----public----assets----__event-loop-visualization.gif)'
- en: '`function parameter scope`'
  id: totrans-85
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`函数参数作用域`'
- en: Take your time to understand exactly what happens behind the scenes. The timer
    is intentionally shown to take longer than 2 seconds to make the visualization
    easier to understand. Understanding the steps above before seeing the image will
    make it easy to understand how our code example executes.
  id: totrans-86
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 花时间准确理解幕后发生的事情。定时器故意显示为超过2秒，以便使可视化更易于理解。在查看图像之前理解上述步骤，将使理解我们的代码示例的执行变得容易。
- en: Any user interaction like the click event requires scheduling a task; the same
    is true for executing the callbacks of timing functions like `setTimeout`. Tasks
    are queued in the `task queue` until the `event loop` processes them. The `task
    queue` is also referred to as the `event queue` or the `callback queue`.
  id: totrans-87
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 任何用户交互，例如点击事件，都需要调度一个任务；定时函数的回调执行（如`setTimeout`）也是如此。任务会被排入`任务队列`，直到`事件循环`处理它们。`任务队列`也被称为`事件队列`或`回调队列`。
- en: The event loop processes a single task during its single turn, commonly referred
    to as the “event loop tick” or just “tick”. The next task is processed during
    the next turn or tick of the event loop. The browser may choose to render UI updates
    between tasks.
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 事件循环在每个单独的轮次中处理一个任务，通常称为“事件循环滴答”或简称“滴答”。下一个任务在事件循环的下一个轮次或滴答中处理。浏览器可以选择在任务之间渲染UI更新。
- en: The event loop can have multiple sources of tasks, and the browser decides which
    source to process tasks from during each tick of the event loop. Another queue
    is known as the `microtask queue`, which we will discuss later in this module.
    The event loop also processes microtasks, but there is a difference in how the
    event loop processes tasks and microtasks. The difference will be clear when we
    discuss the microtask queue.
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 事件循环可以有多个任务源，浏览器在事件循环的每个滴答中决定从哪个源处理任务。另一个队列被称为`微任务队列`，我们将在本模块稍后讨论。事件循环也处理微任务，但事件循环处理任务和微任务的方式有所不同。差异将在我们讨论微任务队列时变得清晰。
- en: 'In this lesson, we discussed what an event loop is and how tasks are processed:
    a single task per tick of the event loop.'
  id: totrans-90
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在本课中，我们讨论了事件循环是什么以及任务是如何处理的：每个事件循环的每个“滴答”处理一个任务。
- en: Tool to visualize the event loop
  id: totrans-91
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 可视化事件循环的工具
- en: 'The following is a great tool to visualize the workings of an event loop using
    our code:'
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下是一个很好的工具，可以使用我们的代码可视化事件循环的工作原理：
- en: '[`loupe`](http://latentflip.com/loupe)'
  id: totrans-93
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[`放大镜`](http://latentflip.com/loupe)'
- en: Further reading
  id: totrans-94
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'The following resources are recommended to further our understanding of the
    event loop:'
  id: totrans-95
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下资源被推荐以进一步加深我们对事件循环的理解：
- en: '[`The event loop (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop)'
  id: totrans-96
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[`事件循环 (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop)`'
- en: '[`What the heck is the event loop anyway? | Philip Roberts (youtube video)](https://www.youtube.com/watch?v=8aGhZQkoFbQ)'
  id: totrans-97
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[`事件循环到底是什么？| Philip Roberts（youtube视频）](https://www.youtube.com/watch?v=8aGhZQkoFbQ)`'
- en: '[`Jake Archibald on the web browser event loop, setTimeout, micro tasks, requestAnimationFrame
    (youtube video)](https://www.youtube.com/watch?v=cCOL7MC4Pl0)'
  id: totrans-98
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[`Jake Archibald 关于网页浏览器事件循环、setTimeout、微任务、requestAnimationFrame（youtube视频）](https://www.youtube.com/watch?v=cCOL7MC4Pl0)`'
- en: Promises introduced in `ES2015` have transformed the way we handle asynchronous
    code in JavaScript. Promises are meant to address the problems we discussed with
    callbacks.
  id: totrans-99
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在`ES2015`中引入的承诺改变了我们处理JavaScript中异步代码的方式。承诺旨在解决我们在回调中讨论的问题。
- en: A promise represents an object that acts as a `placeholder` for a value that
    is typically produced as a result of an asynchronous operation. In other words,
    a promise object represents the successful completion or failure of an asynchronous
    operation. There is a common misconception among beginners that promises to make
    our code asynchronous; they do not. Think of promises as a notification mechanism
    that notifies us about the success or failure of some operation that is `already`
    asynchronous. Promises wrap asynchronous operations and allow us to execute code
    when an asynchronous operation is successfully completed or when it fails. That’s
    all a promise does. Nothing more, nothing less. It is only meant to observe the
    asynchronous operation and notify us when that operation is completed.
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 承诺代表一个对象，它充当一个通常由异步操作产生的值的`占位符`。换句话说，承诺对象代表异步操作的成功完成或失败。在初学者中普遍存在一个误解，认为承诺使我们的代码异步；实际上并非如此。将承诺视为一种通知机制，它通知我们某个`已经`是异步操作的成功或失败。承诺封装异步操作，并允许我们在异步操作成功完成或失败时执行代码。这就是承诺所做的一切。没有更多，没有更少。它的唯一目的是观察异步操作，并在该操作完成时通知我们。
- en: Before we learn how we can create promise objects, let us first learn how we
    can deal with promises using the built-in `fetch` function that allows us to make
    HTTP requests from the JavaScript code running in the browser.
  id: totrans-101
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在学习如何创建承诺对象之前，让我们首先了解如何使用内置的`fetch`函数处理承诺，该函数允许我们从浏览器中运行的JavaScript代码发出HTTP请求。
- en: 当调用`fetch`函数时，函数不会使调用代码等待HTTP请求完成，而是返回一个承诺对象。我们可以将回调函数与返回的承诺对象关联，以便在HTTP请求完成时执行代码。我们仍然使用回调与承诺，但我们在本模块之前的课程中讨论的与回调相关的问题在使用承诺时不存在。与回调相比，承诺提供了一种干净且结构化的方式来处理JavaScript中的异步操作。
  id: totrans-102
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当调用`fetch`函数时，函数不会使调用代码等待HTTP请求完成，而是返回一个承诺对象。我们可以将回调函数与返回的承诺对象关联，以便在HTTP请求完成时执行代码。我们仍然使用回调与承诺，但在本模块之前的课程中讨论的与回调相关的问题在使用承诺时不存在。与回调相比，承诺提供了一种干净且结构化的方式来处理JavaScript中的异步操作。
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`fetch`函数返回的承诺可以看作是`fetch`函数`承诺`我们在HTTP请求未来某个时间完成时提供一个值。在此期间，主线程可以自由执行其他操作。'
  id: totrans-104
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`fetch`函数返回的承诺可以看作是`fetch`函数`承诺`我们在HTTP请求未来某个时间完成时提供一个值。在此期间，主线程可以自由执行其他操作。'
- en: 我们可以对返回的承诺做什么？我们可以在网络请求完成时注册与承诺对象的回调。我们可以注册不同的回调以处理网络请求的成功或失败。
  id: totrans-105
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们可以对返回的承诺做什么？我们可以在网络请求完成时注册与承诺对象的回调。我们可以注册不同的回调以处理网络请求的成功或失败。
- en: 承诺状态
  id: totrans-106
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 承诺状态
- en: 承诺在其生命周期中可以处于以下三种状态之一：
  id: totrans-107
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 承诺在其生命周期中可以处于以下三种状态之一：
- en: '`pending`：承诺通常在创建时的初始状态。这表示与承诺关联的异步操作正在进行中。'
  id: totrans-108
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`pending`：承诺通常在创建时的初始状态。这表示与承诺关联的异步操作正在进行中。'
- en: '`fulfilled`：意味着与承诺关联的异步操作已成功完成。'
  id: totrans-109
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`fulfilled`：意味着与承诺关联的异步操作已成功完成。'
- en: '`rejected`：意味着与承诺关联的异步操作失败了。'
  id: totrans-110
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`rejected`：意味着与承诺关联的异步操作失败了。'
- en: 在承诺的生命周期中，它的状态从`pending`变为`fulfilled`或`rejected`。承诺的状态保存在名为`[[[PromiseState]]]`的隐藏内部插槽中（[链接](https://262.ecma-international.org/14.0/#table-internal-slots-of-promise-instances)）。
  id: totrans-111
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在承诺的生命周期中，它的状态从`pending`变为`fulfilled`或`rejected`。承诺的状态保存在名为`[[[PromiseState]]]`的隐藏内部插槽中（[链接](https://262.ecma-international.org/14.0/#table-internal-slots-of-promise-instances)）。
- en: 处于`pending`状态的承诺被视为`unsettled`。一旦承诺从`pending`状态转换为`fulfilled`或`rejected`状态，就被认为是`settled`。
  id: totrans-112
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 处于`pending`状态的承诺被视为`unsettled`。一旦承诺从`pending`状态转换为`fulfilled`或`rejected`状态，就被认为是`settled`。
- en: 承诺实例方法
  id: totrans-113
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 承诺实例方法
- en: 我们可以在承诺实例上调用的三种实例方法：
  id: totrans-114
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们可以在承诺实例上调用的三种实例方法：
- en: '`Promise.prototype.then()`'
  id: totrans-115
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`Promise.prototype.then()`'
- en: '`Promise.prototype.catch()`'
  id: totrans-116
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`Promise.prototype.catch()`'
- en: '`Promise.prototype.finally()`'
  id: totrans-117
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`Promise.prototype.finally()`'
- en: '`then`方法'
  id: totrans-118
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`then` 方法'
- en: '`then`方法用于注册一个回调函数，该函数在承诺被满足时异步调用，即被承诺包装的异步操作成功完成时。此方法允许我们在异步操作成功完成时执行代码。考虑以下代码示例：'
  id: totrans-119
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`then`方法用于注册一个回调函数，该函数在承诺被满足时异步调用，即被承诺包装的异步操作成功完成时。此方法允许我们在异步操作成功完成时执行代码。考虑以下代码示例：'
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`then`方法接受两个回调函数作为参数：`fulfillment handler`和`rejection handler`。`fulfillment
    handler`是第一个参数，如上面的代码示例所示。`rejection handler`是可选的第二个参数，如果调用`then`方法的承诺被拒绝，则会调用它。'
  id: totrans-121
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`then` 方法接受两个回调函数作为参数：`fulfillment handler`和`rejection handler`。`fulfillment
    handler`是第一个参数，如上面的代码示例所示。`rejection handler`是可选的第二个参数，如果调用`then`方法的承诺被拒绝，则会调用它。'
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The fulfillment handler is passed the result of the asynchronous operation as
    an argument. In other words, the fulfillment handler receives the value with which
    the promise is fulfilled. In the case of an HTTP request, the promise is fulfilled
    with the server response, so the fulfillment handler receives the server response
    as an argument. On the other hand, the rejection handler receives the rejection
    reason as an argument if the promise is rejected.
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 满足处理程序将异步操作的结果作为参数传递。换句话说，满足处理程序接收的是承诺被满足时的值。在HTTP请求的情况下，承诺以服务器响应作为满足，因此满足处理程序接收服务器响应作为参数。另一方面，如果承诺被拒绝，拒绝处理程序将接收拒绝原因作为参数。
- en: '`catch` method'
  id: totrans-124
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`catch` 方法'
- en: We learned in the previous section that we can pass the rejection handler as
    the second argument to the `then` method to handle the promise rejection. There
    is another option to register the rejection handler, and that is through the `catch`
    method. Instead of passing the rejection handler to the `then` method, we can
    call the `catch` method on the promise to register the rejection handler.
  id: totrans-125
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们在上一节中了解到，可以将拒绝处理程序作为第二个参数传递给`then`方法来处理承诺拒绝。还有另一种注册拒绝处理程序的选项，那就是通过`catch`方法。我们可以在承诺上调用`catch`方法来注册拒绝处理程序，而不是将拒绝处理程序传递给`then`方法。
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `catch` method is similar to the `then` method that is called with only
    a rejection handler, as shown below:'
  id: totrans-127
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`catch`方法类似于只使用拒绝处理程序调用的`then`方法，如下所示：'
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: However, using the `catch` method to register a rejection handler is more common
    than using the second argument of the `then` method.
  id: totrans-129
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，使用`catch`方法注册拒绝处理程序比使用`then`方法的第二个参数更为常见。
- en: '`finally` method'
  id: totrans-130
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: '`finally` 方法'
- en: 'Imagine a scenario where we want to send an HTTP request to a server, and while
    the request is in progress, we show a loading spinner to the user to indicate
    that data is being loaded. When the request completes, either successfully or
    unsuccessfully, we want to hide the loading spinner. To achieve this, we will
    have to duplicate the code that hides the loading spinner in the fulfillment and
    rejection handlers, as shown in the following code example:'
  id: totrans-131
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 想象一个场景，我们希望向服务器发送HTTP请求，而在请求进行时，我们向用户显示一个加载指示器以表明数据正在加载。当请求完成时，无论是成功还是失败，我们都希望隐藏加载指示器。为了实现这一点，我们必须在满足和拒绝处理程序中重复隐藏加载指示器的代码，如下所示的代码示例所示：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We want to avoid code duplication, and the `finally` method can help us remove
    the code duplication. The `finally` method allows us to execute code regardless
    of promise fulfillment or rejection. Just like the `then` and `catch` methods,
    the `finally` method also accepts a callback function that is invoked asynchronously
    after promise fulfillment as well as promise rejection. The callback passed to
    the `finally` method is the perfect place for the code that we want to execute
    regardless of whether the asynchronous operation fails or completes successfully.
    We can refactor the code above as shown below:'
  id: totrans-133
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们希望避免代码重复，而`finally`方法可以帮助我们消除代码重复。`finally`方法允许我们在承诺满足或拒绝时执行代码。与`then`和`catch`方法一样，`finally`方法也接受一个回调函数，该函数在承诺满足和拒绝后异步调用。传递给`finally`方法的回调是执行代码的理想之地，无论异步操作是否失败或成功完成。我们可以将上述代码重构如下：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Unlike the callbacks of the `then` and `catch` methods, the callback passed
    to the `finally` method receives no arguments.
  id: totrans-135
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与 `then` 和 `catch` 方法的回调不同，传递给 `finally` 方法的回调不接收任何参数。
- en: Creating promises
  id: totrans-136
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 创建 Promise
- en: 'We can create new promise objects using the `Promise` constructor, as shown
    below:'
  id: totrans-137
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们可以使用 `Promise` 构造函数创建新的 Promise 对象，如下所示：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Promise` constructor takes a callback function as an argument, referred
    to as the `executor` function, that is invoked `synchronously` to create the promise
    object. It is common to incorrectly assume that any code inside the executor function
    is executed asynchronously, but that is not the case. The executor function is
    invoked synchronously to create the promise object. The code inside the executor
    function should be any code that starts some asynchronous operation. The newly
    created promise object will observe that asynchronous operation. The promise object
    will notify us about the success or failure of the asynchronous operation that
    is initiated inside the executor function.
  id: totrans-139
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Promise` 构造函数接受一个回调函数作为参数，该参数被称为 `executor` 函数，并在 `同步` 模式下被调用以创建 Promise 对象。人们常常错误地假设执行函数中的任何代码都是异步执行的，但事实并非如此。执行函数是同步调用的，以创建
    Promise 对象。执行函数中的代码应该是启动某个异步操作的任何代码。新创建的 Promise 对象将观察该异步操作。Promise 对象将通知我们执行函数内部启动的异步操作的成功或失败。'
- en: How is the asynchronous operation linked to the newly created promise? Through
    the `resolve` and `reject` functions that the executor function receives as arguments.
    The parameters could be given different names, but it is common practice to name
    them `resolve` and `reject` to clearly indicate their purpose. The `resolve` function
    is used to resolve or fulfill the promise, and the `reject` function is used to
    reject the promise. Let us take a look at a concrete example that will clarify
    how we can create a promise object that wraps around an asynchronous operation
    and is resolved or rejected depending on whether the asynchronous operation succeeds
    or fails.
  id: totrans-140
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 异步操作是如何与新创建的 Promise 关联的？通过执行函数作为参数接收的 `resolve` 和 `reject` 函数。参数可以使用不同的名称，但通常将它们命名为
    `resolve` 和 `reject` 以明确其目的。`resolve` 函数用于解决或满足 Promise，而 `reject` 函数用于拒绝 Promise。让我们看一个具体的例子，以澄清如何创建一个
    Promise 对象，它包装在异步操作周围，并根据异步操作的成功或失败进行解析或拒绝。
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can run the above code in the Replit below:'
  id: totrans-142
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的 Replit 中运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promises-example9” />`'
  id: totrans-143
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promises-example9" />`'
- en: The code example above shows how a promise object can be wrapped around an asynchronous
    operation and be resolved or rejected when the asynchronous operation succeeds
    or fails. In response to the promise being fulfilled or rejected, the appropriate
    handler (fulfillment or rejection) is invoked asynchronously.
  id: totrans-144
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上面的代码示例展示了如何将一个 Promise 对象包装在异步操作中，并在异步操作成功或失败时进行解析或拒绝。针对 Promise 被满足或拒绝的情况，相应的处理程序（满足或拒绝）会异步调用。
- en: It is important to note that the promise won’t be fulfilled or rejected until
    the `resolve` or `reject` functions are called within the executor function. As
    a result, any registered fulfillment or rejection handlers won’t be called until
    the promise is settled.
  id: totrans-145
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 重要的是要注意，Promise 不会被满足或拒绝，直到在执行函数中调用 `resolve` 或 `reject` 函数。因此，任何注册的满足或拒绝处理程序在
    Promise 被解决之前都不会被调用。
- en: 'The code example above might not make you see how promises are an improvement
    over the traditional way of using callbacks to handle asynchronous code, but wait
    until we discuss promise chaining and `async-await` syntax in the upcoming lessons
    in this module. These two topics will help you see how promises address the two
    main problems with callbacks: Callback hell and error handling.'
  id: totrans-146
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上面的代码示例可能没有让你看到 Promise 是如何改善传统的使用回调处理异步代码的方法，但等到我们在本模块即将到来的课程中讨论 Promise 链和
    `async-await` 语法时再说。这两个主题将帮助你理解 Promise 如何解决回调的两个主要问题：回调地狱和错误处理。
- en: Using promises with callback-based API
  id: totrans-147
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 使用 Promise 与基于回调的 API
- en: If you noticed in the code example in the previous section, we just wrapped
    a promise around the callback-based `XMLHttpRequest` API. We wrapped a promise
    around it so that we could interact with it using promises.
  id: totrans-148
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你注意到上一节的代码示例，我们只是将一个 Promise 包装在基于回调的 `XMLHttpRequest` API 周围。我们这样做是为了能够通过
    Promise 与其进行交互。
- en: 'Similar to what we did above, we can convert any callback-based API into a
    promise-based API. All we need to do is place the callback-based code in the executor
    function and call the `resolve` and `reject` functions at appropriate places to
    fulfill or reject the promise. Following is an example of wrapping a promise around
    `setTimeout` to add an artificial delay in the code:'
  id: totrans-149
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与我们上面做的类似，我们可以将任何基于回调的 API 转换为基于 Promise 的 API。我们需要做的就是将基于回调的代码放入执行函数中，并在适当的位置调用
    `resolve` 和 `reject` 函数来完成或拒绝该 Promise。以下是一个将 Promise 包裹在 `setTimeout` 周围以在代码中添加人为延迟的示例：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can run the above code in the Replit below:'
  id: totrans-151
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的 Replit 中运行上述代码：
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promises-example10" />`'
  id: totrans-152
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promises-example10" />`'
- en: In the code example above, we wrapped `setTimeout` in a promise to add an artificial
    delay in the code. To resolve the promise after the specified delay (2 seconds
    in our code above), we call the `resolve` function inside the callback function
    of `setTimeout`. Note that we didn’t call or use the `reject` function because
    we didn’t need it to reject the promise. We just want the promise to be fulfilled
    after the specified delay.
  id: totrans-153
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上面的代码示例中，我们将 `setTimeout` 包裹在一个 Promise 中，以在代码中添加人为延迟。要在指定延迟（我们上面的代码中为 2 秒）后解析
    Promise，我们在 `setTimeout` 的回调函数内调用 `resolve` 函数。请注意，我们没有调用或使用 `reject` 函数，因为我们不需要它来拒绝
    Promise。我们只是希望在指定延迟后完成 Promise。
- en: Promise specification
  id: totrans-154
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 承诺规范
- en: '[Promises/A+](https://promisesaplus.com/) is a standard that defines the behavior
    of promises in JavaScript. It ensures that different implementations of promises
    in different environments conform to the standard behavior defined in the specification
    to ensure consistency in the behavior of promises across different environments.'
  id: totrans-155
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '[Promises/A+](https://promisesaplus.com/) 是一个标准，定义了 JavaScript 中 Promise 的行为。它确保不同环境中
    Promise 的不同实现符合规范中定义的标准行为，以确保不同环境中 Promise 行为的一致性。'
- en: Promise vs `thenable`
  id: totrans-156
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: Promise 与 `thenable`
- en: 'If you read the promise specification, you will find the word "`thenable`"
    mentioned multiple times. A `thenable` is any object that has defined a method
    named `then` but is not a promise. It is a generic term for objects with a method
    named `then`. As promises have a method named `then`, we can say that all promises
    are `thenables`, but the reverse is not true: every `thenable` is not a promise.'
  id: totrans-157
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你阅读了承诺规范，你会发现多次提到“`thenable`”这个词。`thenable` 是任何定义了名为 `then` 方法的对象，但不是 Promise。它是一个通用术语，指具有名为
    `then` 方法的对象。由于 Promise 具有名为 `then` 的方法，我们可以说所有的 Promise 都是 `thenables`，但反之不成立：并非每个
    `thenable` 都是 Promise。
- en: To summarize the difference, `thenable` is an object with a `then` method, and
    `promise` is an object with a `then` method that conforms to the [Promises/A+](https://promisesaplus.com/)
    specification.
  id: totrans-158
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 总结区别，`thenable` 是一个具有 `then` 方法的对象，而 `promise` 是一个具有符合 [Promises/A+](https://promisesaplus.com/)
    规范的 `then` 方法的对象。
- en: 'In the previous lesson, we discussed the following instance methods of promises:'
  id: totrans-159
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上一课中，我们讨论了以下 Promise 的实例方法：
- en: '`Promise.prototype.then()`'
  id: totrans-160
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`Promise.prototype.then()`'
- en: '`Promise.prototype.catch()`'
  id: totrans-161
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`Promise.prototype.catch()`'
- en: '`Promise.prototype.finally()`'
  id: totrans-162
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`Promise.prototype.finally()`'
- en: We discussed what each of these methods allows us to do, but what we didn’t
    discuss is what each of these methods returns. Their return value is important
    because it allows for promise chaining, which is the topic of this lesson.
  id: totrans-163
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们讨论了这些方法各自可以让我们做什么，但我们没有讨论的是这些方法返回的内容。它们的返回值很重要，因为它允许进行承诺链式调用，这也是本课的主题。
- en: 'Each of the instance methods of promises returns a new promise, which enables
    us to create a chain of method calls, effectively creating a chain of asynchronous
    operations. Promise chaining helps resolve the two main problems we face when
    using callbacks: “Callback Hell” and error handling.'
  id: totrans-164
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 每个 Promise 的实例方法返回一个新的 Promise，这使我们能够创建方法调用链，有效地创建异步操作链。承诺链式调用帮助解决我们在使用回调时面临的两个主要问题：“回调地狱”和错误处理。
- en: 'The following code example shows how we have registered fulfillment and rejection
    handlers with the promise returned by the `fetch` function:'
  id: totrans-165
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下代码示例展示了我们如何在 `fetch` 函数返回的 Promise 上注册完成和拒绝处理程序：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As each promise instance method returns a new promise, we can rewrite the above
    code as shown below:'
  id: totrans-167
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 由于每个 Promise 实例方法返回一个新的 Promise，我们可以将上述代码重写如下：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 重构后的代码实现了与第一个代码示例相同的结果，但从技术上讲，第一个代码示例与重构后的代码是不同的。在第一个代码示例中，拒绝处理程序是在`fetch`函数返回的`promise`上注册的，而在重构后的代码中，拒绝处理程序是在`then`方法返回的`promise`上注册的。重构后的代码中的`promise`链可以分成不同的部分，如下所示，以便更容易理解：
  id: totrans-169
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 重构后的代码实现了与第一个代码示例相同的结果，但从技术上讲，第一个代码示例与重构后的代码是不同的。在第一个代码示例中，拒绝处理程序是在`fetch`函数返回的`promise`上注册的，而在重构后的代码中，拒绝处理程序是在`then`方法返回的`promise`上注册的。重构后的代码中的`promise`链可以分成不同的部分，如下所示，以便更容易理解：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 注意已经注册了满足和拒绝处理程序的`promise`。满足处理程序是在`fetch`函数返回的`promise`上注册的，但与第一个代码示例不同，拒绝处理程序是在`then`方法返回的`promise`上注册的。那么，这是否意味着如果`fetch`函数返回的`promise`被拒绝，就没有注册处理拒绝的处理程序？不，注册在`pThen``promise`上的拒绝处理程序将处理拒绝。要理解它是如何工作的，我们必须理解`promise`链是如何工作的。
  id: totrans-171
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 注意已经注册了满足和拒绝处理程序的`promise`。满足处理程序是在`fetch`函数返回的`promise`上注册的，但与第一个代码示例不同，拒绝处理程序是在`then`方法返回的`promise`上注册的。那么，这是否意味着如果`fetch`函数返回的`promise`被拒绝，就没有注册处理拒绝的处理程序？不，注册在`pThen`的`promise`上的拒绝处理程序将处理拒绝。要理解它是如何工作的，我们必须理解`promise`链是如何工作的。
- en: 本节的进一步代码示例将使用以下函数，该函数模拟一个大约需要两秒钟才能完成的HTTP请求：
  id: totrans-172
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 本节的进一步代码示例将使用以下函数，该函数模拟一个大约需要两秒钟才能完成的HTTP请求：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 这个函数将使我们更容易理解`promise`链。该函数接受一个布尔参数，指定我们是否希望我们的假请求被满足或拒绝。该参数的默认值为`true`，因此如果我们希望请求失败，只需传递参数即可。在函数内部，返回一个包装在`setTimeout`中的`promise`，以模拟一个大约需要两秒钟才能完成的请求。在定时器到期后，`promise`会被满足或拒绝，具体取决于`isSuccessRequest`参数的值。
  id: totrans-174
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这个函数将使我们更容易理解`promise`链。该函数接受一个布尔参数，指定我们是否希望我们的假请求被满足或拒绝。该参数的默认值为`true`，因此如果我们希望请求失败，只需传递参数即可。在函数内部，返回一个包装在`setTimeout`中的`promise`，以模拟一个大约需要两秒钟才能完成的请求。在定时器到期后，`promise`会被满足或拒绝，具体取决于`isSuccessRequest`参数的值。
- en: 定义了`fakeRequest`函数后，让我们深入`promise`链的世界。
  id: totrans-175
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 定义了`fakeRequest`函数后，让我们深入`promise`链的世界。
- en: '`then` `promise`'
  id: totrans-176
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`then` `promise`'
- en: 在一个`promise`上调用`then`方法会在该`promise`上注册一个满足处理程序。`then`方法本身返回一个新的`promise`，该`promise`与调用`then`方法的原始`promise`不同。
  id: totrans-177
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在一个`promise`上调用`then`方法会在该`promise`上注册一个满足处理程序。`then`方法本身返回一个新的`promise`，该`promise`与调用`then`方法的原始`promise`不同。
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 你可以在下面的Replit中运行上述代码：
  id: totrans-179
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的Replit中运行上述代码：
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example5"
    />`'
  id: totrans-180
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example5"
    />`'
- en: '`then`方法返回的`promise`根据以下两个问题来满足或拒绝：'
  id: totrans-181
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`then`方法返回的`promise`根据以下两个问题来满足或拒绝：'
- en: 调用`then`方法的`promise`会发生什么？在我们的案例中，`then`方法是在`pRequest``promise`上调用的。
  id: totrans-182
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 调用`then`方法的`promise`会发生什么？在我们的案例中，`then`方法是在`pRequest`的`promise`上调用的。
- en: 从传递给`then`方法的满足或拒绝处理程序返回的是什么？哪个处理程序会影响`then`方法返回的`promise`取决于在调用`then`方法的原始`promise`解决时哪个处理程序被调用。
  id: totrans-183
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 从传递给`then`方法的满足或拒绝处理程序返回的是什么？哪个处理程序会影响`then`方法返回的`promise`取决于在调用`then`方法的原始`promise`解决时哪个处理程序被调用。
- en: 记住上述两个问题，让我们讨论可能影响`then`方法返回的`promise`的不同场景：
  id: totrans-184
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 记住上述两个问题，让我们讨论可能影响`then`方法返回的`promise`的不同场景：
- en: 场景1：原始`promise`被满足
  id: totrans-185
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 场景1：原始`promise`被满足
- en: 如果调用`then`方法的原始承诺被实现，则`then`方法返回的承诺取决于实现处理程序内部发生的事情。以下是实现处理程序可以执行的不同操作，这些操作会影响`then`方法返回的承诺：
  id: totrans-186
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果调用`then`方法的原始承诺被实现，则`then`方法返回的承诺取决于实现处理程序内部发生的事情。以下是实现处理程序可以执行的不同操作，这些操作会影响`then`方法返回的承诺：
- en: 如果注册了实现处理程序，并且它返回的值不是一个承诺或可then的对象，则`then`方法返回的承诺将以该返回值完成。
  id: totrans-187
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果注册了实现处理程序，并且它返回的值不是一个承诺或可then的对象，则`then`方法返回的承诺将以该返回值完成。
- en: '[PRE24]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 你可以在下面的Replit中运行上述代码：
  id: totrans-189
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的Replit中运行上述代码：
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example6"
    />`'
  id: totrans-190
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example6"
    />`'
- en: 如果实现处理程序没有显式返回任何值，则`then`方法返回的承诺以`undefined`作为实现值完成。
  id: totrans-191
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果实现处理程序没有显式返回任何值，则`then`方法返回的承诺以`undefined`作为实现值完成。
- en: '[PRE25]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 你可以在下面的Replit中运行上述代码：
  id: totrans-193
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的Replit中运行上述代码：
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example7"
    />`'
  id: totrans-194
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example7"
    />`'
- en: 如果在一个承诺上调用`then`方法但没有提供实现处理程序，则`then`方法返回的承诺将以与原始承诺相同的实现值完成。
  id: totrans-195
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果在一个承诺上调用`then`方法但没有提供实现处理程序，则`then`方法返回的承诺将以与原始承诺相同的实现值完成。
- en: '[PRE26]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 你可以在下面的Replit中运行上述代码：
  id: totrans-197
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的Replit中运行上述代码：
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example8"
    />`'
  id: totrans-198
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example8"
    />`'
- en: 如果实现处理程序抛出任何值或错误，则`then`方法返回的承诺将以抛出的值作为拒绝原因或值被拒绝。
  id: totrans-199
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果实现处理程序抛出任何值或错误，则`then`方法返回的承诺将以抛出的值作为拒绝原因或值被拒绝。
- en: '[PRE27]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 你可以在下面的Replit中运行上述代码：
  id: totrans-201
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的Replit中运行上述代码：
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example9"
    />`'
  id: totrans-202
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example9"
    />`'
- en: 如果实现处理程序返回一个承诺，则`then`方法返回的承诺将被*解析*为实现处理程序返回的承诺。一个承诺被*解析为另一个承诺*意味着一个承诺（我们称之为`p1`）的命运取决于另一个承诺（我们称之为`p2`）。如果`p2`被实现，`p1`也将以相同的实现值被实现。如果`p2`被拒绝，`p1`也将以相同的拒绝值被拒绝。承诺`p1`将等待`p2`解决后再解决，最终与`p2`达到相同的命运。
  id: totrans-203
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果实现处理程序返回一个承诺，则`then`方法返回的承诺将被*解析*为实现处理程序返回的承诺。一个承诺被*解析为另一个承诺*意味着一个承诺（我们称之为`p1`）的命运取决于另一个承诺（我们称之为`p2`）。如果`p2`被实现，`p1`也将以相同的实现值被实现。如果`p2`被拒绝，`p1`也将以相同的拒绝值被拒绝。承诺`p1`将等待`p2`解决后再解决，最终与`p2`达到相同的命运。
- en: '[PRE28]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 你可以在下面的Replit中运行上述代码：
  id: totrans-205
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的Replit中运行上述代码：
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example10"
    />`'
  id: totrans-206
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example10"
    />`'
- en: 在上面的代码示例中，`then`方法返回的承诺`pThen`通过`pRequest`承诺的实现处理程序返回的承诺被*解析*。
  id: totrans-207
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上面的代码示例中，`then`方法返回的承诺`pThen`通过`pRequest`承诺的实现处理程序返回的承诺被*解析*。
- en: 场景 2：原始承诺被拒绝
  id: totrans-208
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 场景 2：原始承诺被拒绝
- en: 如果调用`then`方法的原始承诺被拒绝，则`then`方法返回的承诺取决于以下场景：
  id: totrans-209
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果调用`then`方法的原始承诺被拒绝，则`then`方法返回的承诺取决于以下场景：
- en: 如果只将实现处理程序传递给`then`方法，则`then`方法返回的承诺也将以与原始承诺被拒绝时相同的拒绝原因或值被拒绝。
  id: totrans-210
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果只将实现处理程序传递给`then`方法，则`then`方法返回的承诺也将以与原始承诺被拒绝时相同的拒绝原因或值被拒绝。
- en: '[PRE29]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 你可以在下面的Replit中运行上述代码：
  id: totrans-212
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的Replit中运行上述代码：
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example11"
    />`'
  id: totrans-213
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example11"
    />`'
- en: 如果将拒绝处理程序传递给`then`方法，那么`then`方法返回的承诺将取决于拒绝处理程序内部发生的事情。这在履行处理程序的情况下工作类似：
  id: totrans-214
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果将拒绝处理程序传递给`then`方法，那么`then`方法返回的承诺将取决于拒绝处理程序内部发生的事情。这在履行处理程序的情况下工作类似：
- en: 如果拒绝处理程序返回一个非承诺值，则`then`方法返回的承诺将以拒绝处理程序返回的值被兑现。
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果拒绝处理程序返回一个非承诺值，则`then`方法返回的承诺将以拒绝处理程序返回的值被兑现。
- en: 如果拒绝处理程序没有明确返回任何值，那么`then`方法返回的承诺将以`undefined`作为满足值被兑现。
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果拒绝处理程序没有明确返回任何值，那么`then`方法返回的承诺将以`undefined`作为满足值被兑现。
- en: 如果在原始承诺上调用`then`方法，但没有提供拒绝处理程序，则`then`方法返回的承诺将以与原始承诺相同的拒绝值被拒绝。
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果在原始承诺上调用`then`方法，但没有提供拒绝处理程序，则`then`方法返回的承诺将以与原始承诺相同的拒绝值被拒绝。
- en: 如果拒绝处理程序抛出任何值或错误，则`then`方法返回的承诺将以抛出的值作为拒绝原因或值被拒绝。
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果拒绝处理程序抛出任何值或错误，则`then`方法返回的承诺将以抛出的值作为拒绝原因或值被拒绝。
- en: 如果拒绝处理程序返回一个承诺，则`then`方法返回的承诺将被解析为拒绝处理程序返回的承诺，就像之前讨论的履行处理程序的情况一样。
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果拒绝处理程序返回一个承诺，则`then`方法返回的承诺将被解析为拒绝处理程序返回的承诺，就像之前讨论的履行处理程序的情况一样。
- en: 现在我们已经讨论了`then`方法返回的承诺在不同场景下是如何解决的，接下来我们将讨论`catch`方法返回的承诺。
  id: totrans-220
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了`then`方法返回的承诺在不同场景下是如何解决的，接下来我们将讨论`catch`方法返回的承诺。
- en: 捕获承诺
  id: totrans-221
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 捕获承诺
- en: '`catch`方法用于为调用它的承诺注册拒绝处理程序。与`then`方法一样，`catch`方法也返回一个新的承诺，并且与`then`方法的承诺一样，`catch`方法返回的承诺的解决情况取决于以下两个问题：'
  id: totrans-222
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`catch`方法用于为调用它的承诺注册拒绝处理程序。与`then`方法一样，`catch`方法也返回一个新的承诺，并且与`then`方法的承诺一样，`catch`方法返回的承诺的解决情况取决于以下两个问题：'
- en: 在调用`catch`方法的承诺上发生了什么？
  id: totrans-223
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 在调用`catch`方法的承诺上发生了什么？
- en: 传递给`catch`方法的拒绝处理程序返回了什么？
  id: totrans-224
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 传递给`catch`方法的拒绝处理程序返回了什么？
- en: 场景1：原始承诺被兑现
  id: totrans-225
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 场景 1：原始承诺被兑现
- en: 假设调用`catch`方法的原始承诺已经兑现。在这种情况下，使用`catch`方法注册的拒绝处理程序不会被调用，`catch`方法返回的承诺将以与原始承诺相同的满足值被兑现。
  id: totrans-226
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 假设调用`catch`方法的原始承诺已经兑现。在这种情况下，使用`catch`方法注册的拒绝处理程序不会被调用，`catch`方法返回的承诺将以与原始承诺相同的满足值被兑现。
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 您可以在下面的Replit中运行上述代码：
  id: totrans-228
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 您可以在下面的Replit中运行上述代码：
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example12”
    />
  id: totrans-229
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example12"
    />
- en: 场景2：原始承诺被拒绝
  id: totrans-230
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 场景 2：原始承诺被拒绝
- en: 使用`catch`处理程序注册的拒绝处理程序在调用`catch`方法的原始承诺被拒绝时被调用。如果原始承诺被拒绝，那么`catch`方法返回的承诺，就像`then`方法返回的承诺一样，取决于拒绝处理程序内部发生的事情：
  id: totrans-231
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用`catch`处理程序注册的拒绝处理程序在调用`catch`方法的原始承诺被拒绝时被调用。如果原始承诺被拒绝，那么`catch`方法返回的承诺，就像`then`方法返回的承诺一样，取决于拒绝处理程序内部发生的事情：
- en: 如果拒绝处理程序返回一个非承诺值，则`catch`方法返回的承诺将以拒绝处理程序返回的值被兑现。
  id: totrans-232
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果拒绝处理程序返回一个非承诺值，则`catch`方法返回的承诺将以拒绝处理程序返回的值被兑现。
- en: '[PRE31]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 您可以在下面的Replit中运行上述代码：
  id: totrans-234
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 您可以在下面的Replit中运行上述代码：
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example13”
    />
  id: totrans-235
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example13"
    />
- en: If the rejection handler doesn’t explicitly return any value, the promise returned
    by the `catch` method is fulfilled with `undefined` as the fulfillment value.
  id: totrans-236
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果拒绝处理程序没有显式返回任何值，则`catch`方法返回的承诺将以`undefined`作为满足值被兑现。
- en: '[PRE32]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can run the above code in the Replit below:'
  id: totrans-238
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 您可以在下面的Replit中运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example14”
    />`'
  id: totrans-239
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example14"
    />
- en: If the `catch` method is called on the original promise but the rejection handler
    isn’t provided, the promise returned by the `catch` method gets rejected with
    the same rejection value as the original promise.
  id: totrans-240
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果在原始承诺上调用`catch`方法，但未提供拒绝处理程序，则`catch`方法返回的承诺将以与原始承诺相同的拒绝值被拒绝。
- en: '[PRE33]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can run the above code in the Replit below:'
  id: totrans-242
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 您可以在下面的Replit中运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example15”
    />`'
  id: totrans-243
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example15"
    />
- en: If the rejection handler throws any value or an error, the promise returned
    by the `catch` method gets rejected with the thrown value as the rejection reason
    or value.
  id: totrans-244
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果拒绝处理程序抛出任何值或错误，则`catch`方法返回的承诺将以抛出的值作为拒绝原因或值被拒绝。
- en: '[PRE34]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can run the above code in the Replit below:'
  id: totrans-246
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 您可以在下面的Replit中运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example16”
    />`'
  id: totrans-247
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example16"
    />
- en: If the rejection handler returns a promise, the promise returned by the `catch`
    method gets resolved to the promise returned by the rejection handler, the same
    as in the case of the fulfillment handler discussed earlier.
  id: totrans-248
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果拒绝处理程序返回一个承诺，则`catch`方法返回的承诺将解析为拒绝处理程序返回的承诺，这与之前讨论的满足处理程序的情况相同。
- en: '[PRE35]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can run the above code in the Replit below:'
  id: totrans-250
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 您可以在下面的Replit中运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example17”
    />`'
  id: totrans-251
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example17"
    />
- en: '`finally` promise'
  id: totrans-252
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`finally`承诺'
- en: 'The `finally` method is used to register a callback function that is invoked
    asynchronously after the promise settles. The callback passed to the `finally`
    method is invoked regardless of whether the promise on which it is called is fulfilled
    or rejected. Just like the `then` and `catch` methods, the `finally` method also
    returns a new promise, and the settlement of the promise returned by the `finally`
    method depends on the following two questions:'
  id: totrans-253
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`finally`方法用于注册一个回调函数，该函数在承诺解决后异步调用。无论调用`finally`方法的承诺是被满足还是被拒绝，传递给`finally`方法的回调都会被调用。与`then`和`catch`方法一样，`finally`方法也返回一个新的承诺，而`finally`方法返回的承诺的解决情况取决于以下两个问题：'
- en: What happens to the promise on which the `finally` method is called?
  id: totrans-254
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 调用`finally`方法的承诺会发生什么？
- en: What is returned from the callback function passed to the `finally` method?
  id: totrans-255
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 传递给`finally`方法的回调函数返回了什么？
- en: 'Scenario 1: Original promise gets fulfilled'
  id: totrans-256
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 场景 1：原始承诺被兑现
- en: 'Suppose the original promise on which the `finally` method is called is fulfilled.
    In that case, the promise returned by the `finally` method also gets fulfilled
    with the same fulfillment value as the original promise, provided that the following
    conditions are met:'
  id: totrans-257
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 假设调用`finally`方法的原始承诺已被兑现。在这种情况下，`finally`方法返回的承诺也将以与原始承诺相同的满足值被兑现，前提是满足以下条件：
- en: The `finally` callback doesn’t throw an error or a value.
  id: totrans-258
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`finally`回调不会抛出错误或值。'
- en: The `finally` callback doesn’t return a rejected promise or a promise that eventually
    gets rejected.
  id: totrans-259
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`finally`回调不会返回一个被拒绝的 promise 或一个最终被拒绝的 promise。'
- en: '[PRE36]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here’s the code in the Replit:'
  id: totrans-261
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是 Replit 中的代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example18”
    />`'
  id: totrans-262
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example18”
    />`'
- en: Note that the `finally` callback didn’t explicitly return any value, but the
    `finally` promise fulfilled with the fulfillment value of the original `pRequest`
    promise. This behavior is different than that of the `then` and `catch` methods;
    their promise is fulfilled with the value `undefined` if their callback implicitly
    returns `undefined`.
  id: totrans-263
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 注意，`finally`回调没有明确返回任何值，但`finally` promise 以原始`pRequest` promise 的履行值得到履行。这种行为与`then`和`catch`方法的行为不同；如果它们的回调隐式返回`undefined`，那么它们的
    promise 将以值`undefined`得到履行。
- en: 'Scenario 2: Original promise gets rejected'
  id: totrans-264
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 场景 2：原始 promise 被拒绝
- en: 假设调用`finally`方法的原始 promise 被拒绝。在这种情况下，`finally`方法返回的 promise 也会以与原始 promise
    相同的拒绝值被拒绝，前提是满足之前提到的相同两个条件：
  id: totrans-265
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 假设调用`finally`方法的原始 promise 被拒绝。在这种情况下，`finally`方法返回的 promise 也会以与原始 promise
    相同的拒绝值被拒绝，前提是满足之前提到的相同两个条件：
- en: '`finally`回调不会抛出错误或值。'
  id: totrans-266
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`finally`回调不会抛出错误或值。'
- en: '`finally`回调不会返回被拒绝的 promise 或最终被拒绝的 promise。'
  id: totrans-267
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`finally`回调不会返回被拒绝的 promise 或最终被拒绝的 promise。'
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 下面是 Replit 中的代码：
  id: totrans-269
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 下面是 Replit 中的代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example19”
    />`'
  id: totrans-270
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example19”
    />`'
- en: 场景 3：遮蔽原始 promise 的结算
  id: totrans-271
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 场景 3：遮蔽原始 promise 的结算
- en: 与`then`和`catch`方法不同，`finally`回调的返回值被忽略，`finally`方法返回的 promise 简单地与调用它的原始 promise
    同样的命运；如果原始 promise 被满足，`finally` promise 也会被满足；如果原始 promise 被拒绝，`finally` promise
    也会被拒绝。
  id: totrans-272
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与`then`和`catch`方法不同，`finally`回调的返回值被忽略，`finally`方法返回的 promise 简单地与调用它的原始 promise
    同样的命运；如果原始 promise 被满足，`finally` promise 也会被满足；如果原始 promise 被拒绝，`finally` promise
    也会被拒绝。
- en: 然而，`finally`方法的前两个场景中提到的两个条件是这个规则的例外。如果`finally`回调抛出错误，`finally` promise 将以抛出的值被拒绝。
  id: totrans-273
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，`finally`方法的前两个场景中提到的两个条件是这个规则的例外。如果`finally`回调抛出错误，`finally` promise 将以抛出的值被拒绝。
- en: '[PRE38]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 你可以在下面的 Replit 中运行上述代码：
  id: totrans-275
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的 Replit 中运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example20”
    />`'
  id: totrans-276
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example20”
    />`'
- en: '`finally`方法的拒绝遮蔽了原始`pRequest` promise 的拒绝。如果`pRequest` promise 被满足，也会发生同样的情况。从`finally`回调中抛出错误会简单地拒绝`finally`
    promise，而不管原始 promise 发生了什么。'
  id: totrans-277
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`finally`方法的拒绝遮蔽了原始`pRequest` promise 的拒绝。如果`pRequest` promise 被满足，也会发生同样的情况。从`finally`回调中抛出错误会简单地拒绝`finally`
    promise，而不管原始 promise 发生了什么。'
- en: 同样，从`finally`回调返回一个被拒绝的 promise 也会拒绝`finally` promise，而不管原始 promise 发生了什么。
  id: totrans-278
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 同样，从`finally`回调返回一个被拒绝的 promise 也会拒绝`finally` promise，而不管原始 promise 发生了什么。
- en: '[PRE39]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 你可以在下面的 Replit 中运行上述代码：
  id: totrans-280
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的 Replit 中运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example21”
    />`'
  id: totrans-281
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example21”
    />`'
- en: 理解 promise 链接
  id: totrans-282
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 理解 promise 链接
- en: 我们已经讨论了每个 promise 实例方法返回的 promise 可以拒绝或满足的每种场景。最后，我们可以理解 promise 链是如何工作的。我们将通过一系列示例来巩固我们的理解。
  id: totrans-283
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们已经讨论了每个 promise 实例方法返回的 promise 可以拒绝或满足的每种场景。最后，我们可以理解 promise 链是如何工作的。我们将通过一系列示例来巩固我们的理解。
- en: 示例 1
  id: totrans-284
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 示例 1
- en: '[PRE40]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 你可以在下面的 Replit 中运行上述代码：
  id: totrans-286
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的 Replit 中运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example22”
    />`'
  id: totrans-287
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example22”
    />`'
- en: 你在上述代码示例中预期的输出是什么？请记住，每个实例方法返回一个新的 promise，它的满足或拒绝取决于两个因素：
  id: totrans-288
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你在上述代码示例中预期的输出是什么？请记住，每个实例方法返回一个新的 promise，它的满足或拒绝取决于两个因素：
- en: 调用该方法的原始 promise 会发生什么？
  id: totrans-289
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 调用该方法的原始 promise 会发生什么？
- en: 什么会发生在该方法的回调函数内部？
  id: totrans-290
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 什么会发生在该方法的回调函数内部？
- en: 考虑到上述不同场景，这些场景可以使每个 promise 实例方法返回的 promise 被满足或拒绝，尝试通过猜测上述代码的输出测试你的理解。下面是对上述代码输出的解释：
  id: totrans-291
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 考虑到上述不同场景，这些场景可以使每个 promise 实例方法返回的 promise 被满足或拒绝，尝试通过猜测上述代码的输出测试你的理解。下面是对上述代码输出的解释：
- en: 从承诺链的顶部开始，`fakeRequest`函数返回的承诺将被履行，从而调用其使用第一个`then`方法的首次调用注册的履行处理程序。因此，以下内容将在控制台上记录：
  id: totrans-292
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 从承诺链的顶部开始，`fakeRequest`函数返回的承诺将被履行，从而调用其使用第一个`then`方法的首次调用注册的履行处理程序。因此，以下内容将在控制台上记录：
- en: '[PRE41]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`fakeRequest`函数返回的承诺已解决。链中的下一个承诺是由第一个`then`方法调用返回的承诺。当原始承诺得到履行时，第一个`then`承诺现在依赖于其回调函数内部发生的事情。由于它返回字符串“hello
    world”，第一个`then`承诺将以“hello world”作为履行值来履行。'
  id: totrans-294
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`fakeRequest`函数返回的承诺已解决。链中的下一个承诺是由第一个`then`方法调用返回的承诺。当原始承诺得到履行时，第一个`then`承诺现在依赖于其回调函数内部发生的事情。由于它返回字符串“hello
    world”，第一个`then`承诺将以“hello world”作为履行值来履行。'
- en: 结果是，它的履行处理程序被调用，该处理程序是使用第二个`then`方法调用注册的。第一个`then`承诺的履行处理程序将其履行值，即“hello world”，作为参数接收。这导致“hello
    world”被记录到控制台。目前的控制台输出如下所示：
  id: totrans-295
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 结果是，它的履行处理程序被调用，该处理程序是使用第二个`then`方法调用注册的。第一个`then`承诺的履行处理程序将其履行值，即“hello world”，作为参数接收。这导致“hello
    world”被记录到控制台。目前的控制台输出如下所示：
- en: '[PRE42]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 此时，承诺链中的两个承诺已解决。链中的下一个承诺是由第二个`then`方法返回的。与第一个`then`方法一样，第二个`then`方法返回的承诺依赖于其被调用的原始承诺，即第一个`then`方法返回的承诺。当原始承诺得到履行时，第二个`then`承诺现在依赖于其回调函数内部发生的事情。它的回调返回字符串“123”。因此，第二个`then`承诺以“123”作为其履行值来履行。
  id: totrans-297
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 此时，承诺链中的两个承诺已解决。链中的下一个承诺是由第二个`then`方法返回的。与第一个`then`方法一样，第二个`then`方法返回的承诺依赖于其被调用的原始承诺，即第一个`then`方法返回的承诺。当原始承诺得到履行时，第二个`then`承诺现在依赖于其回调函数内部发生的事情。它的回调返回字符串“123”。因此，第二个`then`承诺以“123”作为其履行值来履行。
- en: 但是没有为第二个`then`承诺注册履行处理程序；只有使用`catch`方法注册了拒绝处理程序。因此，没有履行处理程序会在响应第二个`then`方法的履行时被调用。承诺链移动到链中的最后一个承诺，即`catch`方法返回的承诺。
  id: totrans-298
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 但是没有为第二个`then`承诺注册履行处理程序；只有使用`catch`方法注册了拒绝处理程序。因此，没有履行处理程序会在响应第二个`then`方法的履行时被调用。承诺链移动到链中的最后一个承诺，即`catch`方法返回的承诺。
- en: '`catch`方法返回的承诺是在第二个`then`方法返回的承诺上调用的。当第二个`then`承诺得到履行时，`catch`承诺也会以与第二个`then`承诺相同的履行值得到履行。但是，没有为`catch`承诺注册履行或拒绝处理程序，因此其履行被简单忽略。代码的最终输出如下所示：'
  id: totrans-299
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`catch`方法返回的承诺是在第二个`then`方法返回的承诺上调用的。当第二个`then`承诺得到履行时，`catch`承诺也会以与第二个`then`承诺相同的履行值得到履行。但是，没有为`catch`承诺注册履行或拒绝处理程序，因此其履行被简单忽略。代码的最终输出如下所示：'
- en: '[PRE43]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 示例 2
  id: totrans-301
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 示例 2
- en: '[PRE44]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 你可以在下面的Replit中运行上述代码：
  id: totrans-303
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的 Replit 中运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example23”
    />`'
  id: totrans-304
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example23”
    />`'
- en: 以下是对上述代码生成的输出的解释：
  id: totrans-305
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下是对上述代码生成的输出的解释：
- en: 从承诺链的顶部开始，`fakeRequest`函数返回的承诺将被履行，从而调用其使用第一个`then`方法的首次调用注册的履行处理程序。因此，以下内容将在控制台上记录：
  id: totrans-306
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 从承诺链的顶部开始，`fakeRequest`函数返回的承诺将被履行，从而调用其使用第一个`then`方法的首次调用注册的履行处理程序。因此，以下内容将在控制台上记录：
- en: '[PRE45]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 由`fakeRequest`函数返回的承诺已经完成。链中的下一个承诺是由第一个`then`方法调用返回的承诺。由于原始承诺已完成，第一个`then`承诺现在依赖于其回调函数内部发生的事情。由于它通过调用`fakeRequest`函数返回一个新承诺，第一个`then`承诺将被`resolved`为其回调函数返回的承诺。`then`承诺将在其回调函数返回的承诺完成之前等待其自身完成。
  id: totrans-308
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 由`fakeRequest`函数返回的承诺已经完成。链中的下一个承诺是由第一个`then`方法调用返回的承诺。由于原始承诺已完成，第一个`then`承诺现在依赖于其回调函数内部发生的事情。由于它通过调用`fakeRequest`函数返回一个新承诺，第一个`then`承诺将被`resolved`为其回调函数返回的承诺。`then`承诺将在其回调函数返回的承诺完成之前等待其自身完成。
- en: 返回自第一个`then`方法的回调函数的承诺将在大约两秒后完成。它完成后，`then`方法返回的承诺将以与其回调返回的承诺相同的完成值完成。因此，它的完成处理程序被调用，这是通过第二个`then`方法调用注册的。第一个`then`承诺的完成处理程序将其完成值作为参数接收，并在完成处理程序内部记录。到目前为止，控制台输出如下所示：
  id: totrans-309
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 返回自第一个`then`方法的回调函数的承诺将在大约两秒后完成。它完成后，`then`方法返回的承诺将以与其回调返回的承诺相同的完成值完成。因此，它的完成处理程序被调用，这是通过第二个`then`方法调用注册的。第一个`then`承诺的完成处理程序将其完成值作为参数接收，并在完成处理程序内部记录。到目前为止，控制台输出如下所示：
- en: '[PRE46]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 此时，承诺链中的两个承诺已完成。链中的下一个承诺是由第二个`then`方法返回的。与第一个`then`方法一样，第二个`then`方法返回的承诺依赖于其调用的原始承诺，即由第一个`then`方法返回的承诺。由于原始承诺已完成，第二个`then`承诺现在依赖于其回调函数内部发生的事情。它的回调隐式返回`undefined`。因此，第二个`then`承诺以`undefined`作为其完成值完成。
  id: totrans-311
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 此时，承诺链中的两个承诺已完成。链中的下一个承诺是由第二个`then`方法返回的。与第一个`then`方法一样，第二个`then`方法返回的承诺依赖于其调用的原始承诺，即由第一个`then`方法返回的承诺。由于原始承诺已完成，第二个`then`承诺现在依赖于其回调函数内部发生的事情。它的回调隐式返回`undefined`。因此，第二个`then`承诺以`undefined`作为其完成值完成。
- en: 但是没有为第二个`then`承诺注册完成处理程序；只有通过`catch`方法注册了拒绝处理程序。因此，没有完成处理程序在响应第二个`then`方法的完成时被调用。承诺链移动到链中的最后一个承诺，即由`catch`方法返回的承诺。
  id: totrans-312
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 但是没有为第二个`then`承诺注册完成处理程序；只有通过`catch`方法注册了拒绝处理程序。因此，没有完成处理程序在响应第二个`then`方法的完成时被调用。承诺链移动到链中的最后一个承诺，即由`catch`方法返回的承诺。
- en: '`catch`方法返回的承诺是在由第二个`then`方法返回的承诺上调用的。由于第二个`then`承诺已完成，`catch`承诺也将以与第二个`then`承诺相同的完成值完成。但是没有为`catch`承诺注册完成或拒绝处理程序，因此其完成被简单忽略。代码的最终输出如下所示：'
  id: totrans-313
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`catch`方法返回的承诺是在由第二个`then`方法返回的承诺上调用的。由于第二个`then`承诺已完成，`catch`承诺也将以与第二个`then`承诺相同的完成值完成。但是没有为`catch`承诺注册完成或拒绝处理程序，因此其完成被简单忽略。代码的最终输出如下所示：'
- en: '[PRE47]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 示例3
  id: totrans-315
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 示例3
- en: '[PRE48]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 您可以在下面的Replit中运行上述代码：
  id: totrans-317
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 您可以在下面的Replit中运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example24”
    />`'
  id: totrans-318
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/promise-chaining-example24”
    />`'
- en: 下面是对上述代码生成的输出的解释：
  id: totrans-319
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 下面是对上述代码生成的输出的解释：
- en: Starting from the top of the promise chain, the promise returned by the `fakeRequest`
    function will get rejected, but there is no rejection handler registered for this
    promise; only a fulfillment handler is registered. As a result, no rejection handler
    will be invoked for this promise. We move on to the next promise in the chain.
  id: totrans-320
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 从承诺链的顶部开始，`fakeRequest`函数返回的承诺将被拒绝，但对此承诺没有注册拒绝处理程序；只注册了履行处理程序。因此，对于这个承诺不会调用拒绝处理程序。我们继续处理链中的下一个承诺。
- en: 'The promise returned by the `fakeRequest` function has been settled. The next
    promise in the chain is the one returned by the first `then` method call. As the
    original promise is rejected and no rejection handler was passed to the `then`
    method, the promise returned by the `then` method will also get rejected with
    the same rejection value as the original promise. As a result, its rejection handler,
    registered using the `catch` method, is invoked, logging the following on the
    console:'
  id: totrans-321
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`fakeRequest`函数返回的承诺已经解决。链中的下一个承诺是由第一个`then`方法调用返回的承诺。由于原始承诺被拒绝，并且没有拒绝处理程序传递给`then`方法，`then`方法返回的承诺也将以与原始承诺相同的拒绝值被拒绝。因此，它的拒绝处理程序通过`catch`方法注册并被调用，在控制台上记录以下内容：'
- en: '[PRE49]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The error object with which the first promise got rejected is the same value
    with which the promise returned by the `then` method also got rejected. The promise
    chain moves to the last promise in the chain, i.e., the one returned by the `catch`
    method.
  id: totrans-323
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 第一个承诺被拒绝时的错误对象是与`then`方法返回的承诺被拒绝时的值相同。承诺链移动到链中的最后一个承诺，即由`catch`方法返回的承诺。
- en: 'At this point, two promises in the promise chain have settled. The next promise
    in the chain is the one returned by the `catch` method. As the `then` promise
    is rejected, the promise returned by the `catch` method depends on what happens
    inside its callback. Its callback implicitly returns `undefined`, resulting in
    the `catch` promise getting fulfilled with `undefined` as a fulfillment value.
    But there is no fulfillment handler registered for the `catch` promise, so its
    fulfillment is simply ignored. The final output of the code is shown below:'
  id: totrans-324
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 此时，承诺链中的两个承诺已解决。链中的下一个承诺是由`catch`方法返回的承诺。由于`then`承诺被拒绝，`catch`方法返回的承诺依赖于其回调内部发生的事情。它的回调隐式返回`undefined`，导致`catch`承诺以`undefined`作为履行值完成。但是，`catch`承诺没有注册履行处理程序，因此其履行被简单忽略。代码的最终输出如下所示：
- en: '[PRE50]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: One thing to note in the above code example is that the rejection of the promise
    returned by the `fakeRequest` function was eventually handled by the rejection
    handler registered for the promise returned by the `then` method. This is one
    of the powers of promise chaining. Unlike callbacks, where we had to check for
    the error in every callback, with promise chaining, we can register one rejection
    handler, and it can handle the rejection of all the promises that come before
    it in the promise chain. We could have multiple `then` method calls in the promise
    chain and only one rejection handler at the end of the promise chain, registered
    using the `catch` method. This makes error handling easy to manage in a promise
    chain.
  id: totrans-326
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上述代码示例中需要注意的一点是，`fakeRequest`函数返回的承诺的拒绝最终是由为`then`方法返回的承诺注册的拒绝处理程序处理的。这就是承诺链的一种优势。与回调不同，我们需要在每个回调中检查错误，使用承诺链，我们可以注册一个拒绝处理程序，它可以处理所有在它之前的承诺链中的拒绝。我们可以在承诺链中有多个`then`方法调用，而在承诺链的末尾仅有一个拒绝处理程序，通过`catch`方法注册。这使得在承诺链中管理错误处理变得简单。
- en: Example 4
  id: totrans-327
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 示例 4
- en: '[PRE51]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can run the above code in the `Replit` below:'
  id: totrans-329
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的`Replit`中运行上述代码：
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example25"
    />`'
  id: totrans-330
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/promise-chaining-example25"
    />`'
- en: 'Below is an explanation of the output produced by the above code:'
  id: totrans-331
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下是上述代码产生的输出的解释：
- en: Starting from the top of the promise chain, the promise returned by the `fakeRequest`
    function will be fulfilled, resulting in the invocation of its fulfillment handler
    that is registered using the first invocation of the `then` method, passing the
    fulfillment value to its fulfillment handler as an argument.
  id: totrans-332
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 从承诺链的顶部开始，`fakeRequest`函数返回的承诺将被实现，导致调用通过第一次调用`then`方法注册的实现处理程序，将实现值作为参数传递给其实现处理程序。
- en: 由`fakeRequest`函数返回的承诺已经解决。链中的下一个承诺是由第一个`then`方法调用返回的。由于原始承诺已被实现，第一个`then`承诺现在依赖于其回调函数内部发生的情况。由于它通过调用`fakeRequest`函数返回一个新承诺，第一个`then`承诺将被*解析*为其回调函数返回的承诺。`then`承诺将等待其回调函数返回的承诺解决后再解决自身。
  id: totrans-333
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 由`fakeRequest`函数返回的承诺已经解决。链中的下一个承诺是由第一个`then`方法调用返回的。由于原始承诺已被实现，第一个`then`承诺现在依赖于其回调函数内部发生的情况。由于它通过调用`fakeRequest`函数返回一个新承诺，第一个`then`承诺将被*解析*为其回调函数返回的承诺。`then`承诺将等待其回调函数返回的承诺解决后再解决自身。
- en: 从第一个`then`方法的回调函数返回的承诺将在大约两秒后被拒绝。它一旦被拒绝，`then`方法返回的承诺也会以与其回调返回的承诺相同的拒绝值被拒绝。因此，其拒绝处理程序将被调用，该处理程序是通过第一次`catch`方法调用注册的。第一个`then`承诺的拒绝处理程序将其拒绝值作为参数接收。
  id: totrans-334
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 从第一个`then`方法的回调函数返回的承诺将在大约两秒后被拒绝。它一旦被拒绝，`then`方法返回的承诺也会以与其回调返回的承诺相同的拒绝值被拒绝。因此，其拒绝处理程序将被调用，该处理程序是通过第一次`catch`方法调用注册的。第一个`then`承诺的拒绝处理程序将其拒绝值作为参数接收。
- en: 此时，承诺链中的前两个承诺已经解决。链中的下一个承诺是由第一个`catch`方法返回的。由于调用`catch`方法的承诺被拒绝，第一个`catch`承诺现在依赖于其回调函数内部发生的情况。它返回一个对象字面量。因此，第一个`catch`承诺以返回的对象作为其实现值。
  id: totrans-335
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 此时，承诺链中的前两个承诺已经解决。链中的下一个承诺是由第一个`catch`方法返回的。由于调用`catch`方法的承诺被拒绝，第一个`catch`承诺现在依赖于其回调函数内部发生的情况。它返回一个对象字面量。因此，第一个`catch`承诺以返回的对象作为其实现值。
- en: 请注意，`catch`方法不一定必须位于承诺链的末尾；然而，`catch`方法通常放在承诺链的末尾。根据需求，`catch`方法可以放在链中的任何位置。在我们的代码示例中，它在第一个`then`方法之后被调用，以处理第一个`then`承诺的可能拒绝，通过返回默认数据并让链继续。如果第一个`then`承诺的拒绝没有被处理，所有在第一个`then`方法之后的`then`承诺也将以与第一个`then`承诺相同的拒绝值被拒绝，而拒绝最终将在最后一次`catch`方法调用中处理。
  id: totrans-336
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 请注意，`catch`方法不一定必须位于承诺链的末尾；然而，`catch`方法通常放在承诺链的末尾。根据需求，`catch`方法可以放在链中的任何位置。在我们的代码示例中，它在第一个`then`方法之后被调用，以处理第一个`then`承诺的可能拒绝，通过返回默认数据并让链继续。如果第一个`then`承诺的拒绝没有被处理，所有在第一个`then`方法之后的`then`承诺也将以与第一个`then`承诺相同的拒绝值被拒绝，而拒绝最终将在最后一次`catch`方法调用中处理。
- en: 此时，承诺链中的前三个承诺已经解决。链中的下一个承诺是由第二个`then`方法调用返回的。由于在其上调用第二个`then`方法的承诺（第一个`catch`承诺）已被实现，第二个`then`方法返回的承诺现在依赖于其回调函数内部发生的情况。其回调记录了第一个`catch`承诺的实现值并隐式返回`undefined`，导致第二个`then`承诺以`undefined`作为实现值被实现。以下是此时的控制台输出：
  id: totrans-337
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 此时，承诺链中的前三个承诺已经解决。链中的下一个承诺是由第二个`then`方法调用返回的。由于在其上调用第二个`then`方法的承诺（第一个`catch`承诺）已被实现，第二个`then`方法返回的承诺现在依赖于其回调函数内部发生的情况。其回调记录了第一个`catch`承诺的实现值并隐式返回`undefined`，导致第二个`then`承诺以`undefined`作为实现值被实现。以下是此时的控制台输出：
- en: '[PRE52]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: At this point, the first four promises in the promise chain have settled. The
    next promise in the chain is the one returned by the third `then` method call.
    As the promise (the second `then` promise) on which the third `then` method is
    called is fulfilled, the promise returned by the third `then` method now depends
    on what happens inside its callback function. Its callback throws an error, resulting
    in the third `then` promise getting rejected with the thrown error as the rejection
    reason or value. As a result, its rejection handler, registered using the last
    `catch` method, is invoked, passing in the rejection value as an argument.
  id: totrans-339
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 此时，承诺链中的前四个承诺已经解决。链中的下一个承诺是由第三个`then`方法调用返回的。由于在其上调用第三个`then`方法的承诺（第二个`then`承诺）已被实现，第三个`then`方法返回的承诺现在依赖于其回调函数内部发生的情况。它的回调抛出了一个错误，导致第三个`then`承诺以抛出的错误作为拒绝原因或值被拒绝。因此，最后一次`catch`方法注册的拒绝处理程序被调用，拒绝值作为参数传递。
- en: 'As the promise (the third `then` promise) on which the last `catch` method
    is called gets rejected, the last `catch` promise depends on what happens inside
    its callback function. Its callback logs the rejection value of the third `then`
    promise and implicitly returns `undefined`, resulting in the last `catch` promise
    getting fulfilled with `undefined` as the fulfillment value. But there is no fulfillment
    handler registered for the last `catch` promise, so its fulfillment is simply
    ignored. The final console output of the code is shown below:'
  id: totrans-340
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 由于最后一个`catch`方法调用的promise（第三个`then` promise）被拒绝，最后一个`catch` promise依赖于其回调函数内部发生的事情。其回调记录了第三个`then`
    promise的拒绝值，并隐式返回`undefined`，导致最后一个`catch` promise以`undefined`作为完成值得到满足。但最后一个`catch`
    promise没有注册完成处理程序，因此其满足被简单忽略。代码的最终控制台输出如下所示：
- en: '[PRE53]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Hopefully, the examples above, along with the earlier discussion in this lesson
    on different scenarios that can reject or fulfill the promise returned by each
    of the promise instance methods, have laid a solid foundation for understanding
    the promise chains and making use of them in your own code.
  id: totrans-342
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 希望上面的示例，以及本节中对可以拒绝或满足每个promise实例方法返回的promise的不同场景的讨论，为理解promise链并在自己的代码中使用它们奠定了坚实的基础。
- en: Rejection handler in `then` vs `catch`
  id: totrans-343
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`then`中的拒绝处理程序与`catch`'
- en: 'In the previous lesson, it was mentioned that a rejection handler can be registered
    by passing a second argument to the `then` method, as shown below:'
  id: totrans-344
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上一节中提到，可以通过将第二个参数传递给`then`方法来注册拒绝处理程序，如下所示：
- en: '[PRE54]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'There is one thing that should be kept in mind when registering a rejection
    handler using the `then` method: the rejection handler registered using the `then`
    method is not invoked if the promise returned by the `then` method, to which the
    rejection handler is passed as an argument, gets rejected. The following code
    example shows this in action:'
  id: totrans-346
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在使用`then`方法注册拒绝处理程序时，有一点需要注意：如果`then`方法返回的promise被拒绝，那么传递给`then`方法的拒绝处理程序将不会被调用。以下代码示例展示了这一点：
- en: '[PRE55]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The rejection handler registered using the `then` method is only invoked if
    the original promise on which the `then` method is called gets rejected. As a
    result, we have an `unhandled promise rejection` in the above code example, which,
    in the worst case, can terminate the program. As a result, always remember to
    handle all the possible promise rejections in your code when working with promises.
  id: totrans-348
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 只有当调用`then`方法的原始promise被拒绝时，使用`then`方法注册的拒绝处理程序才会被调用。因此，在上面的代码示例中，我们遇到了`unhandled
    promise rejection`，这在最坏的情况下可能导致程序终止。因此，在处理promise时，请始终记得处理代码中所有可能的promise拒绝。
- en: 'In this lesson, we will discuss a couple of common use cases of the two [static
    methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#static_properties)
    of promises and learn how they can be useful. Other promise static methods are
    also useful, but in my opinion, the following two use cases are the most common
    ones:'
  id: totrans-349
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论两个promise的[静态方法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#static_properties)的常见用例，并学习它们的实用性。其他promise静态方法也很有用，但在我看来，以下两个用例是最常见的：
- en: Making concurrent requests
  id: totrans-350
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 发起并发请求
- en: Implementing request timeout
  id: totrans-351
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 实现请求超时
- en: Concurrent requests
  id: totrans-352
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 并发请求
- en: 想象一个场景，我们希望同时发起多个HTTP请求，并等待它们的集体结果。我们不能使用如下的promise链，因为这样会按顺序执行每个请求。
  id: totrans-353
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 想象一个场景，我们希望同时发起多个HTTP请求，并等待它们的集体结果。我们不能使用如下的promise链，因为这样会按顺序执行每个请求。
- en: '[PRE56]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 你可以在下面的Replit中运行上述代码：
  id: totrans-355
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的Replit中运行上述代码：
- en: <ReplitEmbed src="https://replit.com/@newlineauthors/static-promise-methods-example1"
    />
  id: totrans-356
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src="https://replit.com/@newlineauthors/static-promise-methods-example1"
    />
- en: 由于上述代码中的每个请求都是独立的，因此我们希望发起[并发](https://en.wikipedia.org/wiki/Concurrent_computing)请求，而不是按顺序发起请求。这可以通过使用`Promise.all`方法实现。它允许我们一个接一个地开始每个请求，而无需等待一个请求完成后再开始另一个请求。因此，所有三个请求都是并发发起的，我们可以等待它们的集体结果。
  id: totrans-357
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 由于上述代码中的每个请求都是独立的，因此我们希望发起[并发](https://en.wikipedia.org/wiki/Concurrent_computing)请求，而不是按顺序发起请求。这可以通过使用`Promise.all`方法实现。它允许我们一个接一个地开始每个请求，而无需等待一个请求完成后再开始另一个请求。因此，所有三个请求都是并发发起的，我们可以等待它们的集体结果。
- en: '`Promise.all`方法接收一个[可迭代对象](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)作为输入，并返回一个promise，只有在所有传递给它的promise都完成后才会完成。该方法返回的promise的完成值是一个数组，包含了所有传递给该方法作为输入的promise的完成值。如果任何输入的promise被拒绝，该方法返回的promise也会被拒绝。我们可以按照如下方式重写上述代码示例，使用`Promise.all`方法：'
  id: totrans-358
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Promise.all`方法接收一个[可迭代对象](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)作为输入，并返回一个promise，只有在所有传递给它的promise都完成后才会完成。该方法返回的promise的完成值是一个数组，包含了所有传递给该方法作为输入的promise的完成值。如果任何输入的promise被拒绝，该方法返回的promise也会被拒绝。我们可以按照如下方式重写上述代码示例，使用`Promise.all`方法：'
- en: '[PRE57]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 你可以在下面的Replit中运行上述代码：
  id: totrans-360
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的Replit中运行上述代码：
- en: <ReplitEmbed src="https://replit.com/@newlineauthors/static-promise-methods-example2"
    />
  id: totrans-361
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src="https://replit.com/@newlineauthors/static-promise-methods-example2"
    />
- en: 请求超时
  id: totrans-362
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 请求超时
- en: 有时，HTTP请求可能由于服务器上的某些问题而挂起。我们不希望请求在待处理状态下停留超过几秒钟。为了避免请求待处理时间过长，我们可以实现请求超时功能，以便让我们的代码知道请求正在花费超过预期的时间。这使我们能够采取适当的措施。
  id: totrans-363
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 有时，HTTP请求可能由于服务器上的某些问题而挂起。我们不希望请求在待处理状态下停留超过几秒钟。为了避免请求待处理时间过长，我们可以实现请求超时功能，以便让我们的代码知道请求正在花费超过预期的时间。这使我们能够采取适当的措施。
- en: 使用`Promise.race`方法，我们可以发起一个带有超时的HTTP请求。该方法与`Promise.all`方法类似，接收一个可迭代的promise集合，并返回一个promise，当输入的一个或多个promise中的任何一个完成时，它就会完成。同样，当任何一个输入promise被拒绝时，该方法返回的promise也会被拒绝。
  id: totrans-364
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用`Promise.race`方法，我们可以发起一个带有超时的HTTP请求。该方法与`Promise.all`方法类似，接收一个可迭代的promise集合，并返回一个promise，当输入的一个或多个promise中的任何一个完成时，它就会完成。同样，当任何一个输入promise被拒绝时，该方法返回的promise也会被拒绝。
- en: 以下代码示例展示了如何使用`Promise.race`方法实现请求超时：
  id: totrans-365
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下代码示例展示了如何使用`Promise.race`方法实现请求超时：
- en: '[PRE58]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 你可以在下面的Replit中运行上述代码：
  id: totrans-367
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的Replit中运行上述代码：
- en: <ReplitEmbed src="https://replit.com/@newlineauthors/static-promise-methods-example3"
    />
  id: totrans-368
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src="https://replit.com/@newlineauthors/static-promise-methods-example3"
    />
- en: 在本课中，我们只讨论了两个静态方法，但值得学习`Promise`构造函数上其他可用的[静态方法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#static_methods)。每个静态方法都有其自己的使用场景；我们只讨论了我认为最常用的两个使用场景。
  id: totrans-369
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在本课中，我们只讨论了两个静态方法，但值得学习`Promise`构造函数上其他可用的[静态方法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#static_methods)。每个静态方法都有其自己的使用场景；我们只讨论了我认为最常用的两个使用场景。
- en: While promises have changed the way we write asynchronous code in JavaScript,
    we still use callbacks to register fulfillment and rejection handlers with promises.
    Some people might view using callbacks with promises as verbose, even though promises
    solve the problem of “Callback Hell” and the problem of error handling using the
    traditional way of using callbacks. What if there was an easier, more concise,
    and more intuitive way to deal with promises? What if we could get rid of callbacks
    when using promises? Enter `async await`!
  id: totrans-370
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 虽然promise改变了我们在JavaScript中编写异步代码的方式，但我们仍然使用回调来注册promise的成功和拒绝处理程序。尽管promise解决了“回调地狱”和传统回调方式中的错误处理问题，但一些人可能会将使用回调与promise结合看作是冗长的。那么有没有更简单、更简洁、更直观的方式来处理promise呢？如果我们在使用promise时能摆脱回调，那该多好！这就是`async
    await`的优势！
- en: The `async await` can be considered a syntax sugar over the traditional way
    of using promises. It allows us to deal with promises using code that executes
    asynchronously but looks synchronous. It also allows us to write more concise
    code that is easier to reason about, as the code doesn’t include callbacks, and
    the flow of the code looks like that of synchronous code.
  id: totrans-371
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`async await`可以被视为传统使用promise方式的语法糖。它允许我们使用异步执行的代码处理promise，但看起来是同步的。这也使我们能够编写更简洁的代码，更容易理解，因为代码不包含回调，代码流看起来像是同步代码的流。 '
- en: 'Let’s take a look at the following code example that uses promise chaining:'
  id: totrans-372
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们看看下面这个使用promise链的代码示例：
- en: '[PRE59]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here’s a `Replit` where you can run the above code:'
  id: totrans-374
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是一个`Replit`，你可以在这里运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example1”
    />`'
  id: totrans-375
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/async-await-example1"
    />`'
- en: 'The code above is certainly an improvement over the traditional way of using
    callbacks for writing asynchronous code, but it still has room for improvement,
    at least in terms of readability. The `async await` syntax can be used to rewrite
    the above code example as shown below:'
  id: totrans-376
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上述代码确实比传统的使用回调编写异步代码的方式有所改善，但在可读性方面仍然有提升空间。`async await`语法可以用来重写上述代码示例，如下所示：
- en: '[PRE60]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here’s a `Replit` where you can run the above code:'
  id: totrans-378
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是一个`Replit`，你可以在这里运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example2”
    />`'
  id: totrans-379
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/async-await-example2"
    />`'
- en: The revised code achieves the same result but is more readable, doesn’t use
    any callbacks, and is easier to reason about as compared to the earlier example
    that uses promise chaining. Although the code looks like synchronous code, it
    is asynchronous. Let us understand how `async await` works.
  id: totrans-380
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 修改后的代码实现了相同的结果，但更具可读性，不使用任何回调，并且相比于早期使用promise链的示例，更容易理解。尽管代码看起来像是同步代码，但它实际上是异步的。让我们来理解一下`async
    await`是如何工作的。
- en: 'Two things should be noted in the code example above that uses the `async await`
    syntax: the `async` keyword in the function signature and the `await` keyword
    inside the function. Following are the two main steps to using the `async await`
    syntax:'
  id: totrans-381
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上述使用`async await`语法的代码示例中，有两点需要注意：函数签名中的`async`关键字和函数内部的`await`关键字。使用`async
    await`语法的主要步骤如下：
- en: Mark any function as “async” using the `async` keyword. This is needed because
    the `await` keyword can only be used inside an “async” function.
  id: totrans-382
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 使用`async`关键字将任何函数标记为“async”。这是必要的，因为`await`关键字只能在“async”函数内部使用。
- en: Use the `await` keyword inside the `async` function to wait for any promises
    to settle.
  id: totrans-383
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 在`async`函数内部使用`await`关键字来等待任何promise的解决。
- en: :::info While the `await` keyword is mostly used inside an `async` function
    because the `await` keyword was only allowed inside `async` functions until a
    recent change in the language that allows using the [await keyword at the top-level
    of a module](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#top_level_await)
  id: totrans-384
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: :::info 虽然 `await` 关键字大多在 `async` 函数内部使用，因为在最近语言的变更之前，`await` 关键字仅被允许在 `async`
    函数内部使用，现在可以在模块的顶部使用 [await 关键字](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#top_level_await)。
- en: '::::'
  id: totrans-385
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '::::'
- en: '`async` functions'
  id: totrans-386
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`async` 函数'
- en: 'An `async` function allows the use of the `await` keyword inside its body.
    An `async` function is different from a non-async function because an `async`
    function always returns a promise. An `async` function implicitly creates and
    returns a promise, similar to how each promise instance method creates and returns
    a new promise. The following code verifies this claim:'
  id: totrans-387
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`async` 函数允许在其体内使用 `await` 关键字。`async` 函数与非 `async` 函数不同，因为 `async` 函数始终返回一个承诺。`async`
    函数隐式创建并返回一个承诺，类似于每个承诺实例方法创建并返回一个新的承诺。以下代码验证了这一说法：'
- en: '[PRE61]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here’s a Replit where you can run the above code:'
  id: totrans-389
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里有一个 Replit，你可以运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example3”
    />`'
  id: totrans-390
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/async-await-example3"
    />`'
- en: 'The fulfillment or rejection of the promise returned by an `async` function
    depends on what happens inside its body, similar to how the promise returned by
    each of the promise instance methods depends on the events occurring within its
    callback function. The following points summarize the settlement of the `async`
    function promise:'
  id: totrans-391
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`async` 函数返回的承诺的兑现或拒绝取决于其体内发生的事情，类似于每个承诺实例方法返回的承诺依赖于其回调函数内发生的事件。以下几点总结了 `async`
    函数承诺的结算：'
- en: Returning any non-promise value from an `async` function leads to the fulfillment
    of the `async` function promise, using the returned value as the fulfillment value.
  id: totrans-392
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 从 `async` 函数返回任何非承诺值会导致 `async` 函数的承诺被兑现，使用返回的值作为兑现值。
- en: '[PRE62]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here’s a Replit where you can run the above code:'
  id: totrans-394
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里有一个 Replit，你可以运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example4”
    />`'
  id: totrans-395
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/async-await-example4"
    />`'
- en: Not returning any value from the function implicitly returns `undefined`. This
    leads to the function promise getting fulfilled with `undefined` as the fulfillment
    value.
  id: totrans-396
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 不从函数返回任何值会隐式返回 `undefined`。这会导致函数的承诺以 `undefined` 作为兑现值。
- en: '[PRE63]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here’s a Replit where you can run the above code:'
  id: totrans-398
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里有一个 Replit，你可以运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example5”
    />`'
  id: totrans-399
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/async-await-example5"
    />`'
- en: Throwing an error inside the `async` function rejects the `async` function promise,
    using the thrown value as the rejection reason.
  id: totrans-400
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 在 `async` 函数内部抛出错误会拒绝该 `async` 函数的承诺，并使用抛出的值作为拒绝原因。
- en: '[PRE64]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here’s a Replit where you can run the above code:'
  id: totrans-402
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里有一个 Replit，你可以运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example6”
    />`'
  id: totrans-403
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/async-await-example6"
    />`'
- en: Returning a promise from the `async` function results in the `async` function
    promise getting `resolved` to the promise returned inside the function body. As
    we learned about one promise `resolving` to another promise in one of the earlier
    lessons in this module, the promise created by the `async` function will wait
    for the promise, returned inside its body, to settle. Eventually, the `async`
    function promise will be fulfilled or rejected depending on what happens to the
    promise returned inside the `async` function.
  id: totrans-404
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 从 `async` 函数返回一个承诺会使该 `async` 函数的承诺被 `resolved` 为函数体内返回的承诺。正如我们在本模块之前的某个课程中学习到的，一个承诺可能会“解析”到另一个承诺，`async`
    函数创建的承诺将等待函数体内返回的承诺完成。最终，`async` 函数的承诺将根据其内部返回的承诺的结果被兑现或拒绝。
- en: '[PRE65]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here’s a Replit where you can run the above code:'
  id: totrans-406
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里有一个 Replit，你可以运行上述代码：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example7”
    />`'
  id: totrans-407
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/async-await-example7"
    />`'
- en: '`await` keyword'
  id: totrans-408
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`await` 关键字'
- en: 'The `await` keyword, also referred to as the `await` operator, is used to wait
    for a promise to settle. The following is an example of using the `await` keyword
    to wait for a promise to settle:'
  id: totrans-409
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`await` 关键字，也称为 `await` 操作符，用于等待承诺完成。以下是使用 `await` 关键字等待承诺完成的示例：'
- en: '[PRE66]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `await fetch(url)` is an expression that will either evaluate the fulfillment
    value of the promise returned by the `fetch` function or it will throw the rejection
    value if the promise returned by the `fetch` function gets rejected. The thrown
    value can either be caught in the `catch` block of the surrounding `try-catch`
    block or, if `try-catch` is not wrapped around the `await` statement, rejection
    of the `awaited` promise can reject the `async` function promise, allowing the
    calling code to handle the promise rejection.
  id: totrans-411
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`await fetch(url)` 是一个表达式，它将评估 `fetch` 函数返回的 promise 的实现值，或者如果 `fetch` 函数返回的
    promise 被拒绝，则会抛出拒绝值。抛出的值可以在外围 `try-catch` 块的 `catch` 块中捕获，或者如果 `await` 语句没有被 `try-catch`
    包裹，`awaited` promise 的拒绝将使 `async` 函数的 promise 被拒绝，从而允许调用代码处理 promise 的拒绝。'
- en: Unlike promise chaining, where we have to register the fulfillment handler to
    get the fulfillment value of the promise, the `await` expressions evaluate the
    promise fulfillment value, which we can save in a variable. But how does it work?
    Isn’t it blocking the main thread while waiting for the promise to settle?
  id: totrans-412
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与 promise 链接不同，在 promise 链接中我们必须注册实现处理器以获取 promise 的实现值，而 `await` 表达式评估 promise
    的实现值，我们可以将其保存在变量中。但它是如何工作的呢？在等待 promise 解决时，不是阻塞主线程吗？
- en: Whenever an `async` function is called, it is executed synchronously until the
    first `await` expression is encountered. The function’s execution is suspended
    or paused until the awaited promise is settled. Instead of blocking the main thread,
    the function’s execution is paused, and in the meantime, the main thread is free
    to do other things. When the promise is eventually settled, the function’s execution
    is resumed, resuming the code execution after the `await` expression if the promise
    is fulfilled or throwing the rejection value of the promise if the awaited promise
    is rejected.
  id: totrans-413
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 每当调用 `async` 函数时，它会同步执行，直到遇到第一个 `await` 表达式。函数的执行会暂停，直到等待的 promise 被解决。它并不是阻塞主线程，而是函数的执行暂停，同时主线程可以自由处理其他事务。当
    promise 最终被解决时，函数的执行恢复，如果 promise 被实现，代码在 `await` 表达式后继续执行；如果等待的 promise 被拒绝，则抛出
    promise 的拒绝值。
- en: 'What’s important to note is that the code inside the `async` function is executed
    synchronously until the first `await` expression. What if the `async` function
    doesn’t have the `await` keyword inside it? Will the function execute synchronously?
    Yes, it will, but keep in mind that the `async` function always returns a promise,
    and it will either get fulfilled or rejected depending on what happens inside
    the `async` function. This means that the following code doesn’t work as one might
    expect:'
  id: totrans-414
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 重要的是要注意，`async` 函数内部的代码会同步执行，直到第一个 `await` 表达式。如果 `async` 函数内部没有 `await` 关键字，函数会同步执行吗？是的，但请记住，`async`
    函数始终返回一个 promise，它将根据 `async` 函数内部的情况被实现或拒绝。这意味着以下代码并不会按预期工作：
- en: '[PRE67]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `async` function in the above code example didn’t use the `await` keyword,
    so the code inside it is executed synchronously, but does it return the value
    `“123”` synchronously as well? No, it doesn’t. The function is `async`, which
    means it returns a promise, so the `result` in the above example contains the
    promise and not the value `“123”`. To get the fulfillment value of the promise,
    we can either use promise chaining as shown below:'
  id: totrans-416
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上述代码示例中的 `async` 函数没有使用 `await` 关键字，因此其内部代码是同步执行的，但它是否也同步返回值 `“123”`？不，它不会。该函数是
    `async`，这意味着它返回一个 promise，因此上述示例中的 `result` 包含的是 promise 而不是值 `“123”`。要获取 promise
    的实现值，我们可以使用如下所示的 promise 链接：
- en: '[PRE68]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here’s a `Replit` where you can run the above code:'
  id: totrans-418
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是一个可以运行上述代码的 `Replit`：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example10”
    />`'
  id: totrans-419
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example10”
    />`'
- en: 'Or `await` the promise returned by the `foo` function using the `async await`
    syntax as shown below:'
  id: totrans-420
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 或者使用如下所示的 `async await` 语法 `await` `foo` 函数返回的 promise：
- en: '[PRE69]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here’s a `Replit` where you can run the above code:'
  id: totrans-422
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是一个可以运行上述代码的 `Replit`：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example11”
    />`'
  id: totrans-423
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example11”
    />`'
- en: Multiple `await` expressions
  id: totrans-424
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 多个 `await` 表达式
- en: An `async` function is not limited to using the `await` keyword only once inside
    its body. You can use the `await` keyword as many times as you want inside an
    `async` function. The only thing to be aware of regarding multiple `await` expressions
    is that they are not executed in parallel; instead, they are executed in sequence,
    one after the other. The function execution will be paused at each `await` expression,
    and the next `await` expression can only be executed after the ones before it
    has been executed.
  id: totrans-425
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`async`函数并不局限于在其主体内只使用一次`await`关键字。您可以在`async`函数内多次使用`await`关键字。需要注意的唯一事项是多个`await`表达式不会并行执行；相反，它们是顺序执行的，一个接一个。函数执行将在每个`await`表达式处暂停，只有在前面的表达式执行完后，才能执行下一个`await`表达式。'
- en: '[PRE70]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here’s a `Replit` where you can run the above code:'
  id: totrans-427
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是一个可以运行上述代码的`Replit`：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example12”
    />`'
  id: totrans-428
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example12”
    />`'
- en: Each of the `await` expressions in the above code example takes approximately
    1 second, so the function takes approximately 3 seconds to evaluate all the `await`
    expressions, logging their value at the end.
  id: totrans-429
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上述代码示例中的每个`await`表达式大约需要1秒钟，因此函数大约需要3秒钟来评估所有的`await`表达式，并在最后记录它们的值。
- en: '[PRE71]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here’s a `Replit` where you can run the above code:'
  id: totrans-431
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是一个可以运行上述代码的`Replit`：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example13”
    />`'
  id: totrans-432
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example13”
    />`'
- en: The two `await` expressions in the above code example are also not executed
    in parallel; instead, they are executed one after the other, from left to right.
  id: totrans-433
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上述代码示例中的两个`await`表达式也不是并行执行的；相反，它们是一个接一个地执行，从左到右。
- en: Suppose we want concurrent asynchronous operations inside an `async` function.
    In that case, we can use the `Promise.all` function, providing all the promises
    as input and awaiting the promise returned by `Promise.all`.
  id: totrans-434
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 假设我们想在`async`函数内进行并发异步操作。在这种情况下，我们可以使用`Promise.all`函数，将所有的承诺作为输入，并等待`Promise.all`返回的承诺。
- en: '[PRE72]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here’s a `Replit` where you can run the above code:'
  id: totrans-436
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是一个可以运行上述代码的`Replit`：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example14”
    />`'
  id: totrans-437
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example14”
    />`'
- en: Error handling
  id: totrans-438
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'To handle promise rejections inside an `async` function, we can wrap the `await`
    expressions with the `try-catch` block as shown below:'
  id: totrans-439
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 要在`async`函数内处理承诺拒绝，我们可以像下面所示用`try-catch`块包装`await`表达式：
- en: '[PRE73]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: If any of the promises awaited in the `try` block are rejected, the code after
    that `await` expression won’t be executed, and the execution will jump to the
    `catch` block. The `await` keyword throws the promise rejection value, allowing
    the `catch` block to catch the rejection.
  id: totrans-441
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果在`try`块中等待的任何承诺被拒绝，之后的`await`表达式后面的代码将不会被执行，执行将跳转到`catch`块。`await`关键字抛出承诺拒绝值，允许`catch`块捕获拒绝。
- en: 'Alternatively, we can omit the `try-catch` block, but in this case, the code
    that calls the `async` function must handle the promise rejection, either by using
    the promise chaining:'
  id: totrans-442
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 另外，我们可以省略`try-catch`块，但在这种情况下，调用`async`函数的代码必须处理承诺拒绝，方法是使用承诺链：
- en: '[PRE74]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'or using the `try-catch` block in the calling code if we are using the `async
    await` syntax:'
  id: totrans-444
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 或者在调用代码中使用`try-catch`块，如果我们使用`async await`语法：
- en: '[PRE75]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Returning vs awaiting promise
  id: totrans-446
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 返回与等待承诺
- en: 'Forgetting to `await` a promise inside an `async` function can lead to bugs,
    causing unexpected output. The code below shows the problem it can cause:'
  id: totrans-447
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 忘记在`async`函数内`await`一个承诺可能会导致错误，产生意外输出。下面的代码展示了它可能引起的问题：
- en: '[PRE76]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Here’s a `Replit` where you can run the above code:'
  id: totrans-449
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是一个可以运行上述代码的`Replit`：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example18”
    />`'
  id: totrans-450
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example18”
    />`'
- en: 'The `getPromise` function returns a promise that can be rejected, but the promise
    returned by the `foo` function is always fulfilled. Why? The `foo` function has
    a problem: it didn’t `return` or `await` the promise returned by the `getPromise`
    function. As a result, the `foo` function doesn’t wait for the promise returned
    by the `getPromise` function to settle; instead, it just calls the `getPromise`
    function, and the function execution ends, implicitly returning `undefined`, leading
    to the `foo` function promise getting fulfilled with `undefined` as the fulfillment
    value.'
  id: totrans-451
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`getPromise` 函数返回一个可能被拒绝的 promise，但 `foo` 函数返回的 promise 始终是被解决的。为什么？`foo` 函数有一个问题：它没有
    `return` 或 `await` `getPromise` 函数返回的 promise。因此，`foo` 函数不会等待 `getPromise` 函数返回的
    promise 完成；而只是调用 `getPromise` 函数，函数执行结束，隐式返回 `undefined`，导致 `foo` 函数的 promise
    以 `undefined` 作为解决值。'
- en: Further code examples will use the `getPromise` function defined above.
  id: totrans-452
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 进一步的代码示例将使用上面定义的 `getPromise` 函数。
- en: 'To catch the rejection of the promise returned by the `getPromise` function,
    we have the following options:'
  id: totrans-453
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 要捕获 `getPromise` 函数返回的 promise 的拒绝，我们有以下选项：
- en: '`return` the promise returned by the `getPromise` function.'
  id: totrans-454
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`return` `getPromise` 函数返回的 promise。'
- en: '[PRE77]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Here’s a Replit where you can run the above code:'
  id: totrans-456
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是一个可以运行上述代码的 Replit：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example19”
    />`'
  id: totrans-457
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example19”
    />`'
- en: Returning the promise `resolves` the `foo` function of the promise returned
    inside its body. As a result, whatever happens to the promise returned by `getPromise`,
    the `foo` function promise meets the same fate.
  id: totrans-458
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 返回的 promise `resolves` 了其内部返回的 promise 的 `foo` 函数。因此，无论`getPromise` 返回的 promise
    发生了什么，`foo` 函数的 promise 都会有相同的结果。
- en: '`await` the promise returned by the `getPromise` function.'
  id: totrans-459
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`await` `getPromise` 函数返回的 promise。'
- en: '[PRE78]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here’s a Replit where you can run the above code:'
  id: totrans-461
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是一个可以运行上述代码的 Replit：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example20”
    />`'
  id: totrans-462
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example20”
    />`'
- en: As mentioned earlier, if the awaited promise is rejected, its rejection value
    is thrown inside the `async` function. As there is no `try-catch` block inside
    the `foo` function, the promise rejection causes the `foo` function promise to
    also get rejected with the same rejection reason.
  id: totrans-463
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如前所述，如果被等待的 promise 被拒绝，其拒绝值会在 `async` 函数内部抛出。由于 `foo` 函数内部没有 `try-catch` 块，promise
    的拒绝导致 `foo` 函数的 promise 也会以相同的拒绝原因被拒绝。
- en: 'However, one thing to note in this code example is that if the promise returned
    by `getPromise` is fulfilled, the `foo` function promise doesn’t fulfill with
    its fulfillment value; instead, it fulfills with `undefined` as the fulfillment
    value because we didn’t explicitly return anything from the `foo` function, and
    we know what happens to the `async` function promise when we don’t explicitly
    return any value inside the function: the `async` function promise gets fulfilled
    with `undefined` as the fulfillment value.'
  id: totrans-464
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，这段代码示例中需要注意的一点是，如果 `getPromise` 返回的 promise 被解决，`foo` 函数的 promise 不会以其解决值被解决；相反，它以
    `undefined` 作为解决值被解决，因为我们没有明确从 `foo` 函数返回任何内容，我们知道当我们在 `async` 函数内部没有明确返回任何值时，`async`
    函数的 promise 会以 `undefined` 作为解决值被解决。
- en: '`await` the promise returned by the `getPromise` function and surround it with
    the `try-catch` block.'
  id: totrans-465
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`await` `getPromise` 函数返回的 promise，并用 `try-catch` 块包围它。'
- en: '[PRE79]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Here’s a Replit where you can run the above code:'
  id: totrans-467
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是一个可以运行上述代码的 Replit：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example21”
    />`'
  id: totrans-468
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/async-await-example21”
    />`'
- en: 等待`getPromise`调用将捕获promise拒绝，导致`catch`块执行。然而，`foo`函数返回的promise将始终被解决。为什么？因为`catch`块没有抛出错误或返回被拒绝的promise。结果，`foo`函数的promise总是以`catch`块的返回值解决。我们可以从`catch`中抛出错误来解决这个问题。话虽如此，如果我们在`catch`块中所做的只是抛出错误，那么最好省略`try-catch`块，让promise拒绝自动拒绝`foo`函数的promise。
  id: totrans-469
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 等待 `getPromise` 调用将捕获 promise 的拒绝，导致 `catch` 块执行。然而，`foo` 函数返回的 promise 将始终被解决。为什么？因为
    `catch` 块没有抛出错误或返回被拒绝的 promise。结果，`foo` 函数的 promise 总是以 `catch` 块的返回值解决。我们可以从
    `catch` 中抛出错误来解决这个问题。话虽如此，如果我们在 `catch` 块中所做的只是抛出错误，那么最好省略 `try-catch` 块，让 promise
    拒绝自动拒绝 `foo` 函数的 promise。
- en: 此代码示例中的另一个问题是，如果promise被解决而`catch`块从未执行，我们没有显式返回任何值。因此，`foo`函数的promise将以`undefined`解决。在`await`表达式前添加`return`关键字可以解决这个问题。
  id: totrans-470
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 此代码示例中的另一个问题是，如果 promise 被解决而 `catch` 块从未执行，我们没有显式返回任何值。因此，`foo` 函数的 promise
    将以 `undefined` 解决。在 `await` 表达式前添加 `return` 关键字可以解决这个问题。
- en: ':::caution 我们能不能只做`return getPromise();`而不是`return await getPromise();`？如果`await`表达式没有被包装在`try-catch`块中，我们是可以的。`try-catch`块有什么区别呢？有了`try-catch`块，`return
    getPromise();`将导致`foo`函数内的`catch`块永远不会执行。为了使`foo`函数中的`catch`块执行，我们需要在`try`块中`await`这个promise，而不仅仅是返回它。更多细节，请阅读：[await
    vs return vs return await](https://jakearchibald.com/2017/await-vs-return-vs-return-await/)
    :::'
  id: totrans-471
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: ':::caution 我们能不能只做`return getPromise();`而不是`return await getPromise();`？如果`await`表达式没有被包装在`try-catch`块中，我们是可以的。`try-catch`块有什么区别呢？有了`try-catch`块，`return
    getPromise();`将导致`foo`函数内的`catch`块永远不会执行。为了使`foo`函数中的`catch`块执行，我们需要在`try`块中`await`这个promise，而不仅仅是返回它。更多细节，请阅读：[await
    vs return vs return await](https://jakearchibald.com/2017/await-vs-return-vs-return-await/)
    :::'
- en: 等待非promise值
  id: totrans-472
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 等待非promise值
- en: '`await`关键字通常用于等待一个promise解决，但它也可以与非promise值一起使用。以下代码示例展示了这一行为：'
  id: totrans-473
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`await`关键字通常用于等待一个promise解决，但它也可以与非promise值一起使用。以下代码示例展示了这一行为：'
- en: '[PRE80]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 这是一个Replit，你可以运行上述代码：
  id: totrans-475
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是一个Replit，你可以运行上述代码：
- en: <ReplitEmbed src="https://replit.com/@newlineauthors/async-await-example22"
    />
  id: totrans-476
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src="https://replit.com/@newlineauthors/async-await-example22"
    />
- en: 如果你执行上述代码示例，你会注意到代码示例最后的`console.log`语句在随机数打印之前被记录，尽管函数在最后的`console.log`语句之前被调用。这是为什么呢？因为我们没有等待任何promise，所以这里发生了什么？
  id: totrans-477
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你执行上述代码示例，你会注意到代码示例最后的`console.log`语句在随机数打印之前被记录，尽管函数在最后的`console.log`语句之前被调用。这是为什么呢？因为我们没有等待任何promise，所以这里发生了什么？
- en: 当`await`关键字与非承诺值一起使用时，会创建一个新的承诺，该承诺会用我们在`await`关键字中使用的值来满足。在我们的代码示例中，我们等待了一个随机数；它不是一个承诺，因此会创建一个新的承诺，并用生成的随机数来满足。在`await`表达式之后的代码将被执行，就好像它在一个满足处理程序中一样。因此，当承诺被满足时，`await`表达式之后的代码并不会立即执行。它是异步执行的，正如我们在关于事件循环的课程中学到的，任何异步代码只有在我们代码的同步执行结束后才会被执行。最后的`console.log`语句作为我们代码的同步执行的一部分被执行。因此，它在随机数之前被记录。
  id: totrans-478
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当`await`关键字与非承诺值一起使用时，会创建一个新的承诺，该承诺会用我们在`await`关键字中使用的值来满足。在我们的代码示例中，我们等待了一个随机数；它不是一个承诺，因此会创建一个新的承诺，并用生成的随机数来满足。在`await`表达式之后的代码将被执行，就好像它在一个满足处理程序中一样。因此，当承诺被满足时，`await`表达式之后的代码并不会立即执行。它是异步执行的，正如我们在关于事件循环的课程中学到的，任何异步代码只有在我们代码的同步执行结束后才会被执行。最后的`console.log`语句作为我们代码的同步执行的一部分被执行。因此，它在随机数之前被记录。
- en: 使用`await`与非承诺值几乎没有用，但要注意的是，这种情况是可能的，该值会被隐式封装在一个承诺中。
  id: totrans-479
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用`await`与非承诺值几乎没有用，但要注意的是，这种情况是可能的，该值会被隐式封装在一个承诺中。
- en: 我们在本模块的早期课程中了解到，执行DOM事件监听器和`setTimeout`或`setInterval`回调需要调度一个“任务”。任务在任务队列中排队，直到事件循环处理它们。那么承诺的履行或拒绝处理程序呢？它们的执行是否也需要调度一个任务？并不是严格意义上的任务，而是一个“微任务”。
  id: totrans-480
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们在本模块的早期课程中了解到，执行DOM事件监听器和`setTimeout`或`setInterval`回调需要调度一个“任务”。任务在任务队列中排队，直到事件循环处理它们。那么承诺的履行或拒绝处理程序呢？它们的执行是否也需要调度一个任务？并不是严格意义上的任务，而是一个“微任务”。
- en: 微任务，ECMAScript规范称之为[jobs](https://tc39.es/ecma262/#sec-promise-jobs)，被调度用于比“任务”更高优先级的事情。微任务在以下情况下被处理：
  id: totrans-481
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 微任务，ECMAScript规范称之为[jobs](https://tc39.es/ecma262/#sec-promise-jobs)，被调度用于比“任务”更高优先级的事情。微任务在以下情况下被处理：
- en: 每个回调，只要调用栈是空的。
  id: totrans-482
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 每个回调，只要调用栈是空的。
- en: 每个任务
  id: totrans-483
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 每个任务
- en: “任务”按照它们在任务队列中排队的顺序执行，每个事件循环的一个轮次中只执行一个任务。
  id: totrans-484
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: “任务”按照它们在任务队列中排队的顺序执行，每个事件循环的一个轮次中只执行一个任务。
- en: 另一个关于微任务的重要注意事项是，虽然每个事件循环的滴答中仅处理一个任务，但微任务会一直处理，直到微任务队列为空。如果一个任务调度了另一个任务，它不会在下一个事件循环的轮次中被处理，但在微任务的情况下，如果一个微任务由另一个微任务排队，排队的微任务也将被处理。这意味着如果每个微任务不断排队另一个微任务，事件循环可能会陷入无限循环。
  id: totrans-485
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 另一个关于微任务的重要注意事项是，虽然每个事件循环的滴答中仅处理一个任务，但微任务会一直处理，直到微任务队列为空。如果一个任务调度了另一个任务，它不会在下一个事件循环的轮次中被处理，但在微任务的情况下，如果一个微任务由另一个微任务排队，排队的微任务也将被处理。这意味着如果每个微任务不断排队另一个微任务，事件循环可能会陷入无限循环。
- en: 考虑以下代码示例：
  id: totrans-486
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 考虑以下代码示例：
- en: '[PRE81]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 这是上面代码在行动中的一个Replit：
  id: totrans-488
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是上面代码在行动中的一个Replit：
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/microtasks-example1"
    />`'
  id: totrans-489
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/microtasks-example1"
    />`'
- en: 执行上述代码需要调度任务和微任务。以下步骤解释了如何调度不同的任务和微任务以执行上述代码：
  id: totrans-490
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 执行上述代码需要调度任务和微任务。以下步骤解释了如何调度不同的任务和微任务以执行上述代码：
- en: 创建一个任务来执行脚本，开始代码的同步执行。
  id: totrans-491
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 创建一个任务来执行脚本，开始代码的同步执行。
- en: 第一个`console.log`语句被执行，在控制台上记录“start”。
  id: totrans-492
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 第一个`console.log`语句被执行，在控制台上记录“start”。
- en: '[PRE82]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 接下来，我们有一个`setTimeout`调用，延迟500毫秒。这在后台启动一个定时器，其到期将导致一个任务被排队到任务队列中以执行`setTimeout`回调。
  id: totrans-494
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，我们有一个`setTimeout`调用，延迟500毫秒。这在后台启动一个定时器，其到期将导致一个任务被排队到任务队列中以执行`setTimeout`回调。
- en: '[PRE83]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 继续进行代码的同步执行，调用`Promise.resolve`，它创建了一个已解决的承诺。为了执行其履行处理程序，一个微任务或工作被排队到微任务队列中。
  id: totrans-496
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 继续进行代码的同步执行，调用`Promise.resolve`，它创建了一个已解决的承诺。为了执行其履行处理程序，一个微任务或工作被排队到微任务队列中。
- en: '[PRE84]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 接下来，我们有一个`setTimeout`调用，延迟为0毫秒。这也安排了一个任务来执行其回调。
  id: totrans-498
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来，我们有一个`setTimeout`调用，延迟为0毫秒。这也安排了一个任务来执行其回调。
- en: '[PRE85]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 最后，同步执行以最终的`console.log`语句结束，在控制台上记录“end”。此时，调用栈为空，事件循环可以开始处理已安排的任务和微任务。
  id: totrans-500
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 最后，同步执行以最终的`console.log`语句结束，在控制台上记录“end”。此时，调用栈为空，事件循环可以开始处理已安排的任务和微任务。
- en: '[PRE86]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 如前所述，微任务在每个任务以及每个回调之后处理，前提是调用栈为空。代码的同步执行是一个任务，当它结束时，调用栈为空，因此微任务队列中的任何微任务都准备好由事件循环处理。我们在微任务队列中只有一个微任务。它将通过在控制台上记录“first
    ‘then’ callback”来处理。
  id: totrans-502
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 如前所述，微任务在每个任务以及每个回调之后处理，前提是调用栈为空。代码的同步执行是一个任务，当它结束时，调用栈为空，因此微任务队列中的任何微任务都准备好由事件循环处理。我们在微任务队列中只有一个微任务。它将通过在控制台上记录“first
    ‘then’ callback”来处理。
- en: '[PRE87]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 第一个`then`方法的回调函数隐式返回`undefined`，因此`then`方法返回的承诺以`undefined`作为履行值被履行。这在微任务队列中排队了另一个微任务，以执行第一个`then`方法返回的承诺的履行处理程序。
  id: totrans-504
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 第一个`then`方法的回调函数隐式返回`undefined`，因此`then`方法返回的承诺以`undefined`作为履行值被履行。这在微任务队列中排队了另一个微任务，以执行第一个`then`方法返回的承诺的履行处理程序。
- en: '[PRE88]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 如前所述，微任务会被处理直到微任务队列为空，因此新排队的微任务也会被处理，在控制台上记录“second ‘then’ callback”。
  id: totrans-506
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 如前所述，微任务会被处理直到微任务队列为空，因此新排队的微任务也会被处理，在控制台上记录“second ‘then’ callback”。
- en: '[PRE89]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 类似于第8步，第二个`then`方法的回调函数隐式返回`undefined`，因此`then`方法返回的承诺以`undefined`作为履行值被履行。这在微任务队列中排队了另一个微任务，以执行第二个`then`方法返回的承诺的履行处理程序。
  id: totrans-508
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 类似于第8步，第二个`then`方法的回调函数隐式返回`undefined`，因此`then`方法返回的承诺以`undefined`作为履行值被履行。这在微任务队列中排队了另一个微任务，以执行第二个`then`方法返回的承诺的履行处理程序。
- en: '[PRE90]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 这导致“third ‘then’ callback”在控制台上被记录。
  id: totrans-510
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 这导致“third ‘then’ callback”在控制台上被记录。
- en: '[PRE91]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 我们没有对第三个`then`方法返回的承诺做任何操作，因此其履行被忽略。此时，所有微任务都已被处理，微任务队列为空。事件循环现在可以处理任务队列中的第一个任务。
  id: totrans-512
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 我们没有对第三个`then`方法返回的承诺做任何操作，因此其履行被忽略。此时，所有微任务都已被处理，微任务队列为空。事件循环现在可以处理任务队列中的第一个任务。
- en: 任务队列中的第一个任务是第二个`setTimeout`调用，因为它的延迟小于第一个，因此它在另一个`setTimeout`回调的任务之前排队，后者的延迟为500毫秒。处理它导致在控制台上记录“setTimeout
    callback with 0ms delay”。
  id: totrans-513
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 任务队列中的第一个任务是第二个`setTimeout`调用，因为它的延迟小于第一个，因此它在另一个`setTimeout`回调的任务之前排队，后者的延迟为500毫秒。处理它导致在控制台上记录“setTimeout
    callback with 0ms delay”。
- en: '[PRE92]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 最后，任务队列中的最后一个任务是第一个`setTimeout`调用，其延迟为500毫秒，导致“setTimeout callback with 500ms
    delay”在控制台上被记录。
  id: totrans-515
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 最后，任务队列中的最后一个任务是第一个`setTimeout`调用，其延迟为500毫秒，导致“setTimeout callback with 500ms
    delay”在控制台上被记录。
- en: '[PRE93]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: :::note 在本模块中，我们使用“resolved”一词来指代一个正在等待另一个承诺解决的承诺。换句话说，我们使用“resolved”一词来指代一个待处理状态的承诺。
  id: totrans-517
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: :::note 在本模块中，我们使用“resolved”一词来指代一个正在等待另一个承诺解决的承诺。换句话说，我们使用“resolved”一词来指代一个待处理状态的承诺。
- en: 'Having said that, the term “resolved” can also be used to refer to a promise
    that has either been fulfilled or rejected. For more details, read: [promises-unwrapping
    - States and Fates](https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md) '
  id: totrans-518
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 话虽如此，“已解决”一词也可以用来指代已被履行或拒绝的承诺。有关更多细节，请阅读：[promises-unwrapping - 状态与命运](https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md)
- en: '::: '
  id: totrans-519
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '::: '
- en: 'Further reading '
  id: totrans-520
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'The following are links to some of the Stackoverflow questions that I answered
    that are related to microtasks and explain the execution of code examples similar
    to the one discussed above: '
  id: totrans-521
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下是一些与微任务相关的 Stackoverflow 问题的链接，这些问题是我回答的，解释了类似于上面讨论的代码示例的执行：
- en: '[How to explain the output order of this code snippet?](https://stackoverflow.com/questions/63052649/how-to-explain-the-output-order-of-this-code-snippet) '
  id: totrans-522
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[如何解释这段代码片段的输出顺序？](https://stackoverflow.com/questions/63052649/how-to-explain-the-output-order-of-this-code-snippet)'
- en: '[JavaScript quiz of printing sequence with a combination of `promise.then`
    and `async` function](https://stackoverflow.com/questions/72306157/javascript-quiz-of-printing-sequence-with-combination-of-promise-then-and-async) '
  id: totrans-523
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[结合 `promise.then` 和 `async` 函数的 JavaScript 打印顺序测验](https://stackoverflow.com/questions/72306157/javascript-quiz-of-printing-sequence-with-combination-of-promise-then-and-async)'
- en: '[Promise chain `.then` `.catch`](https://stackoverflow.com/questions/68784426/promise-chain-then-catch) '
  id: totrans-524
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[承诺链 `.then` `.catch`](https://stackoverflow.com/questions/68784426/promise-chain-then-catch)'
- en: '[Asynchronous Execution Order in JavaScript](https://stackoverflow.com/questions/68882535/asynchronous-execution-order-in-javascript) '
  id: totrans-525
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[JavaScript 中的异步执行顺序](https://stackoverflow.com/questions/68882535/asynchronous-execution-order-in-javascript)'
- en: 'The following is an article that explains the execution of tasks and microtasks
    with the help of interactive examples: '
  id: totrans-526
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下是一篇通过交互式示例解释任务和微任务执行的文章：
- en: '[Tasks, microtasks, queues, and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/) '
  id: totrans-527
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[任务、微任务、队列和调度](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)'
- en: 'In this lesson, we will discuss common promise-related anti-patterns that should
    be avoided. Following is a list of anti-patterns we will discuss: '
  id: totrans-528
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在本课中，我们将讨论应该避免的常见承诺相关反模式。以下是我们将讨论的反模式列表：
- en: Unnecessary use of the `Promise` constructor
  id: totrans-529
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 不必要使用 `Promise` 构造函数
- en: 'Incorrect error handling '
  id: totrans-530
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 错误处理不当
- en: 'Converting promise rejection into fulfillment '
  id: totrans-531
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 将承诺拒绝转换为履行
- en: 'Async executor function '
  id: totrans-532
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 异步执行器函数
- en: 'Unnecessary use of the `Promise` constructor '
  id: totrans-533
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 不必要使用 `Promise` 构造函数
- en: 'One of the most common mistakes made by JavaScript developers, especially those
    who don’t have much experience with promises, is creating promises unnecessarily
    using the `Promise` constructor function. Let’s take a look at an example: '
  id: totrans-534
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: JavaScript 开发者，尤其是那些对承诺没有太多经验的人，常犯的一个错误是使用 `Promise` 构造函数不必要地创建承诺。让我们来看一个例子：
- en: '[PRE94]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The above code will work if you pass a URL to the `fetchData` function and
    then wait for the promise to resolve, but the use of the `Promise` constructor
    is unnecessary in the above code example. The `fetch` function already returns
    a promise, so instead of wrapping the `fetch` function call with the `Promise`
    constructor, we can re-write the above function as shown below: '
  id: totrans-536
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你向 `fetchData` 函数传递一个 URL 然后等待承诺解决，上述代码将正常工作，但在上述代码示例中使用 `Promise` 构造函数是多余的。`fetch`
    函数已经返回一个承诺，因此我们可以将上述函数重新写为如下所示，而无需用 `Promise` 构造函数包装 `fetch` 函数调用：
- en: '[PRE95]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The revised version of the `fetchData` function is concise, easy to read, free
    from the creation of any unnecessary promises, and allows the code that calls
    the `fetchData` function to catch and handle any errors. The older version of
    the `fetchData` function also allowed the calling code to handle errors, but the
    revised version does it without using the `catch` method call. '
  id: totrans-538
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 修订后的 `fetchData` 函数简洁易读，没有创建任何不必要的承诺，并允许调用 `fetchData` 函数的代码捕获和处理任何错误。旧版本的 `fetchData`
    函数也允许调用代码处理错误，但修订版本在不使用 `catch` 方法调用的情况下完成了这一点。
- en: 'Unnecessary use of the promise constructor can lead to another problem: if
    we forget to add the ``catch`` method call to the promise chain inside the ``Promise``
    constructor, then any error thrown during the HTTP request won’t be caught. Forgetting
    to call the ``reject`` function inside the executor function can hide the failure
    of the asynchronous operation inside the executor function.'
  id: totrans-539
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 不必要地使用承诺构造函数可能导致另一个问题：如果我们忘记在``Promise``构造函数内部的承诺链中添加``catch``方法调用，那么在HTTP请求期间抛出的任何错误都将无法捕获。忘记在执行器函数内部调用``reject``函数会隐藏异步操作失败的情况。
- en: Incorrect Error Handling.
  id: totrans-540
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 错误的错误处理。
- en: When writing code that uses promises, one of the most important rules to keep
    in mind is to either catch and handle the error or return the promise to allow
    the calling code to catch and handle it. This fundamental rule can help you avoid
    hidden bugs in the code that uses promises.
  id: totrans-541
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在编写使用承诺的代码时，最重要的规则之一是要么捕获并处理错误，要么返回承诺以允许调用代码捕获和处理它。这个基本规则可以帮助你避免使用承诺的代码中的隐藏错误。
- en: 'Let’s take a look at an example of incorrect handling of errors that breaks
    the above rule:'
  id: totrans-542
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们看一个错误处理不当的例子，这个例子违反了上述规则：
- en: '[PRE96]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Here’s a Replit of the above code in action:'
  id: totrans-544
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是上面代码运行的Replit：
- en: <ReplitEmbed src="https://replit.com/@newlineauthors/promise-anti-patterns-example3"
    />
  id: totrans-545
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src="https://replit.com/@newlineauthors/promise-anti-patterns-example3"
    />
- en: The above code throws an error because the ``fetchData`` function doesn’t return
    the promise. It also doesn’t allow the calling code to do any kind of error handling.
  id: totrans-546
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上述代码抛出一个错误，因为``fetchData``函数没有返回承诺。这也不允许调用代码进行任何形式的错误处理。
- en: 'There are two ways to fix the above code:'
  id: totrans-547
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 修复上面代码有两种方法：
- en: Return the promise from the ``fetchData`` function by adding the ``return``
    keyword before ``fetch(...)``.
  id: totrans-548
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 通过在``fetchData``函数前添加``return``关键字来返回承诺。
- en: '[PRE97]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Here’s a Replit of the above code in action:'
  id: totrans-550
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是上面代码运行的Replit：
- en: <ReplitEmbed src="https://replit.com/@newlineauthors/promise-anti-patterns-example4"
    />
  id: totrans-551
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src="https://replit.com/@newlineauthors/promise-anti-patterns-example4"
    />
- en: As the above function just makes the HTTP request and returns the response data
    after calling the ``json()`` method on the response object, the calling code is
    responsible for using the response data as well as handling any error.
  id: totrans-552
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 由于上述函数只是发出HTTP请求，并在响应对象上调用``json()``方法后返回响应数据，因此调用代码负责使用响应数据以及处理任何错误。
- en: '[PRE98]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Handle the error inside the ``fetchData`` function by chaining the ``catch``
    method to the ``then`` method.
  id: totrans-554
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 通过将``catch``方法链接到``then``方法，在``fetchData``函数内部处理错误。
- en: '[PRE99]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'and you call the function above as shown below:'
  id: totrans-556
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 并且你以如下所示调用上面的函数：
- en: '[PRE100]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Converting promise rejection into fulfillment.
  id: totrans-558
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 将承诺拒绝转换为履行。
- en: 'Each method on the ``Promise.prototype`` object returns a new promise. If we
    are not careful, we can write code that can implicitly convert promise rejection
    into promise fulfillment. Let’s take a look at an example:'
  id: totrans-559
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '``Promise.prototype``对象上的每个方法都返回一个新的承诺。如果我们不小心，可能会编写代码，将承诺拒绝隐式转换为承诺履行。让我们看一个例子：'
- en: '[PRE101]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Here’s a Replit of the above code in action:'
  id: totrans-561
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是上面代码运行的Replit：
- en: <ReplitEmbed src="https://replit.com/@newlineauthors/promise-anti-patterns-example8"
    />
  id: totrans-562
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src="https://replit.com/@newlineauthors/promise-anti-patterns-example8"
    />
- en: 'What output do you expect? The output is shown below:'
  id: totrans-563
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你期望什么输出？输出如下所示：
- en: '[PRE102]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'We called [``Promise.reject``](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject)
    inside the ``getData`` function, so instead of logging “then block”, why didn’t
    “catch block” get logged? Instead of the catch block, why was the callback function
    of the ``then`` method invoked? Let’s understand how the above code executes:'
  id: totrans-565
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们在``getData``函数内部调用了[``Promise.reject``](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject)，那么为什么没有记录“then
    block”，而是“catch block”没有被记录？为什么是``then``方法的回调函数被调用，而不是catch块？让我们理解上面代码的执行过程：
- en: '``getData`` function is invoked.'
  id: totrans-566
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '``getData``函数被调用。'
- en: '``Promise.reject(new Error())`` creates a rejected promise.'
  id: totrans-567
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '``Promise.reject(new Error())``创建一个被拒绝的承诺。'
- en: As a result of the promise rejection, the callback function of the ``catch``
    method is invoked.
  id: totrans-568
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 由于承诺被拒绝，``catch``方法的回调函数被调用。
- en: “inside catch block in getData function” gets logged on the console.
  id: totrans-569
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: “inside catch block in getData function”被记录在控制台上。
- en: As the callback function of the ``catch`` method didn’t explicitly return anything,
    the callback function implicitly returns ``undefined``.
  id: totrans-570
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 由于``catch``方法的回调函数没有显式返回任何内容，因此回调函数隐式返回``undefined``。
- en: '`catch`方法返回的承诺以其回调函数的返回值被履行，即`undefined`。'
  id: totrans-571
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`catch`方法返回的承诺以其回调函数的返回值被履行，即`undefined`。'
- en: 这个被履行的承诺通过`getData`函数返回给其调用代码。
  id: totrans-572
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 这个被履行的承诺通过`getData`函数返回给其调用代码。
- en: 由于`getData`函数返回的承诺以值`undefined`被履行，`then`方法的回调在调用代码中被调用，记录“then块”。
  id: totrans-573
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: 由于`getData`函数返回的承诺以值`undefined`被履行，`then`方法的回调在调用代码中被调用，记录“then块”。
- en: 请查看这个[stackoverflow帖子](https://stackoverflow.com/questions/62859190/handle-promise-catches-in-typescript)，它更详细地解释了这种行为。
  id: totrans-574
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 请查看这个[stackoverflow帖子](https://stackoverflow.com/questions/62859190/handle-promise-catches-in-typescript)，它更详细地解释了这种行为。
- en: 虽然上面的代码是一个人为的示例，但想象一下，如果`getData`函数中调用的是`fetch`函数而不是`Promise.reject`；如果HTTP请求成功，我们的代码将毫无问题地运行，但如果HTTP请求失败，`getData`函数中的`catch`方法将把承诺拒绝转换为承诺履行。因此，`getData`函数将返回一个被履行的承诺，而不是返回一个被拒绝的承诺。
  id: totrans-575
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 虽然上面的代码是一个人为的示例，但想象一下，如果`getData`函数中调用的是`fetch`函数而不是`Promise.reject`；如果HTTP请求成功，我们的代码将毫无问题地运行，但如果HTTP请求失败，`getData`函数中的`catch`方法将把承诺拒绝转换为承诺履行。因此，`getData`函数将返回一个被履行的承诺，而不是返回一个被拒绝的承诺。
- en: :::info
  id: totrans-576
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: :::info
- en: 有时，您确实希望将承诺拒绝转换为承诺履行，以处理拒绝并让承诺链继续。这是可以的，但要有意识地进行。请注意，如果您不小心，承诺拒绝可能会变成承诺履行。这样做肯定会导致代码中的错误。
  id: totrans-577
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 有时，您确实希望将承诺拒绝转换为承诺履行，以处理拒绝并让承诺链继续。这是可以的，但要有意识地进行。请注意，如果您不小心，承诺拒绝可能会变成承诺履行。这样做肯定会导致代码中的错误。
- en: ':::'
  id: totrans-578
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: ':::'
- en: 假设您在想为什么`catch`方法返回的承诺被履行而不是被拒绝。在这种情况下，答案是，如前面所述，`then`或`catch`方法返回的承诺如果它们的回调函数显式或隐式返回一个值而不是抛出错误或返回一个被拒绝的承诺或最终被拒绝的承诺，就会被履行。
  id: totrans-579
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 假设您在想为什么`catch`方法返回的承诺被履行而不是被拒绝。在这种情况下，答案是，如前面所述，`then`或`catch`方法返回的承诺如果它们的回调函数显式或隐式返回一个值而不是抛出错误或返回一个被拒绝的承诺或最终被拒绝的承诺，就会被履行。
- en: 那么，我们如何修复上述代码示例以避免这个问题呢？有两种方法可以解决这个问题：
  id: totrans-580
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 那么，我们如何修复上述代码示例以避免这个问题呢？有两种方法可以解决这个问题：
- en: 从`catch`方法的回调函数中抛出错误。
  id: totrans-581
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 从`catch`方法的回调函数中抛出错误。
- en: '[PRE103]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 这是上面代码在操作中的一个Replit示例：
  id: totrans-583
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 这是上面代码在操作中的一个Replit示例：
- en: <ReplitEmbed src="https://replit.com/@newlineauthors/promise-anti-patterns-example9"
    />
  id: totrans-584
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src="https://replit.com/@newlineauthors/promise-anti-patterns-example9"
    />
- en: 这将拒绝`catch`方法返回的承诺，并且`getData`函数将返回这个被拒绝的承诺。结果，正如预期的那样，调用代码中的`catch`方法回调将被调用。
  id: totrans-585
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这将拒绝`catch`方法返回的承诺，并且`getData`函数将返回这个被拒绝的承诺。结果，正如预期的那样，调用代码中的`catch`方法回调将被调用。
- en: 删除`catch`方法调用。
  id: totrans-586
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 删除`catch`方法调用。
- en: '[PRE104]'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 这是上面代码在操作中的一个Replit示例：
  id: totrans-588
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 这是上面代码在操作中的一个Replit示例：
- en: <ReplitEmbed src="https://replit.com/@newlineauthors/promise-anti-patterns-example10"
    />
  id: totrans-589
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src="https://replit.com/@newlineauthors/promise-anti-patterns-example10"
    />
- en: '这也将调用调用代码中的`catch`块，因为现在`getData`函数返回的是调用`Promise.reject`的结果，并且如前所述，`Promise.reject`创建了一个被拒绝的承诺。:::tip
    个人而言，我建议使用这种方法而不是从`catch`方法回调中抛出错误。让调用代码捕获并处理错误就可以了。`catch`方法回调仅重新抛出错误是多余的。:::'
  id: totrans-590
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: '这也将调用调用代码中的`catch`块，因为现在`getData`函数返回的是调用`Promise.reject`的结果，并且如前所述，`Promise.reject`创建了一个被拒绝的承诺。:::tip
    个人而言，我建议使用这种方法而不是从`catch`方法回调中抛出错误。让调用代码捕获并处理错误就可以了。`catch`方法回调仅重新抛出错误是多余的。:::'
- en: 异步执行器函数
  id: totrans-591
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 异步执行器函数
- en: When creating a new promise using the `Promise` constructor, we pass a function
    to the promise constructor. This function is known as the `executor` function.
    The `executor` function should never be an `async` function. Why is that?
  id: totrans-592
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在使用`Promise`构造函数创建新承诺时，我们将一个函数传递给承诺构造函数。这个函数被称为`executor`函数。`executor`函数绝不应该是一个`async`函数。为什么呢？
- en: Suppose the `executor` function is an `async` function. In that case, any errors
    thrown by the `async` `executor` function will not be caught, and the thrown error
    won’t cause the newly-constructed promise to reject.
  id: totrans-593
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 假设`executor`函数是一个`async`函数。在这种情况下，`async` `executor`函数抛出的任何错误都不会被捕获，抛出的错误不会导致新构造的承诺被拒绝。
- en: '[PRE105]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In the above code example, as the `executor` function is an `async` function,
    the error thrown inside it doesn’t reject the newly-created promise `p`. As a
    result, the callback function of the `catch` method, called on promise `p`, never
    gets called.
  id: totrans-595
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上面的代码示例中，由于`executor`函数是一个`async`函数，因此其中抛出的错误不会拒绝新创建的承诺`p`。结果，针对承诺`p`调用的`catch`方法的回调函数从未被调用。
- en: If the `executor` function is a synchronous function, then any error thrown
    inside the `executor` function will automatically reject the newly created promise.
    Try removing the `async` keyword in the above code example and observe the output.
  id: totrans-596
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果`executor`函数是一个同步函数，则在`executor`函数内部抛出的任何错误将自动拒绝新创建的承诺。尝试删除上面代码示例中的`async`关键字，并观察输出。
- en: Another thing to note is that if you find yourself using `await` inside the
    `executor` function, this should be a signal to you that you don’t need the `promise`
    constructor at all (remember the first anti-pattern discussed above).
  id: totrans-597
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 另一个需要注意的事项是，如果您发现自己在`executor`函数中使用`await`，这应该提醒您根本不需要`promise`构造函数（记住上面讨论的第一个反模式）。
