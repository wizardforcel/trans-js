- en: 'Chapter 11: Functional Programming: A Paradigm Shift'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Section 11.1: Introduction to Functional Programming'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional programming is a programming paradigm that treats computation as
    the evaluation of mathematical functions and avoids changing-state and mutable
    data. It has gained popularity in recent years due to its elegant and concise
    coding style, which often leads to more maintainable and bug-free code.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, functional programming revolves around the concept of functions
    as first-class citizens. In functional languages, functions can be assigned to
    variables, passed as arguments, and returned as values. This higher-order function
    capability is one of the key distinguishing features of functional programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: One fundamental concept in functional programming is immutability. In functional
    languages, once data is assigned, it cannot be modified. Instead, new data is
    created with each transformation. This immutability ensures that data remains
    unchanged, reducing the chances of side effects and making the code more predictable.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming languages often include features like pattern matching
    and higher-order functions, which simplify code and make it more expressive. These
    languages also encourage recursion as a primary means of repetition, which can
    be more elegant than traditional loops for certain problems.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of Functional Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Functional programming offers several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conciseness: Functional code is often more concise and expressive than equivalent
    imperative code. This can lead to faster development and easier maintenance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Predictability: Immutability and absence of side effects make functional programs
    more predictable and easier to reason about.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Parallelism: Functional programming encourages pure functions, which can be
    easily parallelized, taking advantage of multi-core processors.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reusability: Functional code tends to be more modular, making it easier to
    reuse functions in various parts of the codebase.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Testing: Functional code is typically easier to test since it relies on pure
    functions with well-defined inputs and outputs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functional Features in Python and JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While languages like Haskell and Lisp are known for their pure functional approach,
    mainstream languages like Python and JavaScript also support functional programming
    to varying degrees.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, you can use functions like  map,  filter, and  reduce to work with
    lists in a functional style. Python also supports list comprehensions, which allow
    for concise iteration and transformation of lists.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript, on the other hand, has features like anonymous functions, closures,
    and first-class functions that make it conducive to functional programming. Libraries
    like Underscore.js and lodash provide utility functions for functional-style programming
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming is not an all-or-nothing choice; you can choose to incorporate
    functional principles into your code as needed, even in languages that are not
    purely functional.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we’ll delve deeper into specific functional features and
    use cases in Python and JavaScript, exploring how functional programming can enhance
    your coding skills and problem-solving abilities.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Section 11.2: Functional Features in Python and JavaScript'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional programming concepts are not limited to purely functional languages
    like Haskell; they can be applied effectively in mainstream languages such as
    Python and JavaScript. In this section, we will explore some of the functional
    features and techniques available in these languages.
  prefs: []
  type: TYPE_NORMAL
- en: Python and Functional Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python supports a variety of functional programming features and constructs
    that allow developers to write more concise and expressive code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambda Functions: Python allows the creation of anonymous functions using the  lambda
    keyword. These functions are often used as arguments to higher-order functions
    like  map,  filter, and  reduce.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'square =  lambda x: x **  2'
  prefs: []
  type: TYPE_NORMAL
- en: result =  list(map(square, [1, 2, 3, 4, 5]))  # [1, 4, 9, 16, 25]
  prefs: []
  type: TYPE_NORMAL
- en: 'Map, Filter, and Reduce: These built-in functions enable functional-style operations
    on sequences like lists.  map applies a function to each element,  filter selects
    elements based on a condition, and  reduce aggregates elements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using map to double each element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: numbers = [1, 2, 3, 4]
  prefs: []
  type: TYPE_NORMAL
- en: 'doubled =  list(map(lambda x: x *  2, numbers))  # [2, 4, 6, 8]'
  prefs: []
  type: TYPE_NORMAL
- en: Using filter to select even numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'even =  list(filter(lambda x: x %  2  ==  0, numbers)) # [2, 4]'
  prefs: []
  type: TYPE_NORMAL
- en: Using reduce to find the sum of elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from functools import  reduce
  prefs: []
  type: TYPE_NORMAL
- en: 'total =  reduce(lambda x, y: x + y, numbers) # 10'
  prefs: []
  type: TYPE_NORMAL
- en: 'List Comprehensions: Python’s list comprehensions provide a concise way to
    create lists based on existing ones, often eliminating the need for explicit loops.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: squares = [x **  2  for x in  range(1, 6)]  # [1, 4, 9, 16, 25]
  prefs: []
  type: TYPE_NORMAL
- en: 'Immutable Data Structures: Python’s tuples and frozensets are immutable data
    structures, which align with functional programming principles. Once created,
    their values cannot be changed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: point = (3, 4)
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript and Functional Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript’s support for functional programming is deeply ingrained in its design,
    with features that encourage functional coding practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'First-Class Functions: In JavaScript, functions are first-class citizens, meaning
    they can be assigned to variables, passed as arguments, and returned as values.
    This enables the use of higher-order functions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: const square = x => x **  2;
  prefs: []
  type: TYPE_NORMAL
- en: const result = [1,  2,  3,  4,  5].map(square);  // [1, 4, 9, 16, 25]
  prefs: []
  type: TYPE_NORMAL
- en: 'Closures: JavaScript closures allow functions to capture and remember their
    surrounding lexical scope. This is useful for creating private variables and data
    encapsulation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: function  makeCounter() {
  prefs: []
  type: TYPE_NORMAL
- en: let count =  0;
  prefs: []
  type: TYPE_NORMAL
- en: return () => {
  prefs: []
  type: TYPE_NORMAL
- en: count++;
  prefs: []
  type: TYPE_NORMAL
- en: return count;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: const counter =  makeCounter();
  prefs: []
  type: TYPE_NORMAL
- en: console.log(counter());  // 1
  prefs: []
  type: TYPE_NORMAL
- en: console.log(counter());  // 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Higher-Order Functions: JavaScript has a rich set of higher-order functions
    like  map,  filter, and  reduce that make it easy to work with arrays in a functional
    manner.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: const numbers = [1,  2,  3,  4];
  prefs: []
  type: TYPE_NORMAL
- en: const doubled = numbers.map(x => x *  2);  // [2, 4, 6, 8]
  prefs: []
  type: TYPE_NORMAL
- en: const even = numbers.filter(x => x %  2  ===  0);  // [2, 4]
  prefs: []
  type: TYPE_NORMAL
- en: const total = numbers.reduce((x, y) => x + y,  0);  // 10
  prefs: []
  type: TYPE_NORMAL
- en: 'Immutability: While JavaScript’s objects are mutable, libraries like Immutable.js
    provide immutable data structures, promoting functional programming practices.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: const { Map } =  require("immutable");
  prefs: []
  type: TYPE_NORMAL
- en: 'const map1 =  Map({ a:  1,  b:  2 });'
  prefs: []
  type: TYPE_NORMAL
- en: const map2 = map1.set("b",  3);
  prefs: []
  type: TYPE_NORMAL
- en: Both Python and JavaScript offer powerful tools for functional programming,
    making it possible to write cleaner, more modular, and often more efficient code.
    By embracing functional principles, developers can write code that is easier to
    reason about and maintain, ultimately leading to higher-quality software.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Section 11.3: Comparing Imperative and Functional Approaches'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will explore the differences between imperative and functional
    programming approaches and understand when each approach is most suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Imperative Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imperative programming is a style of coding that focuses on describing the steps
    necessary to achieve a specific goal. It is often characterized by the use of
    statements that change program state. In an imperative program, you specify the
    how of solving a problem, detailing every action required to reach the desired
    outcome.
  prefs: []
  type: TYPE_NORMAL
- en: An imperative Python function to calculate the sum of squares of numbers from
    1 to n.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def sum_of_squares(n):'
  prefs: []
  type: TYPE_NORMAL
- en: total =  0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in  range(1, n +  1):'
  prefs: []
  type: TYPE_NORMAL
- en: total += i **  2
  prefs: []
  type: TYPE_NORMAL
- en: return total
  prefs: []
  type: TYPE_NORMAL
- en: The above code demonstrates an imperative approach to calculating the sum of
    squares. It explicitly defines a loop and accumulates the result step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functional programming, on the other hand, emphasizes what needs to be done
    rather than how to do it. It treats computation as the evaluation of mathematical
    functions and avoids changing state and mutable data. Functional code tends to
    be more concise, modular, and easier to reason about.
  prefs: []
  type: TYPE_NORMAL
- en: A functional Python implementation using a higher-order function.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def sum_of_squares(n):'
  prefs: []
  type: TYPE_NORMAL
- en: 'return  sum(map(lambda x: x **  2, range(1, n +  1)))'
  prefs: []
  type: TYPE_NORMAL
- en: In the functional approach, we use the  map and  sum functions to express the
    computation more declaratively. We don’t specify the individual steps; instead,
    we describe the transformation to be applied to the data.
  prefs: []
  type: TYPE_NORMAL
- en: When to Choose Each Approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The choice between imperative and functional programming depends on the problem
    and the context:'
  prefs: []
  type: TYPE_NORMAL
- en: • Imperative programming is often more suitable for tasks that involve complex
    state changes, mutable data structures, and low-level operations. It can be a
    better choice when performance or resource utilization is a critical concern.
  prefs: []
  type: TYPE_NORMAL
- en: • Functional programming shines when you want to emphasize simplicity, maintainability,
    and correctness. It is particularly effective for tasks that involve data transformation,
    filtering, or aggregation, as it encourages a more declarative and less error-prone
    style of coding.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, many modern programming languages, including Python and JavaScript,
    allow you to mix imperative and functional approaches. This flexibility enables
    developers to choose the most appropriate paradigm for each specific part of their
    codebase.
  prefs: []
  type: TYPE_NORMAL
- en: It’s essential to strike a balance and choose the approach that best matches
    the problem’s nature and the project’s requirements. This flexibility can lead
    to codebases that are both efficient and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Section 11.4: Use Cases for Functional Programming'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional programming (FP) is a paradigm with distinct characteristics that
    make it suitable for certain types of problems. In this section, we will explore
    common use cases where FP shines.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Data Transformation and Processing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functional programming is well-suited for tasks that involve data transformation,
    filtering, and aggregation. Operations like  map,  filter, and  reduce are staples
    in functional programming languages and libraries, making it easy to manipulate
    data in a clean and concise manner.
  prefs: []
  type: TYPE_NORMAL
- en: Using functional programming to manipulate a list of numbers.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: numbers = [1, 2, 3, 4, 5]
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the squares of all numbers greater than 2.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'squares =  list(map(lambda x: x **  2, filter(lambda x: x >  2, numbers)))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Result: [9, 16, 25]'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2\. Parallel and Concurrent Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FP’s emphasis on immutability and statelessness makes it an excellent choice
    for parallel and concurrent programming. Because functions are isolated and don’t
    modify shared state, it’s easier to reason about and manage concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Using functional programming with Python's multiprocessing library.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from multiprocessing import Pool
  prefs: []
  type: TYPE_NORMAL
- en: 'def square(x):'
  prefs: []
  type: TYPE_NORMAL
- en: return x **  2
  prefs: []
  type: TYPE_NORMAL
- en: 'if  __name__  ==  ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: numbers = [1, 2, 3, 4, 5]
  prefs: []
  type: TYPE_NORMAL
- en: 'with Pool() as pool:'
  prefs: []
  type: TYPE_NORMAL
- en: squares = pool.map(square, numbers)
  prefs: []
  type: TYPE_NORMAL
- en: '# Result: [1, 4, 9, 16, 25]'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Complex Mathematical Calculations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functional programming languages, especially those with strong support for first-class
    functions, excel in solving mathematical problems. FP’s mathematical foundation
    allows for concise and expressive representations of complex mathematical functions
    and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: -- A simple Haskell function to calculate the factorial of a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'factorial ::  Integer  ->  Integer'
  prefs: []
  type: TYPE_NORMAL
- en: factorial 0  =  1
  prefs: []
  type: TYPE_NORMAL
- en: factorial n = n * factorial (n -  1)
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Handling Streams and Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In event-driven or reactive programming, where streams of data and events are
    common, FP concepts are valuable. Libraries like RxJS in JavaScript and reactive
    frameworks leverage functional programming principles to handle asynchronous data
    flows.
  prefs: []
  type: TYPE_NORMAL
- en: // Using RxJS to filter and map values in an observable stream.
  prefs: []
  type: TYPE_NORMAL
- en: import { from } from  'rxjs';
  prefs: []
  type: TYPE_NORMAL
- en: import { filter, map } from  'rxjs/operators';
  prefs: []
  type: TYPE_NORMAL
- en: const numbers =  from([1,  2,  3,  4,  5]);
  prefs: []
  type: TYPE_NORMAL
- en: const squares = numbers.pipe(
  prefs: []
  type: TYPE_NORMAL
- en: filter(x => x >  2),
  prefs: []
  type: TYPE_NORMAL
- en: map(x => x **  2)
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '// Result: 9, 16, 25 (as an observable)'
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Domain-Specific Languages (DSLs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functional programming is often used to create domain-specific languages (DSLs)
    tailored to specific problem domains. DSLs enable developers to write code that
    closely resembles the problem space, improving readability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: -- An example of a DSL for working with financial transactions in Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: 'transfer ::  Account  ->  Account  ->  Amount  ->  Transaction'
  prefs: []
  type: TYPE_NORMAL
- en: transfer fromAccount toAccount amount =
  prefs: []
  type: TYPE_NORMAL
- en: Transaction fromAccount toAccount (negate amount) :+  Transaction toAccount
    fromAccount amount
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming’s suitability for these use cases arises from its emphasis
    on immutability, purity, and the absence of side effects. While not all problems
    are best solved with FP, recognizing when to apply its principles can lead to
    cleaner, more maintainable code in specific scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Section 11.5: The Future of Functional Programming'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional programming (FP) has been gaining traction in recent years, and its
    future looks promising. Here, we’ll discuss some trends and developments that
    indicate the continued relevance and growth of FP.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Wider Adoption in Mainstream Languages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many mainstream programming languages have been incorporating functional programming
    features. Languages like Python, JavaScript, and C# have introduced functional
    constructs, making it easier for developers to adopt FP principles without switching
    to purely functional languages.
  prefs: []
  type: TYPE_NORMAL
- en: Python's introduction of lambda functions and comprehensions.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: squares = [x **  2  for x in  range(1, 6)]
  prefs: []
  type: TYPE_NORMAL
- en: 'Result: [1, 4, 9, 16, 25]'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2\. Functional-First Languages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functional-first languages like Haskell, Elm, and Clojure continue to thrive.
    They provide strong support for FP principles and are chosen for projects that
    require correctness, reliability, and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: -- A simple Haskell function that reverses a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'reverseList :: [a] -> [a]'
  prefs: []
  type: TYPE_NORMAL
- en: reverseList [] = []
  prefs: []
  type: TYPE_NORMAL
- en: reverseList (x:xs) = reverseList xs ++ [x]
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Reactive and Event-Driven Systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the rise of reactive and event-driven architectures, functional programming
    is becoming more relevant. Libraries and frameworks like Akka for Scala and RxJS
    for JavaScript enable developers to build highly responsive and scalable systems
    using FP concepts.
  prefs: []
  type: TYPE_NORMAL
- en: // Using Akka Streams for event-driven processing in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: import akka.actor.ActorSystem
  prefs: []
  type: TYPE_NORMAL
- en: import akka.stream._
  prefs: []
  type: TYPE_NORMAL
- en: import akka.stream.scaladsl._
  prefs: []
  type: TYPE_NORMAL
- en: 'implicit  val system: ActorSystem =  ActorSystem("akka-streams-example")'
  prefs: []
  type: TYPE_NORMAL
- en: 'implicit  val materializer: Materializer =  ActorMaterializer()'
  prefs: []
  type: TYPE_NORMAL
- en: val numbers = Source(1 to 5)
  prefs: []
  type: TYPE_NORMAL
- en: val squares = numbers.map(x => x * x)
  prefs: []
  type: TYPE_NORMAL
- en: '// Result: 1, 4, 9, 16, 25 (as a stream)'
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Advances in Type Systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type systems in functional languages are becoming more sophisticated, enabling
    better type inference and safer code. Features like dependent types, refined types,
    and gradual typing are emerging, enhancing the expressiveness and correctness
    of FP code.
  prefs: []
  type: TYPE_NORMAL
- en: -- An Elm type alias representing positive integers.
  prefs: []
  type: TYPE_NORMAL
- en: type  alias  PositiveInt  =  Int
  prefs: []
  type: TYPE_NORMAL
- en: '|>  where (\x  ->  x  >  0)'
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Functional for Data Science and AI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functional programming is finding applications in data science and artificial
    intelligence. Libraries like TensorFlow for Python offer functional APIs for deep
    learning, and functional languages like Scala are used for distributed data processing
    in big data environments.
  prefs: []
  type: TYPE_NORMAL
- en: Functional API in TensorFlow for deep learning.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import tensorflow as tf
  prefs: []
  type: TYPE_NORMAL
- en: model = tf.keras.Sequential([
  prefs: []
  type: TYPE_NORMAL
- en: tf.keras.layers.Dense(128, activation='relu'),
  prefs: []
  type: TYPE_NORMAL
- en: tf.keras.layers.Dense(10, activation='softmax')
  prefs: []
  type: TYPE_NORMAL
- en: '])'
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Functional in Blockchain and Smart Contracts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Blockchain platforms like Ethereum are embracing functional languages like Solidity
    for writing smart contracts. FP’s deterministic and verifiable nature aligns well
    with the requirements of blockchain systems.
  prefs: []
  type: TYPE_NORMAL
- en: // A simple smart contract in Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: pragma solidity ^0.8.0;
  prefs: []
  type: TYPE_NORMAL
- en: contract SimpleStorage {
  prefs: []
  type: TYPE_NORMAL
- en: uint256 storedData;
  prefs: []
  type: TYPE_NORMAL
- en: function set(uint256 x) public {
  prefs: []
  type: TYPE_NORMAL
- en: storedData = x;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: function get() public view returns (uint256) {
  prefs: []
  type: TYPE_NORMAL
- en: return storedData;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: The future of functional programming is not limited to these trends alone. As
    software development continues to evolve, FP’s principles of immutability, purity,
    and composability are expected to play a significant role in addressing the challenges
    of modern software engineering, making it a valuable skill for developers to learn
    and master.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
