- en: Big O of Space Complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interestingly, computer scientists use Big O notation to describe space complexity
    just as they do for time complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back when I introduced Big O notation in Chapter 3, [​*O Yes! Big O Notation*​](f_0031.xhtml#chp.big_o_notation),
    I described Big O in terms of what I called the “key question.” For time complexity,
    the key question was this: if there are N data elements, how many steps will the
    algorithm take?'
  prefs: []
  type: TYPE_NORMAL
- en: To use Big O for space complexity, we just need to reframe the key question.
    When it comes to memory consumption, the key question becomes if there are N data
    elements, how many units of memory will the algorithm consume?
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we’re writing a function that accepts an array of strings and returns
    an array of those strings in ALL CAPS. For example, the function would accept
    an array like ["tuvi", "leah", "shaya", "rami", "yechiel"] and return ["TUVI",
    "LEAH", "SHAYA", "RAMI", "YECHIEL"]. Here’s one way we can write this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ makeUppercase(array) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**const**​ newArray = []; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**for**​ (​**const**​ string ​**of**​ array) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | newArray.push(string.toUpperCase()); |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**return**​ newArray; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: In this makeUppercase function, we accept an array. We then create a brand-new
    array called newArray and fill it with uppercase versions of each string from
    the original array.
  prefs: []
  type: TYPE_NORMAL
- en: By the time this function is complete, we’ll have two arrays floating around
    in our computer’s memory. We have the original array, which contains ["tuvi",
    "leah", "shaya", "rami", "yechiel"], and we have newArray, which contains ["TUVI",
    "LEAH", "SHAYA", "RAMI", "YECHIEL"].
  prefs: []
  type: TYPE_NORMAL
- en: When we analyze this function in terms of space complexity, we can see that
    this function creates a brand-new array that contains N elements. This is in addition
    to the original array which also holds N elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let’s return to our key question: if there are N data elements, how many
    units of memory will the algorithm consume?'
  prefs: []
  type: TYPE_NORMAL
- en: Because our function generated an additional N data elements (in the form of
    newArray), we’d say that this function has a space efficiency of O(N).
  prefs: []
  type: TYPE_NORMAL
- en: 'The way this appears on the following graph should look familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/dealing_with_space_constraints/space_graph.png](images/dealing_with_space_constraints/space_graph.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that this graph is identical to the way we’ve depicted O(N) in graphs in
    previous chapters, with the exception that the vertical axis now represents memory
    consumed rather than time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s present an alternative makeUppercase function that is more memory-efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ makeUppercase(array) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**for**​ (​**let**​ index = 0; index < array.length; index += 1) {
    |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | array[index] = array[index].toUpperCase(); |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**return**​ array; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: In this second version, we don’t create any new arrays. Instead, we modify each
    value within the original array in place, replacing each string with an uppercase
    version of that string. We then return the modified array.
  prefs: []
  type: TYPE_NORMAL
- en: This is a drastic improvement in terms of memory consumption since our new function
    doesn’t consume any additional memory at all.
  prefs: []
  type: TYPE_NORMAL
- en: How do we describe this in terms of Big O notation?
  prefs: []
  type: TYPE_NORMAL
- en: Recall that with time complexity, an O(1) algorithm was one whose speed remained
    constant no matter how large the data. Similarly, with space complexity, O(1)
    means that the memory consumed by an algorithm is constant no matter how large
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: Our revised makeUppercase function consumes a constant amount of additional
    space (zero!) no matter whether the original array contains four elements or one
    hundred. Because of this, this function is said to have a space efficiency of
    O(1).
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth emphasizing that when using Big O to describe space complexity, we’re
    only counting the new data the algorithm is generating. Even our second makeUppercase
    function deals with N elements of data in the form of the array passed into the
    function. However, we’re not factoring those N elements into our Big O description,
    since the original array exists in any case and we’re only focused on the extra
    space the algorithm consumes. This extra space is more formally known as auxiliary
    space.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s good to know that there are some references that include the original
    input when calculating the space complexity, and that’s fine. We’re not including
    it, and whenever you see space complexity described in another resource, you need
    to determine whether it’s including the original input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now compare the two versions of makeUppercase in both time and space
    complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Version | Time Complexity | Space Complexity |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Version #1 | O(N) | O(N) |'
  prefs: []
  type: TYPE_TB
- en: '| Version #2 | O(N) | O(1) |'
  prefs: []
  type: TYPE_TB
- en: Both versions are O(N) in time complexity, since they take N steps for N data
    elements. However, the second version is more memory-efficient, as it is O(1)
    in space complexity compared to the first version’s O(N).
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that Version #2 is more efficient than Version #1 in terms of
    space while not sacrificing any speed, which is a nice win.'
  prefs: []
  type: TYPE_NORMAL
