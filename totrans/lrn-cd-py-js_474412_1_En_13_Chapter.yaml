- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024 J. L. Zuckarelli Learn coding with Python and JavaScript
    [https://doi.org/10.1007/978-3-658-42912-6_13](https://doi.org/10.1007/978-3-658-42912-6_13)
  id: totrans-0
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 13. How Do I Work with Program Functions to Edit Data and Trigger Actions?
  id: totrans-1
  prefs:
  - PREF_H1
  stylish: true
  type: TYPE_NORMAL
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1) München, Germany Overview
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In most programming languages, small subroutines, so-called functions, do the
    actual job. They help to read in data, change it, output it again and much more.
    You can access the functions that your programming language offers as standard,
    install additional libraries with functions from the Internet or write your own
    functions. That’s what this chapter is about.
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'In this chapter you will learn the following:'
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: What functions are
  id: totrans-5
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: How to define functions in the program code
  id: totrans-6
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: How to call functions and specify their behavior
  id: totrans-7
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: What role the scope of variables plays when you work with functions
  id: totrans-8
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: How to use functions in object-oriented programming and the advantages of functions
    being objects themselves in many languages
  id: totrans-9
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: How functions are grouped in libraries and how you can find suitable, freely
    available libraries
  id: totrans-10
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: What frameworks are and how they differ from libraries
  id: totrans-11
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: What Application Programming Interfaces (APIs) are and how you can work with
    them.
  id: totrans-12
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 13.1 Functions
  id: totrans-13
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: What Are Functions?
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As in mathematics (don’t worry, we won’t overuse this comparison!), functions
    are mapping rules that map values, called `arguments`, to another value, their
    `function` or `return value`. For example, the function `f(x) = x²` maps a value
    `x` to its square; thus, one passes a value `x` to the function as an argument
    and receives a processed value (in this case, the square of the argument) back
    from the function as a return value.
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Functions in programming languages work according to the same basic principle,
    with the difference, however, that not all functions produce a return value. We
    have already worked in the pseudo code ► Sect. [11.​7.​5](474412_1_En_11_Chapter.xhtml#Sec15)
    with a function called `showProduct()` which performs an output on the screen.
    This function does not yield a return value. It simply performs a specific action,
    namely displaying on the screen, but otherwise does not process the data passed
    to it as an argument any further. Some programming languages make a strict distinction
    between functions that have a return value and `procedures` that do not. However,
    we will not make this distinction here and will always refer to “functions” instead.
    In some programming languages, functions always return a value; if they do not
    have a “real” return value, they return a special value that signals that there
    is no “real” result (for example, `undefined` in JavaScript or `void` in C/C++).
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Definition of a Function
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Functions usually consist of a `function head` and a `function body`。The header
    regularly contains the function identifier (name) and the list of arguments that
    the function expects。The body is a block of code that is executed whenever the
    function is called。It contains the “meat” of the function；the source code it contains
    describes what the function does。
  id: totrans-18
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Consider the pseudo-code example of a simple function that multiplies two numbers
    together：
  id: totrans-19
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Function multiply(number1, number2) Begin result = number1 * number2 return(result)
    End`'
  id: totrans-20
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: To let the programming language know that the definition of a function begins,
    it starts with the keyword `Function`。This is followed by the function identifier
    and the two arguments of the function，`number1`和`number2`。The function body consists
    of two statements，one that calculates the actual result of the function, and a
    call to another，`return()`，that returns the function result。The two instructions
    form a `code block`，which is introduced with the keyword `Begin` and concluded
    with the keyword `End`。Code blocks exist in practically all programming languages。They
    are usually delimited, as in our pseudo-code, by special keywords (the English
    keywords `Begin` and `End` are particularly common) or symbols, such as opening
    and closing curly braces (`{` and `}`)。Some languages, such as Python, mark a
    block of code without any special keywords or symbols at all, solely by indenting
    all lines of code in the block evenly。
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: But back to our function definition。Its program code does nothing per se。The
    function only appears when it is called from within the program。In our example,
    this could look like this：
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`show(multiply(3, 57.8))`'
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: With this call, we multiply the numbers 3 and 57.8 and immediately output the
    result。What happens here is that the execution of the program branches to the
    definition of the `multiply` function。The code contained in the body of the function
    definition is executed, with the function arguments `number1` and `number2` taking
    the value of the factors passed – in this case, 3 and 57.8。The result of the multiplication
    is returned with `return()`，which causes the program execution to leave the function
    body and return to the main program。By executing the function, the return value
    of the function now takes the place of the function call。This can now be passed
    again as an argument to another function, in our example `show()`。After passing
    through our `multiply()` function, the program code effectively shortens to：
  id: totrans-24
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`show(173.4)`'
  id: totrans-25
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Because the function call is replaced by the return value after its execution，function
    calls can also be assigned to variables：
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`value = multiply(3, 57.8)`'
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Many programming languages require that the function has been defined `before`
    the first call, so the function definition must be “higher up” in the program
    code than the first call。
  id: totrans-28
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Note: Functions can also be defined without arguments. For example, a function
    that simply clears the display on the screen does not need any further information
    passed to it. In most programming languages, even such functions must be called
    with the round brackets in which the values of the arguments are normally found.
    In this case, the parentheses are empty, but the interpreter/compiler of the language
    still recognizes that this is a function call and not an access to a variable
    with the same name.'
  id: totrans-29
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The sequence of a function call from the program is shown schematically in ◘
    Fig. `13.1`.![](../images/474412_1_En_13_Chapter/474412_1_En_13_Fig1_HTML.jpg)
  id: totrans-30
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: An illustration of calling a function. The main program consists of more expressions
    and `My Function`. The `My Function` is called, which has expressions and a return
    statement.
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fig. `13.1`
  id: totrans-32
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Calling a function
  id: totrans-33
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Optional Arguments
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Sometimes you want to give the user the possibility to control the behavior
    of the function via a parameter but preset it with a default value. If the caller
    of the function then does not specify a value for the argument in question, the
    default value is used.
  id: totrans-35
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Suppose we wanted to design our `multiply()` function from above so that `number1`
    is always multiplied by the number `pi` (3.14159…) unless a value for the argument
    `number2` is explicitly passed in the function call. Then we would have to specify
    this default value in the function header: `Function multiply(number1, number2
    = 3.14159)`. Now a call to `multiply` could also look like this:'
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`two_pi = multiply(2)`'
  id: totrans-37
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In this context, `number2` is called an `optional` argument, because it can
    be omitted when calling the function.
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Passing Function Arguments with Their Identifier
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'In many programming languages, the arguments when calling functions can also
    be addressed via their identifiers. This could then look like this:'
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`value = multiply(number1 = 3, number2 = 57.8)`'
  id: totrans-41
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The advantage of these `keyword arguments` is that it becomes clearer (especially
    when calling functions with many arguments) which value belongs to which argument;
    thus, one does not have to keep the order of the arguments in mind. Because now
    the identifiers of the arguments are available, the interpreter/compiler is no
    longer dependent on the order of the arguments. In this latter case, we speak
    of `positional arguments` to distinguish them from keyword arguments. Accordingly,
    you can also deviate from the actual order of the arguments; a valid function
    call would thus also be the following:'
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`value = multiply(number2 = 57.8, number1 = 3)`'
  id: totrans-43
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: An additional advantage is that by using argument identifiers when calling functions
    the program code becomes easier to understand and thus easier to maintain.
  id: totrans-44
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Scope of Variables
  id: totrans-45
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在大多数编程语言中，函数可以说是过着“独立生活”。它们是一个独立的、隔离的世界。回想一下我们`multiply()`函数的定义。在这个函数内部，创建了一个名为`result`的变量，用于保存两个数字的乘积。这个变量仅存在于函数内部。在函数调用结束时，即当函数完全运行时，变量`result`也会消失。它无法从主程序中访问。因此，也可以说它的`scope`仅限于函数体。
  id: totrans-46
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 假设我们的主程序看起来像这样：
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`value = multiply(3, 57.8)show(result)`'
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 语句`show(result)`将导致一个错误信息（或者，根据语言的不同，返回一个默认值像`0`），因为在主程序的作用域中没有名为`result`的变量。这个变量在`multiply()`函数的作用域中。由于其作用域有限，`result`被称为`local
    variable`。另一方面，变量`value`是在主程序中创建的，适用于任何地方。这类变量被称为`global variables`，与局部变量相区别。它们可以从任何地方访问，甚至可以在我们的`multiply()`函数内访问。然而，最佳实践是避免在函数内部访问全局变量（也称为`side
    effects`），因为这使得函数更容易受到程序其余部分变化的影响，尤其是全局变量标识符的变化。
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 但是，如果`multiply()`函数本身使用了一个名为`value`的变量，例如，如果函数的核心指令是`value = number1 * number2`呢？那么我们就有了两个名为`value`的变量，一个是局部的（在`multiply()`函数内部），一个是在主程序中的全局变量。那么，当在程序代码的某处使用标识符`value`时，访问的是哪一个？一般来说，编程语言首先在本地环境中查找具有此标识符的变量，如果在那里找不到，再查找全局环境。所以，如果在`multiply()`函数内部使用变量`value`，将使用局部变量，即在当前作用域中定义的那个。而从主程序访问`value`则会导致访问全局变量。
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 函数参数通常表现得像局部变量，它们也只能从函数代码内部访问。
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 按引用而不是按值传递参数
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 考虑我们`multiply()`函数的以下稍微修改的变体：
  id: totrans-53
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Function multiply(number1, number2, AsReference result) Begin result = number1
    * number2 End`'
  id: totrans-54
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'This time, our function has no return value; instead, the result of the calculation
    is assigned to a variable that was also passed as an argument, but, unlike `number1`
    and `number2`, with the keyword `AsReference`. Normally, the arguments to a function
    are passed as copies of the original values. Consider the following example of
    a call to our function:'
  id: totrans-55
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`number1 = 3 value = 0 multiply(number1, 57.8, value) show(value)`'
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Here the first argument of the function itself is a variable. Its value is available
    as argument `number1` inside the `multiply()` function, but only as a copy of
    the original variable. If we would now adjust the value of `number1` within the
    function body, this would have no effect on the variable `number1` in the main
    program. Only the local variable `number1` in the function body of `multiply()`
    would change in value.
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: This is different in the case of the variable `value`. This is not passed to
    the function as a value, but as a so-called `reference`. This means that changes
    made to this variable within the function affect the original variable; in the
    example, we use this variable to “return” the result of the calculation. Some
    programming languages allow variables to be passed `by value` or `by reference`,
    some only allow them to be passed by value.
  id: totrans-58
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Examples for the Definition of Functions
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: So far, we have only written our function definition in our pseudo-code. Therefore,
    here are two implementations of the original `multiply()` function in real programming
    languages, namely `PHP` and `Pascal`.
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'First the `PHP` version:'
  id: totrans-61
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`function multiply($number1, $number2){$result = $number1 * $number2;return
    $result;}`'
  id: totrans-62
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The statement `return` is, as in some languages, not a function but a keyword
    (hence no round brackets around the “argument”).
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Then the code same in `Pascal`:'
  id: totrans-64
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`function multiply(number1, number2: real): real; var result: real; begin result
    = number1 * number2; multiply = result; end;`'
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Pascal` is a strongly typed programming language. Variables are always declared
    with a fixed type here. Therefore, both the two arguments of the function, `number1`
    and `number2`, as well as the function itself (at the end of the function header)
    each have a type specification: In all cases, they are floating-point numbers
    (`real`). This makes it clear not only what kind of arguments the function expects,
    but also what type its return value will be.'
  id: totrans-66
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The return statement does not work in `Pascal` as in many other programming
    languages with a keyword `return` or a function `return()`, but is achieved by
    assigning the function value to the identifier of the function (assignments are
    formulated in `Pascal` with `=` as assignment operator).
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Functions in Object-Oriented Programming
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'In ► Sect. `[11.​7.​4](474412_1_En_11_Chapter.xhtml#Sec14)`, we saw that, in
    the context of object-oriented programming, functions can also be part of classes.
    As you will remember, such functions are also called `methods`. These methods
    are always called in connection with a concrete object instance of the class,
    i.e., an object that has been created according to the “template” of the class.
    Most programming languages use the period (but some use other symbols, such as
    `->`) to separate object and method when calling them. The call of a method could
    therefore look like this, for example:'
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`object.method(arguments)`'
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Depending on the programming language, the method definition may be part of
    the class definition or outside of it. In any case, however, there is a reference
    to the method in the class definition (often the method header), as we saw in
    ► Sect. `[11.​7.​4](474412_1_En_11_Chapter.xhtml#Sec14)` (scroll back a few pages
    if necessary).
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Apart from the fact that functions as methods can be part of objects (or their
    classes), functions and objects often have another relationship. In many programming
    languages, functions `are` objects. There, a special class exists (often `function`)
    and all functions are objects (i.e., instances) of this class. As such, they may
    also have properties, such as their arguments or their function body, i.e., the
    actual code. When functions are themselves objects, this has some remarkable implications.
    For example, functions themselves can serve as arguments to other functions. Moreover,
    class definitions are logically very stringent; strictly speaking, they consist
    exclusively of attributes. The only difference is that some attributes, namely
    the methods, are `callable` and others (the “normal” attributes in the sense of
    value properties) are not.
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 13.1 [3 min]
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'What is wrong with the following function definitions (written in pseudo-code):'
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: a. **Function** `exponential(base)` **Start** `return(base^exponent)` **End**
    b. **Function** `exponential(base, exponent)` **Begin** `result = base^exponent`
    **End** 13.2 [3 min]
  id: totrans-75
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Suppose we had a function defined as follows:'
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '**Function** `introduce(name, age)` **Begin** `show("My name is ", name, "
    , I am ", age, " years old.")` **End**'
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: What is the difference between the following calls to the function, and why
    do the first and third calls result in the desired behavior of the function, but
    the second does not?
  id: totrans-78
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`introduce("Mary", 25)` `introduce(25, "Mary")` `introduce(age = 25, name =
    "Mary")` 13.3 [5 min]'
  id: totrans-79
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Consider the following program excerpt:'
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`age_person = 25` **Function** `getolder(age_person)` **Begin** `age_person
    = age_person + 1` `show("New age of the person: ", age_person)` `return(age_person)`
    **End** `age_new = getolder(age_person)` `show("Current age: ", age_person)` `show("Result
    of the function getolder(): ", age_new)`'
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: (a)
  id: totrans-82
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: What output does this program generate and why?
  id: totrans-83
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: (b)
  id: totrans-84
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: What two ways are there to modify the program so that the new age, which is
    one year higher, is also reflected in the global variable `age_person`?
  id: totrans-85
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: 13.2 Libraries
  id: totrans-86
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: Libraries as a Toolbox for Programmers
  id: totrans-87
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As a programmer, you can (as seen in the previous section) develop functions
    yourself. This always makes sense if you want to `reuse` program code, because
    the nice thing about functions is that they allow you to detach a certain functionality
    from your actual program and call it from anywhere at any time.
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Of course, programming languages regularly come with an extensive set of standard
    functions that you can use to perform many common tasks. Often, however, these
    standard functions will not be sufficient for what you have in mind. For example,
    functions for sending e-mails, searching web pages (`web scraping`), or training
    neural networks are usually not included in the standard language scope. In these
    and other use cases, if you do not want to develop the functionality in question
    yourself, you will have to extend the language scope by installing the required
    functions from elsewhere.
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Find Suitable Libraries
  id: totrans-90
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Some programming languages such as Python, R and JavaScript have a very extensive
    and lively `ecosystem` with a large number of developers who make the functionalities
    they have developed available to others free of charge. This is regularly done
    in the form of a set of functions focused on a certain topic. Such collections
    are usually called `libraries`, `modules`, `packages`, or `distributions`, depending
    on the programming language. For the sake of simplicity, we always refer here
    to “libraries”. In some cases, these libraries are brought together on a platform
    that is centrally managed by the organization that oversees the development of
    the programming language.
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'This is the case, for example, for:'
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Python with the `Python Package Index` (`PyPI`, ► [https://​pypi.​org/​](https://pypi.org/)),
  id: totrans-93
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Perl with the `Comprehensive Perl Archive Network` (`CPAN`, ► [https://​www.​cpan.​org/​](https://www.cpan.org/)),
  id: totrans-94
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: PHP with the `PHP Extension Community Library` (`PECL`, ► [https://​pecl.​php.​net/​](https://pecl.php.net/)),
  id: totrans-95
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: R with the `Comprehensive R Archive Network` (`CRAN`, ► [https://​cran.​r-project.​org](https://cran.r-project.org)).
  id: totrans-96
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Depending on the design, inclusion in one of these central catalogues is also
    accompanied by (mostly automated) quality control, which ensures, for example,
    that the program code of the library is executable and has at least a minimum
    of documentation.
  id: totrans-97
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: For many programming languages, however, such a centrally organized library
    platform does not exist. Often, developers then deposit their works on `GitHub.`
    `GitHub` is a cross-language platform that allows developers to share source code
    with others by storing it in a `repository`. Underneath `GitHub` lies the version
    management tool `Git,` developed by Linux inventor `Linus Torvalds,` which allows
    changes to source code to be versioned in an elegant way. If necessary, it is
    then easy to revert to an old state of a single code file or even the entire `repository`.
    Developers can also use `GitHub` to create their own `branches of` the source
    code, develop features in them, and eventually `merge` them back into the original
    version, at least if the developer of the original version allows it. With these
    and a whole series of other features, `GitHub` facilitates collaboration between
    different developers on the basis of the underlying version management tool `Git.`
    `GitHub` is completely language agnostic; for most programming languages in use
    today, you will find repositories with code in that language. For developers who
    offer their source code under an open-source license, using `GitHub` is free at
    the time of writing this book. Companies and organizations that want to shield
    their code from the outside world pay for a private environment. While a number
    of comparable platforms exist alongside `GitHub,` `GitHub` is the most popular.
  id: totrans-98
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Of course, `GitHub` is not only used by those developers who work in a language
    without a central library platform. Many developers run `GitHub` repositories
    not for libraries but simply for their normal work on any kind of development
    projects, and to exchange information with other developers. If they do indeed
    develop libraries, they make only the finished versions available on the central
    library platforms such as `PyPI` or `CRAN.` Sometimes developers also don’t want
    to subject themselves to the strict rules and automated quality checks of the
    central library platforms and therefore offer their libraries exclusively on `GitHub.`
  id: totrans-99
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 因此，`GitHub`和中心库平台都是寻找帮助你解决特定问题的库的好地方，这并不奇怪。不过，这种搜索有时并不是完全简单的，原因有几个。平台的搜索功能各不相同，每个库的可用信息也有所不同。因此，有时找到一个库并判断它是否适合解决你的问题并不容易。这种评估进一步复杂化，因为通常会有多个库可能适合。即使在中央管理的库平台上，对于许多任务也存在几个在一定程度上相互竞争的库。推荐两种方法。一种是`trial
    and error`；下载并使用“候选者”，以确定哪个库最适合你的问题。另一种是在互联网上搜索，在相关论坛（如`Stack Overflow`）中，您可以定期找到有关许多库的信息。这在你想通过示例了解如何使用该库时尤其有用。库的文档在范围和质量上各不相同，因此像`Stack
    Overflow`这样的论坛在使用已找到的合适库时也能提供良好的帮助。
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 除此之外，像`Stack Overflow`这样的论坛通常是识别解决问题的库候选者的良好首选——如果你不能或不想直接通过中心库平台或在`GitHub`上搜索。这是因为论坛中的问题通常是按照“我如何解决这个问题……”或“我如何让它……”的结构来组织的，答案中往往包含一个或多个可以帮助解决此类问题的库的引用。许多开发者更喜欢这种论坛搜索，而不是直接在中心库平台或`GitHub`上搜索，因为这些论坛中的示例和用户评论通常提供了宝贵的额外信息。
  id: totrans-101
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 不用说，你也可以使用像`ChatGPT`这样的AI助手来搜索合适的库。例如，询问：“我想写一个读取网站数据的Python程序（`webscraping`）。有哪些库可用，它们有什么不同，哪些特别适合初学者？”
  id: totrans-102
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 安装和导入/加载库
  id: totrans-103
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 一旦你找到了合适的库，你所需要做的就是安装它（如果编程语言对此有要求）并将其包含在程序代码中。包含的方式是通过一个语句，该语句要么将库整体导入，要么将其中的单个元素（例如单个函数或类）导入程序代码。在某些情况下，可以指定一个名称，用于标识已导入的元素，这有助于避免与已存在的变量、类、对象或函数的标识符冲突。
  id: totrans-104
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'A (hypothetical) example from `Python`:'
  id: totrans-105
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`from somelibrary import aclass as my_class import somelibrary`'
  id: totrans-106
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The first statement imports only the class `aclass` into the program code and
    then makes it accessible under the identifier `my_class`。The second, alternative
    statement imports the entire `library` (in this case without assigning it a different
    identifier)。
  id: totrans-107
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: It is easier in `Pascal`
  id: totrans-108
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`uses somelibrary;`'
  id: totrans-109
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: or `R`
  id: totrans-110
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`library(somelibrary)`'
  id: totrans-111
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: where the entire `library` is made available in each case。
  id: totrans-112
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 13.3 Frameworks
  id: totrans-113
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: There is a lot of talk about `frameworks`，especially in the field of web development.
    The terms “`framework`” and “`library`” are sometimes not used in a very clear-cut
    way. Even though the functionality and use of `frameworks` goes beyond what we
    will look at in this book, at least the distinction between the two concepts should
    be examined in more detail. `Libraries` contain functionalities that the user，即，the
    programmer，可以在需要时访问，以执行特定任务。因此，主动权在程序员手中。`Frameworks`，则不同。`Frameworks`控制整个应用程序的流程，并在必要时调用程序员的代码。`Frameworks`因此形成了，正如术语所暗示的那样，一个框架，程序员“只需”填充。这在网页开发领域尤其实用，因为有许多重复的任务，例如用户登录的身份验证、数据库的连接，或在模板页面中输出数据。所有这些任务都可以由`framework`接管。它们已经作为功能内置在程序员正在使用的`framework`中。程序员只需开发与其应用程序特定的内容。通过`framework`和开发者之间的这种劳动分工，应用程序的控制实际上是反转的（这就是为什么在与`frameworks`相关时，有人也会谈论`inversion
    of control`）：`Framework`控制应用程序，开发者提供应用程序特定的程序代码，然后`framework`在合适的地方调用。这使开发者能够集中精力处理重要问题，而将所有相对无聊的“附属工作”留给`framework`。
  id: totrans-114
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Well-known `frameworks` include `AngularJS` and `React` (for `JavaScript`),
    `django` (for `Python`), `CakePHP` and `Zen` (for `PHP`), and `Ruby on Rails`
    (for `Ruby`)。
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Because the focus of this book is on learning the basics of programming, we
    will not be working with `frameworks` here. However, a prerequisite for using
    `frameworks` is, of course, knowledge of the underlying language, and that’s what
    we’re dealing with here in the book.
  id: totrans-116
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 13.4 Application Programming Interfaces (APIs)
  id: totrans-117
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: Another term that is on everyone’s lips is that of the `Application Programming
    Interface`, or API for short. First of all, APIs are – as the name suggests –
    nothing more than `programming interfaces`. In this sense, a library that provides
    a set of functions for specific purposes also provides a programming interface
    that consists of the library’s functions that you can access from within your
    program.
  id: totrans-118
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: When people talk about APIs today, they are often referring to specific programming
    interfaces, such as `Web APIs` through which you can access the functionality
    and data of web services. Many web services today offer programming interfaces
    for developers. For example, a `GoogleMaps API` provided by Google returns the
    geo-coordinates of a city if you pass the name of the city to the API. Here, an
    API is used to retrieve information provided by the web service. In the same way,
    however, APIs can also be used to get a web service to trigger a specific action.
    Twitter’s API, for example, allows you to post tweets. All you need is an account
    that allows you to use the API and a corresponding instruction in your program
    that addresses the API and sends the tweet.
  id: totrans-119
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: So, APIs can be used to query data and trigger functions. There are literally
    thousands of web services that offer APIs which can be accessed via the Internet.
    The website `ProgrammableWeb` (► [https://​www.​programmableweb.​com/​apis/​directory](https://www.programmableweb.com/apis/directory))
    provides an overview of API providers that is certainly not complete, but at least
    very comprehensive. Whether you want to process payments with `PayPal` from your
    program or check the latest football results, with the web APIs available today,
    hardly any wish remains unfulfilled.
  id: totrans-120
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Technically, `Web APIs` mostly work with the `Hypertext Transfer Protocol`
    (HTTP) and can be called like web pages. For example, to access the `GoogleMaps
    API` to get the geo-location of Chicago, a program would simply need to make an
    HTTP request of the form ► [https://​maps.​googleapis.​com/​maps/​api/​geocode/​json?​address=​Chicago&​key=​XX](https://maps.googleapis.com/maps/api/geocode/json?address=Chicago&key=XX),
    where `key` is a parameter that authenticates the caller of the API as a legitimate
    user. Google would then return the coordinates, in JSON format, a data exchange
    format that is extremely popular with `Web APIs` because it is easy to generate
    and easy to read, and which we will learn about in more detail in ► Sect. [31.​5.​6](474412_1_En_31_Chapter.xhtml#Sec17).
    If you were to enter the request as it is into your web browser, you would also
    get a result in JSON format, but an error message, because `XX` is not a key that
    identifies you as the legitimate API user:'
  id: totrans-121
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`{"error_message" : "The provided API key is invalid.","results" : [],"status"
    : "REQUEST_DENIED"}`'
  id: totrans-122
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: However, a program does not need a web browser to make such requests to a web
    service via an API. The corresponding HTTP requests can be triggered from within
    most programming languages (often using a library that provides the corresponding
    functions), and their returns can be processed without the user of the program
    having to know anything about it.
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: We won’t continue discussing Web APIs in detail, because we’re focusing on the
    basics of programming in this book. However, given these basics, it’s easy to
    take the next step and learn exactly how to incorporate Web APIs into your programs.
    The most important thing to understand at this point is that web APIs are a versatile
    tool for extending the functionality of your programs. Ultimately, they work just
    like library functions; they are called (albeit slightly differently), trigger
    an action or retrieve information, and return a value (often a JSON object). The
    basic concept, which is that of a programming interface, or API, is the same in
    both cases.
  id: totrans-124
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 13.5 Your Roadmap to Learning a New Programming Language
  id: totrans-125
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: If you are learning a new programming language …
  id: totrans-126
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'you’ll discover:'
  id: totrans-127
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: how functions are defined; in particular, how optional arguments are used, how
    (and whether) arguments can be taken by reference instead of by value, and how
    functions can return values,
  id: totrans-128
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: how functions are called; in particular, how (and whether) arguments can be
    passed by name when calling a function,
  id: totrans-129
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: how the scopes of variables are designed and whether it is possible to access
    a global variable from within a function (especially if it has the same name as
    a local variable)
  id: totrans-130
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: what good reference sources for libraries exist and how to search for suitable
    libraries; in particular, whether a centrally administered platform exists, which
    is de facto the main point of contact when searching for suitable libraries,
  id: totrans-131
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: how to include libraries (or elements from them) in your program and how to
    access their functionality.
  id: totrans-132
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 13.6 Solutions to the Exercises
  id: totrans-133
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: Exercise 13.1
  id: totrans-134
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: (a)
  id: totrans-135
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: In the return statement `return()` an argument `exponent` is used, but this
    argument does not appear in the argument list in the head of the function. The
    header should therefore correctly read `function exponential(base, exponent)`.
  id: totrans-136
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: (b)
  id: totrans-137
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: This time, the argument `exponent` is included in the argument list in the function
    header. However, the function does not return a value. A variable `result` is
    calculated, but it is not returned with the help of `return()`. The statement
    `return(result)` would have to be added as the last statement of the function.
  id: totrans-138
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: Exercise 13.2
  id: totrans-139
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`**introduce("Mary", 25)** calls the function as it is intended. The first
    argument in the argument list in the function header is the name, the second is
    the age.` `introduce(25, "Mary")` `flips the argument values around when the function
    is called. Now the first argument` `(**name**)` `is assigned the value` `25`,
    `the second argument` `(**age**)` `the value` `"Mary"`. `In the best case, the
    function then outputs a somewhat strange-looking text, but in the worst case,
    it terminates with an error because the expected types of the arguments and the
    passed values do not match. Finally, the call` `introduce(age = 25, name = "Mary")`
    `also flips the arguments around when the function is called, but by specifying
    the argument names it is clear how the passed values should be assigned to the
    arguments of the function, so the different order of the arguments when the function
    is called is not a problem.`'
  id: totrans-140
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Exercise 13.3`'
  id: totrans-141
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`(a)The program will produce the following output:` `New age of the person:
    26Current age: 25Result of the function getolder(): 26`'
  id: totrans-142
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: '`The function` `getolder()` `increments the value of the argument` `age_person`
    `passed to it and returns this as the function value. The` *global* `variable
    of the same name,` `age_person`, `remains unaffected. Priority in the scope of
    the function is given to the argument, which is treated as a` *local* `variable.`'
  id: totrans-143
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '`(b)The first possibility is to catch the return value of the function` `getolder()`
    `in the global variable` `age_person`: `age_person = getolder(age_person)`'
  id: totrans-144
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
- en: '`Alternatively, the argument` `age` `of the function can be defined as an argument
    passed by` *reference* ` (if the programming language used allows it). Then the
    function header would look like this:` `Function getolder(AsReference age_person)`.
    `This way, the` `age_person` `argument would still be considered a local variable
    (it could not be accessed outside of the function’s code block), but changes to
    it would immediately result in changes to the variable passed in (i.e.,` `age`).
    `Thus, the` `getolder()` `function would ultimately be able to change the global
    variable` `age`.`'
  id: totrans-145
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
