- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024 J. L. Zuckarelli Learn coding with Python and JavaScript
    [https://doi.org/10.1007/978-3-658-42912-6_13](https://doi.org/10.1007/978-3-658-42912-6_13)
  id: totrans-0
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: © 作者（们），独家授权 Springer Fachmedien Wiesbaden GmbH，Springer Nature 2024 J. L. Zuckarelli
    《用 Python 和 JavaScript 学习编程》 [https://doi.org/10.1007/978-3-658-42912-6_13](https://doi.org/10.1007/978-3-658-42912-6_13)
- en: 13. How Do I Work with Program Functions to Edit Data and Trigger Actions?
  id: totrans-1
  prefs:
  - PREF_H1
  stylish: true
  type: TYPE_NORMAL
  zh: 13. 如何使用程序函数编辑数据并触发操作？
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1) München, Germany Overview
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: Joachim L. Zuckarelli^([1](#Aff2))(1) 德国慕尼黑 概览
- en: In most programming languages, small subroutines, so-called functions, do the
    actual job. They help to read in data, change it, output it again and much more.
    You can access the functions that your programming language offers as standard,
    install additional libraries with functions from the Internet or write your own
    functions. That’s what this chapter is about.
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，执行实际工作的都是小型子程序，即所谓的函数。它们帮助读取数据、修改数据、再次输出数据等。你可以访问编程语言提供的标准函数，安装来自互联网的附加函数库，或编写自己的函数。这就是本章的内容。
- en: 'In this chapter you will learn the following:'
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在本章中，你将学到以下内容：
- en: What functions are
  id: totrans-5
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 什么是函数
- en: How to define functions in the program code
  id: totrans-6
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何在程序代码中定义函数
- en: How to call functions and specify their behavior
  id: totrans-7
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何调用函数并指定它们的行为
- en: What role the scope of variables plays when you work with functions
  id: totrans-8
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 在使用函数时，变量的作用域扮演着什么角色
- en: How to use functions in object-oriented programming and the advantages of functions
    being objects themselves in many languages
  id: totrans-9
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何在面向对象编程中使用函数，以及在许多语言中函数作为对象本身的优势
- en: How functions are grouped in libraries and how you can find suitable, freely
    available libraries
  id: totrans-10
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 函数是如何在库中进行分组的，以及如何找到合适的、免费的库
- en: What frameworks are and how they differ from libraries
  id: totrans-11
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 什么是框架，它们与库有什么不同
- en: What Application Programming Interfaces (APIs) are and how you can work with
    them.
  id: totrans-12
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 什么是应用程序编程接口（APIs），以及如何使用它们。
- en: 13.1 Functions
  id: totrans-13
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 13.1 函数
- en: What Are Functions?
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 什么是函数？
- en: As in mathematics (don’t worry, we won’t overuse this comparison!), functions
    are mapping rules that map values, called `arguments`, to another value, their
    `function` or `return value`. For example, the function `f(x) = x²` maps a value
    `x` to its square; thus, one passes a value `x` to the function as an argument
    and receives a processed value (in this case, the square of the argument) back
    from the function as a return value.
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 就像在数学中一样（不用担心，我们不会过度使用这个比较！），函数是映射规则，将称为`参数`的值映射到另一个值，即它们的`函数`或返回值。例如，函数`f(x)
    = x²`将一个值`x`映射到它的平方；因此，将一个值`x`作为参数传递给函数，并从函数那里接收一个处理后的值（在这个例子中，就是参数的平方）作为返回值。
- en: Functions in programming languages work according to the same basic principle,
    with the difference, however, that not all functions produce a return value. We
    have already worked in the pseudo code ► Sect. [11.​7.​5](474412_1_En_11_Chapter.xhtml#Sec15)
    with a function called `showProduct()` which performs an output on the screen.
    This function does not yield a return value. It simply performs a specific action,
    namely displaying on the screen, but otherwise does not process the data passed
    to it as an argument any further. Some programming languages make a strict distinction
    between functions that have a return value and `procedures` that do not. However,
    we will not make this distinction here and will always refer to “functions” instead.
    In some programming languages, functions always return a value; if they do not
    have a “real” return value, they return a special value that signals that there
    is no “real” result (for example, `undefined` in JavaScript or `void` in C/C++).
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 编程语言中的函数遵循相同的基本原则，然而，区别在于并非所有函数都会返回值。我们已经在伪代码中使用过一个名为`showProduct()`的函数，该函数在屏幕上执行输出操作。这个函数没有返回值。它只是执行一个特定的操作，即在屏幕上显示，但不会进一步处理传递给它的参数数据。某些编程语言严格区分有返回值的函数和没有返回值的`过程`。然而，我们在这里不会做这样的区分，而是始终称之为“函数”。在一些编程语言中，函数总是返回一个值；如果它们没有“真实”的返回值，则会返回一个特殊的值，表示没有“真实”的结果（例如，JavaScript
    中的`undefined`或 C/C++ 中的`void`）。
- en: Definition of a Function
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 函数的定义
- en: Functions usually consist of a `function head` and a `function body`。The header
    regularly contains the function identifier (name) and the list of arguments that
    the function expects。The body is a block of code that is executed whenever the
    function is called。It contains the “meat” of the function；the source code it contains
    describes what the function does。
  id: totrans-18
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 函数通常由`function head`和`function body`组成。头部通常包含函数标识符（名称）和函数期望的参数列表。函数体是每当函数被调用时执行的代码块。它包含函数的“核心”部分；它所包含的源代码描述了函数的作用。
- en: Consider the pseudo-code example of a simple function that multiplies two numbers
    together：
  id: totrans-19
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 考虑一个简单的伪代码示例，它是一个将两个数字相乘的函数：
- en: '`Function multiply(number1, number2) Begin result = number1 * number2 return(result)
    End`'
  id: totrans-20
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Function multiply(number1, number2) Begin result = number1 * number2 return(result)
    End`'
- en: To let the programming language know that the definition of a function begins,
    it starts with the keyword `Function`。This is followed by the function identifier
    and the two arguments of the function，`number1`和`number2`。The function body consists
    of two statements，one that calculates the actual result of the function, and a
    call to another，`return()`，that returns the function result。The two instructions
    form a `code block`，which is introduced with the keyword `Begin` and concluded
    with the keyword `End`。Code blocks exist in practically all programming languages。They
    are usually delimited, as in our pseudo-code, by special keywords (the English
    keywords `Begin` and `End` are particularly common) or symbols, such as opening
    and closing curly braces (`{` and `}`)。Some languages, such as Python, mark a
    block of code without any special keywords or symbols at all, solely by indenting
    all lines of code in the block evenly。
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为了让编程语言知道函数定义的开始，它以关键字`Function`开头。接下来是函数标识符和函数的两个参数，`number1`和`number2`。函数体由两条语句组成，一条计算函数的实际结果，另一条调用`return()`，返回函数结果。两条语句形成了一个`code
    block`，这个代码块以关键字`Begin`开始，以关键字`End`结束。几乎所有编程语言都有代码块。它们通常由特殊的关键字（如我们伪代码中的英语关键字`Begin`和`End`）或符号（如大括号`{`和`}`）来分隔。一些语言，如Python，完全不使用任何特殊的关键字或符号，而是通过将代码块中的所有行进行一致的缩进来标识代码块。
- en: But back to our function definition。Its program code does nothing per se。The
    function only appears when it is called from within the program。In our example,
    this could look like this：
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 但是回到我们的函数定义。它的程序代码本身并不执行任何操作。函数只有在程序中被调用时才会出现。在我们的示例中，这看起来可能是这样的：
- en: '`show(multiply(3, 57.8))`'
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`show(multiply(3, 57.8))`'
- en: With this call, we multiply the numbers 3 and 57.8 and immediately output the
    result。What happens here is that the execution of the program branches to the
    definition of the `multiply` function。The code contained in the body of the function
    definition is executed, with the function arguments `number1` and `number2` taking
    the value of the factors passed – in this case, 3 and 57.8。The result of the multiplication
    is returned with `return()`，which causes the program execution to leave the function
    body and return to the main program。By executing the function, the return value
    of the function now takes the place of the function call。This can now be passed
    again as an argument to another function, in our example `show()`。After passing
    through our `multiply()` function, the program code effectively shortens to：
  id: totrans-24
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 通过这个调用，我们将数字3和57.8相乘，并立即输出结果。这里发生的事情是，程序的执行分支到`multiply`函数的定义。函数体中包含的代码会被执行，函数参数`number1`和`number2`取传递的因子值——在这个例子中是3和57.8。乘法的结果通过`return()`返回，这使得程序执行离开函数体并返回到主程序。通过执行该函数，函数的返回值现在取代了函数调用的位置。这可以再次作为参数传递给另一个函数，在我们的例子中是`show()`。通过`multiply()`函数后，程序代码实际上简化为：
- en: '`show(173.4)`'
  id: totrans-25
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`show(173.4)`'
- en: Because the function call is replaced by the return value after its execution，function
    calls can also be assigned to variables：
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 由于函数调用在执行后会被返回值替代，函数调用也可以被赋值给变量：
- en: '`value = multiply(3, 57.8)`'
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`value = multiply(3, 57.8)`'
- en: Many programming languages require that the function has been defined `before`
    the first call, so the function definition must be “higher up” in the program
    code than the first call。
  id: totrans-28
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 许多编程语言要求函数必须在第一次调用之前定义，因此函数定义必须在程序代码中位于第一次调用之前的“较高”位置。
- en: 'Note: Functions can also be defined without arguments. For example, a function
    that simply clears the display on the screen does not need any further information
    passed to it. In most programming languages, even such functions must be called
    with the round brackets in which the values of the arguments are normally found.
    In this case, the parentheses are empty, but the interpreter/compiler of the language
    still recognizes that this is a function call and not an access to a variable
    with the same name.'
  id: totrans-29
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 注意：函数也可以定义为没有参数。例如，一个仅仅清除屏幕显示的函数不需要传递任何进一步的信息。在大多数编程语言中，即使是这样的函数，也必须使用圆括号进行调用，其中通常包含参数的值。在这种情况下，圆括号是空的，但语言的解释器/编译器仍然会识别这是一个函数调用，而不是对同名变量的访问。
- en: The sequence of a function call from the program is shown schematically in ◘
    Fig. `13.1`.![](../images/474412_1_En_13_Chapter/474412_1_En_13_Fig1_HTML.jpg)
  id: totrans-30
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 程序中函数调用的顺序在图◘ `13.1`中以示意图形式展示。![](../images/474412_1_En_13_Chapter/474412_1_En_13_Fig1_HTML.jpg)
- en: An illustration of calling a function. The main program consists of more expressions
    and `My Function`. The `My Function` is called, which has expressions and a return
    statement.
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个调用函数的示例。主程序包含更多的表达式和`My Function`。`My Function`被调用，它包含表达式和返回语句。
- en: Fig. `13.1`
  id: totrans-32
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 `13.1`
- en: Calling a function
  id: totrans-33
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 调用函数
- en: Optional Arguments
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 可选参数
- en: Sometimes you want to give the user the possibility to control the behavior
    of the function via a parameter but preset it with a default value. If the caller
    of the function then does not specify a value for the argument in question, the
    default value is used.
  id: totrans-35
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 有时，你希望通过一个参数让用户控制函数的行为，但将其预设为一个默认值。如果函数调用者没有为相关参数指定值，则使用默认值。
- en: 'Suppose we wanted to design our `multiply()` function from above so that `number1`
    is always multiplied by the number `pi` (3.14159…) unless a value for the argument
    `number2` is explicitly passed in the function call. Then we would have to specify
    this default value in the function header: `Function multiply(number1, number2
    = 3.14159)`. Now a call to `multiply` could also look like this:'
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 假设我们想要设计上述的`multiply()`函数，使得`number1`始终与数字`pi`（3.14159…）相乘，除非在函数调用中显式传递了`number2`的值。那么我们需要在函数头部指定这个默认值：`Function
    multiply(number1, number2 = 3.14159)`。现在，调用`multiply`也可以像这样：
- en: '`two_pi = multiply(2)`'
  id: totrans-37
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`two_pi = multiply(2)`'
- en: In this context, `number2` is called an `optional` argument, because it can
    be omitted when calling the function.
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这个上下文中，`number2`被称为`optional`参数，因为在调用函数时可以省略它。
- en: Passing Function Arguments with Their Identifier
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 带有标识符的函数参数传递
- en: 'In many programming languages, the arguments when calling functions can also
    be addressed via their identifiers. This could then look like this:'
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在许多编程语言中，调用函数时的参数也可以通过它们的标识符来指定。这看起来可能是这样的：
- en: '`value = multiply(number1 = 3, number2 = 57.8)`'
  id: totrans-41
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`value = multiply(number1 = 3, number2 = 57.8)`'
- en: 'The advantage of these `keyword arguments` is that it becomes clearer (especially
    when calling functions with many arguments) which value belongs to which argument;
    thus, one does not have to keep the order of the arguments in mind. Because now
    the identifiers of the arguments are available, the interpreter/compiler is no
    longer dependent on the order of the arguments. In this latter case, we speak
    of `positional arguments` to distinguish them from keyword arguments. Accordingly,
    you can also deviate from the actual order of the arguments; a valid function
    call would thus also be the following:'
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这些`keyword arguments`的优势在于，当调用具有多个参数的函数时，哪个值属于哪个参数会更加清晰；因此，调用者不必记住参数的顺序。因为现在可以使用参数的标识符，解释器/编译器不再依赖于参数的顺序。在这种情况下，我们称之为`positional
    arguments`，以区别于关键字参数。因此，你也可以偏离实际的参数顺序；有效的函数调用也可以是以下形式：
- en: '`value = multiply(number2 = 57.8, number1 = 3)`'
  id: totrans-43
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`value = multiply(number2 = 57.8, number1 = 3)`'
- en: An additional advantage is that by using argument identifiers when calling functions
    the program code becomes easier to understand and thus easier to maintain.
  id: totrans-44
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 另一个优点是，通过在调用函数时使用参数标识符，程序代码变得更易于理解，从而也更易于维护。
- en: Scope of Variables
  id: totrans-45
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 变量的作用域
- en: 在大多数编程语言中，函数可以说是过着“独立生活”。它们是一个独立的、隔离的世界。回想一下我们`multiply()`函数的定义。在这个函数内部，创建了一个名为`result`的变量，用于保存两个数字的乘积。这个变量仅存在于函数内部。在函数调用结束时，即当函数完全运行时，变量`result`也会消失。它无法从主程序中访问。因此，也可以说它的`scope`仅限于函数体。
  id: totrans-46
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，函数可以说是过着“独立生活”。它们是一个独立的、隔离的世界。回想一下我们`multiply()`函数的定义。在这个函数内部，创建了一个名为`result`的变量，用于保存两个数字的乘积。这个变量仅存在于函数内部。在函数调用结束时，即当函数完全运行时，变量`result`也会消失。它无法从主程序中访问。因此，也可以说它的`scope`仅限于函数体。
- en: 假设我们的主程序看起来像这样：
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 假设我们的主程序看起来像这样：
- en: '`value = multiply(3, 57.8)show(result)`'
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`value = multiply(3, 57.8)show(result)`'
- en: 语句`show(result)`将导致一个错误信息（或者，根据语言的不同，返回一个默认值像`0`），因为在主程序的作用域中没有名为`result`的变量。这个变量在`multiply()`函数的作用域中。由于其作用域有限，`result`被称为`local
    variable`。另一方面，变量`value`是在主程序中创建的，适用于任何地方。这类变量被称为`global variables`，与局部变量相区别。它们可以从任何地方访问，甚至可以在我们的`multiply()`函数内访问。然而，最佳实践是避免在函数内部访问全局变量（也称为`side
    effects`），因为这使得函数更容易受到程序其余部分变化的影响，尤其是全局变量标识符的变化。
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 语句`show(result)`将导致一个错误信息（或者，根据语言的不同，返回一个默认值像`0`），因为在主程序的作用域中没有名为`result`的变量。这个变量在`multiply()`函数的作用域中。由于其作用域有限，`result`被称为`local
    variable`。另一方面，变量`value`是在主程序中创建的，适用于任何地方。这类变量被称为`global variables`，与局部变量相区别。它们可以从任何地方访问，甚至可以在我们的`multiply()`函数内访问。然而，最佳实践是避免在函数内部访问全局变量（也称为`side
    effects`），因为这使得函数更容易受到程序其余部分变化的影响，尤其是全局变量标识符的变化。
- en: 但是，如果`multiply()`函数本身使用了一个名为`value`的变量，例如，如果函数的核心指令是`value = number1 * number2`呢？那么我们就有了两个名为`value`的变量，一个是局部的（在`multiply()`函数内部），一个是在主程序中的全局变量。那么，当在程序代码的某处使用标识符`value`时，访问的是哪一个？一般来说，编程语言首先在本地环境中查找具有此标识符的变量，如果在那里找不到，再查找全局环境。所以，如果在`multiply()`函数内部使用变量`value`，将使用局部变量，即在当前作用域中定义的那个。而从主程序访问`value`则会导致访问全局变量。
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 但是，如果`multiply()`函数本身使用了一个名为`value`的变量，例如，如果函数的核心指令是`value = number1 * number2`呢？那么我们就有了两个名为`value`的变量，一个是局部的（在`multiply()`函数内部），一个是在主程序中的全局变量。那么，当在程序代码的某处使用标识符`value`时，访问的是哪一个？一般来说，编程语言首先在本地环境中查找具有此标识符的变量，如果在那里找不到，再查找全局环境。所以，如果在`multiply()`函数内部使用变量`value`，将使用局部变量，即在当前作用域中定义的那个。而从主程序访问`value`则会导致访问全局变量。
- en: 函数参数通常表现得像局部变量，它们也只能从函数代码内部访问。
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 函数参数通常表现得像局部变量，它们也只能从函数代码内部访问。
- en: 按引用而不是按值传递参数
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 按引用而不是按值传递参数
- en: 考虑我们`multiply()`函数的以下稍微修改的变体：
  id: totrans-53
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 考虑我们`multiply()`函数的以下稍微修改的变体：
- en: '`Function multiply(number1, number2, AsReference result) Begin result = number1
    * number2 End`'
  id: totrans-54
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Function multiply(number1, number2, AsReference result) Begin result = number1
    * number2 End`'
- en: 'This time, our function has no return value; instead, the result of the calculation
    is assigned to a variable that was also passed as an argument, but, unlike `number1`
    and `number2`, with the keyword `AsReference`. Normally, the arguments to a function
    are passed as copies of the original values. Consider the following example of
    a call to our function:'
  id: totrans-55
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这次，我们的函数没有返回值；相反，计算结果被赋值给一个作为参数传递的变量，但与`number1`和`number2`不同，它使用了关键字`AsReference`。通常，函数的参数作为原始值的副本传递。考虑以下对我们函数的调用示例：
- en: '`number1 = 3 value = 0 multiply(number1, 57.8, value) show(value)`'
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`number1 = 3 value = 0 multiply(number1, 57.8, value) show(value)`'
- en: Here the first argument of the function itself is a variable. Its value is available
    as argument `number1` inside the `multiply()` function, but only as a copy of
    the original variable. If we would now adjust the value of `number1` within the
    function body, this would have no effect on the variable `number1` in the main
    program. Only the local variable `number1` in the function body of `multiply()`
    would change in value.
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里，函数的第一个参数本身是一个变量。它的值在`multiply()`函数内部作为`number1`参数存在，但仅作为原始变量的副本。如果我们在函数体内调整`number1`的值，这将不会影响主程序中的`number1`变量。只有`multiply()`函数体中的局部变量`number1`的值会发生变化。
- en: This is different in the case of the variable `value`. This is not passed to
    the function as a value, but as a so-called `reference`. This means that changes
    made to this variable within the function affect the original variable; in the
    example, we use this variable to “return” the result of the calculation. Some
    programming languages allow variables to be passed `by value` or `by reference`,
    some only allow them to be passed by value.
  id: totrans-58
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这在`value`变量的情况下有所不同。它不是作为值传递给函数，而是作为所谓的`reference`传递。这意味着在函数内部对这个变量的修改会影响原始变量；在这个例子中，我们使用这个变量来“返回”计算结果。一些编程语言允许变量按`值传递`或按`引用传递`，而有些语言只允许按值传递。
- en: Examples for the Definition of Functions
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 函数定义的示例
- en: So far, we have only written our function definition in our pseudo-code. Therefore,
    here are two implementations of the original `multiply()` function in real programming
    languages, namely `PHP` and `Pascal`.
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在伪代码中编写了函数定义。因此，下面是原始`multiply()`函数在真实编程语言中的两种实现，分别是`PHP`和`Pascal`。
- en: 'First the `PHP` version:'
  id: totrans-61
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 首先是`PHP`版本：
- en: '`function multiply($number1, $number2){$result = $number1 * $number2;return
    $result;}`'
  id: totrans-62
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`function multiply($number1, $number2){$result = $number1 * $number2;return
    $result;}`'
- en: The statement `return` is, as in some languages, not a function but a keyword
    (hence no round brackets around the “argument”).
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 语句`return`在某些语言中不是一个函数，而是一个关键字（因此“参数”周围没有圆括号）。
- en: 'Then the code same in `Pascal`:'
  id: totrans-64
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然后是`Pascal`中的相同代码：
- en: '`function multiply(number1, number2: real): real; var result: real; begin result
    = number1 * number2; multiply = result; end;`'
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`function multiply(number1, number2: real): real; var result: real; begin result
    = number1 * number2; multiply = result; end;`'
- en: '`Pascal` is a strongly typed programming language. Variables are always declared
    with a fixed type here. Therefore, both the two arguments of the function, `number1`
    and `number2`, as well as the function itself (at the end of the function header)
    each have a type specification: In all cases, they are floating-point numbers
    (`real`). This makes it clear not only what kind of arguments the function expects,
    but also what type its return value will be.'
  id: totrans-66
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Pascal`是强类型的编程语言。这里的变量始终具有固定的类型声明。因此，函数的两个参数`number1`和`number2`以及函数本身（在函数头部末尾）都有类型规格：在所有情况下，它们都是浮点数（`real`）。这不仅明确了函数期望的参数类型，也明确了其返回值的类型。'
- en: The return statement does not work in `Pascal` as in many other programming
    languages with a keyword `return` or a function `return()`, but is achieved by
    assigning the function value to the identifier of the function (assignments are
    formulated in `Pascal` with `=` as assignment operator).
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在`Pascal`中，`return`语句不像在许多其他具有`return`关键字或`return()`函数的编程语言中那样工作，而是通过将函数值赋给函数标识符来实现的（在`Pascal`中，赋值使用`=`作为赋值操作符）。
- en: Functions in Object-Oriented Programming
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 面向对象编程中的函数
- en: 'In ► Sect. `[11.​7.​4](474412_1_En_11_Chapter.xhtml#Sec14)`, we saw that, in
    the context of object-oriented programming, functions can also be part of classes.
    As you will remember, such functions are also called `methods`. These methods
    are always called in connection with a concrete object instance of the class,
    i.e., an object that has been created according to the “template” of the class.
    Most programming languages use the period (but some use other symbols, such as
    `->`) to separate object and method when calling them. The call of a method could
    therefore look like this, for example:'
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在►节 `[11.​7.​4](474412_1_En_11_Chapter.xhtml#Sec14)` 中，我们看到在面向对象编程的上下文中，函数也可以是类的一部分。正如你可能记得的那样，这类函数通常被称为`方法`。这些方法总是与类的具体对象实例一起调用，即与根据类的“模板”创建的对象一起调用。因此，方法的调用可能看起来像这样：
- en: '`object.method(arguments)`'
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`object.method(arguments)`'
- en: Depending on the programming language, the method definition may be part of
    the class definition or outside of it. In any case, however, there is a reference
    to the method in the class definition (often the method header), as we saw in
    ► Sect. `[11.​7.​4](474412_1_En_11_Chapter.xhtml#Sec14)` (scroll back a few pages
    if necessary).
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 根据编程语言的不同，方法定义可以是类定义的一部分，也可以在类定义外部。然而，无论如何，在类定义中总会有一个方法的引用（通常是方法头），正如我们在►节 `[11.​7.​4](474412_1_En_11_Chapter.xhtml#Sec14)`
    中看到的那样（如果有必要，可以返回几页）。
- en: Apart from the fact that functions as methods can be part of objects (or their
    classes), functions and objects often have another relationship. In many programming
    languages, functions `are` objects. There, a special class exists (often `function`)
    and all functions are objects (i.e., instances) of this class. As such, they may
    also have properties, such as their arguments or their function body, i.e., the
    actual code. When functions are themselves objects, this has some remarkable implications.
    For example, functions themselves can serve as arguments to other functions. Moreover,
    class definitions are logically very stringent; strictly speaking, they consist
    exclusively of attributes. The only difference is that some attributes, namely
    the methods, are `callable` and others (the “normal” attributes in the sense of
    value properties) are not.
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 除了作为方法的函数可以是对象（或其类）的一部分之外，函数和对象通常还有另一种关系。在许多编程语言中，函数`是`对象。在这些语言中，存在一个特殊的类（通常是`function`），所有函数都是该类的对象（即实例）。因此，它们也可以具有属性，比如它们的参数或函数体，即实际的代码。当函数本身是对象时，这带来了一些显著的影响。例如，函数本身可以作为其他函数的参数。此外，类定义在逻辑上是非常严格的；严格来说，它们仅由属性组成。唯一的区别是，有些属性，即方法，是`可调用`的，而其他属性（即“正常”的值属性）则不可调用。
- en: 13.1 [3 min]
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 13.1 [3 min]
- en: 'What is wrong with the following function definitions (written in pseudo-code):'
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下函数定义（伪代码形式）有什么问题：
- en: a. **Function** `exponential(base)` **Start** `return(base^exponent)` **End**
    b. **Function** `exponential(base, exponent)` **Begin** `result = base^exponent`
    **End** 13.2 [3 min]
  id: totrans-75
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: a. **函数** `exponential(base)` **开始** `return(base^exponent)` **结束** b. **函数**
    `exponential(base, exponent)` **开始** `result = base^exponent` **结束** 13.2 [3 min]
- en: 'Suppose we had a function defined as follows:'
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 假设我们有一个如下定义的函数：
- en: '**Function** `introduce(name, age)` **Begin** `show("My name is ", name, "
    , I am ", age, " years old.")` **End**'
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**函数** `introduce(name, age)` **开始** `show("我的名字是 ", name, " , 我 ", age, "
    岁。")` **结束**'
- en: What is the difference between the following calls to the function, and why
    do the first and third calls result in the desired behavior of the function, but
    the second does not?
  id: totrans-78
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下两种调用函数的方式有什么不同，为什么第一个和第三个调用实现了期望的功能，而第二个没有？
- en: '`introduce("Mary", 25)` `introduce(25, "Mary")` `introduce(age = 25, name =
    "Mary")` 13.3 [5 min]'
  id: totrans-79
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`introduce("Mary", 25)` `introduce(25, "Mary")` `introduce(age = 25, name =
    "Mary")` 13.3 [5 分钟]'
- en: 'Consider the following program excerpt:'
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 考虑以下程序片段：
- en: '`age_person = 25` **Function** `getolder(age_person)` **Begin** `age_person
    = age_person + 1` `show("New age of the person: ", age_person)` `return(age_person)`
    **End** `age_new = getolder(age_person)` `show("Current age: ", age_person)` `show("Result
    of the function getolder(): ", age_new)`'
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`age_person = 25` **函数** `getolder(age_person)` **开始** `age_person = age_person
    + 1` `show("新年龄：", age_person)` `return(age_person)` **结束** `age_new = getolder(age_person)`
    `show("当前年龄：", age_person)` `show("getolder()函数的结果：", age_new)`'
- en: (a)
  id: totrans-82
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: (a)
- en: What output does this program generate and why?
  id: totrans-83
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 该程序生成什么输出，为什么？
- en: (b)
  id: totrans-84
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: (b)
- en: What two ways are there to modify the program so that the new age, which is
    one year higher, is also reflected in the global variable `age_person`?
  id: totrans-85
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 有哪两种方法可以修改程序，使得新的年龄（比原来高一岁）也能反映在全局变量 `age_person` 中？
- en: 13.2 Libraries
  id: totrans-86
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 13.2 库
- en: Libraries as a Toolbox for Programmers
  id: totrans-87
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 程序员的工具箱：库
- en: As a programmer, you can (as seen in the previous section) develop functions
    yourself. This always makes sense if you want to `reuse` program code, because
    the nice thing about functions is that they allow you to detach a certain functionality
    from your actual program and call it from anywhere at any time.
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 作为程序员，你可以（如前一节所示）自行开发函数。如果你希望`重用`程序代码，这总是有意义的，因为函数的好处是它们可以将特定功能从实际程序中分离出来，并可以在任何地方、任何时间调用。
- en: Of course, programming languages regularly come with an extensive set of standard
    functions that you can use to perform many common tasks. Often, however, these
    standard functions will not be sufficient for what you have in mind. For example,
    functions for sending e-mails, searching web pages (`web scraping`), or training
    neural networks are usually not included in the standard language scope. In these
    and other use cases, if you do not want to develop the functionality in question
    yourself, you will have to extend the language scope by installing the required
    functions from elsewhere.
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当然，编程语言通常会附带一组丰富的标准函数，你可以用它们来执行许多常见任务。然而，这些标准函数往往不足以满足你的需求。例如，发送电子邮件、网页抓取（`web
    scraping`）或训练神经网络的函数通常不包含在标准语言范围内。在这些及其他使用场景中，如果你不想自己开发所需的功能，就需要通过从其他地方安装所需的函数来扩展语言的功能范围。
- en: Find Suitable Libraries
  id: totrans-90
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 查找合适的库
- en: Some programming languages such as Python, R and JavaScript have a very extensive
    and lively `ecosystem` with a large number of developers who make the functionalities
    they have developed available to others free of charge. This is regularly done
    in the form of a set of functions focused on a certain topic. Such collections
    are usually called `libraries`, `modules`, `packages`, or `distributions`, depending
    on the programming language. For the sake of simplicity, we always refer here
    to “libraries”. In some cases, these libraries are brought together on a platform
    that is centrally managed by the organization that oversees the development of
    the programming language.
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一些编程语言，如 Python、R 和 JavaScript，拥有非常广泛且充满活力的 `生态系统`，有大量开发者将他们开发的功能免费提供给其他人。这通常以一组专注于某一主题的函数的形式发布。根据编程语言的不同，这些集合通常被称为
    `库`、`模块`、`包` 或 `发行版`。为简便起见，我们在此统一称之为“库”。在某些情况下，这些库会被汇集在一个由负责该编程语言开发的组织集中管理的平台上。
- en: 'This is the case, for example, for:'
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 例如，以下情况就是如此：
- en: Python with the `Python Package Index` (`PyPI`, ► [https://​pypi.​org/​](https://pypi.org/)),
  id: totrans-93
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: Python 与 `Python 软件包索引`（`PyPI`，► [https://pypi.org/](https://pypi.org/)），
- en: Perl with the `Comprehensive Perl Archive Network` (`CPAN`, ► [https://​www.​cpan.​org/​](https://www.cpan.org/)),
  id: totrans-94
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: Perl 与 `综合 Perl 存档网络`（`CPAN`，► [https://www.cpan.org/](https://www.cpan.org/)），
- en: PHP with the `PHP Extension Community Library` (`PECL`, ► [https://​pecl.​php.​net/​](https://pecl.php.net/)),
  id: totrans-95
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: PHP 与 `PHP 扩展社区库`（`PECL`，► [https://pecl.php.net/](https://pecl.php.net/)），
- en: R with the `Comprehensive R Archive Network` (`CRAN`, ► [https://​cran.​r-project.​org](https://cran.r-project.org)).
  id: totrans-96
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: R使用`Comprehensive R Archive Network`（`CRAN`，► [https://​cran.​r-project.​org](https://cran.r-project.org)）。
- en: Depending on the design, inclusion in one of these central catalogues is also
    accompanied by (mostly automated) quality control, which ensures, for example,
    that the program code of the library is executable and has at least a minimum
    of documentation.
  id: totrans-97
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 根据设计，加入这些中央目录的过程通常伴随着（主要是自动化的）质量控制，确保例如库的程序代码是可执行的，并且至少有最低限度的文档。
- en: For many programming languages, however, such a centrally organized library
    platform does not exist. Often, developers then deposit their works on `GitHub.`
    `GitHub` is a cross-language platform that allows developers to share source code
    with others by storing it in a `repository`. Underneath `GitHub` lies the version
    management tool `Git,` developed by Linux inventor `Linus Torvalds,` which allows
    changes to source code to be versioned in an elegant way. If necessary, it is
    then easy to revert to an old state of a single code file or even the entire `repository`.
    Developers can also use `GitHub` to create their own `branches of` the source
    code, develop features in them, and eventually `merge` them back into the original
    version, at least if the developer of the original version allows it. With these
    and a whole series of other features, `GitHub` facilitates collaboration between
    different developers on the basis of the underlying version management tool `Git.`
    `GitHub` is completely language agnostic; for most programming languages in use
    today, you will find repositories with code in that language. For developers who
    offer their source code under an open-source license, using `GitHub` is free at
    the time of writing this book. Companies and organizations that want to shield
    their code from the outside world pay for a private environment. While a number
    of comparable platforms exist alongside `GitHub,` `GitHub` is the most popular.
  id: totrans-98
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，对于许多编程语言来说，这样一个集中管理的库平台并不存在。开发者们通常会将自己的作品上传到`GitHub`。`GitHub`是一个跨语言平台，允许开发者通过将源代码存储在`repository`中与他人共享代码。在`GitHub`之下是版本管理工具`Git`，它由Linux发明者`Linus
    Torvalds`开发，能够以优雅的方式对源代码的变更进行版本控制。如果需要，开发者可以轻松地将单个代码文件甚至整个`repository`恢复到以前的状态。开发者还可以使用`GitHub`创建自己的源代码`branches`，在其中开发新功能，并最终将它们`merge`回原始版本，前提是原始版本的开发者允许这么做。凭借这些功能以及其他一系列特性，`GitHub`促进了不同开发者之间的协作，基于底层版本管理工具`Git`。`GitHub`完全不依赖于特定语言；对于今天大多数使用中的编程语言，你都可以在该语言的`repository`中找到代码。对于那些将源代码以开源许可证发布的开发者来说，使用`GitHub`在写本书时是免费的。想要将代码对外界保密的公司和组织需要为私有环境支付费用。尽管还有一些与`GitHub`类似的平台存在，但`GitHub`仍然是最受欢迎的。
- en: Of course, `GitHub` is not only used by those developers who work in a language
    without a central library platform. Many developers run `GitHub` repositories
    not for libraries but simply for their normal work on any kind of development
    projects, and to exchange information with other developers. If they do indeed
    develop libraries, they make only the finished versions available on the central
    library platforms such as `PyPI` or `CRAN.` Sometimes developers also don’t want
    to subject themselves to the strict rules and automated quality checks of the
    central library platforms and therefore offer their libraries exclusively on `GitHub.`
  id: totrans-99
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当然，`GitHub`不仅被那些在没有中心库平台的语言中工作的开发者使用。许多开发者在`GitHub`上运行`repository`，并非为了库，而是为了他们在任何类型的开发项目上的日常工作，或是与其他开发者交换信息。如果他们确实开发了库，他们通常只会将最终版本发布到像`PyPI`或`CRAN`这样的中心库平台上。有时候，开发者也不想受到中心库平台的严格规则和自动化质量检查的限制，因此只在`GitHub`上提供他们的库。
- en: 因此，`GitHub`和中心库平台都是寻找帮助你解决特定问题的库的好地方，这并不奇怪。不过，这种搜索有时并不是完全简单的，原因有几个。平台的搜索功能各不相同，每个库的可用信息也有所不同。因此，有时找到一个库并判断它是否适合解决你的问题并不容易。这种评估进一步复杂化，因为通常会有多个库可能适合。即使在中央管理的库平台上，对于许多任务也存在几个在一定程度上相互竞争的库。推荐两种方法。一种是`trial
    and error`；下载并使用“候选者”，以确定哪个库最适合你的问题。另一种是在互联网上搜索，在相关论坛（如`Stack Overflow`）中，您可以定期找到有关许多库的信息。这在你想通过示例了解如何使用该库时尤其有用。库的文档在范围和质量上各不相同，因此像`Stack
    Overflow`这样的论坛在使用已找到的合适库时也能提供良好的帮助。
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 因此，`GitHub`和中心库平台都是寻找帮助你解决特定问题的库的好地方，这并不奇怪。不过，这种搜索有时并不是完全简单的，原因有几个。平台的搜索功能各不相同，每个库的可用信息也有所不同。因此，有时找到一个库并判断它是否适合解决你的问题并不容易。这种评估进一步复杂化，因为通常会有多个库可能适合。即使在中央管理的库平台上，对于许多任务也存在几个在一定程度上相互竞争的库。推荐两种方法。一种是`trial
    and error`；下载并使用“候选者”，以确定哪个库最适合你的问题。另一种是在互联网上搜索，在相关论坛（如`Stack Overflow`）中，您可以定期找到有关许多库的信息。这在你想通过示例了解如何使用该库时尤其有用。库的文档在范围和质量上各不相同，因此像`Stack
    Overflow`这样的论坛在使用已找到的合适库时也能提供良好的帮助。
- en: 除此之外，像`Stack Overflow`这样的论坛通常是识别解决问题的库候选者的良好首选——如果你不能或不想直接通过中心库平台或在`GitHub`上搜索。这是因为论坛中的问题通常是按照“我如何解决这个问题……”或“我如何让它……”的结构来组织的，答案中往往包含一个或多个可以帮助解决此类问题的库的引用。许多开发者更喜欢这种论坛搜索，而不是直接在中心库平台或`GitHub`上搜索，因为这些论坛中的示例和用户评论通常提供了宝贵的额外信息。
  id: totrans-101
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 除此之外，像`Stack Overflow`这样的论坛通常是识别解决问题的库候选者的良好首选——如果你不能或不想直接通过中心库平台或在`GitHub`上搜索。这是因为论坛中的问题通常是按照“我如何解决这个问题……”或“我如何让它……”的结构来组织的，答案中往往包含一个或多个可以帮助解决此类问题的库的引用。许多开发者更喜欢这种论坛搜索，而不是直接在中心库平台或`GitHub`上搜索，因为这些论坛中的示例和用户评论通常提供了宝贵的额外信息。
- en: 不用说，你也可以使用像`ChatGPT`这样的AI助手来搜索合适的库。例如，询问：“我想写一个读取网站数据的Python程序（`webscraping`）。有哪些库可用，它们有什么不同，哪些特别适合初学者？”
  id: totrans-102
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 不用说，你也可以使用像`ChatGPT`这样的AI助手来搜索合适的库。例如，询问：“我想写一个读取网站数据的Python程序（`webscraping`）。有哪些库可用，它们有什么不同，哪些特别适合初学者？”
- en: 安装和导入/加载库
  id: totrans-103
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 安装和导入/加载库
- en: 一旦你找到了合适的库，你所需要做的就是安装它（如果编程语言对此有要求）并将其包含在程序代码中。包含的方式是通过一个语句，该语句要么将库整体导入，要么将其中的单个元素（例如单个函数或类）导入程序代码。在某些情况下，可以指定一个名称，用于标识已导入的元素，这有助于避免与已存在的变量、类、对象或函数的标识符冲突。
  id: totrans-104
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一旦你找到了合适的库，你所需要做的就是安装它（如果编程语言对此有要求）并将其包含在程序代码中。包含的方式是通过一个语句，该语句要么将库整体导入，要么将其中的单个元素（例如单个函数或类）导入程序代码。在某些情况下，可以指定一个名称，用于标识已导入的元素，这有助于避免与已存在的变量、类、对象或函数的标识符冲突。
- en: 'A (hypothetical) example from `Python`:'
  id: totrans-105
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个来自`Python`的（假设的）示例：
- en: '`from somelibrary import aclass as my_class import somelibrary`'
  id: totrans-106
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`from somelibrary import aclass as my_class import somelibrary`'
- en: The first statement imports only the class `aclass` into the program code and
    then makes it accessible under the identifier `my_class`。The second, alternative
    statement imports the entire `library` (in this case without assigning it a different
    identifier)。
  id: totrans-107
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第一个语句仅将类`aclass`导入程序代码，并将其通过标识符`my_class`进行访问。第二个替代语句导入整个`library`（在此情况下没有分配不同的标识符）。
- en: It is easier in `Pascal`
  id: totrans-108
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在`Pascal`中更容易
- en: '`uses somelibrary;`'
  id: totrans-109
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`uses somelibrary;`'
- en: or `R`
  id: totrans-110
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 或`R`
- en: '`library(somelibrary)`'
  id: totrans-111
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`library(somelibrary)`'
- en: where the entire `library` is made available in each case。
  id: totrans-112
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在每个情况下，整个`library`（库）都会被提供。
- en: 13.3 Frameworks
  id: totrans-113
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 13.3 框架（Frameworks）
- en: There is a lot of talk about `frameworks`，especially in the field of web development.
    The terms “`framework`” and “`library`” are sometimes not used in a very clear-cut
    way. Even though the functionality and use of `frameworks` goes beyond what we
    will look at in this book, at least the distinction between the two concepts should
    be examined in more detail. `Libraries` contain functionalities that the user，即，the
    programmer，可以在需要时访问，以执行特定任务。因此，主动权在程序员手中。`Frameworks`，则不同。`Frameworks`控制整个应用程序的流程，并在必要时调用程序员的代码。`Frameworks`因此形成了，正如术语所暗示的那样，一个框架，程序员“只需”填充。这在网页开发领域尤其实用，因为有许多重复的任务，例如用户登录的身份验证、数据库的连接，或在模板页面中输出数据。所有这些任务都可以由`framework`接管。它们已经作为功能内置在程序员正在使用的`framework`中。程序员只需开发与其应用程序特定的内容。通过`framework`和开发者之间的这种劳动分工，应用程序的控制实际上是反转的（这就是为什么在与`frameworks`相关时，有人也会谈论`inversion
    of control`）：`Framework`控制应用程序，开发者提供应用程序特定的程序代码，然后`framework`在合适的地方调用。这使开发者能够集中精力处理重要问题，而将所有相对无聊的“附属工作”留给`framework`。
  id: totrans-114
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在`web开发`领域，经常会讨论`framework`（框架），尤其是在网页开发方面。术语“`framework`”（框架）和“`library`”（库）有时并不十分明确区分。尽管`framework`的功能和用途超出了本书讨论的范围，但至少应该更详细地探讨这两个概念的区别。`Library`（库）包含程序员可以在需要时访问的功能，以执行特定任务。因此，主动权在程序员手中。`Framework`（框架）则不同。`Framework`控制整个应用程序的流程，并在必要时调用程序员的代码。`Framework`因此形成了，正如术语所暗示的那样，一个框架，程序员“只需”填充。这在网页开发领域尤其实用，因为有许多重复的任务，例如用户登录的身份验证、数据库的连接，或在模板页面中输出数据。所有这些任务都可以由`framework`接管。它们已经作为功能内置在程序员正在使用的`framework`中。程序员只需开发与其应用程序特定的内容。通过`framework`和开发者之间的这种劳动分工，应用程序的控制实际上是反转的（这就是为什么在与`frameworks`相关时，有人也会谈论`inversion
    of control`）：`Framework`控制应用程序，开发者提供应用程序特定的程序代码，然后`framework`在合适的地方调用。这使开发者能够集中精力处理重要问题，而将所有相对无聊的“附属工作”留给`framework`。
- en: Well-known `frameworks` include `AngularJS` and `React` (for `JavaScript`),
    `django` (for `Python`), `CakePHP` and `Zen` (for `PHP`), and `Ruby on Rails`
    (for `Ruby`)。
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 知名的`frameworks`（框架）包括`AngularJS`和`React`（用于`JavaScript`）、`django`（用于`Python`）、`CakePHP`和`Zen`（用于`PHP`）以及`Ruby
    on Rails`（用于`Ruby`）。
- en: Because the focus of this book is on learning the basics of programming, we
    will not be working with `frameworks` here. However, a prerequisite for using
    `frameworks` is, of course, knowledge of the underlying language, and that’s what
    we’re dealing with here in the book.
  id: totrans-116
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 由于本书的重点是学习编程基础，因此我们在这里不会涉及`frameworks`。然而，使用`frameworks`的前提是，当然需要了解底层语言，而这正是我们在本书中讨论的内容。
- en: 13.4 Application Programming Interfaces (APIs)
  id: totrans-117
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 13.4 应用程序编程接口（APIs）
- en: Another term that is on everyone’s lips is that of the `Application Programming
    Interface`, or API for short. First of all, APIs are – as the name suggests –
    nothing more than `programming interfaces`. In this sense, a library that provides
    a set of functions for specific purposes also provides a programming interface
    that consists of the library’s functions that you can access from within your
    program.
  id: totrans-118
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 另一个人人都在谈论的术语是`应用程序编程接口`，简称API。首先，API正如其名字所示，实际上就是`编程接口`。从这个意义上说，一个提供特定目的功能集的库，也提供了一个编程接口，它由可以在程序中访问的库函数组成。
- en: When people talk about APIs today, they are often referring to specific programming
    interfaces, such as `Web APIs` through which you can access the functionality
    and data of web services. Many web services today offer programming interfaces
    for developers. For example, a `GoogleMaps API` provided by Google returns the
    geo-coordinates of a city if you pass the name of the city to the API. Here, an
    API is used to retrieve information provided by the web service. In the same way,
    however, APIs can also be used to get a web service to trigger a specific action.
    Twitter’s API, for example, allows you to post tweets. All you need is an account
    that allows you to use the API and a corresponding instruction in your program
    that addresses the API and sends the tweet.
  id: totrans-119
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当人们今天谈论 API 时，他们通常指的是特定的编程接口，例如 `Web API`，通过这些接口你可以访问 web 服务的功能和数据。如今，许多 web
    服务为开发者提供了编程接口。例如，Google 提供的 `GoogleMaps API`，如果你将城市名称传递给该 API，它会返回该城市的地理坐标。在这里，API
    用于获取 web 服务提供的信息。同样，API 也可以用来让 web 服务触发特定的操作。例如，Twitter 的 API 允许你发布推文。你只需要一个可以使用该
    API 的账户，并在程序中写出相应的指令，指向该 API 并发送推文。
- en: So, APIs can be used to query data and trigger functions. There are literally
    thousands of web services that offer APIs which can be accessed via the Internet.
    The website `ProgrammableWeb` (► [https://​www.​programmableweb.​com/​apis/​directory](https://www.programmableweb.com/apis/directory))
    provides an overview of API providers that is certainly not complete, but at least
    very comprehensive. Whether you want to process payments with `PayPal` from your
    program or check the latest football results, with the web APIs available today,
    hardly any wish remains unfulfilled.
  id: totrans-120
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 因此，API 可以用于查询数据并触发功能。如今，互联网上有成千上万的 web 服务提供 API，这些 API 可以被访问。网站 `ProgrammableWeb`（►
    [https://​www.​programmableweb.​com/​apis/​directory](https://www.programmableweb.com/apis/directory)）提供了一个
    API 提供商的概览，虽然不完全，但至少非常全面。无论你是想在程序中使用 `PayPal` 处理支付，还是查看最新的足球比赛结果，凭借今天提供的 web API，几乎没有什么愿望无法实现。
- en: 'Technically, `Web APIs` mostly work with the `Hypertext Transfer Protocol`
    (HTTP) and can be called like web pages. For example, to access the `GoogleMaps
    API` to get the geo-location of Chicago, a program would simply need to make an
    HTTP request of the form ► [https://​maps.​googleapis.​com/​maps/​api/​geocode/​json?​address=​Chicago&​key=​XX](https://maps.googleapis.com/maps/api/geocode/json?address=Chicago&key=XX),
    where `key` is a parameter that authenticates the caller of the API as a legitimate
    user. Google would then return the coordinates, in JSON format, a data exchange
    format that is extremely popular with `Web APIs` because it is easy to generate
    and easy to read, and which we will learn about in more detail in ► Sect. [31.​5.​6](474412_1_En_31_Chapter.xhtml#Sec17).
    If you were to enter the request as it is into your web browser, you would also
    get a result in JSON format, but an error message, because `XX` is not a key that
    identifies you as the legitimate API user:'
  id: totrans-121
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 从技术上讲，`Web API` 主要与 `超文本传输协议`（HTTP）一起工作，可以像网页一样进行调用。例如，要访问 `GoogleMaps API`
    获取芝加哥的地理位置，一个程序只需要发出如下形式的 HTTP 请求 ► [https://​maps.​googleapis.​com/​maps/​api/​geocode/​json?​address=​Chicago&​key=​XX](https://maps.googleapis.com/maps/api/geocode/json?address=Chicago&key=XX)，其中
    `key` 是一个参数，用于验证调用 API 的用户身份是否合法。然后，Google 会返回坐标，格式为 JSON，这是一种在 `Web API` 中极为流行的数据交换格式，因为它易于生成且易于阅读，稍后我们会在
    ► 第 [31.​5.​6](474412_1_En_31_Chapter.xhtml#Sec17) 节详细了解。如果你将这个请求直接输入到网页浏览器中，你也会得到
    JSON 格式的结果，但会收到一条错误信息，因为 `XX` 不是一个有效的 API 用户密钥：
- en: '`{"error_message" : "The provided API key is invalid.","results" : [],"status"
    : "REQUEST_DENIED"}`'
  id: totrans-122
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`{"error_message" : "提供的 API 密钥无效。","results" : [],"status" : "REQUEST_DENIED"}`'
- en: However, a program does not need a web browser to make such requests to a web
    service via an API. The corresponding HTTP requests can be triggered from within
    most programming languages (often using a library that provides the corresponding
    functions), and their returns can be processed without the user of the program
    having to know anything about it.
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，一个程序并不需要使用网页浏览器通过 API 向 web 服务发出此类请求。相应的 HTTP 请求可以通过大多数编程语言内部触发（通常使用提供相应功能的库），并且返回的结果可以在程序用户无需了解任何细节的情况下进行处理。
- en: We won’t continue discussing Web APIs in detail, because we’re focusing on the
    basics of programming in this book. However, given these basics, it’s easy to
    take the next step and learn exactly how to incorporate Web APIs into your programs.
    The most important thing to understand at this point is that web APIs are a versatile
    tool for extending the functionality of your programs. Ultimately, they work just
    like library functions; they are called (albeit slightly differently), trigger
    an action or retrieve information, and return a value (often a JSON object). The
    basic concept, which is that of a programming interface, or API, is the same in
    both cases.
  id: totrans-124
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们不会继续详细讨论 Web API，因为本书的重点是编程基础。然而，掌握了这些基础后，进一步学习如何将 Web API 融入到程序中就变得非常容易。此时，最重要的是理解
    Web API 是一种用于扩展程序功能的多用途工具。最终，它们的工作方式与库函数相似；它们被调用（尽管方式稍有不同），触发某个操作或检索信息，并返回一个值（通常是一个
    JSON 对象）。在两者之间，编程接口（API）的基本概念是相同的。
- en: 13.5 Your Roadmap to Learning a New Programming Language
  id: totrans-125
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 13.5 学习新编程语言的路线图
- en: If you are learning a new programming language …
  id: totrans-126
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你正在学习一门新的编程语言……
- en: 'you’ll discover:'
  id: totrans-127
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你将发现：
- en: how functions are defined; in particular, how optional arguments are used, how
    (and whether) arguments can be taken by reference instead of by value, and how
    functions can return values,
  id: totrans-128
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 函数是如何定义的；特别是，如何使用可选参数，如何（以及是否）将参数按引用传递而不是按值传递，以及函数如何返回值，
- en: how functions are called; in particular, how (and whether) arguments can be
    passed by name when calling a function,
  id: totrans-129
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 函数是如何被调用的；特别是，当调用函数时，参数是否可以通过名称传递，
- en: how the scopes of variables are designed and whether it is possible to access
    a global variable from within a function (especially if it has the same name as
    a local variable)
  id: totrans-130
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 变量的作用域是如何设计的，以及是否可以在函数内部访问全局变量（特别是当它与局部变量同名时）
- en: what good reference sources for libraries exist and how to search for suitable
    libraries; in particular, whether a centrally administered platform exists, which
    is de facto the main point of contact when searching for suitable libraries,
  id: totrans-131
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 存在什么好的库参考资源以及如何搜索合适的库；特别是，是否存在一个集中管理的平台，这个平台实际上是搜索合适库时的主要联系点，
- en: how to include libraries (or elements from them) in your program and how to
    access their functionality.
  id: totrans-132
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何将库（或其元素）包含到你的程序中，并访问它们的功能。
- en: 13.6 Solutions to the Exercises
  id: totrans-133
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 13.6 练习解答
- en: Exercise 13.1
  id: totrans-134
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 13.1
- en: (a)
  id: totrans-135
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: (a)
- en: In the return statement `return()` an argument `exponent` is used, but this
    argument does not appear in the argument list in the head of the function. The
    header should therefore correctly read `function exponential(base, exponent)`.
  id: totrans-136
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 在`return()`语句中使用了参数`exponent`，但是该参数并没有出现在函数头部的参数列表中。因此，函数头应该正确写作`function exponential(base,
    exponent)`。
- en: (b)
  id: totrans-137
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: (b)
- en: This time, the argument `exponent` is included in the argument list in the function
    header. However, the function does not return a value. A variable `result` is
    calculated, but it is not returned with the help of `return()`. The statement
    `return(result)` would have to be added as the last statement of the function.
  id: totrans-138
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 这次，参数`exponent`被包含在函数头的参数列表中。然而，函数没有返回值。计算了一个变量`result`，但它没有通过`return()`返回。必须将`return(result)`语句作为函数的最后一条语句添加。
- en: Exercise 13.2
  id: totrans-139
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 13.2
- en: '`**introduce("Mary", 25)** calls the function as it is intended. The first
    argument in the argument list in the function header is the name, the second is
    the age.` `introduce(25, "Mary")` `flips the argument values around when the function
    is called. Now the first argument` `(**name**)` `is assigned the value` `25`,
    `the second argument` `(**age**)` `the value` `"Mary"`. `In the best case, the
    function then outputs a somewhat strange-looking text, but in the worst case,
    it terminates with an error because the expected types of the arguments and the
    passed values do not match. Finally, the call` `introduce(age = 25, name = "Mary")`
    `also flips the arguments around when the function is called, but by specifying
    the argument names it is clear how the passed values should be assigned to the
    arguments of the function, so the different order of the arguments when the function
    is called is not a problem.`'
  id: totrans-140
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`**introduce("Mary", 25)** 按照预期调用函数。函数头部参数列表中的第一个参数是姓名，第二个参数是年龄。` `introduce(25,
    "Mary")` `在调用函数时交换了参数的顺序。现在，第一个参数` `(**name**)` `被赋值为` `25`，`第二个参数` `(**age**)`
    `被赋值为` `"Mary"`。`在最好的情况下，函数会输出一个看起来有些奇怪的文本，但在最坏的情况下，它会因预期的参数类型和传入值不匹配而终止并报错。最后，调用`
    `introduce(age = 25, name = "Mary")` `也会交换参数顺序，但通过指定参数名称，传入的值如何分配给函数的参数变得清晰，因此，函数调用时参数顺序的不同不再是问题。`'
- en: '`Exercise 13.3`'
  id: totrans-141
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`练习 13.3`'
- en: '`(a)The program will produce the following output:` `New age of the person:
    26Current age: 25Result of the function getolder(): 26`'
  id: totrans-142
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`(a) 程序将输出以下内容：` `New age of the person: 26Current age: 25Result of the function
    getolder(): 26`'
- en: '`The function` `getolder()` `increments the value of the argument` `age_person`
    `passed to it and returns this as the function value. The` *global* `variable
    of the same name,` `age_person`, `remains unaffected. Priority in the scope of
    the function is given to the argument, which is treated as a` *local* `variable.`'
  id: totrans-143
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: '`函数` `getolder()` `增加了传入参数` `age_person` `的值，并将其作为函数值返回。同名的` *全局* `变量` `age_person`
    `保持不变。函数作用域内优先使用的是该参数，它被视为` *局部* `变量。`'
- en: '`(b)The first possibility is to catch the return value of the function` `getolder()`
    `in the global variable` `age_person`: `age_person = getolder(age_person)`'
  id: totrans-144
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`(b) 第一种可能性是将函数` `getolder()` `的返回值捕获到全局变量` `age_person`：` `age_person = getolder(age_person)`'
- en: '`Alternatively, the argument` `age` `of the function can be defined as an argument
    passed by` *reference* ` (if the programming language used allows it). Then the
    function header would look like this:` `Function getolder(AsReference age_person)`.
    `This way, the` `age_person` `argument would still be considered a local variable
    (it could not be accessed outside of the function’s code block), but changes to
    it would immediately result in changes to the variable passed in (i.e.,` `age`).
    `Thus, the` `getolder()` `function would ultimately be able to change the global
    variable` `age`.`'
  id: totrans-145
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: '`另一种方式是将函数的` `age` `参数定义为通过` *引用* `传递的参数（如果所使用的编程语言允许）。然后，函数头部会像这样定义：` `Function
    getolder(AsReference age_person)`。`这样，` `age_person` `参数仍然被视为局部变量（它不能在函数代码块外部访问），但是对它的修改会立即反映到传入的变量（即`
    `age`）。`因此，` `getolder()` `函数最终能够修改全局变量` `age`。`'
