- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re almost at the end of our journey, as this chapter represents the last
    significant data structure you’ll encounter in this book. You’ve seen that graphs
    are extremely powerful tools for dealing with data involving relationships, and
    in addition to making our code fast, they can also help solve tricky problems.
  prefs: []
  type: TYPE_NORMAL
- en: In truth, I could fill a book just discussing graphs. So many interesting and
    useful algorithms surround this data structure, such as the minimum spanning tree,
    topological sort, bidirectional search, the Floyd--Warshall algorithm, the Bellman–Ford
    algorithm, and graph coloring, just to name a few. But this chapter should serve
    as the foundation for you to explore these additional topics.
  prefs: []
  type: TYPE_NORMAL
- en: Along our travels, our primary focus has been on how fast our code will run;
    that is, we’ve been measuring how efficient our code performs in terms of time,
    and we’ve been measuring that in terms of counting the number of steps our algorithms
    take.
  prefs: []
  type: TYPE_NORMAL
- en: However, efficiency can be measured in ways other than speed alone. In particular,
    we might care about how much memory a data structure or algorithm might consume.
    In the next chapter, you’ll learn how to analyze the efficiency of our code in
    terms of space.
  prefs: []
  type: TYPE_NORMAL
