- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following exercises provide you with the opportunity to practice with optimizing
    your code. The solutions to these exercises are found in the section [​*Chapter
    20*​](f_0225.xhtml#tips.for.code.optimization.solutions).
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re working on software that analyzes sports players. Following are two
    arrays of players of different sports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ​  | const basketballPlayers = [ |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | { firstName: ''Jill'', lastName: ''Huang'', team: ''Gators'' }, |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | { firstName: ''Janko'', lastName: ''Barton'', team: ''Sharks'' }, |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | { firstName: ''Wanda'', lastName: ''Vakulskas'', team: ''Sharks'' },
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | { firstName: ''Jill'', lastName: ''Moloney'', team: ''Gators'' }, |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | { firstName: ''Luuk'', lastName: ''Watkins'', team: ''Gators'' }, |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ]; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | const footballPlayers = [ |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | { firstName: ''Hanzla'', lastName: ''Radosti'', team: ''32ers'' }, |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | { firstName: ''Tina'', lastName: ''Watkins'', team: ''Barleycorns''
    }, |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | { firstName: ''Alex'', lastName: ''Patel'', team: ''32ers'' }, |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | { firstName: ''Jill'', lastName: ''Huang'', team: ''Barleycorns'' },
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | { firstName: ''Wanda'', lastName: ''Vakulskas'', team: ''Barleycorns''
    }, |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ​  | ]; |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: If you look carefully, you’ll see that there are some players who participate
    in more than one kind of sport. Jill Huang and Wanda Vakulskas play both basketball
    and football.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You are to write a function that accepts two arrays of players and returns
    an array of the players who play in both sports. In this case, that would be the
    following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ​  | ["Jill Huang", "Wanda Vakulskas"] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: While there are players who share first names and players who share last names,
    we can assume there’s only one person who has a particular full name (meaning
    first and last name).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can use a nested-loops approach, comparing each player from one array against
    each player from the other array, but this would have a runtime of O(N * M). Your
    job is to optimize the function so that it can run in just O(N + M).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You’re writing a function that accepts an array of distinct integers from 0,
    1, 2, 3…up to N. However, the array will be missing one integer, and your function
    is to return the missing one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, this array has all the integers from 0 to 6 but is missing the
    4:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ​  | [2, 3, 0, 6, 1, 5] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Therefore, the function should return 4.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next example has all the integers from 0 to 9 but is missing the 1:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ​  | [8, 2, 3, 9, 4, 7, 5, 0, 6] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: In this case, the function should return the 1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using a nested-loops approach would take up to O(N²). Your job is to optimize
    the code so that it has a runtime of O(N).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You’re working on some more stock-prediction software. The function you’re writing
    accepts an array of predicted prices for a particular stock over the course of
    time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, look at this array of seven prices:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ​  | [10, 7, 5, 8, 11, 2, 6] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: It predicts that a given stock will have these prices over the next seven days.
    (On Day 1, the stock will close at $10; on Day 2, the stock will close at $7;
    and so on.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Your function should calculate the greatest profit that could be made from a
    single “buy” transaction followed by a single “sell” transaction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this example, the most money could be made if we bought the stock when it
    was worth $5 and sold it when it was worth $11\. This yields a profit of $6 per
    share.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that we could make even more money if we buy and sell multiple times, but
    for now, this function focuses on the most profit that could be made from just
    one purchase followed by one sale.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we could use nested loops to find the profit of every possible buy-and-sell
    combination. However, this would be O(N²) and too slow for our hotshot trading
    platform. Your job is to optimize the code so that the function clocks in at just
    O(N).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You’re writing a function that accepts an array of numbers and computes the
    highest product of any two numbers in the array. At first glance this is easy,
    as we can just find the two greatest numbers and multiply them. However, our array
    can contain negative numbers and look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ​  | [5, -10, -6, 9, 4] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: In this case, it’s actually the product of the two lowest numbers, -10 and -6
    that yield the highest product of 60.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We could use nested loops to multiply every possible pair of numbers, but this
    would take O(N²) time. Your job is to optimize the function so that it’s a speedy
    O(N).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You’re creating software that analyzes the data of body temperature readings
    taken from hundreds of human beings. These readings are taken from both healthy
    and sick people and range from 95 to 105 degrees Fahrenheit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s a sample array of temperature readings:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ​  | [98, 99, 95, 105, 104, 98, 101, 99, 100, 97] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: You are to write a function that sorts these readings from lowest to highest.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you used a classic sorting algorithm such as Quicksort, this would take O(N
    log N). However, in this case, it’s possible to write a faster sorting algorithm.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Yes, that’s right. Even though you’ve learned that the fastest sorts are O(N
    log N), this case is different. Why? In this case, there’s a limited number of
    possibilities of what the readings will be. In such a case, we can sort these
    values in O(N). It may be N multiplied by a constant, but that’s still considered
    O(N).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You’re writing a function that accepts an array of unsorted integers and returns
    the length of the longest consecutive sequence among them. The sequence is formed
    by integers that increase by 1\. For example, have a look at this array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ​  | [10, 5, 12, 3, 55, 30, 4, 11, 2] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: The longest consecutive sequence is 2-3-4-5\. These four integers form an increasing
    sequence because each integer is one greater than the previous one. While there’s
    also a sequence of 10-11-12, it’s only a sequence of three integers. In this case,
    the function should return 4, since that’s the length of the longest consecutive
    sequence that can be formed from this array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s one more example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ​  | [19, 13, 15, 12, 18, 14, 17, 11] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: This array’s longest sequence is 11-12-13-14-15, so the function would return
    5.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we sorted the array, we can then traverse the array just once to find the
    longest consecutive sequence. However, the sorting itself would take O(N log N).
    Your job is to optimize the function so that it takes O(N) time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copyright © 2024, The Pragmatic Bookshelf.
  prefs: []
  type: TYPE_NORMAL
