- en: Password Cracker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’re a hacker (an ethical one, of course) who’s trying to figure out someone’s
    password. You decide on a brute-force approach and write some code that produces
    every possible string of a given length. Here’s the code you whipped up:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**function**​ everyPassword(length) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**let**​ string = ​*''a''*​.repeat(length); |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | console.log(string); |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**while**​ (string !== ​*''z''*​.repeat(length)) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**let**​ stringToBase36 = parseInt(string, 36); |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | stringToBase36 += 1; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | string = (stringToBase36.toString(36)).replace(​*/0/g*​, ​*''a''*​);
    |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | console.log(string); |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: There’s a bit of complicated magic in this code, which thankfully, we don’t
    need to understand at this time. That’s because we’re not going to focus on how
    this code works, but rather what this code does.
  prefs: []
  type: TYPE_NORMAL
- en: When we call the everyPassword function, we pass in an integer, which becomes
    the variable length.
  prefs: []
  type: TYPE_NORMAL
- en: 'If length is 3, the code will return all possible strings within the range
    of "aaa" and "zzz". Running this code will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | aaa |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | aab |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | aac |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | aad |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | aae |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ... |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | zzx |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | zzy |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | zzz |'
  prefs: []
  type: TYPE_TB
- en: 'If length is 4, your code will print all possible strings of length 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | aaaa |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | aaab |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | aaac |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | aaad |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | aaae |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ... |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | zzzx |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | zzzy |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | zzzz |'
  prefs: []
  type: TYPE_TB
- en: If you try running this code even for a mere length of 5, you may be waiting
    some time for it to finish. This is a slow algorithm! But how do we express it
    in terms of Big O?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break it down.
  prefs: []
  type: TYPE_NORMAL
- en: If we simply print each letter from the alphabet once, it will take 26 steps.
  prefs: []
  type: TYPE_NORMAL
- en: When we print every two-character combination, we end up with 26 characters
    multiplied by 26 characters.
  prefs: []
  type: TYPE_NORMAL
- en: When printing every three-character combination, we end up with 26 * 26 * 26
    combinations.
  prefs: []
  type: TYPE_NORMAL
- en: Do you see the pattern?
  prefs: []
  type: TYPE_NORMAL
- en: '| Length | Combinations |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 26 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 26² |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 26³ |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 26⁴ |'
  prefs: []
  type: TYPE_TB
- en: If we look at this in terms of N, it emerges that if N is the length of each
    string, the number of combinations is 26^N.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in Big O notation, we express this as O(26^N). This is an utterly
    glacial algorithm! The truth is that even an algorithm that is a “mere” O(2^N)
    is incredibly slow. Let’s see how it looks on a graph compared to some of the
    other algorithms we’ve seen so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/big_o_in_everyday_code/different_big_os.png](images/big_o_in_everyday_code/different_big_os.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, O(2^N) gets even slower than O(N³) at a point.
  prefs: []
  type: TYPE_NORMAL
- en: In a certain sense, O(2^N) is the opposite of O(log N). With an algorithm of
    O(log N) (like binary search), each time the data is doubled, the algorithm takes
    one additional step. With an algorithm of O(2^N), each time we add one element
    of data, the algorithm doubles in steps!
  prefs: []
  type: TYPE_NORMAL
- en: In our password cracker, each time we increase N by one, the number of steps
    get multiplied by 26. This takes an incredible amount of time, which is why brute
    force is such an inefficient way to crack a password.
  prefs: []
  type: TYPE_NORMAL
