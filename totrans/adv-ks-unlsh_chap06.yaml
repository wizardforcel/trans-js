- en: '`‘this’` keyword'
  id: totrans-0
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`‘this’`关键字'
- en: The `this` keyword is among the most confusing concepts in the JavaScript language.
    The cause of confusion is the different ways in which the value of the `this`
    keyword is set in different contexts.
  id: totrans-1
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`this`关键字是JavaScript语言中最令人困惑的概念之一。混淆的原因在于`this`关键字的值在不同上下文中以不同方式设置。'
- en: 'In this module, we will try to demystify the `this` keyword. We will understand
    different ways in which the value of `this` is set. The `this` keyword can be
    used in different contexts: inside functions, global scope, inside modules, etc.
    We will explore different contexts and how `this` is set in those contexts.'
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在本模块中，我们将尝试揭开`this`关键字的神秘面纱。我们将理解`this`值设置的不同方式。`this`关键字可以在不同的上下文中使用：函数内部、全局作用域、模块内部等。我们将探索不同的上下文以及`this`在这些上下文中是如何设置的。
- en: Function context
  id: totrans-3
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 函数上下文
- en: The `this` keyword is mostly used inside functions to refer to the object using
    which the function was invoked. In other words, when a function is invoked as
    a “method” (invoked using an object), the `this` keyword becomes applicable for
    referencing the object used to invoke the function.
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`this`关键字主要用于函数内部，指代调用该函数的对象。换句话说，当一个函数作为“方法”（使用对象调用）被调用时，`this`关键字适用于引用用于调用该函数的对象。'
- en: The `this` keyword is like an implicit parameter passed to a function. Just
    like explicit function parameters, the value of implicit parameter `this` is set
    when the function is `invoked`. This is an important point. The value of `this`
    inside a function depends on `how` that function is `called`.
  id: totrans-5
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`this`关键字就像是一个隐式参数，传递给函数。就像显式函数参数一样，隐式参数`this`的值在函数被`调用`时设置。这是一个重要的观点。函数内部的`this`值取决于该函数是`如何`被`调用`的。'
- en: 'Consider the following code example:'
  id: totrans-6
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 考虑以下代码示例：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s a `Replit` of the code above:'
  id: totrans-8
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是上面代码的`Replit`：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/what-is-this-example1”>`'
  id: totrans-9
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/what-is-this-example1”>`'
- en: 'The `printInfo` function in the code example above uses the `this` keyword,
    and looking at the code, we can tell that the `printInfo` function assumes that
    the value of `this` inside the `printInfo` function will be an object with three
    properties: `id`, `name`, and `email`. But as mentioned earlier, the value of
    `this` inside a function depends on `how` the function is called.'
  id: totrans-10
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上述代码示例中的`printInfo`函数使用了`this`关键字，查看代码，我们可以知道`printInfo`函数假定`this`在函数内部的值将是一个具有三个属性的对象：`id`、`name`和`email`。但如前所述，函数内部的`this`值取决于函数是`如何`被调用的。
- en: In the code example above, the `printInfo` function is invoked using the `student`
    object, and when a function is invoked using an object, the `this` inside that
    function refers to the object using which the function was invoked. So in our
    code example, `this` inside the `printInfo` refers to the `student` object. As
    the `student` object has the three properties that are accessed using the `this`
    keyword inside the `printInfo` function, their values are logged to the console.
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上述代码示例中，`printInfo`函数使用`student`对象调用，当函数使用对象调用时，该函数内部的`this`指向用于调用该函数的对象。因此在我们的代码示例中，`printInfo`中的`this`指向`student`对象。由于`student`对象具有通过`this`关键字在`printInfo`函数内部访问的三个属性，它们的值被记录到控制台。
- en: 'What will `this` refer to if the function is not invoked as a “method”? Consider
    the following code example:'
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果函数没有作为“方法”调用，`this`将指向什么？考虑以下代码示例：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s a `Replit` of the code above:'
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是上面代码的`Replit`：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/what-is-this-example2”>`'
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/what-is-this-example2”>`'
- en: What does `this` refer to inside the `orderFood` function?
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`orderFood`函数内部的`this`指向什么？'
- en: The answer to the question above depends on whether our code is executed in
    [`strict mode`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
    If non-strict mode, `this` inside a function, when not invoked as a method, refers
    to the global object, which in the case of browsers is the `window` object. However,
    the value of `this` inside a function is `undefined` in strict mode when not invoked
    as a method.
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上面问题的答案取决于我们的代码是否在[`严格模式`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)下执行。如果是非严格模式，当函数未作为方法调用时，函数内部的`this`指向全局对象，而在浏览器中，全局对象是`window`对象。然而，在严格模式下，当函数未作为方法调用时，函数内部的`this`值为`undefined`。
- en: 你能从上面代码的输出中猜出代码是以哪种模式执行的吗？因为`this.fullName`的值为`undefined`，所以代码是在非严格模式下执行的。
  id: totrans-18
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你能从上面代码的输出中猜出代码是以哪种模式执行的吗？因为`this.fullName`的值为`undefined`，所以代码是在非严格模式下执行的。
- en: 如果我们在严格模式下执行上面的代码：
  id: totrans-19
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果我们在严格模式下执行上面的代码：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 这里是上面代码的`Replit`：
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是上面代码的`Replit`：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/what-is-this-example3”>`'
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/what-is-this-example3">`'
- en: An error? Why?
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 有错误吗？为什么？
- en: 回想一下在严格模式下“函数”内`this`的值是什么。它是`undefined`。因此，`this.fullName`抛出一个错误，因为我们无法访问`undefined`值上的任何属性。
  id: totrans-24
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 回想一下在严格模式下“函数”内`this`的值是什么。它是`undefined`。因此，`this.fullName`抛出一个错误，因为我们无法访问`undefined`值上的任何属性。
- en: 全局上下文
  id: totrans-25
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 全局上下文
- en: 在全局作用域中，`this`的值取决于我们JavaScript代码执行的环境。
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在全局作用域中，`this`的值取决于我们JavaScript代码执行的环境。
- en: JavaScript代码可以在不同的环境中执行，例如浏览器、`NodeJS`等。在全局作用域中，`this`的值在不同的环境中是不同的。在浏览器的情况下，全局作用域中的`this`值是`window`对象。
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: JavaScript代码可以在不同的环境中执行，例如浏览器、`NodeJS`等。在全局作用域中，`this`的值在不同的环境中是不同的。在浏览器的情况下，全局作用域中的`this`值是`window`对象。
- en: 在`NodeJS`中，`this`的值取决于我们使用的是`ECMAScript`模块还是`CommonJS`模块。在`ECMAScript`模块中，模块顶层的`this`值为`undefined`。这是因为`ECMAScript`模块中的代码在严格模式下执行。在`CommonJS`模块中，在模块的顶层，`this`引用的是`module.exports`对象。
  id: totrans-28
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在`NodeJS`中，`this`的值取决于我们使用的是`ECMAScript`模块还是`CommonJS`模块。在`ECMAScript`模块中，模块顶层的`this`值为`undefined`。这是因为`ECMAScript`模块中的代码在严格模式下执行。在`CommonJS`模块中，在模块的顶层，`this`引用的是`module.exports`对象。
- en: :::info
  id: totrans-29
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: :::info
- en: 在`Node.js`中，JavaScript代码在技术上并不是在全局作用域中执行的。相反，它是在模块作用域中执行的，常用的模块有`CommonJS`和`ECMAScript`模块。
  id: totrans-30
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在`Node.js`中，JavaScript代码在技术上并不是在全局作用域中执行的。相反，它是在模块作用域中执行的，常用的模块有`CommonJS`和`ECMAScript`模块。
- en: ':::'
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: ':::'
- en: Inside`[web workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)`，`this`的值在顶层引用的是web
    worker的全局作用域，这与浏览器中包含`window`对象的全局作用域不同。代码在web worker内部在其自己的独立上下文中执行，并具有自己的全局作用域。
  id: totrans-32
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在`[web workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)`中，`this`的值在顶层引用的是web
    worker的全局作用域，这与浏览器中包含`window`对象的全局作用域不同。代码在web worker内部在其自己的独立上下文中执行，并具有自己的全局作用域。
- en: 构造函数上下文
  id: totrans-33
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 构造函数上下文
- en: 当一个函数被用`new`关键字作为构造函数调用时，构造函数内部的`this`关键字引用的是新创建的对象。`new`关键字创建一个新对象并将新创建的对象作为`this`的值。因此，我们可以在构造函数内部使用`this`来向新创建的对象添加属性。
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当一个函数被用`new`关键字作为构造函数调用时，构造函数内部的`this`关键字引用的是新创建的对象。`new`关键字创建一个新对象并将其作为`this`的值。因此，我们可以在构造函数内部使用`this`来向新创建的对象添加属性。
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 上面的函数在作为构造函数调用时，将向新创建的对象添加两个属性：`name`和`ingredients`。
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上面的函数在作为构造函数调用时，将向新创建的对象添加两个属性：`name`和`ingredients`。
- en: 类上下文
  id: totrans-37
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 类上下文
- en: JavaScript中类内部的代码在严格模式下执行。因此，方法内部的`this`值如果没有在对象上调用则为`undefined`，否则为用于调用方法的类实例本身。
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: JavaScript中类内部的代码在严格模式下执行。因此，方法内部的`this`值如果没有在对象上调用则为`undefined`，否则为用于调用方法的类实例本身。
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 这里是上面代码的`Replit`：
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是上面代码的`Replit`：
- en: '`<ReplitEmbed src=”https://replit.com/@newlineauthors/what-is-this-example5”>`'
  id: totrans-41
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/what-is-this-example5">`'
- en: 上面的代码示例抛出一个错误，因为我们将`printColor`方法作为“函数”调用。如前所述，类内部的代码在严格模式下执行，因此，在严格模式下的函数中，`this`在方法内部是`undefined`。
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上面的代码示例抛出一个错误，因为我们将`printColor`方法作为“函数”调用。如前所述，类内部的代码在严格模式下执行，因此，在严格模式下的函数中，`this`在方法内部是`undefined`。
- en: DOM event handler context
  id: totrans-43
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: DOM事件处理程序上下文
- en: We already know that `this` inside a function depends on how the function is
    called. But what about the callback functions that we do not call? I mean the
    callbacks like the DOM event handlers that we do not call but instead are called
    for us by JavaScript whenever the click event is triggered. In such cases, what
    is the value of `this`?
  id: totrans-44
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们已经知道，在函数内部`this`的值取决于函数的调用方式。那么，对于我们没有调用的回调函数呢？比如DOM事件处理程序，这些函数并不是由我们调用，而是每当触发点击事件时由JavaScript为我们调用。在这种情况下，`this`的值是什么？
- en: 'The event listener callback is invoked with `this` set to the HTML element
    that triggered the event. Consider the following code example:'
  id: totrans-45
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 事件监听器回调被调用时，`this`被设置为触发事件的HTML元素。考虑以下代码示例：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here’s a Replit of the code above:'
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里是上面代码的Replit：
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/what-is-this-example6">`'
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<ReplitEmbed src="https://replit.com/@newlineauthors/what-is-this-example6">`'
- en: Run the above code in a browser and check the console in the browser developer
    tools. Specifically, note the value of `this` logged by the `submitForm` method.
    The value of `this` inside this method, when it is invoked as an event listener
    callback, is the button element and not the instance of the class like we would
    normally expect.
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在浏览器中运行上述代码，并检查浏览器开发者工具中的控制台。特别注意`submitForm`方法记录的`this`的值。当它作为事件监听器回调被调用时，这个方法内部的`this`值是按钮元素，而不是我们通常预期的类的实例。
- en: 'This can cause a problem if we are not careful when using `this` inside an
    event listener callback function. Imagine a scenario where we had to call another
    method within the `FormHandler` class:'
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果我们在事件监听器回调函数内部使用`this`时不小心，这可能会导致问题。想象一下我们需要在`FormHandler`类中调用另一个方法的场景：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Calling the `sendRequest` method from within the `submitForm` method throws
    an error because, as discussed, `this` inside an event handler function, `submitForm`
    in our case, is an HTML element that triggered the event. So, unlike what we expected,
    `this.sendRequest` throws an error. It would have worked if `this` inside the
    `submitForm` method was an instance of the `FormHandler` class. So, how can we
    call the `sendRequest` method from the `submitForm` method? There are multiple
    ways to achieve this, but we will discuss them in the later lessons in this module.
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 从`submitForm`方法内部调用`sendRequest`方法会抛出一个错误，因为如前所述，在事件处理函数`submitForm`中，`this`是触发事件的HTML元素。因此，与我们预期的不同，`this.sendRequest`会抛出错误。如果在`submitForm`方法内部的`this`是`FormHandler`类的实例，这种情况就不会发生。那么，我们该如何从`submitForm`方法调用`sendRequest`方法呢？有多种方法可以实现这一点，但我们将在本模块的后续课程中讨论。
- en: 'Before diving into how `this` works inside arrow functions, let us first explore
    the problem with using the `this` keyword inside regular functions. Consider the
    following code example:'
  id: totrans-53
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can run the above code in the Replit below:'
  id: totrans-55
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`<ReplitEmbed src="https://replit.com/@newlineauthors/arrow-functions-and-this-example1"
    />`'
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Why did we get `NaN` as an output? The reason for unintended output is the incorrect
    value of `this` inside the function returned from the `incrementFactory` function.
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Recall how the value of `this` gets set inside a function. It depends on `how`
    the function is called. In the code example above, how is `increment5` function
    called? Is it called as a “method” or as a standalone function? It is called a
    “function”, so the value of `this` depends on whether our code is in strict mode
    or not. Assuming that our code is in non-strict mode, the value of `this` inside
    the `increment5` function is the global object, i.e., the `window` object in the
    case of browsers. So, `this.value` is actually `window.value`, and it is `undefined`
    because the `window` object, by default, doesn’t have a `value` property. As a
    result, we get the `NaN` value when `undefined` is added to a number, i.e., the
    value of the `incrementStep` parameter.
  id: totrans-58
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 我们如何解决这个问题？如何确保`increment5`函数内部的`this`值是我们想要的？处理这个问题有多种方法。一种方法是在返回函数之前在`incrementFactory`函数内部保存`this`的值，然后在返回的函数中，使用包含`this`值的变量，而不是直接使用`this`。以下代码示例展示了这种方法的实际应用：
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 你可以在下面的Replit中运行上述代码：
  id: totrans-61
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: <ReplitEmbed src="https://replit.com/@newlineauthors/arrow-functions-and-this-example2"
    />
  id: totrans-62
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 上述方法常用于修复类似的问题，其中需要来自周围上下文的`this`值，而不是当前函数内部实际使用的`this`值。在上面的代码示例中，我们需要来自`incrementFactory`函数的周围上下文的`this`值，而不是`increment5`函数内部的`this`值。
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 箭头函数来拯救我们
  id: totrans-64
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 另一种解决上述问题的方法是使用箭头函数。让我们将上面的代码示例更改为使用箭头函数：
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 你可以在下面的Replit中运行上述代码：
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: <ReplitEmbed src="https://replit.com/@newlineauthors/arrow-functions-and-this-example3"
    />
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 使用箭头函数解决了这个问题，因为与常规函数不同，常规函数在被调用时会获得自己的`this`值，而箭头函数不会获得自己的`this`值；相反，箭头函数内部的`this`值是从周围上下文中获取的。
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 周围上下文是定义箭头函数的环境。在我们的代码示例中，箭头函数是在使用`counter`对象调用`incrementFactory`函数时创建的。因此，`incrementFactory`函数内部的`this`指向`counter`对象，这就是返回自`incrementFactory`函数的箭头函数的周围上下文。结果，箭头函数内部的`this`值在调用时也是`counter`对象，这正是我们想要`increment5`函数内部的`this`值，使我们的代码示例能够正常工作。
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 让我们回顾一下我们在上节课讨论的例子：
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 在上面的代码示例中点击`submit`按钮会抛出一个错误，因为`submitForm`方法内部的`this`值是按钮元素，而不是`FormHandler`类的实例。因此，`this.sendRequest()`调用会抛出错误，因为`this`需要指向`FormHandler`类的实例，以便允许我们从`submitForm`方法中调用该类的其他方法。那么问题是，我们如何从`submitForm`方法调用`sendRequest`方法？我们在上节课中说过，解决这个问题的方法不止一种。其中一种是使用箭头函数。
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: To fix the issue, inside the constructor of the `FormHandler` class, we can
    pass an `arrow function` instead of ``this.submitForm`` as a callback function
    to the click event listener. Inside the `arrow function`, we can invoke the `submitForm`
    method to handle the click event.
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Why did passing an `arrow function` as a callback fix the issue? We are still
    invoking the `submitForm` method inside the `arrow function`, so how is this different
    from directly passing ``this.submitForm`` as a callback function?
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The reason an `arrow function` fixed the issue is that, as discussed earlier,
    `arrow functions` do not have their own value of ``this``; they get it from the
    surrounding environment. The surrounding environment is the constructor in this
    case. What’s the value of ``this`` inside the constructor? Its value is an instance
    of the `FormHandler` class when the constructor is invoked using the `new` keyword.
    So, instead of ``this`` referring to an `HTML` element inside the event handler
    callback function like it did in the previous example, the value of ``this`` inside
    the `arrow function` is the same as in the constructor, i.e., an instance of the
    `FormHandler` class. So when we invoke the `submitForm` method inside the `arrow
    function`, the value of ``this`` inside the `submitForm` method is also an instance
    of the `FormHandler` class. As a result, we can call any other method from inside
    the `submitForm` method.
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`箭头函数`解决问题的原因在于，如前所述，`箭头函数`没有自己的``this``值；它们从周围环境中获取值。在这种情况下，周围环境是构造函数。构造函数内部``this``的值是什么？当使用`new`关键字调用构造函数时，它的值是`FormHandler`类的一个实例。因此，``this``在事件处理程序回调函数中指向一个`HTML`元素，而在`箭头函数`内部的值则与构造函数相同，即`FormHandler`类的一个实例。因此，当我们在`箭头函数`内部调用`submitForm`方法时，`submitForm`方法内部的``this``值也是`FormHandler`类的一个实例。结果，我们可以从`submitForm`方法内部调用任何其他方法。'
- en: In the older version of this code that throws an error, the event handler was
    ``this.submitForm`` method. It was not invoked by our code explicitly. Instead,
    it is invoked by `JavaScript` whenever the submit button is clicked. We know that
    the value of ``this`` inside functions depends on how a function is called. In
    this case, as we weren’t invoking the function explicitly, we couldn’t control
    the value of ``this`` inside the `submitForm` method. Using an `arrow function`
    allowed us to invoke the `submitForm` method explicitly and, consequently, allowed
    us to control the value of ``this`` inside it.
  id: totrans-78
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这个旧版本的代码中，抛出错误的事件处理程序是``this.submitForm``方法。它并不是由我们的代码显式调用的，而是每当点击提交按钮时由`JavaScript`调用。我们知道，函数内部``this``的值取决于函数的调用方式。在这种情况下，由于我们没有显式调用该函数，因此无法控制``this``在`submitForm`方法中的值。使用`箭头函数`使我们能够显式调用`submitForm`方法，从而控制其内部的``this``值。
- en: '`Arrow functions` are really useful and a welcome addition to the `JavaScript`
    language. The problems they solve can also be solved in other ways, but other
    solutions are more verbose than `arrow functions`.'
  id: totrans-79
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`箭头函数`确实非常有用，是`JavaScript`语言的一个受欢迎的补充。它们解决的问题也可以通过其他方式解决，但其他解决方案比`箭头函数`更冗长。'
- en: So far, we have discussed that the value of ``this`` depends either on the environment
    in which our `JavaScript` code is executed or, in the case of functions, on how
    a function is called. We have also discussed that `arrow functions` don’t have
    their own value of ``this``; instead, they get their value from the surrounding
    context.
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了``this``的值要么取决于`JavaScript`代码执行的环境，要么在函数的情况下取决于函数的调用方式。我们还讨论了`箭头函数`没有自己的``this``值；相反，它们从周围的上下文中获取值。
- en: All the ways we have seen so far for setting the value of ``this`` automatically
    set its value. `Javascript` also provides us with ways to explicitly set ``this``
    to whatever value we want.
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的所有设置``this``值的方法都是自动设置其值的。`JavaScript`还提供了显式将``this``设置为我们想要的值的方法。
- en: 'We can use any of the following three built-in methods to explicitly set the
    value of ``this``:'
  id: totrans-82
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们可以使用以下三种内置方法中的任何一种显式设置``this``的值：
- en: '[`Function.prototype.call()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)'
  id: totrans-83
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[`Function.prototype.call()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)'
- en: '[`Function.prototype.apply()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)'
  id: totrans-84
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[`Function.prototype.apply()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)'
- en: '[`Function.prototype.bind()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)'
  id: totrans-85
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '[`Function.prototype.bind()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)'
- en: 我们不会详细介绍这些方法如何工作；你可以通过上面提供的链接学习每个方法是如何工作的。然而，我们将看到显式设置`this`如何是有用的。
  id: totrans-86
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们不会详细介绍这些方法如何工作；你可以通过上面提供的链接学习每个方法的工作原理。然而，我们将看到显式设置`this`如何是有用的。
- en: 让我们重温上一个课程中关于箭头函数的代码示例：
  id: totrans-87
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们重温上一个课程中关于箭头函数的代码示例：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 你可以在下面的`Replit`中运行上述代码：
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的`Replit`中运行上述代码：
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/binding-this-example1”
    />
  id: totrans-90
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src="https://replit.com/@newlineauthors/binding-this-example1"
    />
- en: 在上一个课程中，我们看到使用箭头函数修复了上述代码示例。我们也可以通过显式地将`this`的值设置为所需的值，即`counter`对象来修复这段代码，它用于调用`incrementFactory`函数。我们可以使用`bind`方法来设置`this`的值，而不是使用箭头函数。
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上一个课程中，我们看到使用箭头函数修复了上述代码示例。我们也可以通过显式地将`this`的值设置为所需的值，即`counter`对象来修复这段代码，它用于调用`incrementFactory`函数。我们可以使用`bind`方法来设置`this`的值，而不是使用箭头函数。
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 你可以在下面的`Replit`中运行上述代码：
  id: totrans-93
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的`Replit`中运行上述代码：
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/binding-this-example2”
    />
  id: totrans-94
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src=”https://replit.com/@newlineauthors/binding-this-example2”
    />
- en: 借用方法
  id: totrans-95
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 借用方法
- en: 想象一下有一个对象，它包含对其他对象也有用的方法。我们如何能将这些方法与其他对象一起使用呢？一种选择是为每个需要这些方法的对象复制方法的定义。但我们不想要重复。有办法避免重复并重用现有的方法吗？
  id: totrans-96
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 想象一下有一个对象，它包含对其他对象也有用的方法。我们如何能将这些方法与其他对象一起使用呢？一种选择是为每个需要这些方法的对象复制方法的定义。但我们不想要重复。有办法避免重复并重用现有的方法吗？
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 你可以在下面的`Replit`中运行上述代码：
  id: totrans-98
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以在下面的`Replit`中运行上述代码：
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/binding-this-example3”
    />
  id: totrans-99
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: <ReplitEmbed src=”https://replit.com/@newlineauthors/binding-this-example3”
    />
- en: 我们可以在函数内部显式设置`this`的值，并使用上述提到的三种方法中的任何一种与其他对象一起使用。这使我们能够避免重复并重用代码。
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们可以在函数内部显式设置`this`的值，并使用上述提到的三种方法中的任何一种与其他对象一起使用。这使我们能够避免重复并重用代码。
- en: 在这一点上，你可能会问：*我们是否可以创建一个构造函数，使我们能够创建对象并在构造函数的原型属性中添加公共方法？*你说得对。创建一个构造函数是处理我们想要创建相似对象的正确方法。然而，显式地设置`this`的值使我们能够在无关对象之间重用代码。这是一个很好的选择，可以在合适的地方使用。
  id: totrans-101
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会问：*我们是否可以创建一个构造函数，使我们能够创建对象并在构造函数的原型属性中添加公共方法？*你说得对。创建一个构造函数是处理我们想要创建相似对象的正确方法。然而，显式地设置`this`的值使我们能够在无关对象之间重用代码。这是一个很好的选择，可以在合适的地方使用。
- en: '`Chain`构造函数调用'
  id: totrans-102
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`Chain`构造函数调用'
- en: 在JavaScript引入类之前，继承另一个构造函数的传统方法是显式地设置原型链，并重用被继承的构造函数，将公共属性添加到新创建的对象。以下代码示例展示了我们如何将责任委托给现有构造函数，以将一些属性添加到新创建的对象：
  id: totrans-103
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在JavaScript引入类之前，继承另一个构造函数的传统方法是显式地设置原型链，并重用被继承的构造函数，将公共属性添加到新创建的对象。以下代码示例展示了我们如何将责任委托给现有构造函数，以将一些属性添加到新创建的对象：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the code example above, the `call` method has been used to call the `Employee`
    constructor, passing in the three properties that the `Employee` constructor can
    set on the newly created object. But how can we tell the `Employee` constructor
    to add the properties to the newly created `BankEmployee` object? This is where
    the first argument passed to the `call` method comes in. We have passed `this`
    as the first argument. Recall how the value of `this` is set inside a function:
    it depends on how the function is called. In this case, we expect the `BankEmployee`
    function to be invoked as a constructor function using the `new` keyword. As a
    result, `this` inside the `BankEmployee` function will be the newly created object.
    This newly created object is explicitly set as the value of `this` inside the
    `Employee` constructor.'
  id: totrans-105
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上面的代码示例中，`call`方法被用来调用`Employee`构造函数，传入`Employee`构造函数可以在新创建的对象上设置的三个属性。但我们如何告诉`Employee`构造函数将属性添加到新创建的`BankEmployee`对象上呢？这就是传递给`call`方法的第一个参数的作用。我们将`this`作为第一个参数传递。回想一下，在函数内部`this`的值是如何设置的：它取决于函数是如何调用的。在这种情况下，我们希望`BankEmployee`函数作为构造函数使用`new`关键字来调用。因此，`BankEmployee`函数内部的`this`将是新创建的对象。这个新创建的对象在`Employee`构造函数内部显式设置为`this`的值。
- en: In other words, the `Employee` constructor is invoked from inside of the `BankEmployee`
    constructor, with `this` explicitly set to the newly created `BankEmployee` object.
    As a result, properties added to `this` inside the `Employee` constructor will
    actually add the properties to the newly created `BankEmployee` object. This is
    how we can use the existing constructor function and reduce code duplication.
  id: totrans-106
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 换句话说，`Employee`构造函数是从`BankEmployee`构造函数内部调用的，`this`显式设置为新创建的`BankEmployee`对象。因此，添加到`Employee`构造函数内部的`this`的属性将实际添加到新创建的`BankEmployee`对象。这就是我们如何使用现有构造函数并减少代码重复。
- en: Revisit `“this”` problem
  id: totrans-107
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 重新审视`“this”`问题
- en: Let us revisit the example we discussed in the first lesson.
  id: totrans-108
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们重新审视我们在第一课中讨论的例子。
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The problem we are trying to fix is that we want to call other methods of the
    same class from inside the event handler callback, but trying to do so throws
    an error because `this` inside an event handler is the HTML element that triggered
    the DOM event. In the previous lesson, we saw how an arrow function could solve
    this problem. There’s another way to fix the issue, and that’s to explicitly set
    the value of `this` inside the `submitForm` method.
  id: totrans-110
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们要解决的问题是希望从事件处理程序回调内部调用同一类的其他方法，但尝试这样做会抛出错误，因为事件处理程序内部的`this`是触发DOM事件的HTML元素。在前一课中，我们看到箭头函数如何解决这个问题。还有另一种方法来修复这个问题，那就是在`submitForm`方法内部显式设置`this`的值。
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Explicitly setting the value of `this` inside the `submitForm` method using
    the `bind` method fixes the problem because it overrides the default value of
    `this` inside an event callback function. We have explicitly set it to the value
    of `this` inside the `FormHandler` class constructor, i.e., an instance of the
    `FormHandler` class.
  id: totrans-112
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在`submitForm`方法中显式设置`this`的值，使用`bind`方法解决了问题，因为它覆盖了事件回调函数内`this`的默认值。我们已经将其显式设置为`FormHandler`类构造函数内部的`this`的值，即`FormHandler`类的一个实例。
- en: The difference between passing `this.submitForm` vs. passing `this.submitForm.bind(this)`
    to the `addEventListener` method is that with `this.submitForm`, the value of
    `this` inside the `submitForm` method depends on how the `submitForm` method is
    invoked. In this case, we know that the value of `this` inside it will be the
    html button element, which is not what we want. On the other hand, passing `this.submitForm.bind(this)`
    solves the problem because, unlike before, the value of `this` inside the `submitForm`
    method is explicitly bound to be an instance of the `FormHandler` class.
  id: totrans-113
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 将 `this.submitForm` 和 `this.submitForm.bind(this)` 传递给 `addEventListener` 方法的区别在于，使用
    `this.submitForm` 时，`submitForm` 方法内部的 `this` 的值取决于 `submitForm` 方法的调用方式。在这种情况下，我们知道其内部的
    `this` 值将是 HTML 按钮元素，这并不是我们想要的。另一方面，传递 `this.submitForm.bind(this)` 解决了这个问题，因为与之前不同，`submitForm`
    方法内部的 `this` 的值明确绑定为 `FormHandler` 类的实例。
- en: '`globalThis` is a globally available property in JavaScript that allows us
    to access the global object regardless of which environment our JavaScript code
    is executed in. It provides us with a standard way to access the global object
    across different JavaScript environments.'
  id: totrans-114
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '``globalThis`` 是 JavaScript 中一个全局可用的属性，使我们能够访问全局对象，而不论我们的 JavaScript 代码在哪个环境中执行。它为我们提供了一种在不同
    JavaScript 环境中访问全局对象的标准方式。'
- en: As we know, JavaScript can be executed in different environments, for example,
    the browser, the ``Node.js`` runtime, etc. Each of these environments has a different
    global object available to the JavaScript code executing in the environment. Before
    ``globalThis``, there was no standard way to access the global object in a cross-environment
    way. This made our code less portable.
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如我们所知，JavaScript 可以在不同的环境中执行，例如浏览器、``Node.js`` 运行时等。每个环境都有一个不同的全局对象可供在该环境中执行的
    JavaScript 代码使用。在 ``globalThis`` 出现之前，访问全局对象没有一种跨环境的标准方式。这使得我们的代码可移植性降低。
- en: The ``globalThis`` property made it possible to access the global object without
    worrying about the environment. If we know that our code can be executed in different
    environments, using ``globalThis`` to access the global object is the way to go
    in modern JavaScript code.
  id: totrans-116
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '``globalThis`` 属性使得访问全局对象成为可能，无需担心环境。如果我们知道我们的代码可以在不同的环境中执行，那么在现代 JavaScript
    代码中，使用 ``globalThis`` 来访问全局对象是最佳选择。'
- en: 'Imagine a scenario where you want to check if the global object contains a
    certain property regardless of whether your code is executed in a browser or a
    ``NodeJS`` environment. Without a standard way to access the global object, you
    might write the following code:'
  id: totrans-117
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 想象一个场景，你想检查全局对象是否包含某个属性，而不论你的代码是在浏览器还是在 ``NodeJS`` 环境中执行。没有标准的方式来访问全局对象，你可能会写出以下代码：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With ``globalThis``, we can simplify the above code as shown below:'
  id: totrans-119
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用 ``globalThis``，我们可以简化上述代码，如下所示：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although this property is [well supported](https://caniuse.com/?search=globalThis)
    in modern browsers, older versions of browsers don’t support it. So, browser support
    might be taken into consideration when using this property.
  id: totrans-121
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 尽管这个属性在现代浏览器中得到了[良好的支持](https://caniuse.com/?search=globalThis)，但旧版本的浏览器不支持。因此，在使用这个属性时，可能需要考虑浏览器的支持情况。
- en: '``this`` vs ``globalThis``'
  id: totrans-122
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '``this`` vs ``globalThis``'
- en: The ``globalThis`` should not be confused with the ``this`` keyword. We have
    discussed in this module how the value of ``this`` can vary depending on different
    execution contexts, but ``globalThis`` is just a standard way to access the global
    object in different JavaScript environments. Its value only varies depending on
    the environment in which our code is executed. It isn’t affected by how the function
    is called or whether our code is in strict mode or not.
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '``globalThis`` 不应与 ``this`` 关键字混淆。我们在本模块中讨论了 ``this`` 的值如何因不同的执行上下文而变化，但 ``globalThis``
    只是访问不同 JavaScript 环境中的全局对象的标准方式。它的值仅因我们的代码执行的环境而异，而不受函数调用方式或代码是否处于严格模式的影响。'
- en: In ``ECMAScript`` modules, code is executed in strict mode. As a result, the
    value of ``this`` in module scope is ``undefined``, but the value of ``globalThis``
    is the global object of the execution environment; in ``NodeJS``, it is the ``global``
    object, and in the browsers, it is the ``window`` object.
  id: totrans-124
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在 ``ECMAScript`` 模块中，代码是在严格模式下执行的。因此，模块作用域中的 ``this`` 的值是 ``undefined``，但 ``globalThis``
    的值是执行环境的全局对象；在 ``NodeJS`` 中，它是 ``global`` 对象，而在浏览器中，它是 ``window`` 对象。
- en: This module was all about the ``this`` keyword; we discussed different ways
    its value is set in different contexts; we also discussed a problem that can arise
    due to an unexpected value of ``this`` and explored different options we have
    to fix such problems.
  id: totrans-125
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 本模块主要讨论``this``关键字；我们讨论了在不同上下文中如何设置其值的不同方式；我们还讨论了由于``this``的意外值可能出现的问题，并探索了修复这些问题的不同选项。
- en: 'As ``this`` can have different values in different contexts, let us summarize
    what value ``this`` has in different contexts:'
  id: totrans-126
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 由于``this``在不同上下文中可以有不同的值，让我们总结一下``this``在不同上下文中的值：
- en: In the case of an arrow function, the value of ``this`` is taken from the surrounding
    context.
  id: totrans-127
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 在箭头函数的情况下，``this``的值是从周围的上下文中获取的。
- en: In the case of a regular function, the value of ``this`` depends on *how* a
    function is called and whether the code is executed in strict mode or not.
  id: totrans-128
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 在常规函数的情况下，``this``的值取决于*如何*调用函数，以及代码是否在严格模式下执行。
- en: If a function is invoked as a constructor using the ``new`` keyword, the value
    of ``this`` is the newly created object.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果一个函数作为构造函数被调用，并使用``new``关键字，那么``this``的值就是新创建的对象。
- en: If the value of ``this`` is explicitly set using ``bind``, ``call``, or ``apply``
    functions, then the value of ``this`` is whatever value is passed as the first
    argument to these functions.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果``this``的值通过``bind``、``call``或``apply``函数显式设置，那么``this``的值就是传递给这些函数的第一个参数的值。
- en: If a function is invoked as a “method”, the value of ``this`` is the object
    used to call the method.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果一个函数被作为“方法”调用，那么``this``的值就是调用该方法的对象。
- en: 如果函数在没有任何对象的情况下被调用，即作为一个“函数”，则在非严格模式下，`this`的值是全局对象，而在严格模式下是`undefined`。
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如果函数在没有任何对象的情况下被调用，即作为一个“函数”，则在非严格模式下，`this`的值是全局对象，而在严格模式下是`undefined`。
- en: 在DOM事件处理回调中，`this`的值是触发事件的HTML元素。
  id: totrans-133
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 在DOM事件处理回调中，`this`的值是触发事件的HTML元素。
- en: 在浏览器的全局作用域中，`this`指的是全局`window`对象。
  id: totrans-134
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 在浏览器的全局作用域中，`this`指的是全局`window`对象。
- en: 在NodeJS中，顶层代码在模块作用域中执行。在ECMAScript模块中，模块顶层的`this`是`undefined`，因为ECMAScript模块中的代码隐式在严格模式下执行。在CommonJS模块中，模块顶层的`this`指的是`module.exports`对象。
  id: totrans-135
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 在NodeJS中，顶层代码在模块作用域中执行。在ECMAScript模块中，模块顶层的`this`是`undefined`，因为ECMAScript模块中的代码隐式在严格模式下执行。在CommonJS模块中，模块顶层的`this`指的是`module.exports`对象。
- en: 希望这个模块能让你更好地理解`this`关键字，并帮助你理解在不同上下文中`this`的值是如何设置的。这个模块还旨在帮助你理解意外的`this`值可能在我们的代码中造成的各种问题，以及我们有哪些不同的选项可以解决这些问题。
  id: totrans-136
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 希望这个模块能让你更好地理解`this`关键字，并帮助你理解在不同上下文中`this`的值是如何设置的。这个模块还旨在帮助你理解意外的`this`值可能在我们的代码中造成的各种问题，以及我们有哪些不同的选项可以解决这些问题。
