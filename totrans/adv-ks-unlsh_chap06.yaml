- en: ‘this’ keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `this` keyword is among the most confusing concepts in the JavaScript language.
    The cause of confusion is the different ways in which the value of the `this`
    keyword is set in different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this module, we will try to demystify the `this` keyword. We will understand
    different ways in which the value of `this` is set. The `this` keyword can be
    used in different contexts: inside functions, global scope, inside modules, etc.
    We will explore different contexts and how `this` is set in those contexts.'
  prefs: []
  type: TYPE_NORMAL
- en: Function context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `this` keyword is mostly used inside functions to refer to the object using
    which the function was invoked. In other words, when a function is invoked as
    a “method” (invoked using an object), the `this` keyword becomes applicable for
    referencing the object used to invoke the function.
  prefs: []
  type: TYPE_NORMAL
- en: The `this` keyword is like an implicit parameter passed to a function. Just
    like explicit function parameters, the value of implicit parameter `this` is set
    when the function is *invoked*. This is an important point. The value of `this`
    inside a function depends on *how* that function is *called*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a Replit of the code above:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/what-is-this-example1”>
  prefs: []
  type: TYPE_NORMAL
- en: 'The `printInfo` function in the code example above uses the `this` keyword,
    and looking at the code, we can tell that the `printInfo` function assumes that
    the value of `this` inside the `printInfo` function will be an object with three
    properties: `id`, `name`, and `email`. But as mentioned earlier, the value of
    `this` inside a function depends on *how* the function is called.'
  prefs: []
  type: TYPE_NORMAL
- en: In the code example above, the `printInfo` function is invoked using the `student`
    object, and when a function is invoked using an object, the `this` inside that
    function refers to the object using which the function was invoked. So in our
    code example, `this` inside the `printInfo` refers to the `student` object. As
    the `student` object has the three properties that are accessed using the `this`
    keyword inside the `printInfo` function, their values are logged to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'What will `this` refer to if the function is not invoked as a “method”? Consider
    the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a Replit of the code above:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/what-is-this-example2”>
  prefs: []
  type: TYPE_NORMAL
- en: What does `this` refer to inside the `orderFood` function?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to the question above depends on whether our code is executed in
    [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
    If non-strict mode, `this` inside a function, when not invoked as a method, refers
    to the global object, which in the case of browsers is the `window` object. However,
    the value of `this` inside a function is `undefined` in strict mode when not invoked
    as a method.
  prefs: []
  type: TYPE_NORMAL
- en: Can you guess in which mode the code was executed from the output of the code
    above? As `this.fullName` evaluated to `undefined`, the code was executed in non-strict
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute the code above in strict mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a Replit of the code above:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/what-is-this-example3”>
  prefs: []
  type: TYPE_NORMAL
- en: An error? Why?
  prefs: []
  type: TYPE_NORMAL
- en: Recall what the value of `this` is inside a “function” in strict mode. It is
    `undefined`. So `this.fullName` throws an error because we cannot access any properties
    on the `undefined` value.
  prefs: []
  type: TYPE_NORMAL
- en: Global context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the global scope, the value of `this` depends on the environment in which
    our JavaScript code is executed.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript code can be executed in different environments, for example, browsers,
    NodeJS, etc. The value of `this` in global scope is different in different environments.
    In the case of browsers, the value of `this` in the global scope is the `window`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: In NodeJS, the value of `this` depends on whether we are using the ECMAScript
    modules or the CommonJS modules. In ECMAScript modules, the value of `this` is
    `undefined` at the top level of a module. This is because the code in ECMAScript
    modules is executed in strict mode. In CommonJS modules, at the top level of a
    module, `this` refers to the `module.exports` object.
  prefs: []
  type: TYPE_NORMAL
- en: :::info
  prefs: []
  type: TYPE_NORMAL
- en: In Node.js, the JavaScript code is technically not executed in a global scope.
    Instead, it is executed in a module scope, where commonly used modules are CommonJS
    and ECMAScript modules.
  prefs: []
  type: TYPE_NORMAL
- en: ':::'
  prefs: []
  type: TYPE_NORMAL
- en: Inside [web workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API),
    the value of `this` at the top level refers to the global scope of the web worker,
    which is different from the global scope containing the window object in the browser.
    Code inside a web worker is executed in its own separate context with its own
    global scope.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor function context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a function is invoked as a constructor function using the `new` keyword,
    the `this` keyword inside the constructor function refers to the newly created
    object. The `new` keyword creates a new object and sets the newly created object
    as the value of `this`. As a result, we can use `this` inside a constructor function
    to add properties to the newly created object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The function above, when invoked as a constructor function, will add two properties:
    `name` and `ingredients` to the newly created object.'
  prefs: []
  type: TYPE_NORMAL
- en: Class context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Code inside a class in JavaScript is executed in strict mode. As a result, the
    value of `this` inside methods is either `undefined` if not invoked on an object
    or the class instance itself, which is used to invoke the method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a Replit of the code above:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/what-is-this-example5”>
  prefs: []
  type: TYPE_NORMAL
- en: The code example above throws an error because we have invoked the `printColor`
    method as a “function”. As mentioned earlier, code inside a class executes in
    strict mode, so, as within functions in strict mode, `this` inside methods is
    `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: DOM event handler context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already know that `this` inside a function depends on how the function is
    called. But what about the callback functions that we do not call? I mean the
    callbacks like the DOM event handlers that we do not call but instead are called
    for us by JavaScript whenever the click event is triggered. In such cases, what
    is the value of `this`?
  prefs: []
  type: TYPE_NORMAL
- en: 'The event listener callback is invoked with `this` set to the HTML element
    that triggered the event. Consider the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a Replit of the code above:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/what-is-this-example6”>
  prefs: []
  type: TYPE_NORMAL
- en: Run the above code in a browser and check the console in the browser developer
    tools. Specifically, note the value of `this` logged by the `submitForm` method.
    The value of `this` inside this method, when it is invoked as an event listener
    callback, is the button element and not the instance of the class like we would
    normally expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can cause a problem if we are not careful when using `this` inside an
    event listener callback function. Imagine a scenario where we had to call another
    method within the `FormHandler` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Calling the `sendRequest` method from within the `submitForm` method throws
    an error because, as discussed, `this` inside an event handler function, `submitForm`
    in our case, is an HTML element that triggered the event. So, unlike what we expected,
    `this.sendRequest` throws an error. It would have worked if `this` inside the
    `submitForm` method was an instance of the `FormHandler` class. So, how can we
    call the `sendRequest` method from the `submitForm` method? There are multiple
    ways to achieve this, but we will discuss them in the later lessons in this module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before diving into how `this` works inside arrow functions, let us first explore
    the problem with using the `this` keyword inside regular functions. Consider the
    following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the above code in the Replit below:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/arrow-functions-and-this-example1”
    />
  prefs: []
  type: TYPE_NORMAL
- en: Why did we get `NaN` as an output? The reason for unintended output is the incorrect
    value of `this` inside the function returned from the `incrementFactory` function.
  prefs: []
  type: TYPE_NORMAL
- en: Recall how the value of `this` gets set inside a function. It depends on *how*
    the function is called. In the code example above, how is `increment5` function
    called? Is it called as a “method” or as a standalone function? It is called a
    “function”, so the value of `this` depends on whether our code is in strict mode
    or not. Assuming that our code is in non-strict mode, the value of `this` inside
    the `increment5` function is the global object, i.e., the `window` object in the
    case of browsers. So, `this.value` is actually `window.value`, and it is `undefined`
    because the `window` object, by default, doesn’t have a `value` property. As a
    result, we get the `NaN` value when `undefined` is added to a number, i.e., the
    value of the `incrementStep` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we fix this problem? How can we ensure that the value of `this` inside
    the `increment5` function is what we want it to be? There are multiple ways to
    handle this problem. One way is to save the value of `this` inside the `incrementFactory`
    function before returning a function, and inside the returned function, use the
    variable containing the value of `this` instead of directly using `this`. The
    following code example shows this approach in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the above code in the Replit below:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/arrow-functions-and-this-example2”
    />
  prefs: []
  type: TYPE_NORMAL
- en: The approach shown above was commonly used to fix similar problems where the
    value of `this` from the surrounding context was needed instead of the one from
    the current function where `this` was actually used. In the code example above,
    we needed the value of `this` from the surrounding context of the `incrementFactory`
    function and not the one inside the `increment5` function.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions to the rescue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another way to solve the problem shown above is to use an arrow function. Let’s
    change the code example above to use an arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the above code in the Replit below:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/arrow-functions-and-this-example3”
    />
  prefs: []
  type: TYPE_NORMAL
- en: Using an arrow function solves the problem because, unlike regular functions,
    which get their own value of `this` when they are invoked, arrow functions don’t
    get their own `this` value; instead, the value of `this` inside an arrow function
    is taken from the surrounding context.
  prefs: []
  type: TYPE_NORMAL
- en: The surrounding context is the environment in which the arrow function is defined.
    In our code example, the arrow function is created when the `incrementFactory`
    function is invoked using the `counter` object. So, `this` inside the `incrementFactory`
    function refers to the `counter` object, and this is the surrounding context of
    the arrow function returned from the `incrementFactory` function. As a result,
    the value of `this` inside the arrow function, when it is invoked, is also the
    `counter` object, and this is what we wanted `this` inside the `increment5` function
    to be to make our code example work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us revisit the example we discussed in the previous lesson:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Clicking the `submit` button in the code example above throws an error because
    the value of `this` inside the `submitForm` method is the button element instead
    of the instance of the `FormHandler` class. As a result, the `this.sendRequest()`
    call throws an error because `this` needs to refer to an instance of the `FormHandler`
    class to allow us to call other methods in this class from within the `submitForm`
    method. So the problem is, how can we call the `sendRequest` method from the `submitForm`
    method? We said in the previous lesson that there is more than one way to solve
    this problem. One of them is to use an arrow function.
  prefs: []
  type: TYPE_NORMAL
- en: To fix the issue, inside the constructor of the `FormHandler` class, we can
    pass an arrow function instead of `this.submitForm` as a callback function to
    the click event listener. Inside the arrow function, we can invoke the `submitForm`
    method to handle the click event.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Why did passing an arrow function as a callback fix the issue? We are still
    invoking the `submitForm` method inside the arrow function, so how is this different
    from directly passing `this.submitForm` as a callback function?
  prefs: []
  type: TYPE_NORMAL
- en: The reason an arrow function fixed the issue is that, as discussed earlier,
    arrow functions do not have their own value of `this`; they get it from the surrounding
    environment. The surrounding environment is the constructor in this case. What’s
    the value of `this` inside the constructor? Its value is an instance of the `FormHandler`
    class when the constructor is invoked using the `new` keyword. So, instead of
    `this` referring to an HTML element inside the event handler callback function
    like it did in the previous example, the value of `this` inside the arrow function
    is the same as in the constructor, i.e., an instance of the `FormHandler` class.
    So when we invoke the `submitForm` method inside the arrow function, the value
    of `this` inside the `submitForm` method is also an instance of the `FormHandler`
    class. As a result, we can call any other method from inside the `submitForm`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In the older version of this code that throws an error, the event handler was
    `this.submitForm` method. It was not invoked by our code explicitly. Instead,
    it is invoked by JavaScript whenever the submit button is clicked. We know that
    the value of `this` inside functions depends on how a function is called. In this
    case, as we weren’t invoking the function explicitly, we couldn’t control the
    value of `this` inside the `submitForm` method. Using an arrow function allowed
    us to invoke the `submitForm` method explicitly and, consequently, allowed us
    to control the value of `this` inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions are really useful and a welcome addition to the JavaScript language.
    The problems they solve can also be solved in other ways, but other solutions
    are more verbose than arrow functions.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have discussed that the value of `this` depends either on the environment
    in which our JavaScript code is executed or, in the case of functions, on how
    a function is called. We have also discussed that arrow functions don’t have their
    own value of `this`; instead, they get their value from the surrounding context.
  prefs: []
  type: TYPE_NORMAL
- en: All the ways we have seen so far for setting the value of `this` automatically
    set its value. Javascript also provides us with ways to explicitly set `this`
    to whatever value we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use any of the following three built-in methods to explicitly set the
    value of `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Function.prototype.call()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Function.prototype.apply()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Function.prototype.bind()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won’t go into details of how these methods work; you can learn how each of
    these methods works using the links given above. We will, however, see how explicitly
    setting `this` can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us revisit the code example from the previous lesson about arrow functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the above code in the Replit below:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/binding-this-example1”
    />
  prefs: []
  type: TYPE_NORMAL
- en: In the previous lesson, we saw how using an arrow function fixed the code example
    above. We could also fix this code by explicitly setting the value of `this` to
    the desired value, i.e., the `counter` object, which is used to invoke the `incrementFactory`
    function. Instead of using an arrow function, we could use the `bind` method to
    set the value of `this`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the above code in the Replit below:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/binding-this-example2”
    />
  prefs: []
  type: TYPE_NORMAL
- en: Borrowing methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine having an object that contains methods that can be useful for other
    objects as well. How can we use those methods with other objects? One option is
    to duplicate the definition of methods for each object that needs them. But we
    don’t want duplication. Is there a way to avoid duplication and reuse the existing
    methods?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the above code in the Replit below:'
  prefs: []
  type: TYPE_NORMAL
- en: <ReplitEmbed src=”https://replit.com/@newlineauthors/binding-this-example3”
    />
  prefs: []
  type: TYPE_NORMAL
- en: We can explicitly set the value of `this` inside a function and use it with
    other objects using any of the three methods mentioned above. This allows us to
    avoid duplication and reuse code.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you might ask: *can we not create a constructor that allows
    us to create objects and add common methods in the constructor prototype property?*
    You are right. Creating a constructor is the right way to handle a situation where
    we want to create similar objects. However, explicitly setting the value of `this`
    allows us to reuse code between unrelated objects. It is a nice option to have
    and can be used where appropriate.'
  prefs: []
  type: TYPE_NORMAL
- en: Chain constructor calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before classes were introduced in JavaScript, the traditional way of inheriting
    from another constructor function was to explicitly set the prototype chain and
    reuse the constructor that was being inherited from to add the common properties
    to the newly created object. The following code example shows how we can delegate
    the responsibility to an existing constructor to add some properties to the newly
    created object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code example above, the `call` method has been used to call the `Employee`
    constructor, passing in the three properties that the `Employee` constructor can
    set on the newly created object. But how can we tell the `Employee` constructor
    to add the properties to the newly created `BankEmployee` object? This is where
    the first argument passed to the `call` method comes in. We have passed `this`
    as the first argument. Recall how the value of `this` is set inside a function:
    it depends on how the function is called. In this case, we expect the `BankEmployee`
    function to be invoked as a constructor function using the `new` keyword. As a
    result, `this` inside the `BankEmployee` function will be the newly created object.
    This newly created object is explicitly set as the value of `this` inside the
    `Employee` constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the `Employee` constructor is invoked from inside of the `BankEmployee`
    constructor, with `this` explicitly set to the newly created `BankEmployee` object.
    As a result, properties added to `this` inside the `Employee` constructor will
    actually add the properties to the newly created `BankEmployee` object. This is
    how we can use the existing constructor function and reduce code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Revisit “this” problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us revisit the example we discussed in the first lesson.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The problem we are trying to fix is that we want to call other methods of the
    same class from inside the event handler callback, but trying to do so throws
    an error because `this` inside an event handler is the HTML element that triggered
    the DOM event. In the previous lesson, we saw how an arrow function could solve
    this problem. There’s another way to fix the issue, and that’s to explicitly set
    the value of `this` inside the `submitForm` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Explicitly setting the value of `this` inside the `submitForm` method using
    the `bind` method fixes the problem because it overrides the default value of
    `this` inside an event callback function. We have explicitly set it to the value
    of `this` inside the `FormHandler` class constructor, i.e., an instance of the
    `FormHandler` class.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between passing `this.submitForm` vs. passing `this.submitForm.bind(this)`
    to the `addEventListener` method is that with `this.submitForm`, the value of
    `this` inside the `submitForm` method depends on *how* the `submitForm` method
    is invoked. In this case, we know that the value of `this` inside it will be the
    html button element, which is not what we want. On the other hand, passing `this.submitForm.bind(this)`
    solves the problem because, unlike before, the value of `this` inside the `submitForm`
    method is explicitly bound to be an instance of the `FormHandler` class.
  prefs: []
  type: TYPE_NORMAL
- en: '`globalThis` is a globally available property in JavaScript that allows us
    to access the global object regardless of which environment our JavaScript code
    is executed in. It provides us with a standard way to access the global object
    across different JavaScript environments.'
  prefs: []
  type: TYPE_NORMAL
- en: As we know, JavaScript can be executed in different environments, for example,
    the browser, the Node.js runtime, etc. Each of these environments has a different
    global object available to the JavaScript code executing in the environment. Before
    `globalThis`, there was no standard way to access the global object in a cross-environment
    way. This made our code less portable.
  prefs: []
  type: TYPE_NORMAL
- en: The `globalThis` property made it possible to access the global object without
    worrying about the environment. If we know that our code can be executed in different
    environments, using `globalThis` to access the global object is the way to go
    in modern JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a scenario where you want to check if the global object contains a
    certain property regardless of whether your code is executed in a browser or a
    NodeJS environment. Without a standard way to access the global object, you might
    write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With `globalThis`, we can simplify the above code as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Although this property is [well supported](https://caniuse.com/?search=globalThis)
    in modern browsers, older versions of browsers don’t support it. So, browser support
    might be taken into consideration when using this property.
  prefs: []
  type: TYPE_NORMAL
- en: “this” vs globalThis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `globalThis` should not be confused with the `this` keyword. We have discussed
    in this module how the value of `this` can vary depending on different execution
    contexts, but `globalThis` is just a standard way to access the global object
    in different JavaScript environments. Its value only varies depending on the environment
    in which our code is executed. It isn’t affected by how the function is called
    or whether our code is in strict mode or not.
  prefs: []
  type: TYPE_NORMAL
- en: In ECMAScript modules, code is executed in strict mode. As a result, the value
    of `this` in module scope is `undefined`, but the value of `globalThis` is the
    global object of the execution environment; in NodeJS, it is the `global` object,
    and in the browsers, it is the `window` object.
  prefs: []
  type: TYPE_NORMAL
- en: This module was all about the `this` keyword; we discussed different ways its
    value is set in different contexts; we also discussed a problem that can arise
    due to an unexpected value of `this` and explored different options we have to
    fix such problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'As `this` can have different values in different contexts, let us summarize
    what value `this` has in different contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of an arrow function, the value of `this` is taken from the surrounding
    context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of a regular function, the value of `this` depends on *how* a function
    is called and whether the code is executed in strict mode or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a function is invoked as a constructor using the `new` keyword, the value
    of `this` is the newly created object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value of `this` is explicitly set using `bind`, `call`, or `apply` functions,
    then the value of `this` is whatever value is passed as the first argument to
    these functions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If a function is invoked as a “method”, the value of `this` is the object used
    to call the method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the function is invoked without any object, i.e., as a “function”, the value
    of `this` is the global object in non-strict mode and `undefined` in strict mode.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In DOM event handler callbacks, the value of `this` is the HTML element that
    triggered the event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the global scope in browsers, `this` refers to the global `window` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In NodeJS, code at the top level is executed in a module scope. In ECMAScript
    modules, `this` is `undefined` at the top level of a module because the code in
    the ECMAScript module is implicitly executed in strict mode. In CommonJS modules,
    `this` refers to the `module.exports` object at the top level of a module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopefully, this module gave you a better understanding of `this` keyword and
    helped you understand how its value is set in different contexts. This module
    also aims to help you understand the kinds of problems an unexpected value of
    `this` can cause in our code and what different options are available to us to
    fix such problems.
  prefs: []
  type: TYPE_NORMAL
