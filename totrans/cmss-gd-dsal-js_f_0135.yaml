- en: Insertion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Admittedly, linked lists have yet to impress us from a performance standpoint.
    They’re no better than arrays at search, and much worse at reading. But not to
    worry—linked lists will have their moment. In fact, that moment is now.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion is one operation in which linked lists have a distinct advantage over
    arrays in certain situations.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the worst-case scenario for insertion into an array is when the
    program inserts data into index 0, because it first has to shift the rest of the data
    one cell to the right, which ends up yielding an efficiency of O(N). With linked
    lists, however, insertion at the beginning of the list takes just one step—which
    is O(1). Let’s see why.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have the following linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/pitting_linked_lists_against_arrays/linked_list_2.png](images/pitting_linked_lists_against_arrays/linked_list_2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to add "yellow" to the beginning of the list, all we have to do
    is create a new node and have its link point to the node containing "blue":'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/pitting_linked_lists_against_arrays/insert_yellow_node.png](images/pitting_linked_lists_against_arrays/insert_yellow_node.png)'
  prefs: []
  type: TYPE_IMG
- en: (In our code, we’d also need to update the LinkedList instance so that its firstNode
    attribute now points to this "yellow" node.)
  prefs: []
  type: TYPE_NORMAL
- en: In contrast with an array, the linked list provides the flexibility of inserting
    data to the front of the list without requiring the shifting of any data. How
    sweet is that?
  prefs: []
  type: TYPE_NORMAL
- en: The truth is that, theoretically, inserting data anywhere within a linked list
    takes just one step, but there’s one gotcha. Let’s continue with our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our linked list now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/pitting_linked_lists_against_arrays/linked_list_3.png](images/pitting_linked_lists_against_arrays/linked_list_3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Say we now want to insert "purple" at index 2 (which would be between "blue"
    and "green"). The actual insertion takes just one step; that is, we can create
    the new purple node and simply change the blue node’s link to point to the purple
    node, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/pitting_linked_lists_against_arrays/insert_purple_node.png](images/pitting_linked_lists_against_arrays/insert_purple_node.png)'
  prefs: []
  type: TYPE_IMG
- en: However, for the computer to do this, it first needs to get to the node at index
    1 ("blue") so that it can modify its link to point to the newly created node.
    As we’ve seen, though, reading—which is accessing an item at a given index—from
    a linked list already takes O(N). Let’s see this in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that we want to add a new node after index 1\. So the computer needs
    to get to index 1 of the list. To do this, we must start at the beginning of the
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/pitting_linked_lists_against_arrays/linked_list_4.png](images/pitting_linked_lists_against_arrays/linked_list_4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We then access the next node by following the first link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/pitting_linked_lists_against_arrays/linked_list_5.png](images/pitting_linked_lists_against_arrays/linked_list_5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we’ve found index 1, we can finally add the new node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/pitting_linked_lists_against_arrays/insert_purple_node.png](images/pitting_linked_lists_against_arrays/insert_purple_node.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, adding "purple" took three steps. If we were to add it to the
    end of our list, it would take five steps: four steps to access index 3 and one
    step to insert the new node.'
  prefs: []
  type: TYPE_NORMAL
- en: Practically speaking, then, inserting into a linked list is O(N), as the worst-case
    scenario of inserting at the end of the list will take N + 1 steps.
  prefs: []
  type: TYPE_NORMAL
- en: However, we’ve seen that the best-case scenario of inserting at the beginning
    of the list is only O(1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, our analysis shows that the best- and worst-case scenarios for
    arrays and linked lists are the opposite of one another. The following table breaks
    this all down:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Scenario | Array | Linked List |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Insert at beginning | Worst case | Best case |'
  prefs: []
  type: TYPE_TB
- en: '| Insert at middle | Average case | Average case |'
  prefs: []
  type: TYPE_TB
- en: '| Insert at end | Best case | Worst case |'
  prefs: []
  type: TYPE_TB
- en: As you can see, arrays favor insertions at the end, while linked lists favor
    insertions at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now found one thing that linked lists are great at—inserting things at
    the beginning of the list. Later in this chapter, we’ll see a great practical
    example of where we can take advantage of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code Implementation: Linked List Insertion'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add an insertion method to our LinkedList class. We’ll call it insert:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | insert(index, value) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**const**​ newNode = ​**new**​ Node(value); |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**if**​ (index === 0) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | newNode.nextNode = ​**this**​.firstNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**this**​.firstNode = newNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**return**​; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**let**​ currentNode = ​**this**​.firstNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**let**​ currentIndex = 0; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**while**​ (currentIndex < (index - 1)) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | currentNode = currentNode.nextNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | currentIndex += 1; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | newNode.nextNode = currentNode.nextNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | currentNode.nextNode = newNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: To use the method, we pass in both the new value as well as the index of where
    we want to insert it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to insert "purple" at index 2, we’d say this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | list.insert(2, ​*"purple"*​); |'
  prefs: []
  type: TYPE_TB
- en: Let’s break this insert method down.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a new Node instance with the value provided to our method:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**const**​ newNode = ​**new**​ Node(value); |'
  prefs: []
  type: TYPE_TB
- en: (Here, the node from node.Node refers to the node module we imported at the
    beginning of the file, as we placed the Node class in a separate file from the
    LinkedList class.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we deal with the case where we’re inserting into index 0—that is, at the
    beginning of our list. The algorithm for this case is different than if we insert
    elsewhere into the list, so we deal with this case separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'To insert at the beginning of the list, we simply have our newNode link to
    the first node of the list and declare our newNode to be the first node going
    forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**if**​ (index === 0) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | newNode.nextNode = ​**this**​.firstNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**this**​.firstNode = newNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**return**​; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: The return keyword ends the method early, as there’s nothing left to do.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code deals with a case in which we’re inserting anywhere other
    than at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with reading and searching, we start off by accessing the head of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**let**​ currentNode = ​**this**​.firstNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | ​**let**​ currentIndex = 0; |'
  prefs: []
  type: TYPE_TB
- en: 'We then use a while loop to access the node just before the spot where we want
    to insert our newNode:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | ​**while**​ (currentIndex < (index - 1)) { |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | currentNode = currentNode.nextNode; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | currentIndex += 1; |'
  prefs: []
  type: TYPE_TB
- en: '| ​  | } |'
  prefs: []
  type: TYPE_TB
- en: At this point, the currentNode is the node that’ll immediately precede our newNode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we set the link of our newNode to point to the node after the currentNode:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | newNode.nextNode = currentNode.nextNode; |'
  prefs: []
  type: TYPE_TB
- en: 'Finally, we change the link of the currentNode (which, again, is to be the
    node that precedes our newNode) to point to our newNode:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ​  | currentNode.nextNode = newNode; |'
  prefs: []
  type: TYPE_TB
- en: And we’re done!
  prefs: []
  type: TYPE_NORMAL
