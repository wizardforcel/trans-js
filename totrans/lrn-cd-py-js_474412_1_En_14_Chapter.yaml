- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024 J. L. Zuckarelli Learn coding with Python and JavaScript
    [`https://doi.org/10.1007/978-3-658-42912-6_14`](https://doi.org/10.1007/978-3-658-42912-6_14)
  id: totrans-0
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: © 作者（们），独家许可Springer Fachmedien Wiesbaden GmbH，Springer Nature旗下出版，2024年 J.
    L. Zuckarelli 用Python和JavaScript学习编程 [`https://doi.org/10.1007/978-3-658-42912-6_14`](https://doi.org/10.1007/978-3-658-42912-6_14)
- en: 14. `How Do I Control the Program Flow and Make the Program React to User Actions
    and Other Events?`
  id: totrans-1
  prefs:
  - PREF_H1
  stylish: true
  type: TYPE_NORMAL
  zh: 14. `如何控制程序流并使程序对用户行为和其他事件作出反应？`
- en: Joachim L. Zuckarelli^([1](#Aff2) )(1) München, Germany Overview
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: Joachim L. Zuckarelli^([1](#Aff2) )(1) 慕尼黑，德国 概述
- en: Programs must be able to react flexibly to new situations, for example, when
    the user makes an entry or clicks on a button. Depending on the input made or
    which button is clicked, different program instructions are executed. In effect,
    the program branches off into a different path. This form of flow control makes
    programs dynamic.
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 程序必须能够灵活地对新情况作出反应，例如当用户输入内容或点击按钮时。根据用户的输入或点击的按钮，程序会执行不同的指令。实际上，程序会分支到不同的路径。这种流程控制方式使得程序具有动态性。
- en: 'In this chapter you will learn the following:'
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 本章将学习以下内容：
- en: How to branch to one or the other program part depending on a condition
  id: totrans-5
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何根据条件分支到程序的不同部分
- en: How to formulate such conditions and how to check whether they are fulfilled
    or not
  id: totrans-6
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何制定这样的条件，并检查它们是否被满足
- en: How to formulate complex conditions that are composed of several sub-conditions
  id: totrans-7
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何制定由多个子条件组成的复杂条件
- en: What possibilities there are to test a whole series of similarly structured
    conditions in a simple and clear way
  id: totrans-8
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 有哪些方法可以简单明了地测试一系列结构相似的条件
- en: How you can react to events when you cannot know beforehand exactly when they
    will be triggered in the program flow (for example, the click on a button).
  id: totrans-9
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何在无法预知事件何时会在程序流中被触发的情况下（例如点击按钮时）对事件作出反应
- en: 14.1 Why Program Flow Control Is Necessary
  id: totrans-10
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 14.1 为什么需要程序流程控制
- en: In the previous chapters you have seen what you need to receive data from the
    user, to process it, and to output the results of the processing. Nevertheless,
    programs that you write only with tools from that toolbox would be very limited
    in their possibilities, and thus in their usefulness, because the program flow
    would be completely rigid. It would `*always*` start with an input, which would
    then `*always be*` processed by the program in `*exactly the same way*`, and whose
    result would finally `*always be*` reported back to the user in `*the same form.*`
    In reality, it is unlikely that we would ever accept such inflexible programs.
    Imagine that you enter a new destination into the navigation system of your car.
    The navigation system calculates the optimal route to this destination, but as
    soon as you accidentally deviate from this route, the navigation system rigidly
    sticks to the original routing, even though you are no longer on that route. What
    you need is help to get back to the original course, or to find a completely new
    route, starting from your current location. The behavior of your navigation system
    would seem strange if you set it to avoid toll roads, but the system completely
    ignored this instruction and simply directed you straight onto the first toll
    motorway. You would, quite rightly, think this was a fault in the navigation system.
  id: totrans-11
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在前面的章节中，你已经了解了如何接收用户数据、处理数据并输出处理结果。然而，如果仅用工具箱中的那些工具来编写程序，程序的可能性将非常有限，从而降低其实用性，因为程序流程将完全僵化。它将`*总是*`从一个输入开始，然后`*总是*`按照`*完全相同的方式*`进行处理，最后其结果`*总是*`以`*相同的形式*`返回给用户。实际上，我们很难接受这种僵化的程序。想象一下，你在汽车的导航系统中输入一个新的目的地。导航系统会计算出到该目的地的最佳路线，但一旦你不小心偏离了这条路线，导航系统却依然坚持原来的路线，即使你已经不在那条路上了。你需要的是帮助，以便返回原来的路线，或者从当前位置开始找到一条全新的路线。如果你设置了导航系统避开收费公路，但系统完全忽略了这一指令，直接把你引导到第一条收费高速公路上，那么导航系统的行为就显得很奇怪。你完全可以认为这是导航系统的故障。
- en: So, what we need is a program that reacts to events (`“driver left suggested
    route”`) and takes conditions into account (`“driver wants to avoid toll roads”`).
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 所以，我们需要的是一个能对事件作出反应（`“驾驶员离开建议路线”`）并考虑条件（`“驾驶员希望避开收费公路”`）的程序。
- en: 在这两种情况下，程序的某些部分仅在相应事件发生或相应条件得到满足时执行。程序根据当前情况和其他相关情况`branches`到代码的不同部分。本章将讨论这种类型的程序`flow
    control`。
  id: totrans-13
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这两种情况下，程序的某些部分仅在相应事件发生或条件得到满足时才会执行。程序根据当前情况及其他相关情况`branches`到代码的不同部分。本章将讨论这种类型的程序`flow
    control`。
- en: 14.2 流控制的形式
  id: totrans-14
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 14.2 流控制的形式
- en: 在实践中，程序的流控制通常通过使用`If-(then-)Else constructs`来实现：`if`某个条件满足，`then`执行某个操作，`otherwise`执行其他操作。
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在实践中，程序的流控制通常通过使用`If-(then-)Else构造`来实现：`if`某个条件满足，`then`执行某个操作，`otherwise`执行其他操作。
- en: 被检查的条件也可以是`复杂条件`，由几个子条件组成。在我们的导航系统示例中，这样的复杂条件可能是：“如果‘避免收费公路’被设置为`true`，并且下一个转弯通往收费公路，则在任何情况下都不推荐走这个转弯。”另一个例子是：“如果下一个出口不是收费公路`OR`允许驶入收费公路，则推荐下一个出口。”在这里，两个部分条件通过`AND`或`OR`连接，这两者都是逻辑运算符。
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 被检查的条件也可以是`复杂条件`，由几个子条件组成。在我们的导航系统示例中，这样的复杂条件可能是：“如果‘避免收费公路’被设置为`true`，并且下一个转弯通往收费公路，则在任何情况下都不推荐走这个转弯。”另一个例子是：“如果下一个出口不是收费公路`OR`允许驶入收费公路，则推荐下一个出口。”在这里，两个部分条件通过`AND`或`OR`连接，这两者都是逻辑运算符。
- en: 有时你需要检查一系列相似的条件，例如，如果用户输入一个数字，每个数字会引发不同的反应。条件在结构上总是相同的，即“输入等于数字`X`”，而当满足某个特定条件时执行的程序代码可能因输入的数字而大相径庭。此类条件的使用案例可以通过`If-Else`构造来实现，但这通常会导致复杂的代码，难以阅读（因此也难以维护）。因此，许多编程语言知道`Switch-Case
    construct`，可以用来以非常简单明了的方式实现对相似条件的检查。
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 有时你需要检查一系列相似的条件，例如，如果用户输入一个数字，每个数字会引发不同的反应。条件在结构上总是相同的，即“输入等于数字`X`”，而当满足某个特定条件时执行的程序代码可能因输入的数字而大相径庭。此类条件的使用案例可以通过`If-Else`构造来实现，但这通常会导致复杂的代码，难以阅读（因此也难以维护）。因此，许多编程语言知道`Switch-Case构造`，可以用来以非常简单明了的方式实现对相似条件的检查。
- en: 程序流并不总是线性的，因此在经过一系列明确定义的指令后，你到达一个检查条件的点，然后根据检查结果分支到程序的一个或另一个部分。非线性程序流的最重要原因是用户。例如，在图形用户界面上，用户可以从多个不同的程序功能中选择，并可以相对自由地决定在何时使用哪个功能以及以何种顺序使用。这意味着用户决定了程序的流，而程序不能仅仅是对一长串指令的顽固处理，而必须以某种方式更灵活地结构化。这种流控制引导我们到`events`的概念和在许多编程语言中使用的事件驱动编程范式。
  id: totrans-18
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 程序流并不总是线性的，因此在经过一系列明确定义的指令后，你到达一个检查条件的点，然后根据检查结果分支到程序的一个或另一个部分。非线性程序流的最重要原因是用户。例如，在图形用户界面上，用户可以从多个不同的程序功能中选择，并可以相对自由地决定在何时使用哪个功能以及以何种顺序使用。这意味着用户决定了程序的流，而程序不能仅仅是对一长串指令的顽固处理，而必须以某种方式更灵活地结构化。这种流控制引导我们到`events`的概念和在许多编程语言中使用的事件驱动编程范式。
- en: 我们在本章其余部分将处理这些流控制元素，包括`If-Else`构造、用于它们的条件、多个子条件链接成更复杂的整体条件、`Switch-Case constructs`和事件控制。
  id: totrans-19
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们在本章其余部分将处理这些流控制元素，包括`If-Else`构造、用于它们的条件、多个子条件链接成更复杂的整体条件、`Switch-Case构造`和事件控制。
- en: 14.3 `If-Else Constructs`
  id: totrans-20
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 14.3 `If-Else构造`
- en: Imagine we were working on software for online banking, the programs that run
    a bank’s online banking website. Here we deal with an account balance query. The
    user should receive a warning if his account is in debit, i.e., the account balance
    is negative.
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 想象一下，我们正在为在线银行软件工作，即运行银行在线银行网站的程序。在这里，我们处理一个账户余额查询。如果用户的账户透支了，即账户余额为负数，用户应该收到警告。
- en: 'A program that does just that might look like this:'
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个仅仅执行此操作的程序可能如下所示：
- en: '`balance = query_balance()` **If** `balance < 0` **Then** `show("Attention:
    Your account balance is negative!")` `show("Current balance: $", balance)`'
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`balance = query_balance()` **如果** `balance < 0` **则** `show("警告：您的账户余额为负！")`
    `show("当前余额：$", balance)`'
- en: 'Here we first assign the value of the function **`query_balance()`** to a variable
    **`balance`**. We want to assume that this function returns the current account
    balance as a decimal number. After saving the account balance in the variable,
    we use **`If balance < 0`** to check whether the account balance is negative.
    If it is, a warning message is displayed, which we do here with the function **`show()`**.
    Then, with **`show("Current balance: $", balance)`**, we output the account balance
    itself, i.e., the contents of the variable **`balance`**. Note that this statement
    is always executed, regardless of whether the account is in debit or not. The
    only statement that depends on the condition that the account balance has a negative
    value is the display of the warning message after the keyword **`then`**. Everything
    that follows will be executed in any case.'
  id: totrans-24
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里我们首先将**`query_balance()`**函数的值赋给一个变量**`balance`**。我们假设这个函数返回当前账户余额的十进制数值。在将账户余额保存到变量后，我们使用**`If
    balance < 0`**检查账户余额是否为负。如果是，警告信息将被显示，我们通过**`show()`**函数实现。然后，使用**`show("当前余额：$",
    balance)`**输出账户余额本身，即变量**`balance`**的内容。请注意，无论账户是否透支，这条语句总是会执行。只有在账户余额为负时，跟在**`then`**关键字后的警告信息才会显示。之后的所有语句都会在任何情况下执行。
- en: 'Now suppose that the account balance is `$1000`\. In this case, the output
    of our program would be:'
  id: totrans-25
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 假设账户余额为`$1000`，在这种情况下，我们程序的输出将是：
- en: 'Current balance: `$1000`'
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当前余额：`$1000`
- en: 'However, if the account were in debit, for example, with a balance of `-$280`,
    the user would receive the following output:'
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，如果账户透支了，例如余额为`-$280`，用户将收到以下输出：
- en: '`Attention: Your account balance is negative!` Current balance: `$-280`'
  id: totrans-28
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`警告：您的账户余额为负！` 当前余额：`$-280`'
- en: In this simple example you can see very clearly how the program branches and
    executes certain parts – in our case the warning – only if a certain condition
    is met.
  id: totrans-29
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，你可以非常清楚地看到程序如何分支并执行某些部分——在我们的例子中，只有满足某个条件时，才会执行警告。
- en: 'In the next step, we extend the program so that it also displays how much is
    left of the overdraft facility, which we want to assume is `$500` provided the
    account is in debit. If the account is in credit, i.e., the account balance is
    greater than `0`, no message is to be displayed with regard to the overdraft facility.
    The expansion of our program could look like this:'
  id: totrans-30
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在下一步中，我们扩展程序，使其还显示透支额度剩余多少，假设如果账户透支，则透支额度为`$500`。如果账户余额大于`0`，即账户有盈余，则不显示任何关于透支额度的消息。我们程序的扩展可以是这样的：
- en: '`balance = query_balance()` **If** `balance < 0` **Then** **Begin** `show("Attention:
    Your account balance is negative!")` `overdraftrest = 500 + balance` `show("You
    still have $", overdraftrest, " left of your overdraft facility.")` **End** `show("Current
    balance: $", balance)`'
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`balance = query_balance()` **如果** `balance < 0` **那么** **开始** `show("注意：您的账户余额为负数！")`
    `overdraftrest = 500 + balance` `show("您还剩余 $", overdraftrest, " 的透支额度。")` **结束**
    `show("当前余额：$", balance)`'
- en: To map the overdraft balance, we create a variable called **`overdraftrest`**,
    to which we assign the sum of `$500` and **`balance`**. If the account balance
    is negative (and only then will this part of the program be run), the sum is just
    the amount remaining on the overdraft facility.
  id: totrans-32
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为了映射透支余额，我们创建了一个名为**`overdraftrest`**的变量，并将`$500`与**`balance`**的总和赋值给它。如果账户余额为负（只有在这种情况下程序的这一部分才会执行），则总和就是透支额度中剩余的金额。
- en: 'Unlike the previous example, here the check to see if the account is in debit
    is followed by `several` statements enclosed in a code block between the `Start`
    and `End` keywords. We have already learned about code blocks in connection with
    functions in ► Sect. [13.​1](474412_1_En_13_Chapter.xhtml#Sec1). All statements
    in the code block are executed only if the condition `balance < 0` is met. The
    statement `show("Current balance: $", balance)`, with which we output the current
    account balance, is not part of the code block and is therefore always executed,
    regardless of whether the account is in debit or credit. In many programming languages,
    if the code block is only one line, the delimiters `Begin` and `End` in our pseudo-code)
    can also be omitted, as we did in the examples above.'
  id: totrans-33
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与前面的例子不同，在这里检查账户是否透支的代码后面跟着`多个`语句，这些语句被包含在一个代码块中，位于`开始`和`结束`关键字之间。我们已经在►第[13.1节](474412_1_En_13_Chapter.xhtml#Sec1)中学习过关于函数的代码块。代码块中的所有语句只有在条件`balance
    < 0`满足时才会执行。语句`show("当前余额：$", balance)`，用于输出当前账户余额，它不属于代码块，因此无论账户是透支还是有盈余，都会始终执行。在许多编程语言中，如果代码块只有一行，`开始`和`结束`的分隔符（在我们的伪代码中）也可以省略，就像我们在上面的例子中做的那样。
- en: 'Let’s take our example again with a negative account balance of `-$280`. In
    this case, our program now produces the following output:'
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们再来看一下账户余额为`-$280`的例子。在这种情况下，我们的程序现在会产生以下输出：
- en: '`Attention: Your account balance is negative!` `You still have $220 left of
    your overdraft facility.` `Current balance: $-280`'
  id: totrans-35
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`注意：您的账户余额为负数！` `您还剩余 $220 的透支额度。` `当前余额：$-280`'
- en: 'In the case of a positive account balance of `1000`, the output is reduced
    accordingly:'
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在账户余额为`1000`的情况下，输出会相应地减少：
- en: '`Current balance: $1000`'
  id: totrans-37
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`当前余额：$1000`'
- en: Now suppose we also wanted to display something when the account balance is
    positive (or equal to `0`), for example, `Your account is in credit.`
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在假设我们还想在账户余额为正（或等于`0`）时显示一些内容，例如 `您的账户有盈余。`
- en: 'This can be easily implemented with the means we have learned so far:'
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这一点可以很容易地通过我们到目前为止学到的方法来实现：
- en: '`balance = query_balance()` `If` `balance < 0` `Then` `Begin` `show("Attention:
    Your account balance is negative!")` `overdraftrest = 500 + balance` `show("You
    still have $", overdraftrest, " left of your overdraft facility.")` `End` `If`
    `balance >= 0` `Then` `Begin` `show("Your account is in credit.")` `End` `show("Current
    balance: $", balance)`'
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`balance = query_balance()` `如果` `balance < 0` `那么` `开始` `show("注意：您的账户余额为负数！")`
    `overdraftrest = 500 + balance` `show("您还剩余 $", overdraftrest, " 的透支额度。")` **结束**
    `如果` `balance >= 0` `那么` `开始` `show("您的账户有盈余。")` **结束** `show("当前余额：$", balance)`'
- en: 'However, this can be done more easily if we take into account that each of
    the conditions `balance < 0` and `balance >= 0` is the inverse of the other, i.e.,
    both together cover all possible cases. In this situation we can do without formulating
    the second condition explicitly:'
  id: totrans-41
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，如果我们考虑到条件`balance < 0`和`balance >= 0`互为反向，即两者共同覆盖了所有可能的情况，这可以更容易地实现。在这种情况下，我们可以不明确地写出第二个条件：
- en: '`balance = query_balance()` `If` `balance < 0` `Then` `Begin` `show("Attention:
    Your account balance is negative!")` `overdraftrest = 500 + balance` `show("You
    still have $", overdraftrest, " left of your overdraft facility.")` `End` `Else`
    `Begin` `show("Your account is in credit.")` `End` `show("Current balance: $",
    balance)`'
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`balance = query_balance()` `If` `balance < 0` `Then` `Begin` `show("Attention:
    Your account balance is negative!")` `overdraftrest = 500 + balance` `show("You
    still have $", overdraftrest, " left of your overdraft facility.")` `End` `Else`
    `Begin` `show("Your account is in credit.")` `End` `show("Current balance: $",
    balance)`'
- en: 'Here, the keyword `Else` tells us that now the code block begins which is executed
    only if the condition above (`balance < 0`) is not met, that is, if the account
    balance is greater than or equal to 0. We thus have two blocks of code: The block
    between `If account < 0 Then` and `End`, and the one between `Else` and `End`.
    Each time the program is executed, only *one* block is run. So, the program branches
    at this point. If the condition `If balance < 0` is met, it first continues, shows
    the warning message, calculates the overdraft balance, and displays this. Then
    it encounters the `Else.` Since the first condition was already met, the `Else`
    block is skipped and the execution is continued only with the next statement after
    the `Else` block, in our case `show("Current balance: $", balance)`.'
  id: totrans-43
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '在这里，关键字`Else`告诉我们，代码块现在开始执行，只有当上面的条件（`balance < 0`）不满足时才会执行，也就是说，如果账户余额大于或等于0。我们因此有两个代码块：一个在`If
    account < 0 Then`和`End`之间，另一个在`Else`和`End`之间。每次程序执行时，只有*一个*代码块会被运行。所以，程序在这一点上进行分支。如果条件`If
    balance < 0`被满足，程序首先继续，显示警告信息，计算透支余额并显示它。然后它遇到`Else`。由于第一个条件已经满足，`Else`代码块会被跳过，程序继续执行`Else`代码块后的下一条语句，在我们的例子中是`show("Current
    balance: $", balance)`。'
- en: A schematic representation of the flow of an If-Else construct is shown in ◘
    Fig. `[14.1](#Fig1)`.![](../images/474412_1_En_14_Chapter/474412_1_En_14_Fig1_HTML.jpg)
  id: totrans-44
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: If-Else结构的流程示意图如图◘ `[14.1](#Fig1)`所示。![](../images/474412_1_En_14_Chapter/474412_1_En_14_Fig1_HTML.jpg)
- en: A diagram of the if-else construct. Input is provided to the condition, which
    is classified as either not fulfilled or fulfilled. They are followed by the `else`
    and `if` blocks.
  id: totrans-45
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一个If-Else结构的示意图。输入提供给条件，条件被分类为未满足或已满足。接下来是`else`和`if`代码块。
- en: Fig. 14.1
  id: totrans-46
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 14.1
- en: Flow chart of an If-Else construct
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: If-Else结构的流程图
- en: Most programming languages have such If-Else constructs. The structure of these
    constructs is usually very similar. To illustrate this, let’s take a look at how
    the above problem would be solved in three different programming languages.
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 大多数编程语言都有这种If-Else结构。这些结构的形式通常非常相似。为了说明这一点，我们来看一下如何在三种不同的编程语言中解决上面的问题。
- en: 'First in C/C++:'
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 首先是C/C++：
- en: '`if`(balance < 0){`printf`("Attention: Your account balance is negative!");`float`
    overdraftrest = 500 + balance;`printf`("You still have $%f left of your overdraft
    facility.", overdraftrest);} `else`{`printf`("Your account is in credit.");}`printf`("Current
    balance: $%f", balance);'
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`if`(balance < 0){`printf`("Attention: Your account balance is negative!");`float`
    overdraftrest = 500 + balance;`printf`("You still have $%f left of your overdraft
    facility.", overdraftrest);} `else`{`printf`("Your account is in credit.");}`printf`("Current
    balance: $%f", balance);'
- en: 'Next in Python:'
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 接下来是Python示例：
- en: '`if` balance < 0:`print`("Attention: Your account balance is negative!")overdraftrest
    = 500 + balance`print`("You still have ", overdraftrest, " left of your overdraft
    facility.") `else`:`print`("Your account is in credit.")`print`("Current balance:
    $", balance);'
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`if` balance < 0:`print`("Attention: Your account balance is negative!")overdraftrest
    = 500 + balance`print`("You still have ", overdraftrest, " left of your overdraft
    facility.") `else`:`print`("Your account is in credit.")`print`("Current balance:
    $", balance);'
- en: 'And finally, in `Visual Basic for Applications (VBA)`:'
  id: totrans-53
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 最后是`Visual Basic for Applications (VBA)`：
- en: '`If` balance < 0 `Then` `MsgBox` ("Attention: Your account balance is negative!")overdraftrest
    = 500 + balance`MsgBox` ("You still have " & overdraftrest & " left of your overdraft
    facility.") `Else` `MsgBox` ("Your account is in credit.") `End If` `MsgBox` ("Current
    balance: $" & balance) If you compare the three examples, you will first notice
    the fundamentally similar structure. All three languages have an If-Else construct.
    The implementation differs only in detail:'
  id: totrans-54
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`If` balance < 0 `Then` `MsgBox` ("Attention: Your account balance is negative!")overdraftrest
    = 500 + balance`MsgBox` ("You still have " & overdraftrest & " left of your overdraft
    facility.") `Else` `MsgBox` ("Your account is in credit.") `End If` `MsgBox` ("Current
    balance: $" & balance) 如果比较这三个例子，你会首先注意到它们的基本结构相似。所有三种语言都有If-Else结构。实现的区别仅在于细节：'
- en: '`Keywords`: In all three languages, the keywords `if` and `else` exist. However,
    an explicit `then` is written only in `VBA`.'
  id: totrans-55
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`关键词`：在所有三种语言中，`if`和`else`关键字都存在。然而，只有在`VBA`中才会显式地写出`then`。'
- en: '`Conditions`: C/C++ requires that the condition be written in parentheses,
    which the other two languages do not. There, however, parentheses do no harm either;
    we will learn the reason for this below.'
  id: totrans-56
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`条件`：C/C++ 要求条件写在括号内，而另外两种语言则不需要。然而，括号并不会造成任何问题；我们将在下面学习为什么。'
- en: '`Code blocks`: Significant differences exist, however, in how the code blocks
    that are to be executed when the condition is met (`if-case`), or when the condition
    is not met (`else-case`), are delimited: In `C/C++`, curly braces are used to
    mark the beginning `and` end of a code block. In `Python`, however, code blocks
    start with a colon and are indented. All statements at the same indentation level
    are considered part of the code block. Therefore, there is no need for a special
    keyword at the end of the `else` block anymore. Here you must pay close attention
    to how the code is formatted; the indentations have a meaning and therefore you
    can’t just indent as you like. In the `VBA` example, there are the blocks between
    the `Then` and the `Else`, and between the `Else` and the `End If`. Note here
    that, unlike the `End` used above, the `End If` does not mark the end of the `If`
    block, the part of the code that is executed when the condition `balance < 0`
    is met. It marks the end of the entire `If-Else` construct. The `if-block` simply
    ends at the `Else`. Only if no `Else` branch exists, the `End If` marks the end
    of the `If` block. 14.1 [3 min] What does the following pseudo-code program when
    `a. x = 10` `b. x = 11` `c. x = 25` `d. x = –1`?'
  id: totrans-57
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`代码块`：在代码块的划分上存在显著的差异。代码块是当条件满足时（`if-case`）或不满足时（`else-case`）执行的部分：在 `C/C++`
    中，使用大括号来标记代码块的开始`和`结束。而在 `Python` 中，代码块以冒号开始，并通过缩进表示。所有处于同一缩进级别的语句都视为该代码块的一部分。因此，在
    `else` 块结束时，不再需要特殊的关键字。在这里，你必须特别注意代码的格式化；缩进有着重要的意义，因此不能随意缩进。在 `VBA` 示例中，`Then`
    和 `Else` 之间、`Else` 和 `End If` 之间都有代码块。注意，这里与前面提到的 `End` 不同，`End If` 并不标志着 `If`
    块的结束，即条件 `balance < 0` 满足时执行的代码部分。它标志着整个 `If-Else` 结构的结束。`if-block` 仅在 `Else`
    处结束。只有在没有 `Else` 分支时，`End If` 才标志着 `If` 块的结束。14.1 [3 min] 以下伪代码在 `a. x = 10` `b.
    x = 11` `c. x = 25` `d. x = -1` 时会发生什么？'
- en: is entered?
  id: totrans-58
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 被输入时会发生什么？
- en: '`x = enter("Please enter a number: ")` `If` `x > 10` `Then` `Begin` `If` `x
    > 20` `Then` `show("Result A")` `show("Result B")` `End` `Else` `Begin` `If` `x
    > 0` `Then` `show("Result B")` `End` 14.2 [3 min]'
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`x = enter("请输入一个数字：")` `If` `x > 10` `Then` `Begin` `If` `x > 20` `Then` `show("Result
    A")` `show("Result B")` `End` `Else` `Begin` `If` `x > 0` `Then` `show("Result
    B")` `End` 14.2 [3 min]'
- en: Modify the program section from ► Exercise [14.1](#FPar8) so that `Result B`
    is only displayed if `x` is greater than 10 and less than or equal to 20.
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 修改程序部分，从► 练习 [14.1](#FPar8) 开始，只有当 `x` 大于 10 且小于等于 20 时，才显示 `Result B`。
- en: 14.4 A Closer Look at Conditions
  id: totrans-61
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 14.4 更深入地了解条件
- en: In the previous section, you saw how `If-Else` constructs can be used to branch
    to different parts of the program depending on whether a particular condition
    is met or not. In the following, we will take a closer look at the conditions
    that are checked in the `If-Else` constructs.
  id: totrans-62
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上一节中，你已经看到 `If-Else` 结构如何根据特定条件是否满足，决定程序的不同分支。接下来，我们将更深入地探讨在 `If-Else` 结构中检查的条件。
- en: The great common feature of all conditions is that their result is either `true`
    or `false`，the condition is satisfied or not。 Any logical expression that can
    be evaluated as true or false is thus suitable to be used as a condition。 Often
    such logical expressions are value comparisons，as we saw in the online banking
    example of the previous section。 There，for example，we checked whether the account
    balance was less than `0`。 Such value comparisons can be easily formulated using
    the comparison operators known from mathematics，such as `>` (greater than)，`<`
    (less than)，and `=` (equal to)。 Here，`>=` is usually written for “greater than
    or equal to” and `<=` for “less than or equal to” because the special characters
    `≤` and `≥` did not exist in the character sets of the early computer age，and
    today，even though they are theoretically available，they cannot easily be typed
    directly from the keyboard。 Therefore，to facilitate fast typing of programs，the
    compound notation has been agreed upon。 The not-equal character `≠` poses a particular
    challenge，因为 there is no natural “translation” into a compound character。 And
    indeed，different programming languages have found different solutions for this。
    The two most commonly encountered are `<>` (greater than and less than) and `!=`
    (exclamation mark and equal sign)。
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 所有条件的一个重要共同特征是它们的结果要么是`true`，要么是`false`，条件是否满足。任何可以评估为真或假的逻辑表达式都适合用作条件。这样的逻辑表达式通常是值比较，就像我们在上一节的网上银行示例中看到的那样。例如，我们检查了账户余额是否小于`0`。这种值比较可以通过使用数学中常见的比较运算符来轻松表达，比如`>`（大于）、`<`（小于）和`=`（等于）。这里，`>=`通常表示“大于或等于”，`<=`表示“小于或等于”，因为在早期计算机时代，字符集并没有包括特殊字符`≤`和`≥`，即便现在理论上可以使用，但直接从键盘输入它们仍然不方便。因此，为了方便快速编写程序，大家约定使用这种复合符号。至于“不等于”符号`≠`，则特别具有挑战性，因为它没有直接对应的复合字符。事实上，不同的编程语言对这一点有不同的解决方法。最常见的两种是`<>`（大于小于）和`!=`（叹号和等号）。
- en: In the previous section，conditions always consisted of comparing a variable
    with a value。 In fact，any expression that can be true or false is conceivable
    as a condition。 Imagine that we have a function in our online banking example
    that checks whether the current customer has a positive account balance。 The return
    value of this function can be stored in a variable：
  id: totrans-64
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上一节中，条件总是由比较变量和一个值组成。实际上，任何可以为真或假的表达式都可以作为条件。假设我们在网上银行的示例中有一个函数，用来检查当前客户的账户余额是否为正。该函数的返回值可以存储在一个变量中：
- en: '`accountcredit = is_balance_positive()`'
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`accountcredit = is_balance_positive()`'
- en: So we assign the return value of the function `is_balance_positive()` to the
    variable `accountcredit`。 Accordingly, the value of the `accountcredit` variable
    is now either `TRUE` or `FALSE`。 We can check the content of the variable in a
    condition：
  id: totrans-66
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 所以我们将函数`is_balance_positive()`的返回值赋给变量`accountcredit`。因此，`accountcredit`变量的值现在是`TRUE`或`FALSE`。我们可以在条件中检查该变量的内容：
- en: '`If accountcredit = TRUE Then Begin show("Your account is in credit!") End`'
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`If accountcredit = TRUE Then Begin show("您的账户有余额！") End`'
- en: Instead of checking the variable `accountcredit`，most programming languages
    allow you to simply insert the function directly into the condition：
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 大多数编程语言允许你直接在条件中插入函数，而不是检查变量`accountcredit`：
- en: '`If is_balance_positive() = TRUE Then Begin show("Your account is in credit!")
    End`'
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`If is_balance_positive() = TRUE Then Begin show("您的账户有余额！") End`'
- en: This procedure is always useful if you do not want to continue working with
    the return value of the function。 However，if you want to access this value again
    at another point，it makes sense to store the value in a variable for further use。
    This saves a repeated call of the function and thus computing power and time：
    If the program code behind the function is very complex，your program will run
    faster if you simply fall back on the value stored in the variable instead of
    having it recalculated by a function call。
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你不想继续使用函数的返回值，这个过程始终很有用。然而，如果你希望在其他地方再次访问该值，将其存储在变量中以便进一步使用是很有意义的。这可以避免重复调用函数，从而节省计算能力和时间：如果函数背后的程序代码非常复杂，那么如果你直接使用存储在变量中的值，而不是通过函数调用重新计算，程序的运行速度会更快。
- en: 'Another simplification that most programming languages allow is to simply drop
    the explicit comparison with the logical value `TRUE` . So, the assumption is
    that whenever a value (either the value of a variable, the return value of a function,
    or the result of an expression computed in whatever way) is used in a condition
    without explicitly comparing it to another value, the comparison should be made
    to the logical value `TRUE` . In our example, we could write:'
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 大多数编程语言允许的另一个简化是直接省略与逻辑值`TRUE`的显式比较。因此，假设在条件中使用一个值（无论是变量的值、函数的返回值，还是以任何方式计算得到的表达式结果），而没有显式地与另一个值进行比较时，应该默认与逻辑值`TRUE`进行比较。在我们的示例中，我们可以写成：
- en: '`If` `is_balance_positive()` `Then` `Begin` `show("Your account is in credit!")`
    `End`'
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`If` `is_balance_positive()` `Then` `Begin` `show("您的账户有余额！")` `End`'
- en: If you have given the function a meaningful name, as we have done here, the
    condition is very easy to read and understand.
  id: totrans-73
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你给函数起了一个有意义的名字，就像我们在这里做的那样，条件就非常容易阅读和理解。
- en: As you can see, even a normal comparison of values is in the end always a comparison
    with the value `TRUE` and thus a check of a condition according to the common
    scheme.
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如你所见，即使是普通的值比较，最终也是与值`TRUE`的比较，从而根据常规的检查方案进行条件判断。
- en: For instead of, say
  id: totrans-75
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 比如说，代替
- en: '`If` `balance > 1000000` `Then`'
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`If` `balance > 1000000` `Then`'
- en: 'you could also write:'
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你也可以这样写：
- en: '`If` (`balance > 1000000`) = `TRUE` `Then`'
  id: totrans-78
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`If` (`balance > 1000000`) = `TRUE` `Then`'
- en: Then the expression on the left would be evaluated first. If the account balance
    were now greater than one million, the expression would take the value `TRUE`
    and the condition would be fulfilled. Conditions are therefore ultimately always
    comparisons with the value `TRUE` .
  id: totrans-79
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然后左边的表达式会首先被评估。如果账户余额现在大于一百万，那么该表达式将返回`TRUE`，条件将成立。因此，条件最终总是与值`TRUE`进行比较。
- en: '`14.5 Complex Conditions with Logical Operators (AND, OR, NOT)`'
  id: totrans-80
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`14.5 逻辑运算符的复杂条件（AND，OR，NOT）`'
- en: In the examples of the previous sections, it was always a single elementary
    condition in an if-then block that decided whether a program part is executed
    or not. Of course, the condition in an if-then block can also be a condition composed
    of several sub-conditions.
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在前面部分的示例中，总是一个简单的基本条件决定了程序部分是否执行。当然，if-then块中的条件也可以是由多个子条件组成的条件。
- en: Let’s assume, for example, that in our online banking example we only want to
    allow a transfer if the account is not blocked `and` the sum of the account balance
    (which can also be negative) and the overdraft facility is at least as high as
    the amount to be transferred. If, for example, the account balance were `$–150`
    , the overdraft facility `$500` and the user of our online banking wanted to transfer
    an amount of `$50` , the online banking should allow this, because the sum of
    the account balance and the overdraft facility, and thus the amount available
    for the online banking customer, would amount to `$350` , i.e. more than is actually
    to be transferred. If, on the other hand, the customer wanted to transfer `$400`
    , our online banking application should reject this transaction request, because
    the amount to be transferred would exceed the available sum from the account balance
    and overdraft facility by `$50` .
  id: totrans-82
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 假设，在我们的在线银行示例中，我们只想在账户没有被锁定`并且`账户余额（可能为负值）加上透支额度至少和待转账金额相等时，才允许转账。例如，如果账户余额为`$–150`，透支额度为`$500`，且我们的在线银行用户希望转账`$50`，那么在线银行应该允许此交易，因为账户余额和透支额度的总和，即在线银行客户可用的金额，应该为`$350`，即高于实际转账金额。如果，另一方面，客户希望转账`$400`，我们的在线银行应用应该拒绝这个交易请求，因为待转账金额将比账户余额和透支额度的可用总和多出`$50`。
- en: 'To make life easy for ourselves, let’s assume that we have an `is_account_locked()`
    function available that returns `TRUE` if the account is locked and `FALSE` if
    it is not. Then the condition that checks whether the customer is allowed to make
    a transfer of `amount` dollars or not would look like this in an if-then block:'
  id: totrans-83
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为了简化，我们假设我们有一个`is_account_locked()`函数，如果账户被锁定则返回`TRUE`，否则返回`FALSE`。那么在if-then块中检查客户是否允许转账`amount`金额的条件如下所示：
- en: '`If` `is_account_locked()` = `FALSE` `AND` `balance + overdraftrest >= amount`
    `Then` `Begin` `…` `End`'
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`If` `is_account_locked()` = `FALSE` `AND` `balance + overdraftrest >= amount`
    `Then` `Begin` `…` `End`'
- en: Here you can see that we link two (partial) conditions with a logical **AND**.
    The total condition of the if-then block is therefore only fulfilled if *both*
    the one *and* the other partial conditions are fulfilled.
  id: totrans-85
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里你可以看到，我们用逻辑**AND**将两个（部分）条件连接起来。因此，if-then语句的总条件只有在*两个*部分条件都满足时才会成立。
- en: 'In addition to the `AND`, there are other logical operators that you can use
    to combine more complex conditions. For example, the logical `OR`, which links
    two (partial) conditions in such a way that the total condition is fulfilled exactly
    when one, the other, or both partial conditions are fulfilled. The meaning of
    the logical `OR` is therefore different from that of the “or” in everyday language,
    in which an *exclusive* `OR` is often meant: *either* one *or* the other, but
    not both together.'
  id: totrans-86
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 除了`AND`，还有其他逻辑运算符可以用来组合更复杂的条件。例如，逻辑`OR`，它将两个（部分）条件以一种方式链接，使得总条件只有在一个、另一个或两个部分条件都满足时才会成立。因此，逻辑`OR`的意义不同于日常语言中的“或”，在日常语言中通常是指*排他性的*`OR`：*要么*一个*要么*另一个，但不能同时满足。
- en: As you can easily see, logical operators work just like the ones you know from
    mathematics. Accordingly, programming languages also know an exclusive `OR` (often
    called `XOR`), which corresponds to the colloquial “or”.
  id: totrans-87
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 正如你可以很容易看到的，逻辑运算符的工作方式就像你在数学中熟悉的那样。因此，编程语言中也有一个排他性的`OR`（通常叫做`XOR`），它对应日常语言中的“或”。
- en: 'Another important logical operator is the logical `NOT`, which reverses the
    logical truth content of a statement. The inverse of the truth content of the
    statement “The account is locked” is obviously “The account is not locked”. In
    programming, unfortunately, we usually cannot put the `NOT` so elegantly between
    the “words” of our “sentence”. Therefore, in the program code, it tends to result
    in something like “`NOT` the account is locked”. So instead of the above condition,
    we could also write:'
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 另一个重要的逻辑运算符是逻辑`NOT`，它会反转语句的逻辑真值内容。“账户被锁定”这一语句的真值内容的反面显然是“账户没有被锁定”。然而，在编程中，我们通常无法像在自然语言中那样优雅地把`NOT`放在“句子”的“单词”之间。因此，在程序代码中，它通常会变成“`NOT`
    账户被锁定”。因此，除了上面的条件，我们还可以写成：
- en: '**If NOT** `is_account_locked` **AND** `balance + overdraftrest >= amount`
    **Then** **Begin**… **End**'
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**如果 NOT** `is_account_locked` **并且** `balance + overdraftrest >= amount` **那么**
    **开始**… **结束**'
- en: As you recall from the previous section, `is_account_locked()` is a shorthand
    notation for `is_account_locked() = TRUE`, so if you want to check for the value
    **TRUE**, you can simply omit the explicit comparison to that value, because that
    is what is checked for by default if you do not specify a different comparison
    value.
  id: totrans-90
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如你在前一部分中回忆到的，`is_account_locked()`是`is_account_locked() = TRUE`的简写，因此，如果你想检查值为**TRUE**，你可以简单地省略对该值的显式比较，因为默认情况下，如果你没有指定其他比较值，系统会检查这个值。
- en: The condition designed in this way thus first determines the value of the function
    `is_account_locked()`. With the help of the `NOT` operator, this truth value is
    then simply reversed. So, if the account is unlocked, `is_account_locked()` returns
    the value **FALSE**, the logical `NOT` reverses the value to **TRUE**. Thus, the
    condition shortens to **If TRUE AND `balance + overdraft >= amount`**. The truth
    value of the total condition then depends on whether the second sub-condition
    is fulfilled or not.
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这样设计的条件首先确定了函数`is_account_locked()`的值。借助`NOT`运算符，这个真值就会被反转。所以，如果账户没有被锁定，`is_account_locked()`返回**FALSE**，逻辑`NOT`会将这个值反转为**TRUE**。因此，条件可以简化为**如果
    TRUE 并且 `balance + overdraft >= amount`**。总条件的真值然后取决于第二个子条件是否成立。
- en: Of course, logical expressions like the above can also be nested with brackets
    in any complexity. The parentheses ensure that the contents of the parentheses
    are evaluated first, before the value thus determined is logically linked with
    other expressions.
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当然，像上面这样的逻辑表达式也可以嵌套括号，复杂度可以任意增加。括号确保括号中的内容首先被求值，然后这个计算结果再与其他表达式逻辑连接。
- en: 'Here’s a simple example:'
  id: totrans-93
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这是一个简单的例子：
- en: '**If NOT** `is_account_locked()` **AND** (`balance + overdraftrest >= amount`
    OR `is_customerhistory_positive()`) **Then** **Begin**… **End**'
  id: totrans-94
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**如果 NOT** `is_account_locked()` **并且** (`balance + overdraftrest >= amount`
    或 `is_customerhistory_positive()`) **那么** **开始**… **结束**'
- en: The second sub-condition evaluates whether the amount to be transferred meets
    the usual requirement or whether the customer has such a positive history (for
    example, consisting of regular receipts on the account, no significant overdrafts,
    etc.), determined with the help of a function `is_customerhistory_positive()`.
    Thus, if the customer had exhibited exemplary behavior to date, the transaction
    would be allowed even if it exceeded the overdraft limit. The parentheses ensure
    that the first step is to determine whether the transaction should be allowed
    based on the sufficiently small transfer amount or based on the customer’s past
    behavior. For this purpose, two sub-conditions are linked with logical `OR`. This
    results in a logical value, which is then linked in the second step with the logical
    value from the check whether the customer account is blocked with logical `AND`.
  id: totrans-95
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第二个子条件判断待转账金额是否符合常规要求，或客户是否有良好的历史记录（例如，账户上有定期存款、没有重大透支等），这一点通过函数`is_customerhistory_positive()`来判断。因此，如果客户迄今为止表现良好，即使转账金额超出了透支限额，交易也会被允许。括号确保首先判断是基于足够小的转账金额还是基于客户的历史行为来决定是否允许交易。为此，两个子条件通过逻辑`OR`连接。结果是一个逻辑值，然后在第二步中，和检查客户账户是否被锁定的逻辑值通过逻辑`AND`连接。
- en: 'As you might have guessed, logical operators have different names in different
    programming languages. Often, it remains with the English keywords **AND**, **OR**,
    **XOR**, **NOT**, from which the meaning of the operator is immediately apparent.
    However, some languages like `C`, `C++`, `Java` or `R` use special characters
    instead of the written form: The ampersand (`&`) for the logical `AND`, the pipe
    (`|`) for the logical `OR`, and the exclamation mark (`!`) for the logical `NOT`.
    By the way, now you can easily see why inequality is represented by `!=` in these
    languages. It simply means “NOT equal”.'
  id: totrans-96
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如你所料，逻辑运算符在不同的编程语言中有不同的名称。通常，它们保持使用英语关键字**AND**、**OR**、**XOR**、**NOT**，这些关键词的含义一目了然。然而，一些语言，如`C`、`C++`、`Java`或`R`，使用特殊字符代替书面形式：逻辑`AND`用和号（`&`）表示，逻辑`OR`用管道符号（`|`）表示，逻辑`NOT`用感叹号（`!`）表示。顺便说一句，现在你可以轻松理解为什么在这些语言中不等式用`!=`表示，它的意思就是“NOT
    equal”。
- en: 'In `C`, `C++`, `Java`, or `R`, the if-then block above would read like this:'
  id: totrans-97
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在`C`、`C++`、`Java`或`R`中，上面的if-then语句块会是这样的：
- en: '**if** `(!is_account_locked() & (balance + overdraft >= amount | is_customerhistory_positive()))
    {...}`'
  id: totrans-98
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**如果** `(!is_account_locked() & (balance + overdraft >= amount | is_customerhistory_positive()))
    {...}`'
- en: 'In the Visual Basic for Applications (VBA) macro language, which allows you
    to automate the Microsoft Office suite of applications, you would write this if-then
    block using descriptive identifiers for the logical operators:'
  id: totrans-99
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在Visual Basic for Applications (VBA)宏语言中，它允许你自动化Microsoft Office套件的应用程序，你可以用描述性的标识符来编写这个if-then语句块：
- en: '**If Not** `is_account_locked()` **And** (`balance + overdraftrest >= amount`
    **Or** `is_customerhistory_positive()`) **then**…**End If**[10 min]'
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**如果不是** `is_account_locked()` **且** (`balance + overdraftrest >= amount` **或**
    `is_customerhistory_positive()`) **则**…**结束如果**[10 分钟]'
- en: 'Consider the following program excerpt:'
  id: totrans-101
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 考虑以下程序片段：
- en: '`x = input("Please enter a number: ")`**If** `x > 100` **Then** `show("x greater
    than 100!")`**If** `x > 50` **Then** `show("x greater than 50!")`**If** `x > 10`
    **Then** `show("x greater than 10!")`**If** `x < 0` **Then** `show("x less than
    0!")`**If** `x >= 0` **And** `x <= 10` **Then** `show("x between 0 and 10!")`'
  id: totrans-102
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`x = input("请输入一个数字：")`**如果** `x > 100` **则** `show("x 大于 100!")`**如果** `x
    > 50` **则** `show("x 大于 50!")`**如果** `x > 10` **则** `show("x 大于 10!")`**如果** `x
    < 0` **则** `show("x 小于 0!")`**如果** `x >= 0` **且** `x <= 10` **则** `show("x 在 0
    到 10 之间!")`'
- en: (a)
  id: totrans-103
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: (a)
- en: How many conditions are checked when the user enters a value for `x`?
  id: totrans-104
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 用户输入`x`的值时，检查了多少个条件？
- en: (b)
  id: totrans-105
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: (b)
- en: Modify the algorithm so that only one condition is checked in the best case
    and all conditions are checked only in the worst case.
  id: totrans-106
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 修改算法，使得在最好的情况下只检查一个条件，而在最坏的情况下才检查所有条件。
- en: '[3 min]'
  id: totrans-107
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '[3 分钟]'
- en: Where is the error in the following program excerpt?
  id: totrans-108
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下程序片段的错误在哪里？
- en: '`x = input("Please enter a number: ")`'
  id: totrans-109
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`x = input("请输入一个数字：")`'
- en: '**If** `x > 100` **Then** `show("x greater than 100!")`'
  id: totrans-110
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**如果** `x > 100` **则** `show("x 大于 100!")`'
- en: '**Else**'
  id: totrans-111
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**否则**'
- en: '**Begin**'
  id: totrans-112
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**开始**'
- en: '**If** `x >= 110` **Then** `show("x greater than 110!")`'
  id: totrans-113
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**如果** `x >= 110` **则** `show("x 大于 110!")`'
- en: '**Else** `show("x less than or equal to 100!")`'
  id: totrans-114
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**否则** `show("x 小于或等于 100!")`'
- en: '**End**'
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**结束**'
- en: 14.6 Checking Similar Conditions Efficiently with `Switch-Case` Constructs (`Switch/Select…Case`)
  id: totrans-116
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 14.6 使用`Switch-Case`结构高效检查类似条件（`Switch/Select…Case`）
- en: 'Sometimes you want to check many similar conditions at once. Imagine we wanted
    to classify the customers of our online banking according to how much money is
    received in their account each month, in order to be able to offer special services
    to particularly “good” customers. We want to assume that we have a function `received_3months()`
    available to query the average amount of money received over the last three months.
    In our pseudo-code language, the classification of the customers could be done
    like this:'
  id: totrans-117
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 有时你想一次检查多个相似的条件。想象一下，我们希望根据每月存入账户的金额来对我们的在线银行客户进行分类，从而能够为特别“优秀”的客户提供特殊服务。我们假设可以使用一个函数
    `received_3months()` 来查询过去三个月的平均存入金额。在我们的伪代码语言中，客户分类可以这样写：
- en: '`If received_3months() < 1000 Then Begin category="D" End Else Begin If received_3months()
    < 2000 Then Begin category="C" End Else Begin If received_3months() < 4000 Then
    Begin category="B" End Else Begin category="A" End End End`'
  id: totrans-118
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`If received_3months() < 1000 Then Begin category="D" End Else Begin If received_3months()
    < 2000 Then Begin category="C" End Else Begin If received_3months() < 4000 Then
    Begin category="B" End Else Begin category="A" End End End`'
- en: 'Here, the different thresholds for the average monthly cash inflow are checked
    in a nested `If-Else` construct. However, this is relatively difficult to read.
    Many programming languages know a construct that allows you to write the check
    of several similar conditions more elegantly. In our example, the formulation
    could be written as follows:'
  id: totrans-119
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这里，不同的平均月现金流入阈值通过嵌套的 `If-Else` 结构进行检查。然而，这种方式相对较难阅读。许多编程语言提供了一种结构，允许你更加优雅地检查多个类似的条件。在我们的示例中，这种表达方式可以写成如下：
- en: '`Switch received_3months() Begin Case < 1000: category="D" Case < 2000: category="C"
    Case < 4000: category="B" Else: category="A" End`'
  id: totrans-120
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Switch received_3months() Begin Case < 1000: category="D" Case < 2000: category="C"
    Case < 4000: category="B" Else: category="A" End`'
- en: This notation is much clearer and therefore both more readable and easier to
    program. Behind the keyword `Switch` is first the variable that is subject to
    the check. In our case it is simply the return value of our function `received_3months()`.
    `Case` is used to introduce a condition to be checked, for example `< 1000`. The
    colon is then followed by what is to be done in this case, in our example the
    setting of the customer category. The special keyword `Else` can be used to catch
    all other cases that have not been explicitly checked with specific conditions.
    This statement is only triggered if none of the other conditions apply. If, however,
    one of the other conditions does apply, the statements assigned to this case (in
    our example only one, but there could be several) are executed. After that, the
    entire construct is exited, that is, none of the other conditions are checked.
    Instead, the execution of the program continues after `End`.
  id: totrans-121
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这种写法要清晰得多，因此更加易读，也更容易编程。关键字 `Switch` 后面首先是需要检查的变量。在我们的例子中，它就是我们函数 `received_3months()`
    的返回值。`Case` 用来引入需要检查的条件，例如 `< 1000`。冒号后面是当条件成立时要执行的操作，在我们的例子中是设置客户类别。特殊关键字 `Else`
    用于捕捉所有未通过特定条件显式检查的其他情况。如果没有任何条件适用，则触发这个语句。相反，如果某个条件适用，则执行与该条件相关的语句（在我们的例子中只有一个，但也可以有多个）。执行完该语句后，整个结构退出，也就是说，不再检查其他条件。而是程序在
    `End` 后继续执行。
- en: The schematic representation of the sequence of a `Switch-Case` construct is
    shown in ◘ Fig. [14.2](#Fig2).![](../images/474412_1_En_14_Chapter/474412_1_En_14_Fig2_HTML.jpg)
  id: totrans-122
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Switch-Case` 结构的顺序示意图见图 ◘ [14.2](#Fig2)。![](../images/474412_1_En_14_Chapter/474412_1_En_14_Fig2_HTML.jpg)'
- en: A flowchart of the switch case construct. Input is given to the expression,
    expression blocks through values, and else block of expression, and ends.
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Switch-Case` 结构的流程图。输入给表达式，表达式块通过值、表达式的 else 块，并最终结束。'
- en: Fig. 14.2
  id: totrans-124
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 14.2
- en: Flow chart of a `Switch-Case` construct
  id: totrans-125
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Switch-Case` 结构的流程图'
- en: Many programming languages allow for this elegant approach of checking multiple
    similar conditions. Typically, such constructs are called `Switch-Case` or `Select-Case
    constructs`，after the two central keywords `switch` or `select` and `case`，which
    are commonly used in most languages that have such a construct. Confusingly, some
    languages use the keyword `case` instead of `switch` or `select`，but we won’t
    concern ourselves with that here.
  id: totrans-126
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 许多编程语言允许使用这种优雅的方式检查多个相似条件。通常，这种结构称为 `Switch-Case` 或 `Select-Case` 结构，源自这两个中央关键字
    `switch` 或 `select` 以及 `case`，它们在大多数具有此类结构的编程语言中都很常见。令人困惑的是，有些语言使用关键字 `case` 来代替
    `switch` 或 `select`，但我们在这里不再讨论这个问题。
- en: 'For example, in `C`，a language that supports `Switch-Case constructs`，the above
    check of the client category would then read like this:'
  id: totrans-127
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 例如，在支持`Switch-Case 结构`的语言`C`中，上述对客户类别的检查可以写成如下：
- en: '`switch`(`received_3months()`){`case` < 1000:`category`="D";`break`;`case`
    < 2000:`category`="C";`break`;`case` < 4000:`category`="B";`break`;`default`:`category`="A";`break`;}'
  id: totrans-128
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`switch`(`received_3months()`){`case` < 1000:`category`="D";`break`;`case`
    < 2000:`category`="C";`break`;`case` < 4000:`category`="B";`break`;`default`:`category`="A";`break`;}'
- en: 14.7 Events
  id: totrans-129
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 14.7 事件
- en: In addition to classical `if`-conditions (including their special version as
    `Switch-Case constructs`)，there is yet another important way to branch to different
    parts of the program while it is running, and that is through what are called
    `events`.
  id: totrans-130
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 除了经典的`if`条件语句（包括它们的特殊版本`Switch-Case 结构`）之外，还有另一种重要的方法可以在程序运行时分支到程序的不同部分，那就是通过所谓的`事件`。
- en: Classical conditions are executed when the program has reached the corresponding
    position where the branch condition is located. The program therefore runs completely
    `sequentially`。Sometimes, however, you do not know in advance exactly when in
    the program flow you want to branch. In this case, events can help.
  id: totrans-131
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 经典的条件语句在程序到达相应的位置时执行，该位置是分支条件所在的位置。因此，程序完全按`顺序`执行。然而，有时候，您并不知道程序流中具体什么时候需要进行分支。在这种情况下，事件可以派上用场。
- en: Imagine that in our online banking example there are three buttons on the banking
    website, “New transfer”, “Export transaction as text file” and “Logout”, which
    the user can click at any time. Behind each of these buttons are different program
    instructions, but we do not know in advance when – and if at all – the user will
    trigger the corresponding functions.
  id: totrans-132
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 想象一下，在我们的在线银行示例中，银行网站上有三个按钮：“新转账”、“将交易导出为文本文件”和“注销”，用户可以随时点击这些按钮。每个按钮背后都有不同的程序指令，但我们无法预先知道用户何时——以及是否——会触发相应的功能。
- en: 'There are basically two ways to deal with this problem:'
  id: totrans-133
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 处理这个问题的基本方法有两种：
- en: Either the program runs in a virtually infinite loop and actively observes the
    user’s behavior at all times, that is, it checks whether the user has clicked
    the button or not. We will deal with loops a little later in this part of the
    book, but the basic idea of a practically infinitely repeating loop that always
    jumps back to its beginning and runs again should be understandable. Now, as soon
    as the user clicks on one of the buttons, the program executes the program code
    behind the button and then returns to the infinite loop in which it constantly
    monitors the user’s actions.
  id: totrans-134
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 要么程序以几乎无限的循环运行，并且始终主动观察用户的行为，也就是检查用户是否点击了按钮。我们将在本书的稍后部分讨论循环，但基本的想法是，程序进入一个实际上无限重复的循环，并总是回到其起点重新运行。现在，只要用户点击了其中一个按钮，程序就执行该按钮背后的程序代码，然后返回到无限循环中，继续监控用户的行为。
- en: The second possibility is that the program does not wait in an infinite loop
    for the user but does whatever it is supposed to do. However, when it learns from
    the outside that the user has clicked one of the buttons, it immediately jumps
    into a function that then executes the instructions behind the button.
  id: totrans-135
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 第二种可能性是程序并不会在无限循环中等待用户，而是完成它应做的事情。然而，当它从外部得知用户已经点击了某个按钮时，它会立即跳转到一个函数，然后执行该按钮背后的指令。
- en: 这两种方法的区别在于，在第一种情况下，等待用户并监控他们的活动几乎会阻塞程序。它始终处于`active monitoring state`，不断检查某个按钮是否被点击。在第二种情况下，程序从`the
    outside`得知某个`event`已发生。一旦发生这种情况，与该事件关联的函数将被执行。这类函数也被称为`event handlers`，因为它们描述了如何处理事件。
  id: totrans-136
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这两种方法的区别在于，在第一种情况下，等待用户并监控他们的活动几乎会阻塞程序。它始终处于`主动监控状态`，不断检查某个按钮是否被点击。在第二种情况下，程序从`外部`得知某个`事件`已发生。一旦发生这种情况，与该事件关联的函数将被执行。这类函数也被称为`事件处理程序`，因为它们描述了如何处理事件。
- en: 这种方法节省了计算能力，因为第一种方法所需的主动观察就像主动倾听。它意味着信号必须不断处理，而通过事件控制，其他东西，如操作系统或解释器，会简单地通知您事件已发生。这使得程序可以在此期间做其他事情，并在事件发生时仍能作出反应。
  id: totrans-137
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这种方法节省了计算能力，因为第一种方法所需的主动观察就像主动倾听。它意味着信号必须不断处理，而通过事件控制，其他东西，如操作系统或解释器，会简单地通知您事件已发生。这使得程序可以在此期间做其他事情，并在事件发生时仍能作出反应。
- en: 它的工作方式类似于烤箱，您必须将其预热到某个温度才能烤制比萨饼。例如，只有当预热温度达到时，才能将比萨放入烤箱。您可以每隔几分钟去烤箱查看预热温度是否已经达到。或者，您可以有一个独立发出声响的烤箱，当它准备好时会发出信号。在第一种情况下，我们处于无限循环中，一遍又一遍地检查烤箱是否已经达到预热温度。在第二种情况下，其他人（在这种情况下是烤箱本身）通知我们“预热温度已达到”事件已经发生。只要这还没有发生，我们可以做其他事情，因为我们知道烤箱会在适当的时候报告。
  id: totrans-138
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 它的工作方式类似于烤箱，您必须将其预热到某个温度才能烤制比萨饼。例如，只有当预热温度达到时，才能将比萨放入烤箱。您可以每隔几分钟去烤箱查看预热温度是否已经达到。或者，您可以有一个独立发出声响的烤箱，当它准备好时会发出信号。在第一种情况下，我们处于无限循环中，一遍又一遍地检查烤箱是否已经达到预热温度。在第二种情况下，其他人（在这种情况下是烤箱本身）通知我们“预热温度已达到”事件已经发生。只要这还没有发生，我们可以做其他事情，因为我们知道烤箱会在适当的时候报告。
- en: 许多编程语言支持事件的使用。由于这改变了程序的结构，我们在此上下文中称之为`event-oriented programming paradigm`。支持事件处理的语言，如JavaScript，通常用于开发图形用户界面，在这些界面中，程序流并不是完全顺序的，您也无法预先确切知道哪个程序部分必须执行，因为用户的行为是不可预测的。一般来说，图形用户界面，如我们在►`Sect.
    [12.​2.​1](474412_1_En_12_Chapter.xhtml#Sec3)`中了解到的，是事件导向方法的典型应用。
  id: totrans-139
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 许多编程语言支持事件的使用。由于这改变了程序的结构，我们在此上下文中称之为`事件导向编程范式`。支持事件处理的语言，如JavaScript，通常用于开发图形用户界面，在这些界面中，程序流并不是完全顺序的，您也无法预先确切知道哪个程序部分必须执行，因为用户的行为是不可预测的。一般来说，图形用户界面，如我们在►`Sect.
    [12.​2.​1](474412_1_En_12_Chapter.xhtml#Sec3)`中了解到的，是事件导向方法的典型应用。
- en: 事件控制程序的示意图如◘`Fig. [14.3](#Fig3)`所示。![](../images/474412_1_En_14_Chapter/474412_1_En_14_Fig3_HTML.jpg)
  id: totrans-140
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 事件控制程序的示意图如◘`Fig. [14.3](#Fig3)`所示。![](../images/474412_1_En_14_Chapter/474412_1_En_14_Fig3_HTML.jpg)
- en: 事件控制程序的流程图。事件1由事件循环的事件1到3组成。事件1与事件处理程序1连接，并返回事件循环。
  id: totrans-141
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 事件控制程序的流程图。事件1由事件循环的事件1到3组成。事件1与事件处理程序1连接，并返回事件循环。
- en: '`Fig. 14.3`'
  id: totrans-142
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Fig. 14.3`'
- en: 事件控制程序的流程图
  id: totrans-143
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 事件控制程序的流程图
- en: By the way, not only the user can trigger events. The operating system or connected
    devices can also trigger events to which the programs can then react. For example,
    the operating system can announce that it now wants to shut down; that gives programs
    that have an event handler the opportunity to react, and save the current state
    of the program before the program is closed. Similarly, devices can trigger events,
    such as a printer or hard disk drive.
  id: totrans-144
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 顺便说一下，触发事件的不仅仅是用户。操作系统或连接的设备也可以触发事件，程序可以对此作出反应。例如，操作系统可以宣布它现在要关闭；这时，有事件处理程序的程序就有机会做出反应，在程序关闭之前保存当前的状态。同样，设备也可以触发事件，比如打印机或硬盘驱动器。
- en: 'So far we have dealt with the basic functionality of event handlers, but what
    do such functions look like now? Here is an excerpt from the example outlined
    above (as always, in our pseudo-code language):'
  id: totrans-145
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 到目前为止，我们处理了事件处理程序的基本功能，但这些函数现在是什么样的呢？这里是上面示例的摘录（如往常一样，采用我们伪代码语言）：
- en: '`Function` `event_transfer(e)` `Begin` `create_transfer()` `End` `Function`
    `event_logout(e)` `Begin` `logout()` `End`'
  id: totrans-146
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Function` `event_transfer(e)` `Begin` `create_transfer()` `End` `Function`
    `event_logout(e)` `Begin` `logout()` `End`'
- en: Here we define two event handlers, one for the event where the user clicked
    on the “New transfer” button, and one for the event where the user wants to log
    out. As you can see here, the event handlers are just normal functions. In some
    languages, event handlers are passed a special object as a function argument (above,
    the argument `e` of type `event`) that describes the event in more detail. For
    example, for an event that fires whenever the user moves the mouse, the current
    “coordinates” of the mouse pointer could be passed as properties of the object.
    The event handler function can then retrieve these coordinates from the object
    and react accordingly.
  id: totrans-147
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个事件处理程序，一个用于用户点击“新转账”按钮的事件，另一个用于用户想要注销的事件。如你所见，事件处理程序只是普通的函数。在某些语言中，事件处理程序会作为函数参数传递一个特殊对象（如上所示，`e`
    类型为 `event`），该对象更详细地描述了事件。例如，对于一个每当用户移动鼠标时触发的事件，可以将当前鼠标指针的“坐标”作为对象的属性传递。事件处理程序函数随后可以从对象中获取这些坐标，并做出相应的反应。
- en: The only difference between these functions and the ones we learned about in
    ► Chap. `[13](474412_1_En_13_Chapter.xhtml)` is that they are not called by us,
    the programmers, but “from outside”. The interpreter or the operating system notifies
    us when our event has occurred, and they do this by calling our event handler,
    giving it the event object `e` as additional information. So, in the end, event
    handlers are simply functions that we develop but don’t call ourselves; we just
    provide them for whoever signals us that the event has occurred.
  id: totrans-148
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这些函数和我们在►第[13](474412_1_En_13_Chapter.xhtml)章中学习到的函数的唯一区别在于，它们不是由我们程序员调用的，而是“外部调用”的。当事件发生时，解释器或操作系统会通知我们，并通过调用我们的事件处理程序，将事件对象
    `e` 作为附加信息传递给它。因此，最终，事件处理程序只是我们开发的函数，但并不是我们自己调用的；我们只是为那些通知我们事件已经发生的人提供这些函数。
- en: 'The above examples would look like this in JavaScript:'
  id: totrans-149
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 上述示例在 JavaScript 中的表现如下：
- en: '`function` `event_transfer() {create_transfer();}` `function` `event_logout()
    {logout();}`'
  id: totrans-150
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`function` `event_transfer() {create_transfer();}` `function` `event_logout()
    {logout();}`'
- en: 'In order for the interpreter to know which event handler to call for each event,
    the button definitions in the HTML source code of the website would need to be
    as follows:'
  id: totrans-151
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为了让解释器知道在每个事件发生时调用哪个事件处理程序，网站 HTML 源代码中的按钮定义需要如下所示：
- en: '`<button onclick="event_transfer()">New transfer</button><button onclick="event_logout()">Log
    out</button>`'
  id: totrans-152
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`<button onclick="event_transfer()">新转账</button><button onclick="event_logout()">注销</button>`'
- en: This way, two buttons are created and their (standard) `onclick` events, which
    are triggered whenever someone clicks on the button, is linked to our respective
    event handlers.
  id: totrans-153
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这样就创建了两个按钮，并将它们的（标准）`onclick` 事件与我们的事件处理程序连接起来，每当有人点击按钮时，就会触发这些事件。
- en: 'In Delphi, our event handlers would look like this:'
  id: totrans-154
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在 Delphi 中，我们的事件处理程序将是这样的：
- en: '`procedure` `BankingForm.LogoutButtonClick(Sender: TObject);` `begin` `create_transfer();`
    `end`; `procedure` `BankingForm.NewTransferButtonClick(Sender: TObject);` `begin`
    `logout();` `end`;'
  id: totrans-155
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`procedure` `BankingForm.LogoutButtonClick(Sender: TObject);` `begin` `create_transfer();`
    `end`; `procedure` `BankingForm.NewTransferButtonClick(Sender: TObject);` `begin`
    `logout();` `end`;'
- en: Here we would have defined a window (a “form”) called `BankingForm`，on which
    we would place the buttons with the names `NewTransferButton` and `LogoutButton`。The
    event handlers not only carry the name of the respective button, but also, with
    “Click”, the name of the event they cover. This way Delphi understands which event
    it is and which element of the user interface it refers to. The event handlers
    are also given the respective button that was clicked with the argument `Sender`，which
    becomes interesting if you use the same event handler for several user interface
    elements, and you have to distinguish between the different elements that may
    have triggered the event within the event handler function.
  id: totrans-156
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这里，我们将定义一个名为`BankingForm`的窗口（一个“表单”），在上面放置名为`NewTransferButton`和`LogoutButton`的按钮。事件处理程序不仅带有相应按钮的名称，还带有“Click”，即它们所处理的事件名称。这样，Delphi就能理解这是哪个事件，并且知道它所指的界面元素是什么。事件处理程序还通过`Sender`传递被点击的按钮，`Sender`在使用相同事件处理程序处理多个界面元素时变得非常有用，这时你需要在事件处理函数内区分触发事件的不同元素。
- en: '`14.5` [3 min]'
  id: totrans-157
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`14.5` [3分钟]'
- en: How does a program that follows the event-oriented programming paradigm differ
    from completely linear programs?
  id: totrans-158
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 遵循事件驱动编程范式的程序与完全线性程序有何不同？
- en: '`14.6` [3 min]'
  id: totrans-159
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`14.6` [3分钟]'
- en: Why is event control particularly well suited for graphical user interfaces?
  id: totrans-160
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为什么事件控制特别适合图形用户界面？
- en: '`14.8` Your Roadmap to Learning a New Programming Language'
  id: totrans-161
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`14.8` 学习新编程语言的路线图'
- en: If you are learning a new programming language….
  id: totrans-162
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你正在学习一门新的编程语言……
- en: 'you’ll discover:'
  id: totrans-163
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你将会发现：
- en: how `If-Else` constructs are formulated in the language (key words used for
    this in many languages are `if`，`then`，`else`)，
  id: totrans-164
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何在该语言中构建`If-Else`语句（许多语言中用于此的关键字是`if`，`then`，`else`），
- en: how to write the comparison operators used to formulate conditions,
  id: totrans-165
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何编写用于构建条件的比较运算符，
- en: how to write the logical operators that are used to combine several elementary
    conditions into one overall condition,
  id: totrans-166
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何编写逻辑运算符，用于将多个基本条件组合成一个整体条件，
- en: whether the language has a `Switch-Case` construct and, if so, how it is formulated
    (keywords used for this in many languages are `switch`，`select`，`case`)，
  id: totrans-167
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 语言是否具有`Switch-Case`结构，如果有，如何构建（许多语言中用于此的关键字是`switch`，`select`，`case`），
- en: how code blocks are delimited (i.e., opened and closed) in the language, and
    whether these delimiters can be omitted if the code block contains only a single
    statement,
  id: totrans-168
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 代码块如何在该语言中被定界（即如何打开和关闭），以及如果代码块只包含一条语句，是否可以省略这些定界符，
- en: whether the language supports events, and if so, how to define event handlers
    (including which arguments to pass to event handlers, if any), and how to link
    event handlers to the events on whose occurrence they are to be called.
  id: totrans-169
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 语言是否支持事件，如果支持，如何定义事件处理程序（包括是否需要传递任何参数），以及如何将事件处理程序与事件链接，以便在事件发生时调用它们。
- en: An overview of the considered constructs for sequence control can be seen in
    ◘ Fig. [`14.4`](#Fig4).![](../images/474412_1_En_14_Chapter/474412_1_En_14_Fig4_HTML.jpg)
  id: totrans-170
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 视图`14.4`中可以看到考虑的顺序控制结构概述。◘ 图示 [`14.4`](#Fig4)。![](../images/474412_1_En_14_Chapter/474412_1_En_14_Fig4_HTML.jpg)
- en: A table illustrates the conditions and events. Row 1 consists of elementary
    and complex conditions. Row 2 consists of 3 columns of if-else constructs, switch
    case constructs, and event handler functions.
  id: totrans-171
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一张表格展示了条件和事件。第1行包含基本条件和复杂条件，第2行包含3列的if-else语句、switch case语句和事件处理函数。
- en: Fig. `14.4`
  id: totrans-172
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图示 `14.4`
- en: Conditions and events for sequence control
  id: totrans-173
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 顺序控制的条件和事件
- en: '`14.9` Solutions to the Exercises'
  id: totrans-174
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`14.9` 练习解答'
- en: Exercise `14.1`
  id: totrans-175
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 `14.1`
- en: '`(a)`'
  id: totrans-176
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`(a)`'
- en: 'Output: `Result C`'
  id: totrans-177
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 输出：`Result C`
- en: '`(b)`'
  id: totrans-178
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`(b)`'
- en: 'Output: `Result B`'
  id: totrans-179
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 输出：`Result B`
- en: '`(c)`'
  id: totrans-180
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`(c)`'
- en: 'Output: `Result A`，`Result B`'
  id: totrans-181
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 输出：`Result A`，`Result B`
- en: '`(d)`'
  id: totrans-182
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`(d)`'
- en: No output (none of the conditions covers the case where `x` is negative)
  id: totrans-183
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 无输出（没有任何条件覆盖`x`为负数的情况）
- en: 'Exercise `14.2` x = input("Please enter a number: ") `If` x > 10 `Then` `If`
    x > 20 `Then` show("Result A") `Else` show("Result B") `Else` `If` x > 0 `Then`
    show("Result B") `End`'
  id: totrans-184
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 `14.2` x = input("请输入一个数字：") `If` x > 10 `Then` `If` x > 20 `Then` show("Result
    A") `Else` show("Result B") `Else` `If` x > 0 `Then` show("Result B") `End`
- en: Within the code block `If x > 10`, we first check for `x > 20`. If this condition
    does not apply, we know that `x` must be greater than `10` (otherwise the program
    would not have entered this code block at all), but less than or equal to `20`.
    Therefore, it is sufficient to place the keyword `Else` in front of the output
    of `Result B`.
  id: totrans-185
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在代码块 `If x > 10` 内部，我们首先检查 `x > 20`。如果这个条件不成立，我们知道 `x` 必定大于 `10`（否则程序根本不会进入这个代码块），但小于或等于
    `20`。因此，只需在 `Result B` 的输出前放置关键字 `Else` 即可。
- en: '`Exercise 14.3`'
  id: totrans-186
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`练习 14.3`'
- en: '`(a)`'
  id: totrans-187
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`(a)`'
- en: Five times. Each condition is checked, regardless of the previous result of
    the conditions.
  id: totrans-188
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 五次。每个条件都会被检查，无论前一个条件的结果如何。
- en: '`(b)`'
  id: totrans-189
  prefs:
  - PREF_OL
  stylish: true
  type: TYPE_NORMAL
  zh: '`(b)`'
- en: By clever nesting of `If-Else` constructs, the number of checks of conditions
    can be reduced. If `x` is less than `0`, only one condition is checked. The remaining
    conditions are then not checked at all since they are in the `else` branch to
    the condition `x < 0`. Only if `x` is greater than or equal to `0` and at the
    same time less than or equal to `10`, the program passes through all conditions.
  id: totrans-190
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 通过巧妙地嵌套 `If-Else` 结构，可以减少条件检查的次数。如果 `x` 小于 `0`，那么只检查一个条件。剩下的条件就不会被检查，因为它们在 `x
    < 0` 的 `else` 分支中。只有当 `x` 大于或等于 `0`，同时小于或等于 `10` 时，程序才会通过所有条件。
- en: The trick here is to arrange the conditions in such a way that each condition
    can at least theoretically be achieved. For example, if we had used `x > 10` as
    the top/outermost condition, conditions such as `x > 50` would no longer be checked
    at all, because `x > 10` has already been evaluated as true, and everything that
    lies in the `else` branch to `x > 10` condition is no longer passed through.
  id: totrans-191
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里的诀窍是以一种方式安排条件，使得每个条件至少在理论上是可达成的。例如，如果我们将 `x > 10` 作为最外层的条件，那么像 `x > 50` 这样的条件将根本不再被检查，因为
    `x > 10` 已经被评估为真，并且所有位于 `x > 10` 的 `else` 分支中的内容将不再被通过。
- en: Of course, a formulation with a `Switch-Case` construct (► Sect. `[14.6](#Sec6)`)
    would be a much more elegant and readable solution.
  id: totrans-192
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当然，使用 `Switch-Case` 构造（► 第[14.6节](#Sec6)）会是一个更加优雅且易读的解决方案。
- en: '`x = input("Please enter a number: ") If x < 0 Then show("x less than 0!")
    Else If x > 100 Then show("x greater than 100!") Else If x > 50 Then show("x greater
    than 50!") Else If x > 10 Then show("x greater than 10!") Else If x >= 0 AND x
    <= 10 Then show("x between 0 and 10!") End End End End End` `Exercise 14.4`'
  id: totrans-193
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`x = input("请输入一个数字: ") 如果 x < 0 则 显示("x 小于 0!") 否则 如果 x > 100 则 显示("x 大于 100!")
    否则 如果 x > 50 则 显示("x 大于 50!") 否则 如果 x > 10 则 显示("x 大于 10!") 否则 如果 x >= 0 且 x <=
    10 则 显示("x 在 0 到 10 之间!") 结束 结束 结束 结束 结束` `练习 14.4`'
- en: The problem with this nested `If-Else` construct is that the condition that
    checks `x` in the inner `If-Else` construct to see if it has a value greater than
    or equal to `110` can never come to a positive result. If `x` is indeed greater
    than `110`, the outer condition `x > 100` is already true, and its associated
    code block (here consisting of only a single statement) is then executed. The
    `else`-block, on the other hand, is only executed if `x` is less than or equal
    to `100`, but then the condition of the inner `If-Then` construct (`x >= 110`)
    can never be true. The output statement for `x` greater than `110` is isolated,
    so to speak.
  id: totrans-194
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这个嵌套的 `If-Else` 结构的问题在于，它检查 `x` 是否大于或等于 `110` 的内部条件永远无法得到正面结果。如果 `x` 确实大于 `110`，外部条件
    `x > 100` 已经为真，它的关联代码块（此处只包含一条语句）就会执行。另一方面，`else` 块只有在 `x` 小于或等于 `100` 时才会执行，但此时内部
    `If-Then` 结构的条件（`x >= 110`）永远不可能为真。可以说，`x` 大于 `110` 的输出语句是孤立的。
- en: '`Exercise 14.5`'
  id: totrans-195
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`练习 14.5`'
- en: 与线性程序不同，遵循事件导向编程范式的程序可以通过跳转到为此类事件精心开发的代码位置来响应事件（例如，用户点击按钮）。如果此刻没有事件需要处理，程序会仔细观察其环境，等待再次激活。当线性程序是从头到尾逐步执行的一长串指令时，事件导向程序由一组事件处理程序组成，即在相应事件发生时激活的函数。事件处理程序本身是指令序列，但程序不是执行线性控制流，而是根据当前处理的事件在事件处理程序之间来回跳转。
  id: totrans-196
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与线性程序不同，遵循事件导向编程范式的程序可以通过跳转到为此类事件精心开发的代码位置来响应事件（例如，用户点击按钮）。如果此刻没有事件需要处理，程序会仔细观察其环境，等待再次激活。当线性程序是从头到尾逐步执行的一长串指令时，事件导向程序由一组事件处理程序组成，即在相应事件发生时激活的函数。事件处理程序本身是指令序列，但程序不是执行线性控制流，而是根据当前处理的事件在事件处理程序之间来回跳转。
- en: '`Exercise 14.6`'
  id: totrans-197
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`练习 14.6`'
- en: 图形用户界面通常给予用户很大的自由来决定调用哪些功能。用户往往不是被紧密引导的，而是从一系列选项中选择，这些选项通常反映在菜单、工具栏、按钮、标签和其他控件中。这就是事件驱动控制派上用场的地方，简单地调用与用户触发/激活的控件相关联的事件处理程序。
  id: totrans-198
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图形用户界面通常给予用户很大的自由来决定调用哪些功能。用户往往不是被紧密引导的，而是从一系列选项中选择，这些选项通常反映在菜单、工具栏、按钮、标签和其他控件中。这就是事件驱动控制派上用场的地方，简单地调用与用户触发/激活的控件相关联的事件处理程序。
