- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024J. L. ZuckarelliLearn coding with Python and JavaScript
    [https://doi.org/10.1007/978-3-658-42912-6_20](https://doi.org/10.1007/978-3-658-42912-6_20)
  prefs: []
  type: TYPE_NORMAL
- en: '20. Syntax, Comments, Code Style & Documentation: How Do I Make Sure That I
    (And Others) Still Understand My Program Later?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1)München, GermanyOverview
  prefs: []
  type: TYPE_NORMAL
- en: Before we really get into Python programming, we will first look at what Python
    code and its most important basic elements look like, and which fundamental conventions
    must be observed when writing code. Compared to many other programming languages,
    Python has a special feature in code design that, at first glance, seems to take
    away some design freedom from us as programmers, but at the same time makes our
    lives easier.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we will look at how Python code is *commented* and *documented.*
    Commenting is important so that we as developers can still understand our own
    code later, especially if we want to develop it further. Documentation is used
    to provide information so that other developers who want to use our code in their
    programs understand exactly how to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: What meaning line indentations have in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how to terminate statements in Python and how to extend statements over multiple
    lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how identifiers for variables, functions, methods, and modules are usually chosen
    in Python and what restrictions there are in doing so
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how to formulate comments in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: what docstrings are and how you can use them to document the program code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.1 Design of the Program Code and Naming Conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 20.1.1 Indentation and General Code Formatting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We saw in ► Sect. [10.​2](474412_1_En_10_Chapter.xhtml#Sec2) that many programming
    languages give the developer a lot of leeway in how the source code should be
    formatted. By choosing suitable indentations, for example, one can make the program
    code clearer. This freedom of design is ultimately due to the fact that many programming
    languages completely ignore the formatting of the program code. In other words,
    the formatting has no significance for the content of the program.
  prefs: []
  type: TYPE_NORMAL
- en: This is different in Python. Where other programming languages have special
    symbols to mark the beginning and end of code blocks (for example, **begin** and
    **end**, or open and closed curly braces), Python uses indentations. Statements
    that are indented the same distance belong to the same code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a simple function that you can pass a text and a number
    of repetitions, and it will simply output the text to the screen the appropriate
    number of times (in uppercase) and announce the current repetition number. Don’t
    worry that you may not yet understand all the code, you will by the end of this
    part of the book. Here it’s just about the indentations for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def** repeat_text(text: str, reps: int):text = text.upper()**for** x **in**
    range(1, reps+1):output = ''Run no.'' + str(x) + '': '' + textprint(output)repeat_text(''Hello
    world'', 3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the function has been created with **def**, it is then called in the
    last line. The program generates the following output with this function call:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run No.1: HELLO WORLDRun No.2: HELLO WORLDRun No.3: HELLO WORLD'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the code block belonging to the **repeat_text()** function
    is indented. The same applies to the code block that is executed in the **for**
    loop and causes the output. This block is even indented twice, it belongs to the
    function **repeat_text()** and within that function to the **for** loop **for
    x in range(1, reps+1)**: After the end of the function definition, **repeat_text(''Hello
    world'', 3)** continues on the far left again. This statement does not belong
    to the code block of the **for** loop, not even to the code block of the function
    definition.'
  prefs: []
  type: TYPE_NORMAL
- en: So, code blocks in Python are delimited by indentation (and introduced by a
    colon, as you can see in both the function definition using the **def** keyword
    and the **for** loop). Indentations are usually made either with the tab key or
    by entering four spaces. The second type is generally preferred. For the sake
    of consistent code, however, you should especially not mix both types of indentation
    in one program. Due to the enforced indentations, Python code is quite readable,
    so the loss of design freedom is tolerable. This way of delimiting code blocks
    eliminates the need to use parentheses or other keywords, the forgetting of which—especially
    at the end of a code block—is a common source of errors in other programming languages.
    Apart from the indentations, you are completely free regarding the design of the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In the form of style guidelines, however, there is a whole series of suggestions
    and recommendations on how to write Python code. Adhering to them helps to make
    the code more readable and understandable. But many of the rules are very detailed
    and are certainly not always followed, even by Python professionals. The official
    style guide can be found as a *Python Enhancement Proposal* (PEP) under the serial
    number PEP 8 on the ► [python.​org](http://python.org) website. It doesn’t hurt
    to take a look there.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with *PyCharm*, the handy “Reformat Code” feature from the
    “Code” menu allows you to have your code automatically formatted according to
    PEP 8 rules. Also, *PyCharm* alerts you to “violations” of the PEP 8 rules with
    wavy, gray underlines and small tooltip overlays, as you see in ◘ Fig. [20.1](#Fig1).![](../images/474412_1_En_20_Chapter/474412_1_En_20_Fig1_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a set of program codes and a block of tooltip insertion. Repeat
    text of text string and reps integer is defined along with for loop statement.
    A Pep 8 block overlays the program.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 20.1
  prefs: []
  type: TYPE_NORMAL
- en: Tool tip insertion for code formatting
  prefs: []
  type: TYPE_NORMAL
- en: 20.1.2 End of Statement Without Semicolon, Statements Over Several Lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python generally does not require a delimiter such as a semicolon at the end
    of a statement. Each statement simply ends automatically at the end of the line.
    Even if it is not advisable, due to the reduced clarity, you can also write several
    statements on one line in Python. In this case, however, you must separate the
    individual statements with a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, there are also possibilities to extend an instruction over several
    lines. This makes sense if the statement is very long. Of course, you could also
    simply write the statement on one long line. However, you might have to scroll
    horizontally to see the end of the statement. This is uncomfortable and should
    be avoided. According to the code styling recommendations of PEP 8, lines of code
    should not be longer than 79 characters. Now, however, there are statements that
    are simply too long. So, what to do?
  prefs: []
  type: TYPE_NORMAL
- en: 'Statements can be easily wrapped within round, square or curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: repeat_text('Hello world', 3)repeat_text('Hello World',3)
  prefs: []
  type: TYPE_NORMAL
- en: We could also display the function call from our example above in two lines.
    However, it is not allowed to break within the string **'Hello world'**! Indentations
    are not regulated here, so you can indent as you like, which can greatly improve
    the readability of the program code.
  prefs: []
  type: TYPE_NORMAL
- en: 'But you can also break statements outside of round, square and curly brackets
    by placing a backslash (**\**) at the end of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: x = \'Hello World'print(x)
  prefs: []
  type: TYPE_NORMAL
- en: However, this method is frowned upon and should only be used when absolutely
    necessary. Mostly, the line breaks are necessary for function calls with many
    function arguments, and there you are inside round brackets anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'A final type of wrapped statement is the *docstrings* or, more generally, strings
    enclosed in triple quotes (we will deal with docstrings in more detail in ► Sect.
    [20.3](#Sec6)). These can run over several lines:'
  prefs: []
  type: TYPE_NORMAL
- en: x = '''This is a very long text which does not fit in one line and therefore
    must be spread over several lines.'''
  prefs: []
  type: TYPE_NORMAL
- en: 'A “normal” string cannot do that. If we let a string run past the end of the
    line, the Python interpreter assumes we forgot to terminate the string, and this
    leads to an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SyntaxError: EOL while scanning string literal**'
  prefs: []
  type: TYPE_NORMAL
- en: 20.1.3 Case Sensitivity and Choice of Identifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python is case-sensitive, which means that case is generally distinguished.
    Thus, a variable named **age** is completely different from the variable **AGE**.
    Of course, case-sensitivity applies not only to variables, but also to the identifiers
    of functions and methods, classes, modules, and packages.
  prefs: []
  type: TYPE_NORMAL
- en: Identifiers of all these elements can consist of letters, digits and the *underscore*
    (**_**). However, they must never begin with a digit. **customer_age** is therefore
    a permissible variable name, **take2** and **_2times4** as well, but not **11friends**.
    Identifiers that start and/or end with an underscore (or two underscores) have
    a special meaning in Python, which we will discuss in more detail later. It is
    recommended to generally avoid identifiers that start or end with underscores,
    and to use the underscore only *within* identifiers, unless you intend one of
    the effects associated with leading or trailing underscores.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from these few rules, you are free to choose your identifiers. However,
    there are some conventions that many Python programmers adhere to, although violating
    these rules does not lead to syntax errors in the program code. Adherence to these
    rules makes your code look more "pythonic". For example, class names or their
    components usually start with uppercase letters (so, for example, **MyClass**),
    module names with lowercase letters (for example, **myModule**), variables and
    functions/methods usually with lowercase letters, with different components regularly
    separated with underscores (for example, **my_variable**, **my_function**).
  prefs: []
  type: TYPE_NORMAL
- en: You could even use special characters like umlauts in your identifiers, by the
    way. Python supports the extensive UTF-8 character set, which allows this. However,
    such identifiers are not recommended. At the least, code exchange with developers
    whose native language (and keyboards!) don’t know these characters is made much
    more difficult. It is best to stick to identifiers that can easily be typed on
    a standard English keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you don’t have to follow all these non-binding conventions. But if
    you do, your code will look more “Python” and other developers will get along
    better with your code, not least because they can concentrate on the meaning and
    functionality of the code and not regularly get “stuck” on the style of the identifiers
    they are not used to.
  prefs: []
  type: TYPE_NORMAL
- en: 20.2 Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Comments, as you already know, are parts of the program code that are simply
    ignored by the interpreter and that you can use to leave notes and explanations
    for yourself or for others reading your program code. Such comments are introduced
    with the hash sign (**#**). Everything to the right of it is considered a comment.
    The comment symbol does not necessarily have to be at the very beginning of a
    line. In the following example you see both variants, once at the beginning of
    the line, once further to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '*# Our first little Python program*print(''Hello world'')*# Output on the screen*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The comments that start somewhere in the middle of the line are also called
    *inline comments*. They are not welcome in Python, nor in most, if not all programming
    languages, because they make the code a bit more difficult to read. If you use
    them, you should make sure that there are some (officially recommended: two) spaces
    between the end of the actual code line and the comment symbol.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can also use comments to temporarily “turn off” program code
    by removing it from the access of the interpreter, which ignores everything to
    the right of the comment character. It makes sense to speak of *commenting out*
    in this context. This is exactly what happened with the second print statement
    in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*# Our first little Python program*print(''Hello World'')*# print(''Hello,
    world'')*'
  prefs: []
  type: TYPE_NORMAL
- en: Comments always extend to the end of the line; Python does not know multiline
    comments in principle. So, if you want to write over several lines—and you will
    from time to time, because your comments should be fully readable on a normal
    screen even without scrolling horizontally (officially recommended are at most
    79 characters per line)—you have to preface each line with an extra comment symbol.
    Many development environments do the work for you here, though. If you’re working
    with *PyCharm*, you can highlight the lines you want to comment out, then click
    the "Comment With Line Comment" option in the Code menu (or alternatively press
    the <CTRL> and </> key combination) and PyCharm will add a comment symbol to the
    beginning of each of the selected code lines. You can also use the same option
    to remove the comment symbols from commented lines. Apart from that, there is
    also a trick you can use to create something like a true multi-line comment. More
    about this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sense and nonsense of comments can be philosophized and argued about, especially
    regarding the question about when comments are helpful and when they just make
    the code more extensive and thus less clear. Go back a few pages to ► Sect. [10.​3](474412_1_En_10_Chapter.xhtml#Sec3),
    where we learned about a number of best practices for commenting program code.
    As a rule of thumb we can state: There is usually not enough commenting, so feel
    free to write comments; your “future self” who tries to understand your old code
    will thank you!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you also use comments to document open tasks directly at the appropriate
    place in the program code. If you work with *PyCharm,* you can preface such comments
    with ***# TODO***:'
  prefs: []
  type: TYPE_NORMAL
- en: '*# TODO: Add more languages here*print(''Hello World'')print(''Hallo Welt'')Similarly,
    you can mark and explain small errors that still need to be fixed at the appropriate
    code location with ***# FIXME.*** Comments that start like this are specially
    highlighted as part of syntax highlighting and are treated specially by *PyCharm.
    PyCharm* displays these kinds of comments in a special sidebar pane called “TODO”
    as seen in ◘ Fig. [20.2](#Fig2). All ***TODO*** and ***FIXME*** comments are displayed
    there; double-clicking on an entry in the TODO area will take you directly to
    the corresponding place in the code. If you can''t see the TODO pane, click the
    three dots in the sidebar to see areas that are currently hidden.![](../images/474412_1_En_20_Chapter/474412_1_En_20_Fig2_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a set of 9-line hello world program code in the Python project.
    The Todo pane displays the comments at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 20.2
  prefs: []
  type: TYPE_NORMAL
- en: The TODO pane in *PyCharm*
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can also define your own comment types analogous to ***# TODO***
    and ***# FIXME*** via *PyCharm*’s settings. In the vast majority of cases, however,
    the two special comment types mentioned above should suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 20.3 Documentation with Docstrings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the “real” comments, which are always introduced with the comment
    symbol **#**, there is a second possibility to store information in the code that
    is not executed by the interpreter, namely with the help of so-called *docstrings*.
    Docstrings are special strings written between triple quotes. Consider the following
    program as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '''''''This is a docstring for our hello world program, namelyone that even
    spans several lines.''''''print(''Hello world!'')'
  prefs: []
  type: TYPE_NORMAL
- en: If you run this program, you will get the output **Hello world!** The docstring,
    on the other hand, is not displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try something else: This time we don’t use a docstring with three quotes,
    but a whole ordinary string, similar to **''Hello world!''**, which we output
    below. Unlike docstrings, ordinary strings in Python can’t span multiple lines
    in program code, so we’ve put our ‘comment’ on one line. Now what happens when
    you run this program? Nothing changes! Again, only **''Hello world!''** is output.
    The reason is quite simple: whenever you write text into your Python program code,
    as we did first with the docstring and then with a normal string, this does not
    result in any output on the screen. Instead, the text is simply ignored (not technically
    true, but at least there is no visible effect). The same goes for variables, as
    you’ll see in the next chapter. If we simply enter the name of a variable into
    our program code without any further instruction, nothing happens at all. To display
    the contents of the variable, or just our text from the example above, we must
    explicitly tell Python to output it. We do this by calling the **print()** function.
    It is different in the console. If you enter the name of a variable there and
    press <ENTER>, the contents are displayed. If you enter a string in the console,
    the string is immediately displayed again in the console.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, like all other strings, docstrings, if they are in the program code without
    any other instruction, will not be displayed on the screen. If this is so, can’t
    we just use normal strings to explain our code? Yes, that would work. However,
    docstrings have two special properties that make them particularly suitable for
    *documenting* program code, as their name suggests: First, they can span several
    lines: We’ve already seen that. Second, Python treats these docstrings in a special
    way. If they are at the beginning of a function, class definition, or module,
    they are used as the contents of the help for that function, class, or module.
    If you call the **help()** function (for example, for **print()**: **help(print))**,
    you will see the docstring that is stored at the beginning of the respective program
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous Python tools that process these docstrings and output them
    in the form of documentation. Python’s own help uses a tool called *pydoc*, which
    extracts the docstring from the code and displays it when **help()** is called.
    In addition, there are several other utilities that work with docstrings, for
    example autodoc*, doxygen*, and *pydoctor*. Some of these programs are specifically
    designed for Python, others allow the automatic generation of code documentation
    for different programming languages. The output of this documentation does not
    have to be just text in the Python console. Quite a few tools also support the
    generation of HTML, PDF or even LaTex documents. To structure the documentation
    cleanly, some tools require a special structure of the docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, clever minds have long since considered the question of what docstrings
    in general should look like. The official answer to this question can be found
    in the *Python Enhancement Proposals* (PEP) as PEP 257 (*Docstring Conventions*).
  prefs: []
  type: TYPE_NORMAL
- en: Unlike comments, docstrings are used more to document code *for other users,*
    that is, to explain how to *use* the code for your own purposes, and less to make
    notes about how the code *works*. That’s what comments are usually used for. We
    will come back to docstrings in some later places and use them in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: We will also take a closer look at another type of documentation later. These
    are the *function annotations*, which allow you to document the expected data
    types of function arguments, as well as the data types of the return values of
    functions in the program code. The annotations are also used by *pydoc* for help
    and can also be processed by other documentation tools.
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings and function annotations are often aimed at an audience other than
    yourself, namely the *users of* your code. When writing Python code to be used
    by other developers, it is important to document what, for example, functions
    do, what their arguments mean, and what return values the developer using your
    code can expect. He doesn’t want to have to read your code to find out this information.
    That’s why it’s important to provide documentation that allows third parties (if
    that’s provided) to use your program code “blindly” and view its inner workings
    like a black box. Relevant for the users of your code is only the *interface*,
    i.e., how to use it, not how it works in detail. Docstrings and function annotations
    are suitable tools for this.
  prefs: []
  type: TYPE_NORMAL
- en: 20.4 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we have looked at the special features of Python when it comes
    to formatting the program code, how identifiers (for example, the variables and
    functions/methods) may/must be structured, and how you can comment and document
    your program code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should definitely take away the following points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, indentations mark a coherent block of code and can therefore not
    be used arbitrarily; Python already “enforces” an easily readable formatting of
    the program code, so to speak.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements usually end at the end of a line in Python, no special delimiter
    is needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements can go over several lines if the line break is inside round, square,
    or curly brackets, or is specially marked by the backslash (\), although the latter
    type of line break is rather rare.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several statements can be separated by semicolons on a single line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python is case-sensitive when defining variables or identifiers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifiers are allowed to consist of letters, numbers, and the underscore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike digits, letters and underscores may also appear at the beginning of an
    identifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since single and double underscores at the beginning (and also at the end) of
    identifiers have a special meaning, identifiers beginning with underscores should
    generally be avoided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifiers of variables and functions/methods are usually written in lowercase
    in Python, and their components, if they are compound terms, are separated from
    each other with underscores.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments explaining the code are always single line in Python and are introduced
    with the comment symbol **#**; anything to the right of this is not interpreted
    as program code but is ignored by the interpreter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docstrings, which are enclosed in triple quotes, are used in Python to provide
    documentation for users of the code; they are the essential part of Python help,
    which can be called via **help()**, and are further processed into various formats
    of documentation by numerous developer tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docstrings can span multiple lines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
