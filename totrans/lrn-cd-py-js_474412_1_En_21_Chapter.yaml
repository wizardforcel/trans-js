- en: © 作者，独家授权`Springer Fachmedien Wiesbaden GmbH`，`Springer Nature`的一部分 2024`J.
    L. Zuckarelli`学习使用`Python`和`JavaScript` [https://doi.org/10.1007/978-3-658-42912-6_21](https://doi.org/10.1007/978-3-658-42912-6_21)
  id: totrans-0
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: © 作者，独家授权`Springer Fachmedien Wiesbaden GmbH`，`Springer Nature`的一部分 2024`J.
    L. Zuckarelli`学习使用`Python`和`JavaScript` [https://doi.org/10.1007/978-3-658-42912-6_21](https://doi.org/10.1007/978-3-658-42912-6_21)
- en: 21. 变量与对象：如何存储数据以便使用？
  id: totrans-1
  prefs:
  - PREF_H1
  stylish: true
  type: TYPE_NORMAL
  zh: 21. 变量与对象：如何存储数据以便使用？
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1)`München`, `Germany`Overview
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: Joachim L. Zuckarelli^([1](#Aff2) )(1)`München`, `Germany`概览
- en: 在本章中，我们将把重点转向在`Python`中处理变量。此外，我们还将探讨如何将各种变量聚合到类列表的结构（数组）中，并在哈希（字典）中映射键值对。鉴于`Python`的面向对象特性，所有变量都是具有属性和方法的对象，我们的讨论将超越仅仅创建、赋值和在不同数据类型之间转换变量。我们将深入探讨`Python`的面向对象实现，并演示您如何利用面向对象编程在`Python`中为您的项目带来益处。
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在本章中，我们将把重点转向在`Python`中处理变量。此外，我们还将探讨如何将各种变量聚合到类列表的结构（数组）中，并在哈希（字典）中映射键值对。鉴于`Python`的面向对象特性，所有变量都是具有属性和方法的对象，我们的讨论将超越仅仅创建、赋值和在不同数据类型之间转换变量。我们将深入探讨`Python`的面向对象实现，并演示您如何利用面向对象编程在`Python`中为您的项目带来益处。
- en: 在本章中，您将学习：
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: 如何在`Python`中创建变量并为其赋值
  id: totrans-5
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何在`Python`中创建变量并为其赋值
- en: 变量的基本类型有哪些，如何使用它们
  id: totrans-6
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 变量的基本类型有哪些，如何使用它们
- en: 变量的对象特性表达了什么，以及这对您在变量的实际工作中意味着什么
  id: totrans-7
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 变量的对象特性表达了什么，以及这对您在变量的实际工作中意味着什么
- en: 如何将变量从一种数据类型转换为另一种数据类型，以及`Python`何时自动为您进行转换
  id: totrans-8
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何将变量从一种数据类型转换为另一种数据类型，以及`Python`何时自动为您进行转换
- en: 存在更复杂的数据类型（例如，列表和字典），以及如何使用它们
  id: totrans-9
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 存在更复杂的数据类型（例如，列表和字典），以及如何使用它们
- en: 如何在`Python`中定义类，如何自己定义和使用对象类
  id: totrans-10
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 如何在`Python`中定义类，如何自己定义和使用对象类
- en: 21.1 创建和赋值变量
  id: totrans-11
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 21.1 创建和赋值变量
- en: 与其他一些语言不同，在`Python`中创建变量是相当简单的。这是因为变量在`Python`中不需要声明；它们在首次使用时会自动创建。因此，赋值
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与其他一些语言不同，在`Python`中创建变量是相当简单的。这是因为变量在`Python`中不需要声明；它们在首次使用时会自动创建。因此，赋值
- en: '`>>>` `x = 5`创建了一个（整数）变量并将其值设置为`5`（`>>>`是提示字符，提示您输入，因此您不需要输入这个！）'
  id: totrans-13
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `x = 5`创建了一个（整数）变量并将其值设置为`5`（`>>>`是提示字符，提示您输入，因此您不需要输入这个！）'
- en: 我们在这里简单地将变量命名为`x`。在►章节[11](474412_1_En_11_Chapter.xhtml)，我们说变量名应该是有意义的，并允许代码的阅读者猜测变量将包含什么样的内容。尽管在这些例子中我们将其简化，`Python`仍然为您提供了使用有意义的变量名的每一个机会。正如您从►节[20.​1.​3](474412_1_En_20_Chapter.xhtml#Sec4)中已知，`Python`中的名称可以由大小写字母、数字和下划线字符组成。数字不允许出现在变量名的开头，但可以在名称的其他地方使用。此外，名称开头（有时结尾）带下划线在`Python`中有特殊含义，我们将在后面讨论。因此，不建议以下划线开头或结尾命名变量。除此之外，您可以完全自由地命名您的变量。
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们在这里简单地将变量命名为`x`。在►章节[11](474412_1_En_11_Chapter.xhtml)，我们说变量名应该是有意义的，并允许代码的阅读者猜测变量将包含什么样的内容。尽管在这些例子中我们将其简化，`Python`仍然为您提供了使用有意义的变量名的每一个机会。正如您从►节[20.​1.​3](474412_1_En_20_Chapter.xhtml#Sec4)中已知，`Python`中的名称可以由大小写字母、数字和下划线字符组成。数字不允许出现在变量名的开头，但可以在名称的其他地方使用。此外，名称开头（有时结尾）带下划线在`Python`中有特殊含义，我们将在后面讨论。因此，不建议以下划线开头或结尾命名变量。除此之外，您可以完全自由地命名您的变量。
- en: '`Python`决定变量应该具有什么类型。在变量的生命周期内，类型可能会改变，例如，通过将不同类型的数据分配给变量。'
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Python`决定变量应该具有什么类型。在变量的生命周期内，类型可能会改变，例如，通过将不同类型的数据分配给变量。'
- en: '`>>> x = ''A string (str) variable''`不仅值发生了变化，变量的数据类型也发生了变化，现在它是一个字符串变量。在下一节中，当我们查看变量的对象特性时，您将学习到在`Python`中创建变量的第二种方法，除了赋值以外。'
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> x = ''A string (str) variable''`不仅值发生了变化，变量的数据类型也发生了变化，现在它是一个字符串变量。在下一节中，当我们查看变量的对象特性时，您将学习到在`Python`中创建变量的第二种方法，除了赋值以外。'
- en: 如果您在`Python`控制台中工作，可以随时通过输入变量的名称来显示变量的值。
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果您在`Python`控制台中工作，可以随时通过输入变量的名称来显示变量的值。
- en: '`>>> x` `''A string (str) variable''`如果您在`Python`脚本中编写代码，则必须使用`print()`函数，您在上一章中已学习过，来打印变量的内容：`print(x)`'
  id: totrans-18
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> x` `''A string (str) variable''`如果您在`Python`脚本中编写代码，则必须使用`print()`函数，您在上一章中已学习过，来打印变量的内容：`print(x)`'
- en: 如果您在`Python`程序中仅写变量名，则没有输出。
  id: totrans-19
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果您在`Python`程序中仅写变量名，则没有输出。
- en: 顺便提一下，您不能在控制台中访问您在程序中创建的变量。控制台的命名空间和您程序的命名空间是分开的。如果您在控制台中使用一个您在程序中创建的变量，您将收到一个错误信息（当然，除非您已经通过控制台创建了一个同名变量——但那样您也会使用这个变量，而不是您在程序中使用的那个变量）。
  id: totrans-20
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 顺便提一下，您不能在控制台中访问您在程序中创建的变量。控制台的命名空间和您程序的命名空间是分开的。如果您在控制台中使用一个您在程序中创建的变量，您将收到一个错误信息（当然，除非您已经通过控制台创建了一个同名变量——但那样您也会使用这个变量，而不是您在程序中使用的那个变量）。
- en: 有时您会意外访问一个不存在的变量，例如因为您输入了错误的标识符。然后，您将收到如下错误信息：
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 有时您会意外访问一个不存在的变量，例如因为您输入了错误的标识符。然后，您将收到如下错误信息：
- en: '`Traceback (most recent call last):` `File "D:\Applications\Anaconda\lib\site-packages\IPython\core\interactiveshell.py",
    line 2961, in run_code` `exec(code_obj, self.user_global_ns, self.user_ns)` `File
    "<ipython-input-16-9063a9f0e032>", line 1, in <module>` `y` `NameError: name ''y''
    is not defined`'
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Traceback (most recent call last):` `File "D:\Applications\Anaconda\lib\site-packages\IPython\core\interactiveshell.py",
    line 2961, in run_code` `exec(code_obj, self.user_global_ns, self.user_ns)` `File
    "<ipython-input-16-9063a9f0e032>", line 1, in <module>` `y` `NameError: name ''y''
    is not defined`'
- en: 这里关键的是最后一行。它告诉我们一个名为`y`的变量，在这里我们尝试访问它，但它根本不存在。
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里关键的是最后一行。它告诉我们一个名为`y`的变量，在这里我们尝试访问它，但它根本不存在。
- en: 21.2 删除变量
  id: totrans-24
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 21.2 删除变量
- en: 一旦创建，变量可以使用`del`命令再次删除。这是有意义的，特别是如果变量占用了大量内存（例如，如果您已经完全读取了一个大文件），并且在您不再需要数据后希望释放内存。
  id: totrans-25
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一旦创建，变量可以使用`del`命令再次删除。这是有意义的，特别是如果变量占用了大量内存（例如，如果您已经完全读取了一个大文件），并且在您不再需要数据后希望释放内存。
- en: 如果您在`Python`控制台中删除一个变量，然后尝试访问它，您将收到一个错误信息：
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果您在`Python`控制台中删除一个变量，然后尝试访问它，您将收到一个错误信息：
- en: '`>>> del x` `>>> x` `Traceback (most recent call last):` `File "<input>", line
    1, in <module>` `NameError: name ''x'' is not defined`'
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> del x` `>>> x` `Traceback (most recent call last):` `File "<input>", line
    1, in <module>` `NameError: name ''x'' is not defined`'
- en: The error message talks about the `name` `x` not being defined. Like many other
    programming languages, Python makes a clear distinction between the value of the
    variable and its name. The name is just a reference to the value, which is located
    in a certain area of memory. In principle, the name and value exist independently
    of each other. Now, it could be that several names refer to exactly the same value,
    that is, to the same location in memory. If the value stored in the memory in
    question changes, the values of all these variables also change accordingly. In
    such a situation with multiple names all pointing to the same memory location,
    if you delete one name, the value and the other names (and therefore variables)
    are preserved. You can then simply no longer address the value under the deleted
    name, but only under the remaining names.
  id: totrans-28
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 错误信息提到`名称` `x`未定义。像许多其他编程语言一样，Python明确区分变量的值和它的名称。名称仅是对值的引用，值存储在内存的某个区域。原则上，名称和值是独立存在的。现在，可能有多个名称指向完全相同的值，也就是说，指向内存中的相同位置。如果该内存位置中的值发生了变化，那么所有这些变量的值也会相应地发生变化。在这种多个名称指向同一内存位置的情况下，如果删除了其中一个名称，值和其他名称（因此也包括变量）将被保留。然后，你将不能再通过被删除的名称来访问该值，只能通过剩余的名称来访问。
- en: Python counts the names that point to a value (the result is called the `reference
    counter`). If there is no more name pointing to a certain value, Python deletes
    the value itself. This process is called `garbage collection`. However, since
    there will usually be only one name that has a `binding to` the value of your
    variable, when you call the `del` command, the value itself is usually also deleted
    and the memory in question is freed.
  id: totrans-29
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: Python会计算指向某个值的名称（结果称为`引用计数`）。如果没有名称再指向某个值，Python会删除该值本身。这个过程称为`垃圾回收`。然而，由于通常只有一个名称与变量的值`绑定`，当你调用`del`命令时，该值本身通常也会被删除，相关的内存也会被释放。
- en: '`21.3 Basic Types of Variables`'
  id: totrans-30
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`21.3 变量的基本类型`'
- en: In this section we deal with the most important types of variables. We will
    first concentrate on variables that contain only one value. In the following section,
    we will look at more complex data types that can hold multiple values at the same
    time.
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 本节我们讨论最重要的几种变量类型。我们首先集中讨论只包含一个值的变量。在接下来的章节中，我们将讨论可以同时容纳多个值的更复杂的数据类型。
- en: '`21.3.1 Numbers (int, float)`'
  id: totrans-32
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`21.3.1 数字（int, float）`'
- en: Numbers in Python come in the form of integers (`int`) or floating-point numbers
    (`float`). Unlike many other programming languages, `int` variables in Python
    do not have a fixed range of values beyond which another data type that takes
    up more memory must be chosen. Python simply reserves as much memory for the variable
    as is needed to hold the value it contains.
  id: totrans-33
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: Python中的数字有整数（`int`）或浮动小数（`float`）两种形式。与许多其他编程语言不同，Python中的`int`变量没有固定的值范围，超过这个范围就必须选择一个占用更多内存的数据类型。Python会根据变量所包含的值需要的内存量来为变量保留足够的内存空间。
- en: 'You can see this very nicely by looking at the size of the variables using
    the `sys.getsizeof(object)` function:'
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以通过使用`sys.getsizeof(object)`函数查看变量的大小，从而很清楚地看到这一点：
- en: '`>>> x = 5 >>> sys.sizeof(x) 14 >>> x = 1000000000000 18`'
  id: totrans-35
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> x = 5 >>> sys.sizeof(x) 14 >>> x = 1000000000000 18`'
- en: As you can see, the memory requirement has increased from the original `14`
    bytes to `18` bytes after we assigned a significantly larger value, one trillion,
    to the variable instead of `5`.
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如你所见，在我们将一个显著更大的值——一万亿，赋给变量而不是`5`之后，内存需求从原来的`14`字节增加到了`18`字节。
- en: You may wonder why even a small value like `5` still requires `14` bytes in
    memory. In many other programming languages such a variable would have the size
    of only `2` bytes (= `16` bits). This can represent numbers between `0` and `2^(16)
    = 65,536`. So why is Python such a “memory hog”? The answer has to do with the
    way Python stores variables and will be discussed in the following section.
  id: totrans-37
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可能会想，为什么即使是像`5`这样的小值仍然需要`14`字节的内存。在许多其他编程语言中，类似的变量仅需要`2`字节（= `16`位）。这可以表示从`0`到`2^(16)
    = 65,536`之间的数字。那么为什么Python会如此“占内存”？答案与Python存储变量的方式有关，下面的章节会进行讨论。
- en: 'The decimal separator for floating point numbers is the period, as is customary
    in English. The biggest problem with this in Python is that if you habitually
    use the comma instead of the period (as it is common in many European and South
    American countries), you don’t get an error message:'
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 浮点数的小数分隔符是句点，这在英语中是习惯用法。在Python中，最大的问题是，如果你习惯用逗号而不是句点（在许多欧洲和南美国家很常见），你不会收到错误提示：
- en: '`>>>` `pi = 3.1415926535` `>>>` `pi(3, 1415926535)`'
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `pi = 3.1415926535` `>>>` `pi(3, 1415926535)`'
- en: Python misinterpreted our input and created a variable of a completely different
    type, namely a `tuple` . We will deal with these tuples in more detail a little
    later in this chapter.
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: Python误解了我们的输入，并创建了一个完全不同类型的变量，即`tuple`。稍后在本章中我们会更详细地讲解这些元组。
- en: '`21.3.2 Strings (str)`'
  id: totrans-41
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`21.3.2 字符串（str）`'
- en: 'Strings, variables of type `str` , can be enclosed in Python in either single
    or double quotes:'
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 字符串，类型为`str`的变量，可以在Python中用单引号或双引号括起来：
- en: '`>>>` `x = "A text in double quotes."` `>>>` `x` `''A text in double quotes.''`
    `>>>` `y = ''A text in single quotes.''` `>>>` `y` `''A text in single quotes.''`'
  id: totrans-43
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `x = "这是一个双引号中的文本。"` `>>>` `x` `''这是一个双引号中的文本。''` `>>>` `y = ''这是一个单引号中的文本。''`
    `>>>` `y` `''这是一个单引号中的文本。''`'
- en: 'The advantage of being able to use both types of quotation marks is that in
    Python you have no difficulty in displaying quotation marks within a text, because
    the two different variants of quotation marks mean that there is no danger of
    confusion between the quotation marks that are part of the text and those that
    delimit the string at the front and back:'
  id: totrans-44
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 能够使用两种类型的引号的优势在于，在Python中你可以轻松地在文本中显示引号，因为这两种不同的引号变体可以避免混淆文本中的引号和用于界定字符串的引号：
- en: '`>>>` `quote = ''Hamlet said, "To be or not to be. That is the question here!"''`
    `>>>` `quote` `''Hamlet said, "To be or not to be. That is the question here!"''`'
  id: totrans-45
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `quote = ''哈姆雷特说：“生存还是毁灭，这是个问题！”''` `>>>` `quote` `''哈姆雷特说：“生存还是毁灭，这是个问题！”''`'
- en: 'As you will have noticed, Python automatically encloses the output of the variable’s
    contents in (single) quotes to make it clear that this is a string. The following
    example shows that this is a practical feature:'
  id: totrans-46
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 正如你所注意到的，Python自动将变量内容的输出括在（单）引号中，以明确表示这是一个字符串。以下示例展示了这一功能的实用性：
- en: '`>>>` `x = ''5''` `>>>` `x` `''5''` `>>>` `x = 5` `>>>` `x` `5`'
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `x = ''5''` `>>>` `x` `''5''` `>>>` `x = 5` `>>>` `x` `5`'
- en: In the first assignment, the content of the variable is a string, in the second
    case it is a number, which could now be used in a calculation.
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在第一次赋值中，变量的内容是一个字符串，在第二次赋值中，它是一个数字，之后可以用在计算中。
- en: 'In Python, it is very easy to create strings that go over multiple lines. To
    do this, simply enclose the text in triple quotes:'
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在Python中，创建跨越多行的字符串非常容易。只需将文本括在三引号中：
- en: '`z = """The text starts on the first lineand continues on the second line."""`
    `print(z)` This program results in the following output: The text begins on the
    first line and continues on the second line.'
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`z = """文本从第一行开始，继续到第二行。"""` `print(z)` 该程序的输出结果如下：文本从第一行开始，继续到第二行。'
- en: In fact, the line break is preserved in the output. You can use this feature
    not only when you are working in script mode, i.e., writing a program to execute
    it afterwards. Even in interactive mode, Python recognizes after pressing the
    `<ENTER>` key that you have started a multiline string here, and therefore waits
    with the execution of the statement (which is, after all, normally triggered with
    `<ENTER>`) and allows you to continue writing on the next line instead.
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 事实上，换行符在输出中被保留。你不仅可以在脚本模式下使用此功能，即编写程序后再执行，甚至在交互模式下，Python会在你按下`<ENTER>`键后识别出你已经开始编写多行字符串，因此会等待语句的执行（通常是按`<ENTER>`触发），并允许你继续在下一行书写。
- en: You have already become acquainted with this type of string as `docstrings`
    in the previous chapter. Docstrings are placed in your program code as documentation,
    but not with the intention of being further processed or output to the screen
    for the end user of the program.
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上一章中，你已经接触过这种类型的字符串，称为`docstrings`。文档字符串用于作为程序代码中的文档，但并不是为了进一步处理或输出到程序的最终用户屏幕。
- en: 有时您希望在程序代码中包装字符串，而这种包装在输出字符串时不可见；关键是要使程序代码更清晰（记得从► Sect. [20.​1.​1](474412_1_En_20_Chapter.xhtml#Sec2)！推荐的每行79个字符的限制！）。在这种情况下，您可以使用反斜杠（`\\`）：
  id: totrans-53
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 有时你希望在程序代码中包装字符串，而这种包装在输出时不可见；关键是使程序代码更加清晰（记得遵守► Sect. [20.​1.​1](474412_1_En_20_Chapter.xhtml#Sec2)！推荐的每行79个字符限制！）。在这种情况下，你可以使用反斜杠（`\\`）：
- en: '`message = ''Hello '' \''world''` `print(message)`'
  id: totrans-54
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`message = ''Hello '' \''world''` `print(message)`'
- en: 这段代码生成的输出为：
  id: totrans-55
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这段代码生成的输出为：
- en: '`Hello world`'
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Hello world`'
- en: 这意味着并不是有两行不同的字符串，而只是一个字符串，出于实际原因在代码中分布在两行上。
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这意味着并不是有两行不同的字符串，而只是一个字符串，出于实际原因在代码中分布在两行上。
- en: '`21.3.3 Truth Values (bool)`'
  id: totrans-58
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`21.3.3 真值（bool）`'
- en: 真值或逻辑值`true`和`false`在`Python`中使用数据类型`bool`表示，`bool`是对19世纪英语数学家和逻辑学家乔治·布尔的致敬，他在形式逻辑的发展中做出了重要贡献。
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 真值或逻辑值`true`和`false`在`Python`中使用数据类型`bool`表示，`bool`是对19世纪英语数学家和逻辑学家乔治·布尔的致敬，他在形式逻辑的发展中做出了重要贡献。
- en: 与其他变量类型不同，类型为`bool`的变量只能取两个值：`True`和`False`。请注意大小写！常量`True`和`False`必须以大写字母书写。如果我们写成`false`，`Python`会认为我们想使用一个名为`false`的变量，而这个变量当然不存在：
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与其他变量类型不同，类型为`bool`的变量只能取两个值：`True`和`False`。请注意大小写！常量`True`和`False`必须以大写字母书写。如果我们写成`false`，`Python`会认为我们想使用一个名为`false`的变量，而这个变量当然不存在：
- en: '`>>> x = false` `Traceback (most recent call last):` `File "<input>", line
    1, in <module>` `NameError: name ''false'' is not defined` `>>> x = False` `>>>
    x` `False`'
  id: totrans-61
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> x = false` `Traceback (most recent call last):` `File "<input>", line
    1, in <module>` `NameError: name ''false'' is not defined` `>>> x = False` `>>>
    x` `False`'
- en: 此外，不要使用引号，因为它们会使变量成为`str`变量：
  id: totrans-62
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 此外，不要使用引号，因为它们会使变量成为`str`变量：
- en: '`>>> x = ''False''` `>>> x` `''False''` `>>> type(x)` `<class ''str''>` `>>>
    x = False` `>>> x` `False` `>>> type(x)` `<class ''bool''>`'
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> x = ''False''` `>>> x` `''False''` `>>> type(x)` `<class ''str''>` `>>>
    x = False` `>>> x` `False` `>>> type(x)` `<class ''bool''>`'
- en: '`Python`内部将值`True`和`False`存储为`0`和`1`，因此您可以像对待普通数字一样对它们进行计算：'
  id: totrans-64
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Python`内部将值`True`和`False`存储为`0`和`1`，因此您可以像对待普通数字一样对它们进行计算：'
- en: '`>>> x = 5 * True` `>>> x` `5`'
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> x = 5 * True` `>>> x` `5`'
- en: '`21.3.4 None`'
  id: totrans-66
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`21.3.4 None`'
- en: 一种特殊的数据类型是`NoneType`。您不能创建自己的这种类型的变量。相反，`Python`已经为您创建了一个类型为`NoneType`的对象，即`None`（多么有创意！）。这允许您将值`None`赋给一个变量，这意味着该变量当前没有真正有意义的值：
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 一种特殊的数据类型是`NoneType`。您不能创建自己的这种类型的变量。相反，`Python`已经为您创建了一个类型为`NoneType`的对象，即`None`（多么有创意！）。这允许您将值`None`赋给一个变量，这意味着该变量当前没有真正有意义的值：
- en: '`>>> x = None` `>>> x` `None` `>>> type(x)` `<class ''NoneType''>`'
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> x = None` `>>> x` `None` `>>> type(x)` `<class ''NoneType''>`'
- en: But isn’t that a bit awkward? Couldn’t we just assign the variable the value
    `0` if the variable is a number, or `''`，即一个空字符串，如果它是一个字符串？当然，我们确实可以这样做，但前提是`0`或`''`在内容上没有实际意义。然而，当你测量温度时，例如，或者在一个从−5到+5的范围内调查一个人对某个话题的态度时，值`0`确实可以具有其自身的真实意义。在这种情况下，受访者给出了值`0`，从而表示对该话题的中立态度，还是根本没有回答问题（`None`），这之间是有区别的。为了使这种区别显而易见，使用一个特殊的指示符来表示“没有真实值存在”是有意义的，而这正是`None`值的作用。
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 但这不是有点尴尬吗？如果变量是数字，我们不可以直接赋值为`0`，或者如果它是字符串的话，赋值为`''`（即一个空字符串）吗？当然，我们可以这样做，但前提是`0`或`''`在内容上没有实际意义。然而，当你测量温度时，例如，或者在一个从−5到+5的范围内调查一个人对某个话题的态度时，值`0`确实可以具有其自身的真实意义。在这种情况下，受访者给出了值`0`，从而表示对该话题的中立态度，还是根本没有回答问题（`None`），这之间是有区别的。为了使这种区别显而易见，使用一个特殊的指示符来表示“没有真实值存在”是有意义的，而这正是`None`值的作用。
- en: 顺便说一下，你不能用`None`进行计算：
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 顺便说一下，你不能用`None`进行计算：
- en: '`>>> None + 1 Traceback (most recent call last): File "<input>", line 1, in
    <module> TypeError: unsupported operand type(s) for +: ''NoneType'' and ''int''.`'
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> None + 1 Traceback (most recent call last): File "<input>", line 1, in
    <module> TypeError: unsupported operand type(s) for +: ''NoneType'' and ''int''.`'
- en: 如果`None`被作为逻辑表达式进行评估，它被视为`False`。所以，`None`确实没有其他任何用途，除了表明变量不包含真实值。
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果`None`被作为逻辑表达式进行评估，它被视为`False`。所以，`None`确实没有其他任何用途，除了表明变量不包含真实值。
- en: 21.3.5 其他数据类型
  id: totrans-73
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 21.3.5 其他数据类型
- en: 除了到目前为止讨论的数据类型外，Python本身还知道几种其他数据类型，例如`complex`，这是一种用于表示数学中已知的复数的数据类型，复数由实部和虚部组成。
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 除了到目前为止讨论的数据类型外，Python本身还知道几种其他数据类型，例如`complex`，这是一种用于表示数学中已知的复数的数据类型，复数由实部和虚部组成。
- en: 各种不是标准语言一部分的包（程序库）也提供了自己的数据类型。一个例子是`NumPy`包，这是一个用于高效处理向量和矩阵的库，是在统计和机器学习方法中进行工作的重要基础，Python在这些领域找到了相当大的应用。
  id: totrans-75
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 各种不是标准语言一部分的包（程序库）也提供了自己的数据类型。一个例子是`NumPy`包，这是一个用于高效处理向量和矩阵的库，是在统计和机器学习方法中进行工作的重要基础，Python在这些领域找到了相当大的应用。
- en: '`NumPy`不仅提供了一些新的复杂数据类型，还有几种基本数据类型也可以使用。对于已经熟知的数据类型`int`和`float`，例如，`NumPy`有自己的替代品，其特征在于，它们在内存需求上并不随变量内容的变化而变化，正如Python中的标准数据类型那样，而是始终占用固定数量的内存字节。这允许在处理这样的变量时进行非常快速的计算，特别是在处理大量此类变量时，效率计算是一个重要的技能，尤其是在处理大量数据（如机器学习）时。'
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`NumPy`不仅提供了一些新的复杂数据类型，还有几种基本数据类型也可以使用。对于已经熟知的数据类型`int`和`float`，例如，`NumPy`有自己的替代品，其特征在于，它们在内存需求上并不随变量内容的变化而变化，正如Python中的标准数据类型那样，而是始终占用固定数量的内存字节。这允许在处理这样的变量时进行非常快速的计算，特别是在处理大量此类变量时，效率计算是一个重要的技能，尤其是在处理大量数据（如机器学习）时。'
- en: 然而，由于我们在大多数使用案例中可以使用到目前为止讨论的数据类型，我们就先到这里，接下来在下一节中更仔细地观察Python中变量的特性。
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，由于我们在大多数使用案例中可以使用到目前为止讨论的数据类型，我们就先到这里，接下来在下一节中更仔细地观察Python中变量的特性。
- en: 21.4 变量作为对象
  id: totrans-78
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 21.4 变量作为对象
- en: 21.4.1 变量的属性和方法
  id: totrans-79
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 21.4.1 变量的属性和方法
- en: Python受到面向对象编程范式的强烈影响。与一些其他也采用这种编程方法的编程语言（如`C++`）不同，在Python中，即使是最简单的变量也是对象。
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: Python受到面向对象编程范式的强烈影响。与一些其他也采用这种编程方法的编程语言（如`C++`）不同，在Python中，即使是最简单的变量也是对象。
- en: 在`Python`中，变量最终始终是一个`class`的具体实例，例如浮点数的类`float`。类`float`有一整套可以通过该类的具体实例，即变量对象访问的方法和属性。如果你对类和实例/对象的术语不再熟悉，只需翻回几页到►`Sect.
    [11.​7](474412_1_En_11_Chapter.xhtml#Sec10)`并在继续之前刷新你的知识！
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在`Python`中，变量最终始终是一个`class`的具体实例，例如浮点数的类`float`。类`float`有一整套可以通过该类的具体实例，即变量对象访问的方法和属性。如果你对类和实例/对象的术语不再熟悉，只需翻回几页到►`Sect.
    [11.​7](474412_1_En_11_Chapter.xhtml#Sec10)`并在继续之前刷新你的知识！
- en: 如果你在使用`PyCharm`时，在代码编辑器中输入你已经在程序中使用的变量名，后面跟着一个点，一个小的代码补全菜单会弹出，在这里你可以看到属于该变量类的方法和属性。你也可以在控制台中做同样的事情，输入一个你已经通过`Python`控制台赋值的变量，同样后面跟着一个点。
  id: totrans-82
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你在使用`PyCharm`时，在代码编辑器中输入你已经在程序中使用的变量名，后面跟着一个点，一个小的代码补全菜单会弹出，在这里你可以看到属于该变量类的方法和属性。你也可以在控制台中做同样的事情，输入一个你已经通过`Python`控制台赋值的变量，同样后面跟着一个点。
- en: '`The dot`是`Python`中的运算符，它允许你访问对象的方法和属性。因此，当你在变量名后输入一个点时，`PyCharm`期望你使用该变量的方法或属性，并显示相应的列表。你可以在◘`Fig.
    [21.1](#Fig1)`中看到这个示例。![](../images/474412_1_En_21_Chapter/474412_1_En_21_Fig1_HTML.jpg)'
  id: totrans-83
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`The dot`是`Python`中的运算符，它允许你访问对象的方法和属性。因此，当你在变量名后输入一个点时，`PyCharm`期望你使用该变量的方法或属性，并显示相应的列表。你可以在◘`Fig.
    [21.1](#Fig1)`中看到这个示例。![](../images/474412_1_En_21_Chapter/474412_1_En_21_Fig1_HTML.jpg)'
- en: 编辑器窗口中的代码补全菜单的截图。编辑器显示文本`x dot`，代码补全菜单显示标识符，如`image`、`real`、`numerator`和`denominator`。
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 编辑器窗口中的代码补全菜单的截图。编辑器显示文本`x dot`，代码补全菜单显示标识符，如`image`、`real`、`numerator`和`denominator`。
- en: '`Fig. 21.1`'
  id: totrans-85
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Fig. 21.1`'
- en: 整数变量的代码补全菜单，从代码编辑器中调用
  id: totrans-86
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 整数变量的代码补全菜单，从代码编辑器中调用
- en: 菜单中标记为小“m”的条目是类`float`为对象提供的方法，标记为小“p”的条目是属性（“p”代表`property`）。你还可以在右侧的代码补全菜单中看到对象的方法或属性来自哪里。在我们的例子中，所有方法和属性都直接来自类`int`，但有些也会来自更一般的类`object`，类`int`正是从该类派生的。从某种意义上说，类`object`是类`int`的父类，并从中继承了方法和属性。
  id: totrans-87
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 菜单中标记为小“m”的条目是类`float`为对象提供的方法，标记为小“p”的条目是属性（“p”代表`property`）。你还可以在右侧的代码补全菜单中看到对象的方法或属性来自哪里。在我们的例子中，所有方法和属性都直接来自类`int`，但有些也会来自更一般的类`object`，类`int`正是从该类派生的。从某种意义上说，类`object`是类`int`的父类，并从中继承了方法和属性。
- en: 现在在控制台中创建一个`float`变量，并调用该变量对象的方法`is_integer()`：
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在在控制台中创建一个`float`变量，并调用该变量对象的方法`is_integer()`：
- en: '`>>> x = 5.3 >>> x.is_integer() False`'
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> x = 5.3 >>> x.is_integer() False`'
- en: 该方法检查浮点数是否也是整数，当然在我们的例子中并非如此。类方法`is_integer()`不需要任何函数参数，因为它自动引用我们调用它的对象，即`x`。虽然不需要传递参数给函数，但它仍然必须始终用（空）圆括号调用，以识别它是一个函数。
  id: totrans-90
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 该方法检查浮点数是否也是整数，当然在我们的例子中并非如此。类方法`is_integer()`不需要任何函数参数，因为它自动引用我们调用它的对象，即`x`。虽然不需要传递参数给函数，但它仍然必须始终用（空）圆括号调用，以识别它是一个函数。
- en: 然而，类`float`不仅具有方法，还有一些属性。其中一个属性是`__class__`。它表示对象的类：
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然而，类`float`不仅具有方法，还有一些属性。其中一个属性是`__class__`。它表示对象的类：
- en: '`>>> x.__class__ <class ''float''>`'
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> x.__class__ <class ''float''>`'
- en: 另外，您也可以使用函数``type(*****object*****)``来确定对象类型，该对象作为参数传递给函数：
  id: totrans-93
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 另外，您也可以使用函数``type(*****object*****)``来确定对象类型，该对象作为参数传递给函数：
- en: '``>>>`` ``type(x)``**<class ''float''>**'
  id: totrans-94
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '``>>>`` ``type(x)``**<class ''float''>**'
- en: 借助函数``isinstance(*****object*****,** ***class*****)``，它像``type(*****object*****)``一样是Python标准库的一部分，您可以确定一个变量是否属于某种类型；用我们的面向对象术语更准确地说，您可以确定一个变量是否是某个``class``的``instance``。要做到这一点，变量和要检查的类作为参数传递给函数：
  id: totrans-95
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 借助函数``isinstance(*****object*****,** ***class*****)``，它像``type(*****object*****)``一样是Python标准库的一部分，您可以确定一个变量是否属于某种类型；用我们的面向对象术语更准确地说，您可以确定一个变量是否是某个``class``的``instance``。要做到这一点，变量和要检查的类作为参数传递给函数：
- en: '``>>>`` ``isinstance(x, str)``False``>>>`` ``isinstance(x, float)``True'
  id: totrans-96
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '``>>>`` ``isinstance(x, str)``False``>>>`` ``isinstance(x, float)``True'
- en: 让我们更仔细地看看对象的方法，即类为对象提供的函数。稍早之前，我们已经了解了``is_integer()``，这是类``float``的一个方法，它检查当前对象，即我们正在调用其方法的对象，是否是一个整数。如您所知，我们不必将要检查的变量传递给这个特殊函数，因为该方法已经是对象的一部分，因此知道应该处理哪个对象。
  id: totrans-97
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看对象的方法，即类为对象提供的函数。稍早之前，我们已经了解了``is_integer()``，这是类``float``的一个方法，它检查当前对象，即我们正在调用其方法的对象，是否是一个整数。如您所知，我们不必将要检查的变量传递给这个特殊函数，因为该方法已经是对象的一部分，因此知道应该处理哪个对象。
- en: 现在让我们看看字符串变量：
  id: totrans-98
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在让我们看看字符串变量：
- en: '``text = ''Strings in Python have many interesting methods.''``如果您在``PyCharm``中工作，在脚本编辑器或Python控制台中，您可以在脚本编辑器或Python控制台中键入``text.``（使用点操作符），熟悉的上下文菜单将显示字符串类``str``为您的``text``对象提供的属性和方法。您将立即看到这里有丰富的不同方法可供选择（◘
    图 [21.2](#Fig2)）。![](../images/474412_1_En_21_Chapter/474412_1_En_21_Fig2_HTML.jpg)'
  id: totrans-99
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '``text = ''Python中的字符串有许多有趣的方法.''``如果您在``PyCharm``中工作，在脚本编辑器或Python控制台中，您可以在脚本编辑器或Python控制台中键入``text.``（使用点操作符），熟悉的上下文菜单将显示字符串类``str``为您的``text``对象提供的属性和方法。您将立即看到这里有丰富的不同方法可供选择（◘
    图 [21.2](#Fig2)）。![](../images/474412_1_En_21_Chapter/474412_1_En_21_Fig2_HTML.jpg)'
- en: 在编辑器窗口中，代码补全菜单的截图。编辑器显示文本``text``，代码补全菜单显示标识符，如``upper``、``find``、``join``和``count``。
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在编辑器窗口中，代码补全菜单的截图。编辑器显示文本``text``，代码补全菜单显示标识符，如``upper``、``find``、``join``和``count``。
- en: 图 21.2
  id: totrans-101
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 21.2
- en: '``str``对象的方法让我们尝试其中的一些：'
  id: totrans-102
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '``str``对象的方法让我们尝试其中的一些：'
- en: '``lower()``和``upper()``分别将字符串转换为小写和大写字母：``>>>`` ``text = ''An ordinary text,
    with a few words and punctuation marks.''`` ``>>>`` ``text.lower()``''an ordinary
    text, with a few words and punctuation marks.''`` ``>>>`` ``text.upper()``''AN
    ORDINARY TEXT, WITH A FEW WORDS AND PUNCTUATION MARKS.'''
  id: totrans-103
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '``lower()``和``upper()``分别将字符串转换为小写和大写字母：``>>>`` ``text = ''一段普通文本，包含一些单词和标点符号。````>>>``
    ``text.lower()``''一段普通文本，包含一些单词和标点符号。''`` ``>>>`` ``text.upper()``''一段普通文本，包含一些单词和标点符号。'''
- en: '``isnumeric()``检查字符串是否可以转换为数字：``>>>`` ``text.isnumeric()``False'
  id: totrans-104
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '``isnumeric()``检查字符串是否可以转换为数字：``>>>`` ``text.isnumeric()``False'
- en: '``count(*****substring*****)``计算作为参数传递给该方法的（部分）字符串``substring``的出现次数；它是区分大小写的，如以下示例所示（仅计算“and”中的“an”）：``>>>``
    ``text.count(''an'')``1'
  id: totrans-105
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '``count(*****substring*****)``计算作为参数传递给该方法的（部分）字符串``substring``的出现次数；它是区分大小写的，如以下示例所示（仅计算“and”中的“an”）：``>>>``
    ``text.count(''an'')``1'
- en: '`replace(*****old*****,** ***new*****,** ***occurrences*****)` replaces the
    specified number of occurrences of the old string with the new string; specifying
    the number of occurrences to replace is optional, so you can omit it, which will
    simply replace `all` occurrences:`>>>` text.replace(''words'', ''terms'', 1)''An
    ordinary text, with a few terms and punctuation marks.'''
  id: totrans-106
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`replace(*****old*****,** ***new*****,** ***occurrences*****)` 替换旧字符串的指定次数为新字符串；指定替换的次数是可选的，因此您可以省略它，这将替换`all`的所有出现：`>>>`
    text.replace(''words'', ''terms'', 1)''一段普通文本，其中包含一些术语和标点符号。'''
- en: '`__len__()` determines the length of the string:`>>>` text.__len__()`58`'
  id: totrans-107
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`__len__()` 确定字符串的长度：`>>>` text.__len__()`58`'
- en: As you can see from the two leading and trailing underscores, this is a special
    core Python method. `21.1 [20 min]`
  id: totrans-108
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 正如您从前后两个下划线可以看出，这是一个特殊的核心Python方法。`21.1 [20 min]`
- en: Objects of type `str`，i.e.，string variables, have several interesting methods
    other than the ones presented here as an example. Find out what other methods
    are available for `str` objects and try them out in the Python console. If you
    don’t understand a method or can’t use it successfully, don’t dwell on it and
    move on to the next method.
  id: totrans-109
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`str`类型的对象，即字符串变量，除了这里展示的示例方法之外，还有几个其他有趣的方法。找出`str`对象还提供了哪些方法，并在Python控制台中尝试使用它们。如果您不理解某个方法或无法成功使用它，别过于纠结，继续尝试下一个方法。'
- en: You can read about the details of the methods in the help. To do this, call
    the help with `help()` in the Python console and put `str.` in front of the methods
    when calling them, so that Python knows exactly which class you want to look at
    for the method (there could be several classes that have a method of that name),
    for example `help(str.isnumeric).`
  id: totrans-110
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 您可以在帮助文档中阅读有关方法的详细信息。为此，请在Python控制台中调用`help()`，并在调用方法时在方法前加上`str.`，这样Python就能准确地知道您要查看哪个类的方法（因为可能有多个类具有相同名称的方法），例如
    `help(str.isnumeric).`
- en: 'You may have noticed during the exercise that methods such as `upper()`，`lower()`，and
    `replace()` do not modify the object for which they are called, but merely `return`
    a `modified copy of` the object. If you want to change the original object, you
    must assign the changed version, i.e., the return value of the method, to it.
    Let’s take a closer look at this using `upper()` as an example:'
  id: totrans-111
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可能在练习中注意到，像`upper()`、`lower()`和`replace()`这样的函数并不会修改它们调用的对象，而只是`返回`该对象的一个`修改副本`。如果你想修改原始对象，必须将修改后的版本，也就是方法的返回值，赋给它。我们通过`upper()`来更详细地了解这一点：
- en: '`>>>` text = ''An ordinary text, with a few words and punctuation marks.''`>>>`
    text.upper()`''AN ORDINARY TEXT, WITH A FEW WORDS AND PUNCTUATION MARKS.''`>>>`
    text`''An ordinary text, with a few words and punctuation marks.''`>>>` text =
    text.upper()`>>>` text`''AN ORDINARY TEXT, WITH A FEW WORDS AND PUNCTUATION MARKS.'''
  id: totrans-112
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` text = ''一段普通的文本，包含一些单词和标点符号。'' `>>>` text.upper()`''一段普通的文本，包含一些单词和标点符号。''`>>>`
    text`''一段普通的文本，包含一些单词和标点符号。''`>>>` text = text.upper()`>>>` text`''一段普通的文本，包含一些单词和标点符号。'''
- en: As you can see, calling the `text.upper()`方法 leaves the `text` variable completely
    unchanged. Only assigning the return value of the method to our original variable
    changes the object `text`。
  id: totrans-113
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如你所见，调用`text.upper()`方法并不会改变`text`变量。只有将方法的返回值赋给原始变量，才会改变对象`text`。
- en: '`21.4.2 Creating Variables with the Constructor Method`'
  id: totrans-114
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`21.4.2 使用构造方法创建变量`'
- en: 'In the previous section, we saw that variables can be created simply by assigning
    a value to them for the first time. But there is another way to create new variables.
    As you know by now, variables are objects, that is, instances of a class. Like
    all classes, these objects have a constructor method, which is a special method
    that creates an object of that type. We can use these constructors to create variables.
    Let’s look at the following example:'
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到，变量可以通过第一次给它赋值来创建。但还有另一种创建新变量的方法。正如你现在所知道的，变量是对象，也就是类的实例。像所有类一样，这些对象有一个构造方法，它是一个特殊的方法，用来创建该类型的对象。我们可以使用这些构造方法来创建变量。让我们看一下以下示例：
- en: '`>>>` x = int(3)`>>>` x`3` `>>>` type(x)`<class ''int''>`'
  id: totrans-116
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` x = int(3)`>>>` x`3` `>>>` type(x)`<class ''int''>`'
- en: 'So, the constructor method returns an `int` object with the value passed to
    it as argument. This alone is perhaps not all that interesting; after all, we
    could have achieved the same effect more easily with the simple assignment `x
    = 3`. What is interesting is that we can also pass a floating-point number or
    a string to the constructor and it will create an `int` object from it. In the
    case of the floating-point number, the decimal part is simply ignored. If a string
    is passed to the constructor, the text must of course be convertible into a number,
    otherwise we get an error message:'
  id: totrans-117
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 所以，构造方法返回一个`int`对象，其值是作为参数传入的。这本身可能并不那么有趣；毕竟，我们可以通过简单的赋值`x = 3`轻松实现相同的效果。值得注意的是，我们还可以将一个浮动小数或字符串传递给构造方法，它会从中创建一个`int`对象。在浮动小数的情况下，小数部分会被忽略。如果传递的是一个字符串，文本当然必须能转换为数字，否则会出现错误信息：
- en: '`>>>` x = int(3.7) `>>>` x 3 `>>>` x = int(''3.7'') `>>>` x 3 `>>>` x = int(''abc'')
    Traceback (most recent call last): File "<input>", line 1, in <module> ValueError:
    invalid literal for int() with base 10: ''abc''.'
  id: totrans-118
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` x = int(3.7) `>>>` x 3 `>>>` x = int(''3.7'') `>>>` x 3 `>>>` x = int(''abc'')
    Traceback (most recent call last): File "<input>", line 1, in <module> ValueError:
    invalid literal for int() with base 10: ''abc''。'
- en: 21.5 Converting Variables
  id: totrans-119
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 21.5 变量转换
- en: 'It is not uncommon to need to change the data type of variables. To do this,
    consider the following example, in which we add an integer variable and a floating-point
    number variable:'
  id: totrans-120
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在需要更改变量的数据类型时并不罕见。为此，请考虑以下示例，在其中我们将一个整数变量和一个浮动小数变量相加：
- en: '`>>>` x = 2 `>>>` type(x) `<class ''int''>` `>>>` x = x + 3.7 `>>>` x 5.7 `>>>`
    type(x) `<class float''>`'
  id: totrans-121
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` x = 2 `>>>` type(x) `<class ''int''>` `>>>` x = x + 3.7 `>>>` x 5.7 `>>>`
    type(x) `<class float''>`'
- en: When we created the variable, Python automatically chose `int` as the data type
    because we had assigned an integer to the variable. But when we then added 3.7,
    a floating-point number, Python changed the type to `float` to accommodate the
    new value. So, Python *implicitly* converts without us having to intervene.
  id: totrans-122
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当我们创建变量时，Python 会自动选择`int`作为数据类型，因为我们已经给变量赋了一个整数值。但当我们再加上 3.7 这个浮动小数时，Python
    会把类型更改为`float`以适应新值。所以，Python会*隐式*转换类型，而我们不需要进行干预。
- en: 'Now let’s try something else:'
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在让我们尝试一些其他的操作：
- en: '`>>>` x = 2 `>>>` x = x + ''2.7'' Traceback (most recent call last): File "<input>",
    line 1, in <module> TypeError: unsupported operand type(s) for +: ''int'' and
    ''str''.'
  id: totrans-124
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` x = 2 `>>>` x = x + ''2.7'' 报错信息（最近一次调用）： 文件 "<input>"，第 1 行，在 <module>
    中 TypeError: 不支持操作数类型：''int'' 和 ''str''。'
- en: If we add a string to our variable `x`, Python no longer implicitly converts.
    Maybe it works the other way around, where we define `x` as a string and add a
    number to it?
  id: totrans-125
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果我们将一个字符串加到变量 `x` 上，Python 将不再隐式地进行转换。也许相反的情况有效，我们将 `x` 定义为字符串并加上一个数字呢？
- en: '`>>>` x = ''2'' `>>>` x = x + 3.7 Traceback (most recent call last): File "<input>",
    line 1, in <module> TypeError: can only concatenate str (not "float") to str.'
  id: totrans-126
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` x = ''2'' `>>>` x = x + 3.7 报错信息（最近一次调用）： 文件 "<input>"，第 1 行，在 <module>
    中 TypeError: 只能将 str 类型与 str 类型连接，不能与 float 类型连接。'
- en: This doesn’t work either. So, Python does not convert between numbers and strings
    implicitly. Nevertheless, we sometimes need to convert strings to numbers to compute
    with them.
  id: totrans-127
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这个也不起作用。所以，Python 并不会在数字和字符串之间进行隐式转换。然而，我们有时需要将字符串转换为数字，以便进行计算。
- en: 'Let’s look at this with an example. Do you remember the conversion from Kelvin
    to Celsius from ► Sect. [12.​2.​2](474412_1_En_12_Chapter.xhtml#Sec6)? There we
    discussed a simple program that takes a temperature in Kelvin as user input and
    converts it to degrees Celsius. We will now develop this program in Python. To
    do this, we make use of the `input(prompt)` function for input, which prompts
    the user for input, and returns that input in the form of a string. With this
    knowledge, it would be obvious to write code like the following:'
  id: totrans-128
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看。你记得从► 第 [12.2.2](474412_1_En_12_Chapter.xhtml#Sec6) 节中的开尔文到摄氏度的转换吗？在那里我们讨论了一个简单的程序，它接受用户输入的开尔文温度并将其转换为摄氏度。我们现在将在
    Python 中开发这个程序。为此，我们使用 `input(prompt)` 函数获取输入，该函数提示用户输入并将输入以字符串的形式返回。掌握了这些知识后，写出如下代码应该是显而易见的：
- en: '`temp_kelvin = input(''Please enter a temperature in Kelvin: '') temp_celsius
    = temp_kelvin + 273.15 print(temp_kelvin, ''Kelvin are'', temp_celsius, ''degrees
    Celsius.'')`'
  id: totrans-129
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`temp_kelvin = input(''请输入温度（单位：开尔文）：'') temp_celsius = temp_kelvin + 273.15
    print(temp_kelvin, ''开尔文是'', temp_celsius, ''摄氏度。'')`'
- en: 'If we run this program and enter a temperature in Kelvin, we get output like
    the following:'
  id: totrans-130
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序并输入一个开尔文温度，我们将得到如下输出：
- en: '**Traceback (most recent call last):** **File "C:/Users/MyUser/Python/var_examples.py",
    line 54, in <module>.** `temp_celsius = temp_kelvin + 273.15` **TypeError: can
    only concatenate str (not "float") to str**'
  id: totrans-131
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**报错信息（最近一次调用）：** **文件 "C:/Users/MyUser/Python/var_examples.py"，第 54 行，在 <module>
    中。** `temp_celsius = temp_kelvin + 273.15` **TypeError: 只能将 str 类型与 str 类型连接，不能与
    float 类型连接**'
- en: 'By now you understand the problem that occurs here: The `input()` function
    returns a string, but it can’t be computed with because Python doesn’t convert
    to a number implicitly. We need to convert `explicitly`. That’s exactly what we
    do in this modified version of the example:'
  id: totrans-132
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 到目前为止，你已经理解了这里出现的问题：`input()` 函数返回的是一个字符串，但由于 Python 不会隐式地将其转换为数字，因此无法进行计算。我们需要**显式**地进行转换。这正是我们在修改版示例中所做的：
- en: '`temp_kelvin = input(''Please enter a temperature in Kelvin: '')` `temp_celsius
    = float(temp_kelvin) + 273.15` `print(temp_kelvin, ''Kelvin are'', temp_celsius,
    ''degrees Celsius.'')`'
  id: totrans-133
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`temp_kelvin = input(''请输入温度（单位：开尔文）：'')` `temp_celsius = float(temp_kelvin)
    + 273.15` `print(temp_kelvin, ''开尔文是'', temp_celsius, ''摄氏度。'')`'
- en: 'This time we explicitly convert the string variable `temp_celsius` into a floating
    point number, using the `float()` function. You will immediately recognize the
    reference to the last section: `float()` is, of course, the constructor method
    of the class `float` here as well. So, when we convert the string variable `temp_kelvin`
    to a floating-point number, we are doing nothing more than simply creating a new
    `float` object by calling the constructor of this class. We immediately initialize
    the new `float` object with a value; this value may also be a string, the `float`
    constructor then creates a floating point number from it. The `explicit` conversion
    in Python thus runs via the class constructors. They can receive as arguments
    not only a value of the type that the class constructor creates (`float` in our
    case), but also various other types (`str` in our example). In general, the explicit
    conversion thus has the form: `datatype(value)`.'
  id: totrans-134
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这一次，我们显式地将字符串变量 `temp_celsius` 转换为浮点数，使用了 `float()` 函数。你会立刻发现这是对上一节的引用：`float()`
    当然也是 `float` 类的构造方法。所以，当我们将字符串变量 `temp_kelvin` 转换为浮点数时，我们实际上只是在通过调用该类的构造方法来创建一个新的
    `float` 对象。我们立即初始化这个新的 `float` 对象，赋予它一个值；这个值也可以是一个字符串，`float` 构造方法会从中创建一个浮点数。因此，Python
    中的`显式`转换就是通过类构造方法完成的。它们不仅可以接收创建该类对象的数据类型（在我们这个例子中是 `float`），还可以接收各种其他类型（例如 `str`）。通常，显式转换的形式是：`datatype(value)`。
- en: 21.2 [10 min]
  id: totrans-135
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 21.2 [10 min]
- en: Write a program that takes the age of the user in years and outputs the number
    of minutes the user has lived (at least).
  id: totrans-136
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 写一个程序，获取用户的年龄（以年为单位），并输出用户至少活过多少分钟。
- en: 21.6 Complex Data Types
  id: totrans-137
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 21.6 复杂数据类型
- en: 21.6.1 Lists
  id: totrans-138
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 21.6.1 列表
- en: 21.6.1.1 Creating and Displaying Lists
  id: totrans-139
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 21.6.1.1 创建和显示列表
- en: 'Unlike many other programming languages, Python does not know the concept of
    arrays as such. Instead, however, Python has a more general type of variable fields
    of which the array is ultimately a special case: the list.'
  id: totrans-140
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与许多其他编程语言不同，Python 并没有数组的概念。相反，Python 有一种更通用的变量类型：字段数组，而数组则是其特例：列表。
- en: 'Lists are `ordered` summaries of `arbitrary` objects. Therefore, an array can
    also be understood as a list because it is nothing more than an ordered summary
    of objects of the `same type`. Lists are created in Python with square brackets,
    as you can see in the following example:'
  id: totrans-141
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 列表是 `有序` 的 `任意` 对象的集合。因此，数组也可以理解为列表，因为它无非就是 `相同类型` 对象的有序集合。列表在 Python 中通过方括号创建，如下例所示：
- en: '**>>>** `numbers = [1, 2, 3, 4, 5, 6, 7]`**>>>** `first_names = [''Beverly'',
    ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`'
  id: totrans-142
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**>>>** `numbers = [1, 2, 3, 4, 5, 6, 7]`**>>>** `first_names = [''Beverly'',
    ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`'
- en: 'Entering the list name into the console shows us the contents of the list.
    Square brackets around the elements of the list remind us that this is indeed
    a list:'
  id: totrans-143
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在控制台中输入列表名，会显示列表的内容。列表元素周围的方括号提醒我们这确实是一个列表：
- en: '**>>>** `numbers[1, 2, 3, 4, 5, 6, 7]`**>>>** `first_names[''Beverly'', ''Thomas'',
    ''Marc'', ''Jimmy'', ''Cathy'']`'
  id: totrans-144
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**>>>** `numbers[1, 2, 3, 4, 5, 6, 7]`**>>>** `first_names[''Beverly'', ''Thomas'',
    ''Marc'', ''Jimmy'', ''Cathy'']`'
- en: 'If you are not working in the console but in script mode, i.e. writing a whole
    program, then use the `print()` function for output, which can also process lists:'
  id: totrans-145
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你不是在控制台中工作，而是在脚本模式下编写完整程序，那么使用 `print()` 函数输出，它也可以处理列表：
- en: '`print(numbers)` `print(first_names)`'
  id: totrans-146
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`print(numbers)` `print(first_names)`'
- en: 单独写列表的标识符，例如`numbers`并不会在程序中产生输出——与在 Python 控制台中不同——正如我们在►节中看到的那样[21.1](#Sec1)。
  id: totrans-147
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 单独写列表的标识符，例如`numbers`并不会在程序中产生输出——与在 Python 控制台中不同——正如我们在►节中看到的那样[21.1](#Sec1)。
- en: 21.6.1.2 Selecting Individual Elements of a List
  id: totrans-148
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 21.6.1.2 选择列表中的单个元素
- en: 现在可以通过索引再次使用方括号访问列表的单个元素：
  id: totrans-149
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在可以通过索引再次使用方括号访问列表的单个元素：
- en: '`>>>` `numbers[3]` `4` `>>>` `first_names[2]` `''Marc''`'
  id: totrans-150
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `numbers[3]` `4` `>>>` `first_names[2]` `''Marc''`'
- en: Python 中的索引从`0`开始，因此索引为`1`的元素已经是列表中的*第二*个元素。你可以使用*负*索引从后面选择。如果我们想从列表的后面选择第二个名字，可以写：
  id: totrans-151
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: Python 中的索引从`0`开始，因此索引为`1`的元素已经是列表中的*第二*个元素。你可以使用*负*索引从后面选择。如果我们想从列表的后面选择第二个名字，可以写：
- en: '`>>>` `first_names[-2]` `''Jimmy''`'
  id: totrans-152
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `first_names[-2]` `''Jimmy''`'
- en: 列表的最后一个元素的索引是`−1`，而不是`−0`，正如你可能期望的那样。
  id: totrans-153
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 列表的最后一个元素的索引是`−1`，而不是`−0`，正如你可能期望的那样。
- en: 冒号运算符也可以用来指定一个范围作为索引。例如，如果我们想选择第二到第四个名字，可以这样做：
  id: totrans-154
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 冒号运算符也可以用来指定一个范围作为索引。例如，如果我们想选择第二到第四个名字，可以这样做：
- en: '`>>>` `first_names[2:5]` `[''Marc'', ''Jimmy'', ''Cathy'']`'
  id: totrans-155
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `first_names[2:5]` `[''Marc'', ''Jimmy'', ''Cathy'']`'
- en: 具有索引`2`、`3`和`4`的元素，即列表的第三个、第四个和第五个元素被选中。请注意，索引为`5`的元素，即第六个元素，不在选择范围内。索引规格的右边界——反直觉且与其他语言（如
    R）不同——不属于所选元素。
  id: totrans-156
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 具有索引`2`、`3`和`4`的元素，即列表的第三个、第四个和第五个元素被选中。请注意，索引为`5`的元素，即第六个元素，不在选择范围内。索引规格的右边界——反直觉且与其他语言（如
    R）不同——不属于所选元素。
- en: 就像原始列表一样，选择本身又是一个列表，因为我们选择了多个元素。如果另一方面我们只选择单个元素，选择不再是列表，而是具有该列表相应元素的类型：
  id: totrans-157
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 就像原始列表一样，选择本身又是一个列表，因为我们选择了多个元素。如果另一方面我们只选择单个元素，选择不再是列表，而是具有该列表相应元素的类型：
- en: '`>>>` `type(first_names)` `<class ''list''>` `>>>` `sel = first_names[2:5]`
    `>>>` `type(sel)` `<class ''list''>` `>>>` `sel = first_names[2]` `>>>` `type(sel)`
    `<class ''str''>`'
  id: totrans-158
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `type(first_names)` `<class ''list''>` `>>>` `sel = first_names[2:5]`
    `>>>` `type(sel)` `<class ''list''>` `>>>` `sel = first_names[2]` `>>>` `type(sel)`
    `<class ''str''>`'
- en: 当使用索引范围时，一侧也可以保持开放。如果左侧保持开放，系统将从列表的开头选择；如果右侧保持开放，系统将选择到列表的末尾：
  id: totrans-159
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当使用索引范围时，一侧也可以保持开放。如果左侧保持开放，系统将从列表的开头选择；如果右侧保持开放，系统将选择到列表的末尾：
- en: '`>>>` `first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names[:3]` `[''Beverly'', ''Thomas'', ''Marc'']` `>>>` `first_names[3:]`
    `[''Jimmy'', ''Cathy'']`'
  id: totrans-160
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names[:3]` `[''Beverly'', ''Thomas'', ''Marc'']` `>>>` `first_names[3:]`
    `[''Jimmy'', ''Cathy'']`'
- en: 你也可以将两个范围边界保持开放（`first_names[:]`），那么列表的所有元素将被简单选择（最终创建列表的副本）。如果你想一步选择多个不连续的元素，例如第一个和第三个元素，在
    Python 中并不是那么简单。这就是使用列表推导表达式派上用场的地方，我们将在稍后研究 Python 中循环的实现时讨论。
  id: totrans-161
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你也可以将两个范围边界保持开放（`first_names[:]`），那么列表的所有元素将被简单选择（最终创建列表的副本）。如果你想一步选择多个不连续的元素，例如第一个和第三个元素，在
    Python 中并不是那么简单。这就是使用列表推导表达式派上用场的地方，我们将在稍后研究 Python 中循环的实现时讨论。
- en: 21.6.1.3 Edit Lists
  id: totrans-162
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 21.6.1.3 编辑列表
- en: 我们刚刚学习的索引不仅可以用来从列表中选择项目以显示或进一步处理，还可以直接修改列表中的项目。在本节中，我们将研究如何修改列表的元素、向列表中添加元素、删除列表中的元素、排序列表，以及将多个列表合并成一个新列表。
  id: totrans-163
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们刚刚学习的索引不仅可以用来从列表中选择项目以显示或进一步处理，还可以直接修改列表中的项目。在本节中，我们将研究如何修改列表的元素、向列表中添加元素、删除列表中的元素、排序列表，以及将多个列表合并成一个新列表。
- en: 'Change List Elements Let’s start by changing the value of a list item: `>>>`
    `first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']` `>>>`
    `first_names[1] = ''Jason''` `>>>` `first_names = [''Beverly'', ''Jason'', ''Marc'',
    ''Jimmy'', ''Cathy'']`'
  id: totrans-164
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 修改列表元素：让我们从改变列表项的值开始：`>>>` `first_names = ['Beverly', 'Thomas', 'Marc', 'Jimmy',
    'Cathy']` `>>>` `first_names[1] = 'Jason'` `>>>` `first_names = ['Beverly', 'Jason',
    'Marc', 'Jimmy', 'Cathy']`
- en: 'Even entire index ranges can be assigned like this:'
  id: totrans-165
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 甚至整个索引范围也可以像这样赋值：
- en: '`>>>` `first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names[3:5] = [''Joe'', ''Aimee'']` `>>>` `first_names = [''Beverly'',
    ''Thomas'', ''Marc'', ''Joe'', ''Aimee'']`'
  id: totrans-166
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names[3:5] = [''Joe'', ''Aimee'']` `>>>` `first_names = [''Beverly'',
    ''Thomas'', ''Marc'', ''Joe'', ''Aimee'']`'
- en: In this case, make sure that the value you assign is again a list (that is,
    it is enclosed in square brackets and is of the same the length of the sublist
    you want to replace).
  id: totrans-167
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这种情况下，确保你赋值的值再次是一个列表（也就是用方括号括起来，并且它的长度与要替换的子列表相同）。
- en: 21.3 [5 min]
  id: totrans-168
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 21.3 [5 min]
- en: What happens if the assigned object is not a list or does not have the length
    of the substituted sublist? Try it out and see if you can explain the results!
  id: totrans-169
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果赋值的对象不是列表，或者其长度与被替换的子列表不匹配，会发生什么？试试看，并看看你是否能解释结果！
- en: Lists, like all variables in Python, are objects, so they have corresponding
    attributes and methods.
  id: totrans-170
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 列表，像 Python 中的所有变量一样，都是对象，因此它们有相应的属性和方法。
- en: 'Append Elements to Lists The `append(object)` method can be used to add an
    object to the list. This directly changes the list instance for which the `append()`
    method is called: `>>>` `first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'',
    ''Cathy'']` `>>>` `first_names.append(''Sandy'')` `>>>` `first_names = [''Beverly'',
    ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'', ''Sandy'']`'
  id: totrans-171
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 向列表中添加元素：`append(object)`方法可以用来向列表中添加一个对象。这会直接改变调用`append()`方法的列表实例：`>>>` `first_names
    = ['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']` `>>>` `first_names.append('Sandy')`
    `>>>` `first_names = ['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy', 'Sandy']`
- en: 'If you want to add an element `anywhere in` the list, use the method `insert(insert_before_element_index,
    object)` and pass it the position you want the new element to have and the element
    itself:'
  id: totrans-172
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你想在列表的`任何位置`添加元素，可以使用方法`insert(insert_before_element_index, object)`，并传入你希望新元素位于的位置和元素本身：
- en: '`>>>` `first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names.insert(2, ''Sandy'')` `>>>` `first_names = [''Beverly'', ''Thomas'',
    ''Sandy'', ''Marc'', ''Jimmy'', ''Cathy'']` Delete Elements from Lists You can
    delete items from a list with similar ease: `>>>` `first_names = [''Beverly'',
    ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']` `>>>` `first_names.__delitem__(4)`
    `>>>` `first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'']` `>>>` `del
    first_names[2]` `first_names = [''Beverly'', ''Thomas'', ''Jimmy'']`'
  id: totrans-173
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names.insert(2, ''Sandy'')` `>>>` `first_names = [''Beverly'', ''Thomas'',
    ''Sandy'', ''Marc'', ''Jimmy'', ''Cathy'']` 删除列表中的元素：你可以轻松地删除列表中的项目：`>>>` `first_names
    = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']` `>>>` `first_names.__delitem__(4)`
    `>>>` `first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'']` `>>>` `del
    first_names[2]` `first_names = [''Beverly'', ''Thomas'', ''Jimmy'']`'
- en: To do this, you can either use the class method `__delitem__(elementindex)`
    to which you only need to pass the index of the element to be deleted, or the
    operator `del`, which, because it is an operator, is used without parentheses!
    You call it together with the element to be deleted. You can even use the `del`
    operator to delete several elements at once, for example by calling `del first_names[2:4]`.
  id: totrans-174
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为了实现这一点，你可以使用类方法`__delitem__(elementindex)`，你只需要传递要删除的元素的索引，或者使用运算符`del`，由于它是一个运算符，因此不需要使用括号！你可以将它和要删除的元素一起调用。你甚至可以使用`del`运算符一次删除多个元素，例如通过调用`del
    first_names[2:4]`。
- en: As you can see from the example of deletion, some operations can be implemented
    with both a class method and an operator. This is also true for the selections
    we looked at in the previous section. Ultimately, the selection `first_names[2]`
    is nothing more than the call `first_names.__getitem__(3)` of the `__getitem__(elementindex)`
    method, and that’s exactly what Python processes internally when you index your
    list using the square brackets, which are themselves nothing more than an operator.
  id: totrans-175
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 正如我们从删除的示例中看到的那样，一些操作可以通过类方法和运算符来实现。这对于我们在上一节中看到的选择操作也同样适用。归根结底，选择`first_names[2]`不过是调用`first_names.__getitem__(3)`方法的结果，这正是Python在你使用方括号进行列表索引时内部处理的方式，而方括号本身也只是一个运算符。
- en: Sort Lists You can easily sort your list by using the class methods `sort()`
    and `reverse()`, depending on whether you want to sort in ascending or descending
    order:**>>>** `first_names = ['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']`**>>>**
    `first_names.sort()`**>>>** `first_names`['Beverly', 'Cathy', 'Jimmy', 'Marc',
    'Thomas']**>>>** `first_names.reverse()`**>>>** `first_names`['Thomas', 'Marc',
    'Jimmy', 'Cathy', 'Beverly'] Determine the Length of a List You can easily determine
    the length of a list using the `__len__()` method.**>>>** `first_name.__len__()`5
  id: totrans-176
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 排序列表 你可以通过使用类方法`sort()`和`reverse()`来轻松排序你的列表，具体取决于你是想按升序还是降序排序：**>>>** `first_names
    = ['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']`**>>>** `first_names.sort()`**>>>**
    `first_names`['Beverly', 'Cathy', 'Jimmy', 'Marc', 'Thomas']**>>>** `first_names.reverse()`**>>>**
    `first_names`['Thomas', 'Marc', 'Jimmy', 'Cathy', 'Beverly'] 确定列表的长度 你可以使用`__len__()`方法轻松地确定列表的长度。**>>>**
    `first_name.__len__()`5
- en: Unlike the previously discussed methods to manipulate the class `list`, `__len__()`
    does not modify the list, but only returns the length of the list.
  id: totrans-177
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与之前讨论的操作类`list`的方法不同，`__len__()`不会修改列表，它只是返回列表的长度。
- en: Joining Lists If you want to join two lists together, use the plus operator
    (**+**).**>>>** `first_names + numbers`['Beverly', 'Thomas', 'Marc', 'Jimmy',
    'Cathy', 1, 2, 3, 4, 5, 6, 7]
  id: totrans-178
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 合并列表 如果你想将两个列表合并在一起，可以使用加号运算符（**+**）。**>>>** `first_names + numbers`['Beverly',
    'Thomas', 'Marc', 'Jimmy', 'Cathy', 1, 2, 3, 4, 5, 6, 7]
- en: Here you can see that the result is a list whose elements are partly strings,
    but also partly numbers. Lists, unlike the more specialized arrays found in many
    programming languages, can contain different kinds of elements. In particular,
    the elements of lists can themselves be lists. We will take a closer look at this
    situation in the following section.
  id: totrans-179
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在这里，你可以看到结果是一个列表，其中的元素部分是字符串，部分是数字。与许多编程语言中的更专门化数组不同，列表可以包含不同类型的元素。特别地，列表的元素本身可以是列表。我们将在接下来的章节中仔细看看这种情况。
- en: 21.6.1.4 Lists as Elements of Lists
  id: totrans-180
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 21.6.1.4 列表作为列表的元素
- en: 'Consider the following list:'
  id: totrans-181
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 请考虑以下列表：
- en: '**>>>** `list_with_sublist = [1, 2, 3, [''a'', ''b'', ''c''], 4]`'
  id: totrans-182
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**>>>** `list_with_sublist = [1, 2, 3, [''a'', ''b'', ''c''], 4]`'
- en: 'It contains as fourth element (i.e., as element with index 3) again a list.
    We can also see this very quickly if we select the element and inspect it more
    closely:'
  id: totrans-183
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 它作为第四个元素（即索引为3的元素）再次包含一个列表。如果我们选择该元素并仔细检查，很快就可以看到这一点：
- en: '**>>>** `list_with_sublist = [1, 2, 3, [''a'', ''b'', ''c''], 4]`**>>>** `list_with_sublist[3]`[''a'',
    ''b'', ''c'']**>>>** `type(list_with_sublist[3])`**<class ''list''>**'
  id: totrans-184
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**>>>** `list_with_sublist = [1, 2, 3, [''a'', ''b'', ''c''], 4]`**>>>** `list_with_sublist[3]`[''a'',
    ''b'', ''c'']**>>>** `type(list_with_sublist[3])`**<class ''list''>**'
- en: 'To access an element of our “sub-list”, we first pick the fourth element with
    `list_with_sublist[3]`. This is now again a list. So, we should be able to select
    from this (sub-)list again, just as we did with the full list. For example, if
    we wanted to pick out the third element of the list, i.e., the **c**, we would
    index “twice” as follows:'
  id: totrans-185
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 要访问我们“子列表”的元素，我们首先使用`list_with_sublist[3]`来选择第四个元素。这个元素又是一个列表。所以，我们应该能够再次从这个（子）列表中选择元素，就像我们对整个列表做的一样。例如，如果我们想选出列表中的第三个元素，即**c**，我们可以进行“二次”索引，如下所示：
- en: '**>>>** `list_with_lists[3][2]`''c''In this way, lists can also be used to
    construct multidimensional variable fields. Suppose we wanted to map a rectangular
    value scheme that looks like this:'
  id: totrans-186
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**>>>** `list_with_lists[3][2]` ''c'' 通过这种方式，列表也可以用来构建多维变量字段。假设我们想要映射如下的矩形值方案：'
- en: '| 1 | 2 | 3 |'
  id: totrans-187
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| 1 | 2 | 3 |'
- en: '| 4 | 5 | 6 |'
  id: totrans-188
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| 4 | 5 | 6 |'
- en: '| 7 | 8 | 9 |'
  id: totrans-189
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| 7 | 8 | 9 |'
- en: This can be easily mapped with nested lists:**>>>** `three_by_three = [[1, 2,
    3], [4, 5, 6], [7, 8, 9]]`**>>>** `three_by_three`[[1, 2, 3], [4, 5, 6], [7, 8,
    9]]
  id: totrans-190
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这可以通过嵌套列表轻松映射：**>>>** `three_by_three = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]` **>>>**
    `three_by_three`[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
- en: 'We can then access the coordinates row 2, column 1 (i.e., the number 4 in our
    value scheme) by double indexing our list (note that the indexing starts at 0!):'
  id: totrans-191
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然后我们可以通过双重索引来访问坐标行 2，列 1（即我们值方案中的数字 4）（注意索引从 0 开始！）：
- en: '**>>>** `three_by_three[1][0]`4'
  id: totrans-192
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**>>>** `three_by_three[1][0]` 4'
- en: The first index is always the row index, the second the column index. Although
    multidimensional fields can also be represented very well with lists, at least
    if you are working with very large fields and the speed of the program is an important
    factor, you will want to use special data structures such as those contained in
    the `NumPy` module. `NumPy` is an important add-on library for anyone working
    in the data science area. The library also provides a special array data type
    that, while not as flexible as lists (because it only takes elements of the same
    type), is more compact in memory and faster to access. For our purposes here,
    however, lists, which are part of the standard Python language, will suffice.
  id: totrans-193
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 第一个索引总是行索引，第二个是列索引。虽然多维数组也可以通过列表很好地表示，但如果你处理的是非常大的数据集，且程序速度至关重要，那么你可能会希望使用如
    `NumPy` 模块中包含的特殊数据结构。`NumPy` 是从事数据科学工作者的一个重要扩展库。该库还提供了一种特殊的数组数据类型，虽然不如列表灵活（因为它只接受相同类型的元素），但在内存中更加紧凑，访问速度也更快。然而，在这里，为了我们的目的，标准
    Python 语言中的列表就足够了。
- en: 21.4 [20 min]
  id: totrans-194
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 21.4 [20 min]
- en: Try out working with lists a little! Create lists, select items from them, add
    new items, delete items. It is important that you get a feel for how to work with
    lists, because lists play a big role in practical work with Python.
  id: totrans-195
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 尝试一下操作列表！创建列表、选择列表中的项、添加新项、删除项。了解如何操作列表很重要，因为列表在实际的 Python 编程中扮演着重要角色。
- en: 21.6.1.5 Strings as Lists
  id: totrans-196
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
  zh: 21.6.1.5 字符串作为列表
- en: 'A special feature regarding lists are strings. In Python, they have list-like
    properties. Their individual elements, the characters, can be read-accessed in
    list notation:'
  id: totrans-197
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 有关列表的一个特殊特点是字符串。在 Python 中，字符串具有类似列表的特性。它们的各个元素（字符）可以通过列表表示法进行读取访问：
- en: '**>>>** `message = ''Hello World''` **>>>** `message[1]` ''e'''
  id: totrans-198
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**>>>** `message = ''Hello World''` **>>>** `message[1]` ''e'''
- en: Attempting to `edit` a string character in this way, such as with **`message[1]
    = 'x'`**, will result in the error message **‘str’ object does not support item
    assignment.**
  id: totrans-199
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 尝试以这种方式`编辑`字符串字符，例如使用 **`message[1] = 'x'`**，将导致错误信息 **‘str’ object does not
    support item assignment.**
- en: 21.6.2 Tuples
  id: totrans-200
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 21.6.2 元组
- en: 'Tuples are a data type that is similar to lists in many ways. Just like lists,
    tuples are ordered collections of multiple objects that do not necessarily have
    to be of the same type. The main difference with lists is that tuples are `immutable`.
    Take a look at the following example, in which we create a tuple from three integers:'
  id: totrans-201
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 元组是一种与列表在许多方面相似的数据类型。像列表一样，元组是有序的多个对象集合，这些对象不一定必须是相同类型的。与列表的主要区别在于元组是`不可变的`。看看下面的例子，我们从三个整数创建了一个元组：
- en: '**>>>** `number = (27, 9, 51)` **>>>** `number(27, 9, 51)` **>>>** `type(number)`
    **<class ''tuple''>** **>>>** `number[1]` 9 **>>>** `type(number[1])` **<class
    ''int''>** **>>>** `number[1]=36` **Traceback (most recent call last):** **File
    "<input>", line 1, in <module>** **TypeError: ''tuple'' object does not support
    item assignment**'
  id: totrans-202
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**>>>** `number = (27, 9, 51)` **>>>** `number(27, 9, 51)` **>>>** `type(number)`
    **<class ''tuple''>** **>>>** `number[1]` 9 **>>>** `type(number[1])` **<class
    ''int''>** **>>>** `number[1]=36` **Traceback (most recent call last):** **File
    "<input>", line 1, in <module>** **TypeError: ''tuple'' object does not support
    item assignment**'
- en: Note that—unlike with lists—the elements with which the tuple is initialized
    are enclosed in `round` brackets. However, the elements are accessed in exactly
    the same way as in lists, namely by specifying the index of the element in question
    in `square` brackets; and here, too, indexing naturally starts at 0—as always
    in Python—so that **`number[1]`** queries the `second` element of the tuple. In
    the last step, we try to assign a value to this second element of the tuple. This
    fails because tuples are an immutable data type whose elements cannot be changed
    after initialization. Also, no new elements can be added. The tuple is and remains
    as it was created when it was created.
  id: totrans-203
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 注意——与列表不同——初始化元组的元素被括在`圆括号`中。然而，元素的访问方式与列表完全相同，即通过在`方括号`中指定元素的索引；而且，在这里，索引自然从0开始——正如Python中始终如此——因此，**`number[1]`**查询的是元组的`第二`个元素。在最后一步，我们尝试给元组的第二个元素赋值。由于元组是不可变的数据类型，其元素在初始化后无法更改，因此赋值失败。同样，也不能添加新元素。元组在创建时的状态保持不变。
- en: 'By the way, you can also omit the parentheses when creating the tuple. So,
    we could also create the tuple **`number`** above this way:'
  id: totrans-204
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 顺便说一下，在创建元组时，你也可以省略括号。因此，我们也可以通过这种方式创建上面**`number`**的元组：
- en: '**>>>** `number = 27, 9, 51` **>>>** `number(27, 9, 51)`'
  id: totrans-205
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '**>>>** `number = 27, 9, 51` **>>>** `number(27, 9, 51)`'
- en: '-   你可能会问，既然列表可以做所有元组能做的事情，并且列表是可变的，那么为什么还要使用元组呢？元组的主要优势在于，Python可以比列表更快地处理它们。当你想确保数据不会被覆盖时，元组也很有用。如果你在程序中意外尝试这样做，将会收到错误信息，就像你在上面的示例中看到的那样。即使你不常意识到地使用元组，Python在后台也会使用元组。例如，与许多其他语言不同，Python允许你在一条语句中放置多个变量赋值，如下所示：'
  id: totrans-206
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '-   你可能会问，既然列表可以做所有元组能做的事情，并且列表是可变的，那么为什么还要使用元组呢？元组的主要优势在于，Python可以比列表更快地处理它们。当你想确保数据不会被覆盖时，元组也很有用。如果你在程序中意外尝试这样做，将会收到错误信息，就像你在上面的示例中看到的那样。即使你不常意识到地使用元组，Python在后台也会使用元组。例如，与许多其他语言不同，Python允许你在一条语句中放置多个变量赋值，如下所示：'
- en: '`>>>` `a, b = 5, 3` `>>>` `a` 5 `>>>` `b` 3'
  id: totrans-207
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `a, b = 5, 3` `>>>` `a` 5 `>>>` `b` 3'
- en: 这里的内部过程是，Python首先创建一个元组`(5, 3)`，然后将其元素分配给两个变量`a`和`b`。我们稍后将看到，在Python中——而这在许多其他编程语言中是不可行的——你可以让一个函数/方法返回多个值。“在幕后”这个过程与元组一起进行。
  id: totrans-208
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里的内部过程是，Python首先创建一个元组`(5, 3)`，然后将其元素分配给两个变量`a`和`b`。我们稍后将看到，在Python中——而这在许多其他编程语言中是不可行的——你可以让一个函数/方法返回多个值。“在幕后”这个过程与元组一起进行。
- en: 21.6.3`Dictionaries`
  id: totrans-209
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 21.6.3`字典`
- en: 除了列表和元组，另一个复杂的数据类型是字典。术语“字典”很好地描述了这些数据结构的功能。与列表不同，在列表中我们使用相关元素在列表中的索引来选择值，而在字典中使用*键*来实现同样的功能。因此，字典是*关联字段*。如果你不再记得这个概念，最好向后翻几页到►
    Sect. [11.​6](474412_1_En_11_Chapter.xhtml#Sec9)。
  id: totrans-210
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 除了列表和元组，另一个复杂的数据类型是字典。术语“字典”很好地描述了这些数据结构的功能。与列表不同，在列表中我们使用相关元素在列表中的索引来选择值，而在字典中使用*键*来实现同样的功能。因此，字典是*关联字段*。如果你不再记得这个概念，最好向后翻几页到►
    Sect. [11.​6](474412_1_En_11_Chapter.xhtml#Sec9)。
- en: 作为一个示例，让我们创建一个字典，存储每个名字（键）对应的年龄（值）。各种键值对用大括号书写，键和值之间用冒号分隔，键值对之间用逗号分隔：
  id: totrans-211
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 作为一个示例，让我们创建一个字典，存储每个名字（键）对应的年龄（值）。各种键值对用大括号书写，键和值之间用冒号分隔，键值对之间用逗号分隔：
- en: '`>>>` `d = {''Thomas'': 30, ''Beverly'': 19, ''Marc'': 28}` `>>>` `d` `{''Thomas'':
    30, ''Beverly'': 19, ''Marc'': 28}`'
  id: totrans-212
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `d = {''Thomas'': 30, ''Beverly'': 19, ''Marc'': 28}` `>>>` `d` `{''Thomas'':
    30, ''Beverly'': 19, ''Marc'': 28}`'
- en: 在我们的示例中，键是字符串，值是数字。然而，这并不一定是这样。数字本身也可以是键。甚至元组也可以是键，但列表不行，因为键必须始终是不可变的（记住，元组是不可变的，而列表可以被修改）。所有可能的对象类型都可以作为值，包括列表或字典本身。通过这种方式，也可以构造一个嵌套字典。我们将在以后的练习中更详细地研究这一点。
  id: totrans-213
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在我们的示例中，键是字符串，值是数字。然而，这并不一定是这样。数字本身也可以是键。甚至元组也可以是键，但列表不行，因为键必须始终是不可变的（记住，元组是不可变的，而列表可以被修改）。所有可能的对象类型都可以作为值，包括列表或字典本身。通过这种方式，也可以构造一个嵌套字典。我们将在以后的练习中更详细地研究这一点。
- en: 现在可以通过键来访问单个元素，这与关联字段的使用方式是一致的：
  id: totrans-214
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在可以通过键来访问单个元素，这与关联字段的使用方式是一致的：
- en: '`>>>` `d[''Thomas'']`30'
  id: totrans-215
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `d[''Thomas'']`30'
- en: 注意，虽然在创建字典时键值对是用大括号书写的，但在访问字段的单个元素时则使用方括号。
  id: totrans-216
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 注意，虽然在创建字典时键值对是用大括号书写的，但在访问字段的单个元素时则使用方括号。
- en: 'Unlike lists, dictionaries are `unordered` collections of elements. Accessing
    individual elements using a numeric index, which specifies the position of the
    element within the dictionary, is not possible because in an unordered data structure
    elements have no natural position at which they can be located and queried. Therefore,
    attempting to access an element using a numeric index will result in an error
    message:'
  id: totrans-217
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与列表不同，字典是`无序`的元素集合。不能使用数字索引来访问单个元素，因为在无序的数据结构中，元素没有自然的位置来定位和查询。因此，尝试使用数字索引访问元素会导致错误信息：
- en: '`>>> d[1] Traceback (most recent call last): File "<input>", line 1, in <module>
    KeyError: 1`'
  id: totrans-218
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> d[1] Traceback (most recent call last): File "<input>", line 1, in <module>
    KeyError: 1`'
- en: This `KeyError` tells us that a key `1` does not occur in the dictionary. Python
    interprets the `1` as a key, tries to find the corresponding value, but finds
    that `1` is not among the keys used in the dictionary. We would receive a similar
    error message if we used a name as a key that does not occur in the dictionary,
    for example with `d['Jacob']`.
  id: totrans-219
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这个`KeyError`告诉我们，键`1`在字典中不存在。Python将`1`视为一个键，尝试查找相应的值，但发现`1`不在字典的键中。如果我们使用一个字典中没有的名字作为键，也会收到类似的错误信息，例如使用`d['Jacob']`时。
- en: 'Elements can easily be added to a dictionary by making an assignment for the
    new element, associating the new key with a value:'
  id: totrans-220
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 可以通过为新元素进行赋值来轻松向字典中添加元素，将新键与值关联起来：
- en: '`>>> d[''Cathy''] = 36 >>> d {''Thomas'': 31, ''Beverly'': 19, ''Marc'': 28,
    ''Cathy'': 36}`'
  id: totrans-221
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> d[''Cathy''] = 36 >>> d {''Thomas'': 31, ''Beverly'': 19, ''Marc'': 28,
    ''Cathy'': 36}`'
- en: 'Of course, we can also use an existing key in such an assignment, as in the
    following example:'
  id: totrans-222
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当然，我们也可以在这样的赋值操作中使用已有的键，如以下示例所示：
- en: '`>>> d[''Beverly''] = 22 >>> d {''Thomas'': 31, ''Beverly'': 22, ''Marc'':
    28, ''Cathy'': 36}`'
  id: totrans-223
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> d[''Beverly''] = 22 >>> d {''Thomas'': 31, ''Beverly'': 22, ''Marc'':
    28, ''Cathy'': 36}`'
- en: Since the key is ultimately the identifier we use to access an element of the
    dictionary, it must be unique. Therefore, we cannot simply add a new element that
    has a key which already exists in the dictionary. Instead we change the already
    existing element in this case.
  id: totrans-224
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 由于键最终是我们用来访问字典元素的标识符，因此它必须是唯一的。因此，我们不能简单地添加一个已有键的元素。相反，在这种情况下我们会更改已经存在的元素。
- en: 'Not only adding, but also deleting elements is very easy with the `del` operator
    already known from lists:'
  id: totrans-225
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 不仅是添加元素，使用 `del` 运算符删除元素也和列表中一样简单：
- en: '`>>> del d[''Thomas''] >>> d {''Beverly'': 22, ''Marc'': 28, ''Cathy'': 36}`'
  id: totrans-226
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> del d[''Thomas''] >>> d {''Beverly'': 22, ''Marc'': 28, ''Cathy'': 36}`'
- en: 'Alternatively, as with lists, a call to the class method `__delitem__()` would
    be possible: `d.__delitem__(''Thomas'')`. Unlike the ordered lists, this method
    takes the corresponding key as argument instead of a numeric position index.'
  id: totrans-227
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 或者，就像列表一样，调用类方法 `__delitem__()` 也是可行的：`d.__delitem__('Thomas')`。与有序列表不同，这个方法接受对应的键作为参数，而不是数字位置索引。
- en: Sometimes you are interested in checking whether a certain key occurs in the
    dictionary. This can easily be done with the `in` operator. If you apply the `in`
    operator to a key and a dictionary, the result is a logical value that indicates
    whether the key is used in the dictionary or not.
  id: totrans-228
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 有时候，你可能需要检查某个键是否存在于字典中。这可以通过 `in` 运算符轻松实现。如果你将 `in` 运算符应用于一个键和字典，结果将是一个逻辑值，表示该键是否在字典中。
- en: '`>>> ''Cathy'' in d True >>> ''Amy'' in d False`'
  id: totrans-229
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> ''Cathy'' in d True >>> ''Amy'' in d False`'
- en: 'Of course, keys and values can also be extracted from the dictionary. For this
    purpose, the dictionary class has two special methods, `keys()` and `values()`.
    The return values of these methods are a bit more complicated, we will deal with
    this kind of object, the iterable objects, in more detail later. To work with
    them easily, we convert them into a list using the `list()` method, which is the
    constructor method of the `list` class:'
  id: totrans-230
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 当然，键和值也可以从字典中提取。为此，字典类有两个特殊方法：`keys()` 和 `values()`。这些方法的返回值稍微复杂一些，稍后我们会更详细地处理这种对象——可迭代对象。为了方便操作，我们使用
    `list()` 方法将它们转换为列表，`list` 类的构造方法：
- en: '`>>> list(d.keys()) [''Beverly'', ''Marc'', ''Cathy''] >>> list(d.values())
    [22, 28, 36]`'
  id: totrans-231
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> list(d.keys()) [''Beverly'', ''Marc'', ''Cathy''] >>> list(d.values())
    [22, 28, 36]`'
- en: 'With these lists, in turn, we can of course do anything that lists allow us
    to do, for example, access a particular element. Since the list of keys is of
    course an ordered data structure, we can access its elements with a numerical
    index. For example, the second element with index `1` (remember: indexing in Python
    starts at `0` for the first element):'
  id: totrans-232
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用这些列表，我们当然可以做任何列表允许的操作，例如访问特定元素。由于键的列表显然是有序的数据结构，我们可以用数字索引访问其元素。例如，索引为 `1`
    的第二个元素（记住：Python 中的索引从 `0` 开始）：
- en: '`>>> list(d.keys())[1] ''Marc''`'
  id: totrans-233
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> list(d.keys())[1] ''Marc''`'
- en: 'The complete elements of the dictionary can also be extracted into a list:'
  id: totrans-234
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 字典的完整元素也可以提取为列表：
- en: '`>>> list(d.items()) [ (''Beverly'', 22), (''Marc'', 28), (''Cathy'', 36) ]`'
  id: totrans-235
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> list(d.items()) [ (''Beverly'', 22), (''Marc'', 28), (''Cathy'', 36) ]`'
- en: 'The elements of the list are now the individual elements of the dictionary.
    They are themselves tuples of key and value:'
  id: totrans-236
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在，列表的元素就是字典的单个元素，它们本身是键值对的元组：
- en: '`>>> type(list(d.items())[0]) <class ''tuple''> 21.5 [10 min]`'
  id: totrans-237
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> type(list(d.items())[0]) <class ''tuple''> 21.5 [10 min]`'
- en: Create a dictionary whose keys are numeric product numbers and whose values
    are dictionaries containing, for each product number, the description, manufacturer,
    and price of the product in question.
  id: totrans-238
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 创建一个字典，其中键是数字型产品编号，值是包含每个产品编号的描述、制造商和价格的字典。
- en: '`21.6.4 Sets`'
  id: totrans-239
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: '`21.6.4 集合`'
- en: The last data type we want to look at is the `sets`.* Sets and dictionaries
    have in common that both are `unordered` collections of objects. Similar to the
    keys of a dictionary, which must always be unique, each element in a set can only
    occur once. Sets support set operations as they are known from mathematical set
    theory, for example, the determination of the intersection or union of two sets.
  id: totrans-240
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们要查看的最后一种数据类型是`集合`。*集合和字典的共同点是，它们都是`无序`的对象集合。类似于字典的键必须始终唯一，每个集合中的元素也只能出现一次。集合支持数学集合论中的集合操作，例如确定两个集合的交集或并集。*
- en: 'To create a set, we use the curly braces—similar to the dictionary; this time,
    however, the curly braces do not contain key-value pairs, but simply the individual
    elements of the set:'
  id: totrans-241
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 要创建一个集合，我们使用花括号——类似于字典；不过这次花括号中不包含键值对，而是集合的单个元素：
- en: '`>>> friends_thomas = {''Will'', ''Beverly'', ''Peter'', ''Michael''} >>> friends_julia
    = {''Peter'', ''Will'', ''Helen'', ''Michael'', ''Caroline''}`'
  id: totrans-242
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> friends_thomas = {''Will'', ''Beverly'', ''Peter'', ''Michael''} >>> friends_julia
    = {''Peter'', ''Will'', ''Helen'', ''Michael'', ''Caroline''}`'
- en: 'You can easily verify that the order of the elements does not matter by comparing
    two sets containing the same elements but in different order:'
  id: totrans-243
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以通过比较两个包含相同元素但顺序不同的集合，轻松验证元素的顺序无关紧要：
- en: '`>>> {''Beverly'', ''Peter''} == {''Peter'', ''Beverly''} True`'
  id: totrans-244
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> {''Beverly'', ''Peter''} == {''Peter'', ''Beverly''} True`'
- en: In doing so, we use the double equal sign for comparison, which, we will see
    later, is Python’s operator for comparisons for equality (a single equal sign
    would be considered by Python to be an attempt at assignment, which of course
    would not work here). The result of the comparison, `True`, confirms that the
    order of the elements in the sets does not matter; the two sets are identical
    despite different orders of their otherwise equal elements.
  id: totrans-245
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在此过程中，我们使用双等号进行比较，正如我们稍后会看到的，双等号是 Python 用于等式比较的操作符（单等号会被 Python 认为是赋值尝试，显然在这里无法使用）。比较的结果`True`确认了集合中元素的顺序无关紧要；这两个集合虽然元素顺序不同，但其余元素相同，因此它们是相同的集合。
- en: 'With the sets defined above, we could now check, for example, which elements
    occur in both sets, i.e., which people are friends of both Julia and Thomas:'
  id: totrans-246
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 使用上述定义的集合，我们现在可以检查，例如，哪些元素在两个集合中都出现，也就是说，哪些人是朱莉亚和托马斯的共同朋友：
- en: '`>>> friends_thomas.intersection(friends_julia) {''Will'', ''Peter''}`'
  id: totrans-247
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>> friends_thomas.intersection(friends_julia) {''Will'', ''Peter''}`'
- en: To do this, we use the class method `intersection(other_set)` here, which the
    class `set` brings with it by default. In this case, the result, namely the intersection
    that is again returned to us as `set` (easily recognizable by the curly brackets),
    would of course be the same if instead of calling `friends_thomas.intersection(friends_julia)`
    we had called `friends_julia.intersection(friends_thomas)` the other way around.
  id: totrans-248
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为此，我们使用类方法`intersection(other_set)`，这是`set`类默认提供的。此时，结果，即交集，依然以`set`形式返回（可以通过花括号轻松识别）。如果我们调用`friends_julia.intersection(friends_thomas)`，结果也将是相同的，顺序颠倒也不会影响交集。
- en: 'Similarly, we could have worked with the intersection operator `&`, which is
    supported by the class `set`:'
  id: totrans-249
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用交集操作符`&`，这是`set`类所支持的：
- en: '`>>>` `friends_thomas & friends_julia` `{''Will'', ''Peter''}`'
  id: totrans-250
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `friends_thomas & friends_julia` `{''Will'', ''Peter''}`'
- en: The fact that the intersection operator is an ampersand is no coincidence, since
    we are looking for all elements in the intersection that are contained in one
    `and` the other set.
  id: totrans-251
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 交集操作符是与符号（&）并非偶然，因为我们要寻找交集中的所有元素，这些元素同时包含在一个`和`另一个集合中。
- en: '`Union sets`, i.e., the set of all elements contained in one or both initial
    sets, can be determined with the class method `union(other_set)` or the pipe operator
    `|`:'
  id: totrans-252
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`并集`，即包含在一个或两个初始集合中的所有元素，可以通过类方法`union(other_set)`或管道操作符`|`来确定：'
- en: '`>>>` `friends_thomas.union(friends_julia)` `{''Helen'', ''Caroline'', ''Michael'',
    ''Will'', ''Peter'', ''Beverly''}` `>>>` `friends_thomas | friends_julia` `{''Helen'',
    ''Caroline'', ''Michael'', ''Will'', ''Peter'', ''Beverly''}`'
  id: totrans-253
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `friends_thomas.union(friends_julia)` `{''Helen'', ''Caroline'', ''Michael'',
    ''Will'', ''Peter'', ''Beverly''}` `>>>` `friends_thomas | friends_julia` `{''Helen'',
    ''Caroline'', ''Michael'', ''Will'', ''Peter'', ''Beverly''}`'
- en: 'As you can see, the union of our two sets contains the names `Will` and `Peter`
    only once, although they appear in both `friends_thomas` and `friends_julia`.
    But this is precisely the nature of sets (as well as sets in mathematics): All
    elements of a set are different from each other, no element can occur more than
    once.'
  id: totrans-254
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如您所见，我们的两个集合的并集只包含`Will`和`Peter`的名字一次，尽管它们在`friends_thomas`和`friends_julia`中都出现了。但这正是集合的特点（以及数学中的集合）：集合中的所有元素都是不同的，没有元素可以出现多次。
- en: 'Similarly, we can check whether one set is a `subset of` another:'
  id: totrans-255
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 同样，我们可以检查一个集合是否是另一个集合的`子集`：
- en: '`>>>` `friends_thomas.issubset(friends_julia)` `False` `>>>` `{''Michael'',
    ''Beverly''}.issubset(friends_thomas)` `True`'
  id: totrans-256
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `friends_thomas.issubset(friends_julia)` `False` `>>>` `{''Michael'',
    ''Beverly''}.issubset(friends_thomas)` `True`'
- en: 'Again, a convenient shortcut is available in the form of an operator, namely
    the less-than-equal operator:'
  id: totrans-257
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 再次，操作符提供了一个便捷的快捷方式，即小于等于操作符：
- en: '`>>>` `{''Michael'', ''Beverly''} <= friends_thomas` `True` 21.6 [20 min]'
  id: totrans-258
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `{''Michael'', ''Beverly''} <= friends_thomas` `True` 21.6 [20 min]'
- en: Find out (for example, with the `help()` function) what other interesting operations
    are possible with sets and try them out. Use the example sets `friends_thomas`
    and `friends_julia` from this section or create your own sets.
  id: totrans-259
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 查找（例如，通过`help()`函数）集合的其他有趣操作，并进行尝试。可以使用本节中的示例集合`friends_thomas`和`friends_julia`，或者创建自己的集合。
- en: 21.7 Self-Defined Classes
  id: totrans-260
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 21.7 自定义类
- en: 21.7.1 Defining and Using Classes
  id: totrans-261
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 21.7.1 定义和使用类
- en: All the data types we looked at were classes, whether they were basic types
    like `int` and `str` or more complex types like lists or dictionaries. Because
    Python as a programming language follows the object-oriented paradigm, we can
    of course define classes ourselves.
  id: totrans-262
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们查看过的所有数据类型都是类，无论是像`int`和`str`这样的基本类型，还是像列表或字典这样的复杂类型。因为Python作为一种编程语言遵循面向对象的范式，我们当然可以自定义定义类。
- en: 'Remember the example of the `Product` class from ► Sect. [11.​7.​2](474412_1_En_11_Chapter.xhtml#Sec12),
    which captures all the important basic information about a product? These properties
    were the name, a more detailed description, the part number, the manufacturer’s
    name, and the price. We can build such a class very easily in Python, using the
    `class` keyword:'
  id: totrans-263
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 记住来自► Sect. [11.​7.​2](474412_1_En_11_Chapter.xhtml#Sec12)的`Product`类示例，它捕获了有关产品的所有重要基本信息？这些属性包括名称、更详细的描述、零件编号、制造商名称和价格。我们可以在Python中非常容易地构建这样的类，使用`class`关键字：
- en: '`class` `Product`: `name = ''''` `description = ''''` `item_number = ''''`
    `manufacturer = ''''` `price = 0.0`'
  id: totrans-264
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`class` `Product`: `name = ''''` `description = ''''` `item_number = ''''`
    `manufacturer = ''''` `price = 0.0`'
- en: 'After the colon, the code block begins (attention, indentation!) with the attributes
    of the classes, to each of which we assign an initial value. That’s about it!
    Now we can use our class `Product` and create a variable of this type:'
  id: totrans-265
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在冒号后，代码块开始（注意缩进！）并定义类的属性，每个属性都分配了一个初始值。就是这样！现在我们可以使用我们的`Product`类并创建该类型的变量：
- en: '`gardenshovel = Product()`'
  id: totrans-266
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`gardenshovel = Product()`'
- en: '`Product()` is the constructor method of our class, which we use here just
    as we did for Python’s basic data types in ► Sect. [21.4.2](#Sec11). While we
    haven’t defined a constructor of our own at all, our class gets a default constructor
    from Python that does nothing but create an object of the class. Later, when we
    look at methods/functions in a bit more detail, we’ll look at how we can write
    our own constructor and use it to allow the user of our class to, for example,
    set the values of certain attributes to their own specifications right when a
    new class instance is created. This is exactly what we did in ► Sect. [21.4.2](#Sec11),
    when we called the constructor of the class `int` with `int(56)` and caused it
    to create a new `int` object containing the integer value 56.'
  id: totrans-267
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`Product()`是我们类的构造方法，我们在这里就像在► Sect. [21.4.2](#Sec11)中对Python的基本数据类型那样使用它。虽然我们根本没有定义自己的构造函数，但我们的类从Python获得了一个默认的构造函数，它什么也不做，只是创建一个类的对象。稍后，当我们更详细地学习方法/函数时，我们将看看如何编写自己的构造函数，并利用它让我们类的使用者在创建新实例时，比如设置某些属性的值为自己的规格。这正是我们在►
    Sect. [21.4.2](#Sec11)中做的，当时我们通过`int(56)`调用了`int`类的构造函数，从而创建了一个包含整数值56的新`int`对象。'
- en: 'Now that we have created the object of type `Product`, we can customize its
    properties as we wish:'
  id: totrans-268
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`Product`类型的对象，可以根据需要自定义它的属性：
- en: '`gardenshovel.name = ''Garden shovel, stainless steel''`. `gardenshovel.price
    = 10.99`'
  id: totrans-269
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`gardenshovel.name = ''Garden shovel, stainless steel''`。`gardenshovel.price
    = 10.99`'
- en: If you work with `*PyCharm*` and type `gardenshovel.` (including the dot operator!),
    the dropdown menu that opens will list, among other things, the attributes we
    just defined that the object `gardenshovel`, as an instance of the `Product` class,
    has.
  id: totrans-270
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 如果你在 `*PyCharm*` 中工作并输入 `gardenshovel.`（包括点操作符！），弹出的下拉菜单将列出我们刚刚定义的属性，作为 `Product`
    类的实例，`gardenshovel` 对象将具有这些属性。
- en: 'You can easily verify that these assignments worked by displaying the values
    of the attributes:'
  id: totrans-271
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你可以轻松验证这些赋值是否成功，通过显示属性的值来检查：
- en: '`print(gardenshovel.name)` `print(gardenshovel.price)`'
  id: totrans-272
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`print(gardenshovel.name)` `print(gardenshovel.price)`'
- en: Note that we are no longer in Python’s interactive mode here (you can easily
    tell by the missing input prompt `>>>` before the statements), although we could
    of course have fed the class definition into the Python console. Therefore, to
    display the contents of a variable, simply typing its identifier is no longer
    sufficient (in fact, it has no effect at all). Instead, we must explicitly cause
    the output by calling the `print()` function.
  id: totrans-273
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 请注意，我们现在不再处于 Python 的交互模式（可以通过语句前缺少提示符 `>>>` 来轻松辨别），尽管我们当然也可以将类定义输入到 Python
    控制台中。因此，单纯输入变量的标识符不再足以显示内容（事实上，它完全没有效果）。相反，我们必须显式地调用 `print()` 函数来输出结果。
- en: 21.7.2 Deriving Classes from Other Classes
  id: totrans-274
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 21.7.2 从其他类派生类
- en: 'In ► Sect. [11.​7.​3](474412_1_En_11_Chapter.xhtml#Sec13) we learned about
    the concept of inheritance, which of course Python also offers as an object-oriented
    language. There, we defined the class `Book` as a derived class of the class `Product`,
    which has two special attributes, `author` and `pages`, that the base/parent class
    `Product` does not have by default. In Python, to derive one class from another,
    the base class name is placed in parentheses after the derived class name in the
    class definition:'
  id: totrans-275
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在 ► Sect. [11.​7.​3](474412_1_En_11_Chapter.xhtml#Sec13) 中，我们学习了继承的概念，Python
    作为一种面向对象的语言，当然也提供了继承机制。在那里，我们将 `Book` 类定义为 `Product` 类的派生类，后者没有默认的 `author` 和
    `pages` 这两个特殊属性。为了在 Python 中将一个类从另一个类派生，派生类的类名后面要加上基类的类名，并用括号括起来：
- en: '`class` `Book(Product):` `pages = 0` `author = ''''`'
  id: totrans-276
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`class` `Book(Product):` `pages = 0` `author = ''''`'
- en: 'Now we can create an instance of the `Book` class by calling its default constructor,
    which Python kindly provides:'
  id: totrans-277
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在我们可以通过调用 `Book` 类的默认构造函数来创建一个实例，Python 会很友好地提供该构造函数：
- en: '`grisham1992` = `Book`()If you now display the attributes of the new object
    in `*PyCharm*` by typing `grisham1992`. you will immediately see that the instance
    of the class `Book` has not only its own attributes, namely `pages` and `author`,
    but also the properties inherited from `Product`, such as `description` and `price`.
    `*PyCharm*` also shows you, as you can see in ◘ Fig. [21.3](#Fig3), from which
    class the respective attribute originates.![](../images/474412_1_En_21_Chapter/474412_1_En_21_Fig3_HTML.jpg)'
  id: totrans-278
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`grisham1992` = `Book`()如果你现在在 `*PyCharm*` 中通过输入 `grisham1992` 显示新对象的属性，你会立即看到
    `Book` 类的实例不仅拥有自己的属性，如 `pages` 和 `author`，还继承了来自 `Product` 的属性，如 `description`
    和 `price`。如图 ◘ [21.3](#Fig3) 所示，`*PyCharm*` 还会显示每个属性来源的类！[](../images/474412_1_En_21_Chapter/474412_1_En_21_Fig3_HTML.jpg)'
- en: A screenshot of a code completion menu in an editor window. The editor displays
    the text of properties of the book `grisham 1992`, and the code completion menu
    displays identifiers such as `pages`, `price`, `author`, and `name`.
  id: totrans-279
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 编辑器窗口中的代码补全菜单截图。编辑器显示了 `grisham 1992` 这本书的属性文本，而代码补全菜单显示了如 `pages`、`price`、`author`
    和 `name` 等标识符。
- en: Fig. 21.3
  id: totrans-280
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 图 21.3
- en: Own and inherited properties of the `“Book”` class
  id: totrans-281
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`“Book”` 类的拥有属性和继承属性'
- en: 'We can now work with all properties as we wish:'
  id: totrans-282
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在我们可以随意操作所有属性：
- en: '`grisham1992.name` = `''The Pelican Brief''` `grisham1992.price` = `8.99` `grisham1992.author`
    = `''John Grisham''` `grisham1992.pages` = `478`'
  id: totrans-283
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`grisham1992.name` = `''The Pelican Brief''` `grisham1992.price` = `8.99` `grisham1992.author`
    = `''John Grisham''` `grisham1992.pages` = `478`'
- en: 'Classes in Python can be derived not only from one base class, but also from
    multiple base classes. For example, there could be another class `Copyright`:'
  id: totrans-284
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: Python 中的类不仅可以继承自一个基类，还可以继承自多个基类。例如，还可以有另一个类 `Copyright`：
- en: '`class` `Copyright`:`owner` = ''''`year` = 1900'
  id: totrans-285
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`class` `Copyright`:`owner` = ''''`year` = 1900'
- en: 'Then we could derive our class `Book` from both base classes, `Product` and
    `Copyright` at the same time:'
  id: totrans-286
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 然后，我们可以同时将 `Book` 类从 `Product` 和 `Copyright` 两个基类派生：
- en: '`class` `Book`(`Product`, `Copyright`):`pages` = 0`author` = '''''
  id: totrans-287
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`class` `Book`(`Product`, `Copyright`):`pages` = 0`author` = '''''
- en: 'By specifying both base classes in the definition of our class `Book`, we create
    a class that inherits the attributes and methods of both classes. Accordingly,
    we can now work with the attributes that the `Copyright` class brings:'
  id: totrans-288
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 通过在我们`Book`类的定义中指定两个基类，我们创建了一个同时继承了两个类的属性和方法的类。因此，我们现在可以使用`Copyright`类带来的属性：
- en: '`grisham1992` = `Book`() `grisham1992.owner` = `''Double''` `grisham1992.year`
    = `1992`21.7 [10 min]'
  id: totrans-289
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`grisham1992` = `Book`() `grisham1992.owner` = `''Double''` `grisham1992.year`
    = `1992`21.7 [10 min]'
- en: Define a `Customer` class with useful customer attributes and derive a `BusinessCustomer`
    class from this class that contains additional attributes that are only relevant
    for business customers.
  id: totrans-290
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 定义一个包含有用客户属性的`Customer`类，并从该类派生出一个包含仅对商业客户相关的附加属性的`BusinessCustomer`类。
- en: '21.7.3 Avoid Ambiguity: Name Mangling'
  id: totrans-291
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
  zh: 21.7.3 避免歧义：名称混淆
- en: 'But what if not only the class `Product`, but also the class `Copyright` had
    an attribute called `name`? The derived class `Book` would nevertheless have only
    `one` attribute `name`. But from which “parent” would this attribute now originate?
    Is it the name from `Product` or the name from `Copyright`? The answer in this
    case would be: that of `Product`, because Python proceeds from left to right,
    i.e. the class from which it is derived “first” is searched first for the attribute
    name. Python only searches in the other parent classes if the first parent class
    did not have an attribute of this identifier.'
  id: totrans-292
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 但是，如果不仅是`Product`类，`Copyright`类也有一个名为`name`的属性呢？派生类`Book`仍然只有一个`name`属性。但是这个属性现在是从哪个“父类”来的呢？是从`Product`的`name`，还是从`Copyright`的`name`？在这种情况下，答案是：来自`Product`，因为Python是从左到右进行搜索的，即“先”查找派生类中“左边”的父类中的属性名。如果第一个父类没有该标识符的属性，Python才会继续在其他父类中查找。
- en: 'To eliminate name confusion altogether, there is an option to prefix class
    attributes with a double underscore. Then the class definition of our `Copyright`
    class would look like this:'
  id: totrans-293
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 为了完全消除名称混淆，可以选择用双下划线为类属性添加前缀。然后，我们的`Copyright`类的类定义将如下所示：
- en: '`class` `Copyright`:`owner` = ''''`__name` = ''''`year` = 1900'
  id: totrans-294
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`class` `Copyright`:`owner` = ''''`__name` = ''''`year` = 1900'
- en: 'The effect of the double underscore is that Python automatically makes the
    property accessible under the identifier `__class__attribute__`, which in our
    example is `__Copyright__name`:'
  id: totrans-295
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 双下划线的效果是，Python会自动通过`__class__attribute__`的标识符来访问属性，在我们的示例中就是`__Copyright__name`：
- en: '`grisham1992._Copyright__name = ''Copyright''` `print(grisham1992._Copyright__name)`'
  id: totrans-296
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`grisham1992._Copyright__name = ''Copyright''` `print(grisham1992._Copyright__name)`'
- en: 这个过程，也称为`name mangling`，可以避免在访问类层次结构中可能重复出现的属性名称时的歧义和误解。
  id: totrans-297
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这个过程，也称为`name mangling`，可以避免在访问类层次结构中可能重复出现的属性名称时的歧义和误解。
- en: '`21.8 Summary`'
  id: totrans-298
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: '`21.8 小结`'
- en: 在本章中，我们学习了Python中的变量及如何使用它们。我们还学习了如何定义类并创建对象作为类的实例。
  id: totrans-299
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Python中的变量及如何使用它们。我们还学习了如何定义类并创建对象作为类的实例。
- en: 你应该从本章中记住以下几点：
  id: totrans-300
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 你应该从本章中记住以下几点：
- en: Python知道简单数据类型，最显著的是`int`（整数）、`float`（浮点数）、`str`（字符串）和`bool`（逻辑/真值），以及更复杂的数据类型，最显著的是`list`（不同对象的有序集合）、`dictionary`（无序关联字段）、`tuple`（不可变对象的集合）和`set`（无序唯一对象的集合）。
  id: totrans-301
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: Python知道简单数据类型，最显著的是`int`（整数）、`float`（浮点数）、`str`（字符串）和`bool`（逻辑/真值），以及更复杂的数据类型，最显著的是`list`（不同对象的有序集合）、`dictionary`（无序关联字段）、`tuple`（不可变对象的集合）和`set`（无序唯一对象的集合）。
- en: 所有数据类型都是类，这些数据类型的变量是对象实例；它们具有属性（或特性）和方法，用于操作和处理对象。
  id: totrans-302
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 所有数据类型都是类，这些数据类型的变量是对象实例；它们具有属性（或特性）和方法，用于操作和处理对象。
- en: 变量名区分大小写，这在Python中是普遍的；官方推荐使用小写变量，并用下划线分隔变量名中的多个术语。
  id: totrans-303
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 变量名区分大小写，这在Python中是普遍的；官方推荐使用小写变量，并用下划线分隔变量名中的多个术语。
- en: 变量不需要声明。
  id: totrans-304
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 变量不需要声明。
- en: 变量可以通过将对象赋值给变量名生成（此时Python自动确定类型），也可以通过使用相应数据类型类的构造方法生成。
  id: totrans-305
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 变量可以通过将对象赋值给变量名生成（此时Python自动确定类型），也可以通过使用相应数据类型类的构造方法生成。
- en: 构造函数通常可以用其他类型的对象作为参数调用；这允许数据类型之间的显式转换。
  id: totrans-306
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 构造函数通常可以用其他类型的对象作为参数调用；这允许数据类型之间的显式转换。
- en: Python隐式转换的相对较少，但在必要时会在`int`和`float`之间进行转换。
  id: totrans-307
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: Python隐式转换的相对较少，但在必要时会在`int`和`float`之间进行转换。
- en: 字符串可以用单引号和双引号括起来。
  id: totrans-308
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 字符串可以用单引号和双引号括起来。
- en: 要显示变量的内容，可以在Python控制台中输入其名称；然而，在Python程序中，输出必须始终明确调用（主要使用`print()`函数）。
  id: totrans-309
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 要显示变量的内容，可以在Python控制台中输入其名称；然而，在Python程序中，输出必须始终明确调用（主要使用`print()`函数）。
- en: Python中的复杂数据类型在是否可变（可变：`list`、`dictionary`、`set`；不可变：`tuple`）以及其元素是以有序还是无序方式存储（有序：`list`、`tuple`；无序：`dictionary`、`set`）上有所不同。
  id: totrans-310
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: Python中的复杂数据类型在是否可变（可变：`list`、`dictionary`、`set`；不可变：`tuple`）以及其元素是以有序还是无序方式存储（有序：`list`、`tuple`；无序：`dictionary`、`set`）上有所不同。
- en: 复杂数据类型的元素（在字典的情况下，包括键和值）可以是不同类型的，甚至可以是该复杂数据类型或其他复杂数据类型的对象；例如，可能有一个列表，其中包含列表作为元素，或者一个字典，其键部分是元组，值是列表和其他字典。
  id: totrans-311
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 复杂数据类型的元素（在字典的情况下，包括键和值）可以是不同类型的，甚至可以是该复杂数据类型或其他复杂数据类型的对象；例如，可能有一个列表，其中包含列表作为元素，或者一个字典，其键部分是元组，值是列表和其他字典。
- en: 有序数据类型（列表、元组）的元素可以通过数字索引（即元素编号）访问；第一个元素的索引总是0。
  id: totrans-312
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 有序数据类型（列表、元组）的元素可以通过数字索引（即元素编号）访问；第一个元素的索引总是0。
- en: 冒号运算符可以用来表示索引范围，其中`A:B`表示范围边界`A`（包含）和`B-1`（包含）之间的所有元素。
  id: totrans-313
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 冒号运算符可以用来表示索引范围，其中`A:B`表示范围边界`A`（包含）和`B-1`（包含）之间的所有元素。
- en: Range boundaries can also be left open, which is equivalent to “from the beginning”
    (left boundary not specified) or to the end (right boundary not specified).
  id: totrans-314
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 范围边界也可以留空，这相当于“从头开始”（未指定左边界）或“到结束”（未指定右边界）。
- en: 'Negative indexes mean: Indexing from the back instead of the front.'
  id: totrans-315
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 负数索引意味着：从后面索引，而不是从前面索引。
- en: Python does not know a special data type for arrays/fields, but the data type
    `list`, which holds arbitrary elements in ordered form; an array is thus a special
    case of a `list` (namely one whose elements are all of the same type).
  id: totrans-316
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: Python 没有一个特殊的数据类型用于数组/字段，而是使用`列表`类型来保存有序形式的任意元素；因此，数组是`列表`的一种特殊情况（即所有元素类型相同的列表）。
- en: Strings also behave like `lists` in read access, in that their individual characters
    can be addressed in the notation usual for `lists`; however, write access to the
    characters is not possible in this way.
  id: totrans-317
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 字符串在读取访问时也表现得像`列表`，因为它们的单个字符可以像`列表`一样通过常用符号进行访问；然而，不能通过这种方式写入字符。
- en: You can define your own classes using the keyword `class`; classes can be derived
    from one or more “parent classes”, i.e., inherit their attributes and methods.
  id: totrans-318
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 您可以使用`class`关键字定义自己的类；类可以从一个或多个“父类”派生，即继承它们的属性和方法。
- en: A double underscore of an attribute or method in a class definition means that
    the attribute/method is also accessible under the name `_*class*__*attribute*`
    or `_*class*__*method()*` (*name mangling*); in this way, ambiguities in attribute/method
    identifiers caused by multiple inheritance can be avoided.
  id: totrans-319
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: 类定义中，属性或方法的双下划线表示该属性/方法也可以通过`_*class*__*attribute*`或`_*class*__*method()*`访问（*名称重整*）；通过这种方式，可以避免由于多重继承引起的属性/方法标识符的歧义。
- en: The following table gives an overview of the most important data types. For
    the simple data types, you can see the creation by assignment and by calling the
    constructor method of the respective class. Of course, the complex data types
    `list`, `tuple`, `dictionary` and `set` can also be created by constructor, but
    this is not shown here for the sake of clarity.
  id: totrans-320
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 以下表格概述了最重要的数据类型。对于简单数据类型，可以通过赋值或调用相应类的构造方法进行创建。当然，复杂数据类型如`列表`、`元组`、`字典`和`集合`也可以通过构造器创建，但为了简洁起见，这里不显示构造器的创建方式。
- en: Overview of the most important data types
  id: totrans-321
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 重要数据类型概览
- en: '| Data type | Saves | Creation of a variable | Access to elements |'
  id: totrans-322
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| 数据类型 | 存储内容 | 变量的创建 | 元素的访问 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-323
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `int` | Integers | Assignment:`x = 5`Constructor:`x = int(''5'')` | – |'
  id: totrans-324
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `整数` | 整数 | 赋值：`x = 5` 构造器：`x = int(''5'')` | – |'
- en: '| `float` | Floating point values | Assignment:`x = 0.5`Constructor:`x = float(''5'')`
    | – |'
  id: totrans-325
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `浮点数` | 浮动小数值 | 赋值：`x = 0.5` 构造器：`x = float(''5'')` | – |'
- en: '| `str` | Strings | Assignment:`x = ''Hello World''`Constructor:`x = str(0.5)`
    | – |'
  id: totrans-326
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `字符串` | 字符串 | 赋值：`x = ''Hello World''` 构造器：`x = str(0.5)` | – |'
- en: '| `boolean` | Logical/truth values | Assignment:`x = False`Constructor:`x =
    bool(''True'')` | – |'
  id: totrans-327
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `布尔值` | 逻辑/真值 | 赋值：`x = False` 构造器：`x = bool(''True'')` | – |'
- en: '| `list` | Ordered, changeable compilation of other objects (possibly also
    of different types) | Elements comma-separated in square brackets:`x = [''Marc'',
    ''Helen'', ''Toby'', ''Thomas'']` | Index or index range in square brackets:`x[1]`(gives:
    `''Helen''`)*`x[2:3]`*(gives: `[''Hellen'', ''Thomas'']`) |'
  id: totrans-328
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `列表` | 有序、可更改的其他对象的组合（可能也是不同类型的） | 元素用逗号分隔并放在方括号中：`x = [''Marc'', ''Helen'',
    ''Toby'', ''Thomas'']` | 用方括号表示索引或索引范围：`x[1]`（返回：`''Helen''`） *`x[2:3]`*（返回：`[''Helen'',
    ''Thomas'']`） |'
- en: '| `tuple` | Ordered, unchangeable compilation of other objects (possibly of
    different types) | Elements comma separated in round brackets:`x = (''abc'', 27.5)`
    | Index in round brackets:`x(1)`(gives: `27.5`) |'
  id: totrans-329
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `元组` | 有序的、不可更改的其他对象的组合（可能是不同类型的） | 元素用逗号分隔并放在圆括号中：`x = (''abc'', 27.5)`
    | 用圆括号表示索引：`x(1)`（返回：`27.5`） |'
- en: '| `dictionary` | Unordered set of key-value pairs, keys and values can be objects
    of different types; keys must be unique | Key-value pairs comma-separated in curly
    brackets, key and value each separated by colon:`x = {''Marc'' : 27, ''Helen''
    : 41}` | Key in square brackets:`x = [''Marc'']`(provides: `27`) |'
  id: totrans-330
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `字典` | 无序的键值对集合，键和值可以是不同类型的对象；键必须是唯一的 | 用逗号分隔的键值对，键和值之间用冒号分隔：`x = {''Marc''
    : 27, ''Helen'' : 41}` | 用方括号表示键：`x = [''Marc'']`（返回：`27`） |'
- en: '| `set` | 不可排序的对象集合（可能是不同类型），必须是唯一的（对象在列表中只能出现一次） | 以逗号分隔的元素在大括号中：`x = {''Marc'',
    ''Helen''}` | 由于没有自然顺序且没有访问的键，选择单个元素是没有意义的（您必须已经知道该元素才能访问它） |'
  id: totrans-331
  prefs: []
  stylish: true
  type: TYPE_TB
  zh: '| `集合` | 不可排序的对象集合（可能是不同类型），必须是唯一的（对象在集合中只能出现一次） | 以逗号分隔的元素在大括号中：`x = {''Marc'',
    ''Helen''}` | 由于没有自然顺序且没有访问的键，选择单个元素是没有意义的（您必须已经知道该元素才能访问它） |'
- en: 21.9 练习的解决方案
  id: totrans-332
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
  zh: 21.9 练习的解决方案
- en: 练习 21.1 `str`对象的其他方法的一些示例是：
  id: totrans-333
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 21.1 `str`对象的其他方法的一些示例是：
- en: '`find(''sub'')`：在`str`对象的字符串中搜索`sub`，并返回找到的子字符串的第一个字符的索引，如果未找到子字符串，则返回−1。这个过程是区分大小写的。使用示例：`>>>
    x = ''Hello world!''` `>>> x.find(''wo'') 6` `>>> x.find(''WO'') -1` `>>> x.upper().find(''WO'')
    6`'
  id: totrans-334
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`find(''sub'')`：在`str`对象的字符串中搜索`sub`，并返回找到的子字符串的第一个字符的索引，如果未找到子字符串，则返回−1。这个过程是区分大小写的。使用示例：`>>>
    x = ''Hello world!''` `>>> x.find(''wo'') 6` `>>> x.find(''WO'') -1` `>>> x.upper().find(''WO'')
    6`'
- en: 在最后的示例中，字符串首先被转换为大写。`x.upper()`返回转换为大写的字符串。这当然又是一个`str`对象。然后使用其`find()`方法进行搜索。这次返回了一个命中。
  id: totrans-335
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 在最后的示例中，字符串首先被转换为大写。`x.upper()`返回转换为大写的字符串。这当然又是一个`str`对象。然后使用其`find()`方法进行搜索。这次返回了一个命中。
- en: 可以使用进一步的参数来限制要搜索的字符串范围；帮助中的规范 `x.find('sub'[, start[, end]]) -> int` 意味着由于`start`和`end`是`find()`的可选参数，因此可以指定也可以不指定。这就是为什么它们各自被方括号括起来。注意括号顺序的细微差别：围绕`end`参数的方括号被包含在围绕`start`参数的方括号中。这意味着`end`只能在指定了`start`的情况下被指定，但`start`可以在不指定`end`的情况下使用！
  id: totrans-336
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 可以使用进一步的参数来限制要搜索的字符串范围；帮助中的规范 `x.find('sub'[, start[, end]]) -> int` 意味着由于`start`和`end`是`find()`的可选参数，因此可以指定也可以不指定。这就是为什么它们各自被方括号括起来。注意括号顺序的细微差别：围绕`end`参数的方括号被包含在围绕`start`参数的方括号中。这意味着`end`只能在指定了`start`的情况下被指定，但`start`可以在不指定`end`的情况下使用！
- en: 在`->`之后，您会找到函数返回值的类型，在我们的例子中是`int`，因为索引作为数字返回。
  id: totrans-337
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
  zh: 在`->`之后，您会找到函数返回值的类型，在我们的例子中是`int`，因为索引作为数字返回。
- en: '`capitalize()`：将字符串的首字母大写（仅首个单词！），并将所有其他字符转换为小写。使用示例：`>>> x = ''hello world''`
    `>>> x.capitalize() ''Hello world''`'
  id: totrans-338
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`capitalize()`：将字符串的首字母大写（仅首个单词！），并将所有其他字符转换为小写。使用示例：`>>> x = ''hello world''`
    `>>> x.capitalize() ''Hello world''`'
- en: '`is.lower()`，`is.upper()`：检查字符串是否全为小写或全为大写。使用示例：`>>> x.isupper() False` `>>>
    x = ''HELLO WORLD''` `>>> x.isupper() True`'
  id: totrans-339
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`is.lower()`，`is.upper()`：检查字符串是否全为小写或全为大写。使用示例：`>>> x.isupper() False` `>>>
    x = ''HELLO WORLD''` `>>> x.isupper() True`'
- en: '`center(width, [fillchar])`：创建一个长度为`width`的字符串，由`str`对象的字符串居中。左右两侧用填充字符“填充”（默认情况下，如果未指定，则为空格）。使用示例：`>>>
    x = ''Hello World''` `>>> x.center(50, ''*'') ''********************Hello World********************''
    练习 21.2 一个程序，读取用户的年龄（以年为单位）并将其输出为分钟，可能如下所示：`age = input(''Please enter your age
    in years:'')` `minutes = int(age) * 365 * 24 * 60` `print(''With'', age, ''you
    have already experienced at least'', minutes)` 练习 21.3'
  id: totrans-340
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`center(width, [fillchar])`：创建一个长度为`width`的字符串，由`str`对象的字符串居中。左右两侧用填充字符“填充”（默认情况下，如果未指定，则为空格）。使用示例：`>>>
    x = ''Hello World''` `>>> x.center(50, ''*'') ''********************Hello World********************''
    练习 21.2 一个程序，读取用户的年龄（以年为单位）并将其输出为分钟，可能如下所示：`age = input(''Please enter your age
    in years:'')` `minutes = int(age) * 365 * 24 * 60` `print(''With'', age, ''you
    have already experienced at least'', minutes)` 练习 21.3'
- en: 让我们首先为具有索引 3 和 4 的列表元素分配一个对象。我们从一个整数开始：
  id: totrans-341
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 让我们首先为具有索引 3 和 4 的列表元素分配一个对象。我们从一个整数开始：
- en: '`>>>` `first_names` = `[''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names [3:4]` = 23 `Traceback (most recent call last):` `File "<input>",
    line 1, in <module>` `TypeError: can only assign an iterable`'
  id: totrans-342
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `first_names` = `[''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names [3:4]` = 23 `Traceback (most recent call last):` `File "<input>",
    line 1, in <module>` `TypeError: can only assign an iterable`'
- en: 'We get an error message. Generally, Python cannot assign something which is
    itself not a list to a list/selection from a list (unless the selection contains
    only one element). Contrary to what one might expect, Python does not simply replace
    the elements 3 and 4, i.e. `‘Jimmy’` and `‘Cathy’` (indexing starts at 0!), with
    the number 23\. The picture changes when we “wrap” the number 23 in a list:'
  id: totrans-343
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 我们得到了一个错误信息。通常，Python无法将一个非列表对象分配给列表/从列表选择的元素（除非该选择只包含一个元素）。与预期相反，Python不会简单地用数字
    23 替换索引 3 和 4，即`‘Jimmy’`和`‘Cathy’`（索引从 0 开始！）。当我们将数字 23“包装”在列表中时，情况发生了变化：
- en: '`>>>` `first_names` = `[''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names[3:4]` = `[23]` `>>>` `first_names` = `[''Beverly'', ''Thomas'',
    ''Marc'', 23]`'
  id: totrans-344
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `first_names` = `[''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names[3:4]` = `[23]` `>>>` `first_names` = `[''Beverly'', ''Thomas'',
    ''Marc'', 23]`'
- en: Now the two selected elements are actually replaced by the list containing only
    the number 23\. But since this is shorter than the replaced partial list, our
    list `first_names` is `shortened` accordingly.
  id: totrans-345
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在，两个选中的元素实际上被只包含数字 23 的列表替换了。但由于这个列表比被替换的部分列表要短，我们的列表`first_names`也因此被`缩短`了。
- en: 'Now let’s try something else. This time we replace the part list with a string:'
  id: totrans-346
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 现在让我们尝试其他操作。这次我们用一个字符串替换了部分列表：
- en: '`>>>` `first_names` = `[''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names[3:4]` = `''Amy''` `>>>` `first_names` = `[''Beverly'', ''Thomas'',
    ''Marc'', ''A'', ''m'', ''y'']`'
  id: totrans-347
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `first_names` = `[''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names[3:4]` = `''Amy''` `>>>` `first_names` = `[''Beverly'', ''Thomas'',
    ''Marc'', ''A'', ''m'', ''y'']`'
- en: 'Unlike the assignment `first_names[3:4] = 23` above, this time we don’t get
    an error message. But something seemingly strange happens: The partial list `first_names[3:4]`
    is replaced by the letters of the name `Amy`, with each letter becoming a new
    list element. The reason is that strings can also be interpreted as lists. Therefore,
    the assignment `first_names[3:4] = ''Amy''` is ultimately a replacement by a list,
    namely by the list `[''A'', ''m'', ''y'']`.'
  id: totrans-348
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 与上面`first_names[3:4] = 23`的赋值不同，这次我们没有得到错误信息。但发生了一些看似奇怪的事情：部分列表`first_names[3:4]`被名字`Amy`的字母替换，每个字母都变成了新的列表元素。原因在于字符串也可以被当作列表来解释。因此，赋值`first_names[3:4]
    = 'Amy'`最终是用一个列表来替换，即用列表`['A', 'm', 'y']`替换。
- en: Exercise 21.4
  id: totrans-349
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 21.4
- en: '`No solution`.'
  id: totrans-350
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`没有解决方案`。'
- en: Exercise 21.5
  id: totrans-351
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 21.5
- en: 'Here we are now dealing with a nested dictionary. For the sake of clarity,
    you can see the dictionary definition below with line breaks (you remember from
    ► Sect. [20.​1.​2](474412_1_En_20_Chapter.xhtml#Sec3) that a statement can be
    wrapped inside curly braces):'
  id: totrans-352
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 这里我们现在处理的是一个嵌套字典。为了清晰起见，下面可以看到带有换行符的字典定义（你应该记得，► 第[20.1.2节](474412_1_En_20_Chapter.xhtml#Sec3)中提到，语句可以被包裹在大括号中）：
- en: '`>>>` `d` = `{ 12345: {... ''description'': ''Plastic Garden Chair "Garden
    Friend"'', ... ''manufacturer'': ''Garden Paradise Inc.'', ... ''price'': 10.99
    ... }, 56789: {... ''description'': ''Garden shovel, stainless steel'', ... ''manufacturer'':
    ''Big G Gardening Tools Inc.'', ... ''price'': 49.90 ... }}`'
  id: totrans-353
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `d = { 12345: {... ''description'': ''塑料花园椅 "Garden Friend"'', ... ''manufacturer'':
    ''Garden Paradise Inc.'', ... ''price'': 10.99 ... }, 56789: {... ''description'':
    ''花园铲，不锈钢'', ... ''manufacturer'': ''Big G Gardening Tools Inc.'', ... ''price'':
    49.90 ... }}`'
- en: 'Access is then via two keys:'
  id: totrans-354
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 访问则通过两个键：
- en: '`>>>` `d[12345][''price'']` 10.99'
  id: totrans-355
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`>>>` `d[12345][''price'']` 10.99'
- en: The expression `d[12345]` returns a dictionary, and a value is selected from
    this dictionary using a key that exists in this dictionary.
  id: totrans-356
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 表达式 `d[12345]` 返回一个字典，并通过该字典中存在的键来选择该字典中的值。
- en: 'Exercise 21.6 Some examples of other set operations:'
  id: totrans-357
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 21.6 其他集合操作的一些示例：
- en: '`difference(other_set)`: Returns the elements that exist in `other_set` but
    not in the set whose `difference()` method was called. Usage example: `>>>` `friends_thomas`
    = `{''Will'', ''Beverly'', ''Peter'', ''Michael''}` `>>>` `friends_julia` = `{''Peter'',
    ''Will'', ''Helen'', ''Michael'', ''Caroline''}` `>>>` `friends_julia.difference(friends_thomas)`
    `{''Caroline'', ''Helen''}`'
  id: totrans-358
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`difference(other_set)`：返回存在于`other_set`中但不在调用`difference()`方法的集合中的元素。使用示例：`>>>`
    `friends_thomas = {''Will'', ''Beverly'', ''Peter'', ''Michael''}` `>>>` `friends_julia
    = {''Peter'', ''Will'', ''Helen'', ''Michael'', ''Caroline''}` `>>>` `friends_julia.difference(friends_thomas)`
    `{''Caroline'', ''Helen''}`'
- en: '`remove(***element***)`: Deletes an element from a set. Usage example: `>>>`
    `friends_julia.remove(''Helen'')` `>>>` `friends_julia` `{''Peter'', ''Will'',
    ''Michael'', ''Caroline''}`'
  id: totrans-359
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`remove(***element***)`：从集合中删除一个元素。使用示例：`>>>` `friends_julia.remove(''Helen'')`
    `>>>` `friends_julia` `{''Peter'', ''Will'', ''Michael'', ''Caroline''}`'
- en: '`isdisjoint(***other_set***)`: Checks if the set whose `isdisjoint()` method
    is called and the other set are disjoint, that is, have no elements in common.
    Usage example: `>>>` `friends_thomas = {''Will'', ''Beverly'', ''Peter'', ''Michael''}`
    `>>>` `friends_julia = {''Peter'', ''Will'', ''Helen'', ''Michael''}` `>>>` `friends_thomas.isdisjoint(friends_julia)`
    `False`'
  id: totrans-360
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
  zh: '`isdisjoint(***other_set***)`：检查调用`isdisjoint()`方法的集合与另一个集合是否没有交集，即它们没有共同的元素。使用示例：`>>>`
    `friends_thomas = {''Will'', ''Beverly'', ''Peter'', ''Michael''}` `>>>` `friends_julia
    = {''Peter'', ''Will'', ''Helen'', ''Michael''}` `>>>` `friends_thomas.isdisjoint(friends_julia)`
    `False`'
- en: '`Exercise 21.7`'
  id: totrans-361
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 练习 21.7
- en: 'The two classes `Customer` and `BusinessCustomer` could look like this:'
  id: totrans-362
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: 两个类 `Customer` 和 `BusinessCustomer` 可能是这样的：
- en: '`class` `Client`: `firstname = ''''` `lastname = ''''` `street = ''''` `city
    = ''''` `zip = ''''` `email = ''''` `class` `BusinessCustomer`(`Customer`): `company
    = ''''` `payment_terms = 14` `taxid = ''''`'
  id: totrans-363
  prefs: []
  stylish: true
  type: TYPE_NORMAL
  zh: '`class` `Client`: `firstname = ''''` `lastname = ''''` `street = ''''` `city
    = ''''` `zip = ''''` `email = ''''` `class` `BusinessCustomer`(`Customer`): `company
    = ''''` `payment_terms = 14` `taxid = ''''`'
