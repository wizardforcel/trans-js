- en: © The Author(s), under exclusive license to Springer Fachmedien Wiesbaden GmbH,
    part of Springer Nature 2024J. L. ZuckarelliLearn coding with Python and JavaScript
    [https://doi.org/10.1007/978-3-658-42912-6_21](https://doi.org/10.1007/978-3-658-42912-6_21)
  prefs: []
  type: TYPE_NORMAL
- en: '21. Variables & Objects: How Do I Store Data to Work With?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1)München, GermanyOverview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll shift our focus to handling variables in Python. Additionally,
    we'll explore how to aggregate various variables into list-like structures (arrays)
    and map key-value pairs in hashes (dictionaries). Given Python's object-oriented
    nature, where all variables are objects possessing attributes and methods, our
    discussion will extend beyond merely creating, assigning, and converting variables
    across different data types. We'll delve into Python's implementation of object
    orientation and demonstrate how you can leverage object-oriented programming in
    Python to benefit your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create variables in Python and assign values to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: what basic types of variables there are, and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: what the object character of variables expresses and what this means for your
    practical work with variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how to convert variables from one data type to another, and where Python does
    the conversion for you automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: which more complex data types (for example, lists and dictionaries) exist and
    how you use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how class definitions work in Python, and how to define and work with object
    classes yourself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 21.1 Creating and Assigning Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike some other languages, creating variables in Python is quite simple. This
    is because variables do not need to be declared in Python; they are simply created
    automatically the first time they are used. Thus, the assignment
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x = 5creates an (integer) variable and sets its value to 5 (the **>>>**
    is the prompt character that prompts you for input, so you don’t enter this!)'
  prefs: []
  type: TYPE_NORMAL
- en: We have named our variable **x** here for simplicity. In ► Chap. [11](474412_1_En_11_Chapter.xhtml),
    we said that variable names should ideally be meaningful and allow the reader
    of the code to guess what kind of content the variable will have. Even though
    we’re making it very simple here in these examples, Python gives you every opportunity
    to use meaningful variable names. As you already know from ► Sect. [20.​1.​3](474412_1_En_20_Chapter.xhtml#Sec4),
    names in Python can consist of upper and lower case letters, digits, and the underscore
    character. Numbers are not allowed at the beginning of the variable name but can
    be used everywhere else in the name. In addition, the underscore at the beginning
    (and sometimes also at the end) of names has a special meaning in Python, which
    we will discuss later. It is therefore advisable not to start or end variable
    names with an underscore. Otherwise, however, you are completely free to name
    your variables as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Python decides for itself what type the variable should have. Over the lifetime
    of the variable, the type may well change, for example, by assigning a different
    type of data to the variable. With
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x = ''A string (str) variable''not only the value but also the data
    type of the variable is changed, it is now a string variable. In the next section,
    when we look at the object character of variables, you will learn about a second
    way to create variables in Python beyond assigning values.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with the Python console, you can display the value of a variable
    at any time by typing its name.
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x''A string (str) variable''If, on the other hand, you write your code
    in a Python script, you must use the **print()** function, which you learned about
    in the previous chapter, to print the contents of the variable:print(x)'
  prefs: []
  type: TYPE_NORMAL
- en: If you write only the variable name in your Python program, there is no output.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, you cannot access variables that you create in your program in the
    console. The namespace of the console and that of your program are separate. If
    you use a variable in the console that you have created in the program, you will
    receive an error message (unless, of course, you have already created a variable
    with the same name via the console—but then you would also work with this variable
    and not with the one that you use in your program).
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you will accidentally access a variable that does not exist, for
    example because you mistyped the identifier. Then you will get an error message
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Traceback (most recent call last):****File "D:\Applications\Anaconda\lib\site-packages\IPython\core\interactiveshell.py",
    line 2961, in run_code****exec(code_obj, self.user_global_ns, self.user_ns)****File
    "<ipython-input-16-9063a9f0e032>", line 1, in <module>.****y****NameError: name
    ''y'' is not defined**'
  prefs: []
  type: TYPE_NORMAL
- en: The crucial thing here is the last line. It tells us that a variable called
    **y**, which we have tried to access here, does not exist at all.
  prefs: []
  type: TYPE_NORMAL
- en: 21.2 Deleting Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once created, variables can be deleted again with the help of the **del** command.
    This makes sense, especially if the variable occupies a lot of memory (for example,
    if you have completely read in a large file) and you want to release the memory
    again after you no longer need the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you delete a variable in the Python console and then try to access it, you
    will get an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** del x**>>>** x**Traceback (most recent call last):****File "<input>",
    line 1, in <module>****NameError: name ''x'' is not defined**'
  prefs: []
  type: TYPE_NORMAL
- en: The error message talks about the *name* **x** not being defined. Like many
    other programming languages, Python makes a clear distinction between the value
    of the variable and its name. The name is just a reference to the value, which
    is located in a certain area of memory. In principle, the name and value exist
    independently of each other. Now, it could be that several names refer to exactly
    the same value, that is, to the same location in memory. If the value stored in
    the memory in question changes, the values of all these variables also change
    accordingly. In such a situation with multiple names all pointing to the same
    memory location, if you delete one name, the value and the other names (and therefore
    variables) are preserved. You can then simply no longer address the value under
    the deleted name, but only under the remaining names.
  prefs: []
  type: TYPE_NORMAL
- en: Python counts the names that point to a value (the result is called the *reference
    counter*). If there is no more name pointing to a certain value, Python deletes
    the value itself. This process is called *garbage collection*. However, since
    there will usually be only one name that has a *binding to* the value of your
    variable, when you call the **del** command, the value itself is usually also
    deleted and the memory in question is freed.
  prefs: []
  type: TYPE_NORMAL
- en: 21.3 Basic Types of Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section we deal with the most important types of variables. We will
    first concentrate on variables that contain only one value. In the following section,
    we will look at more complex data types that can hold multiple values at the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 21.3.1 Numbers (int, float)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Numbers in Python come in the form of integers (**int**) or floating-point numbers
    (**float**). Unlike many other programming languages, **int** variables in Python
    do not have a fixed range of values beyond which another data type that takes
    up more memory must be chosen. Python simply reserves as much memory for the variable
    as is needed to hold the value it contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this very nicely by looking at the size of the variables using
    the **sys.getsizeof(*****object*****)** function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x = 5**>>>** sys.sizeof(x)14**>>>** x = 100000000000018'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the memory requirement has increased from the original 14 bytes
    to 18 bytes after we assigned a significantly larger value, one trillion, to the
    variable instead of 5.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why even a small value like 5 still requires 14 bytes in memory.
    In many other programming languages such a variable would have the size of only
    2 bytes (= 16 bits). This can represent numbers between 0 and 2^(16) = 65,536\.
    So why is Python such a “memory hog”? The answer has to do with the way Python
    stores variables and will be discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decimal separator for floating point numbers is the period, as is customary
    in English. The biggest problem with this in Python is that if you habitually
    use the comma instead of the period (as it is common in many European and South
    American countries), you don’t get an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** pi = 3.1415926535**>>>** pi(3, 1415926535)'
  prefs: []
  type: TYPE_NORMAL
- en: Python misinterpreted our input and created a variable of a completely different
    type, namely a *tuple*. We will deal with these tuples in more detail a little
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 21.3.2 Strings (str)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strings, variables of type **str**, can be enclosed in Python in either single
    or double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x = "A text in double quotes."**>>>** x''A text in double quotes.''**>>>**
    y = ''A text in single quotes.''**>>>** y''A text in single quotes.'''
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of being able to use both types of quotation marks is that in
    Python you have no difficulty in displaying quotation marks within a text, because
    the two different variants of quotation marks mean that there is no danger of
    confusion between the quotation marks that are part of the text and those that
    delimit the string at the front and back:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** quote = ''Hamlet said, "To be or not to be. That is the question here!"''**>>>**
    quote''Hamlet said, "To be or not to be. That is the question here!"'''
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will have noticed, Python automatically encloses the output of the variable’s
    contents in (single) quotes to make it clear that this is a string. The following
    example shows that this is a practical feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x = ''5''**>>>** x''5''**>>>** x = 5**>>>** x5'
  prefs: []
  type: TYPE_NORMAL
- en: In the first assignment, the content of the variable is a string, in the second
    case it is a number, which could now be used in a calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, it is very easy to create strings that go over multiple lines. To
    do this, simply enclose the text in triple quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: z = """The text starts on the first lineand continues on the second line."""print(z)This
    program results in the following output:The text begins on the first lineand continues
    on the second line.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the line break is preserved in the output. You can use this feature
    not only when you are working in script mode, i.e., writing a program to execute
    it afterwards. Even in interactive mode, Python recognizes after pressing the
    <ENTER> key that you have started a multiline string here, and therefore waits
    with the execution of the statement (which is, after all, normally triggered with
    <ENTER>) and allows you to continue writing on the next line instead.
  prefs: []
  type: TYPE_NORMAL
- en: You have already become acquainted with this type of string as *docstrings in*
    the previous chapter. Docstrings are placed in your program code as documentation,
    but not with the intention of being further processed or output to the screen
    for the end user of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you want to wrap strings in the program code without this wrapping
    being visible when the string is output; the point is simply to make the program
    code clearer (remember the recommended limit of 79 characters per line from ►
    Sect. [20.​1.​1](474412_1_En_20_Chapter.xhtml#Sec2)!). In this situation you can
    use backslash (**\**):'
  prefs: []
  type: TYPE_NORMAL
- en: message = 'Hello ' \'world'print(message)
  prefs: []
  type: TYPE_NORMAL
- en: 'This code generates the output:'
  prefs: []
  type: TYPE_NORMAL
- en: Hello world
  prefs: []
  type: TYPE_NORMAL
- en: This means that there are not two strings on two different lines, but only one
    string, which is distributed over two lines in the code for practical reasons
    only.
  prefs: []
  type: TYPE_NORMAL
- en: 21.3.3 Truth Values (bool)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Truth values, or the logical values true and false, are represented in Python
    with the data type **bool**, a reverence to the English mathematician and logician
    George Boole, already mentioned in the first part of the book, who made a significant
    contribution to the development of formal logic in the nineteenth century.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the other variable types, variables of type **bool** can only take on
    two values: **True** and **False**. Pay attention to upper and lower case! The
    constants **True** and **False** must each be written with a capital letter. If
    we were to write **false** instead, Python would assume that we wanted to use
    a variable called **false**, which of course does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x = false**Traceback (most recent call last):****File "<input>", line
    1, in <module>****NameError: name ''false'' is not defined****>>>** x = False**>>>**
    xFalse'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, do not use quotes because they would make the variable a **str** variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x = ''False''**>>>** x''False''**>>>** type(x)**<class ''str''>****>>>**
    x = False**>>>** xFalse**>>>** type(x)<class ''bool''>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python stores the values **True** and **False** internally as 0 and 1, so you
    can calculate with them just like with normal numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x = 5 * True**>>>** x5'
  prefs: []
  type: TYPE_NORMAL
- en: 21.3.4 None
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A special data type is **NoneType**. You cannot create your own variables of
    this type. Instead, Python has already created an object of type **NoneType**
    for you, namely **None** (how creative!). This allows you to assign the value
    **None** to a variable, which means that this variable currently has no real,
    meaningful value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x = None**>>>** xNone**>>>** type(x)**<class ''NoneType''>**'
  prefs: []
  type: TYPE_NORMAL
- en: But isn’t that a bit awkward? Couldn’t we just assign the variable the value
    **0** if the variable is a number, or **''**, i.e., an empty string, if it is
    a string? Of course, we could indeed do that, but only if the values **0** or
    **''** have no meaning in terms of content. However, when you measure temperatures,
    for example, or survey a person’s attitude to a topic on a scale from −5 to +5,
    the value 0 can well have a real meaning of its own. In this case, it makes a
    difference whether the respondent has given the value 0 and thus signaled a neutral
    attitude to the topic or has not answered the question at all (**None**). In order
    to make this distinction visible, it makes sense to have a special indicator for
    “no real value present”, and this is exactly what the **None** value is.
  prefs: []
  type: TYPE_NORMAL
- en: 'You cannot calculate with **None**, by the way:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** None + 1**Traceback (most recent call last):****File "<input>", line
    1, in <module>****TypeError: unsupported operand type(s) for +: ''NoneType'' and
    ''int''.**'
  prefs: []
  type: TYPE_NORMAL
- en: If **None** is evaluated as a logical expression, it is treated as **False.**
    So, **None** is really not good for anything other than indicating that a variable
    does not contain a real value.
  prefs: []
  type: TYPE_NORMAL
- en: 21.3.5 Other Data Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the data types discussed so far, Python inherently knows several
    other data types, such as **complex**, a data type used to represent the complex
    numbers known from mathematics, which consist of a real and an imaginary part.
  prefs: []
  type: TYPE_NORMAL
- en: Various packages (program libraries) that are not part of the standard language
    also provide their own data types. One example is the *NumPy* package, a library
    for efficient work with vectors and matrices that is an important foundation for
    work with statistical and machine learning methods, fields in which Python has
    found considerable use.
  prefs: []
  type: TYPE_NORMAL
- en: Not only are some new complex data types provided by *NumPy*, but also several
    basic data types are available with *NumPy*. For the already known data types
    **int** and **float**, for example, *NumPy* has its own alternatives, which are
    characterized by the fact that they do not adapt in their memory requirements
    to the variable content, as the standard data types in Python do, but always occupy
    a fixed number of bytes in memory. This allows for very fast computation with
    such variables, especially with large fields of such variables, and efficient
    computation is an essential skill, especially in processing large amounts of data,
    such as in machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: However, since we can get by for most use cases with the data types discussed
    here, we’ll leave it at that and now take a closer look at the character of variables
    in Python in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 21.4 Variables as Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 21.4.1 Attributes and Methods of Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python is strongly influenced by the object-oriented programming paradigm. Unlike
    some other programming languages that have also adopted this programming approach,
    such as C++, in Python even the simplest variables are objects.
  prefs: []
  type: TYPE_NORMAL
- en: A variable in Python is ultimately always the concrete instance of a *class*,
    for example the class **float** for floating point numbers. The class **float**
    has a whole series of methods and attributes that you can access via the concrete
    instance of the class, i.e., variable object. If you are no longer familiar with
    the terms class and instance/object, simply turn back a few pages to ► Sect. [11.​7](474412_1_En_11_Chapter.xhtml#Sec10)
    and refresh your knowledge before continuing!
  prefs: []
  type: TYPE_NORMAL
- en: If you work with *PyCharm* and enter the name of a variable you already use
    in your program in the code editor, followed by a dot, a small code completion
    menu pops up where you can see the methods and properties that belong to the class
    of your variable. You can do the same thing in the console by typing a variable
    that you have already assigned a value to via the Python console, again followed
    by a period.
  prefs: []
  type: TYPE_NORMAL
- en: The dot is the operator in Python that allows you to access the methods and
    attributes of an object. Therefore, when you type a dot after the variable name,
    *PyCharm* expects you to use a method or attribute of that variable and displays
    the corresponding list. You can see an example of this in ◘ Fig. [21.1](#Fig1).![](../images/474412_1_En_21_Chapter/474412_1_En_21_Fig1_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a code completion menu in an editor window. The editor displays
    the text, x dot, and the code completion menu displays identifiers such as image,
    real, numerator, and denominator.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 21.1
  prefs: []
  type: TYPE_NORMAL
- en: Code completion menu for an integer variable, called from the code editor
  prefs: []
  type: TYPE_NORMAL
- en: The menu entries marked with a small “m” are the methods that the class **float**
    makes available to the object, the entries marked with a small “p” are the attributes
    (“p” for *property*). You can also see where the object got its methods or attributes
    from in the code completion menu on the right. In our case, all methods and attributes
    come directly from the class **int**, but some others will also come from the
    more general class **object**, from which the class **int** is derived. In a sense,
    the class **object** is the parent class for the class **int** and inherits methods
    and attributes from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a **float** variable in the console and call the method **is_integer()**
    for this variable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x = 5.3**>>>** x.is_integer()False'
  prefs: []
  type: TYPE_NORMAL
- en: The method checks whether the floating-point number is also an integer, which
    is of course not the case in our example here. The class method is_integer() does
    not need any function arguments, because it automatically refers to the object
    for which we call it, i.e. **x**. Although no arguments need to be passed to the
    function, it must still always be called with the (empty) round brackets that
    identify it as a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the class **float** has not only methods, but also some attributes.
    One of these attributes is **__class__**. It represents the class of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x.__class__**<class ''float''>**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can also determine the object type with the function **type(*****object*****)**,
    to which the object is passed as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** type(x)**<class ''float''>**'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the help of the function **isinstance(*****object*****,** ***class*****)**,
    which like **type(*****object*****)** is part of the Python standard library,
    you can determine whether a variable is of a certain type; with our object-oriented
    terminology more precisely formulated, you can determine whether a variable is
    an *instance* of a certain *class*. To do this, the variable and the class to
    be checked for are passed to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** isinstance(x, str)False**>>>** isinstance(x, float)True'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at the methods of the objects, i.e., the functions
    that the class makes available to the object. A little earlier on, we already
    got to know **is_integer()**, a method of the class **float**, which checks the
    current object, the object *whose* method we are calling, to see whether it is
    an integer. As you remember, we don’t have to pass the variable we want to check
    to this special function, because the method is already part of the object and
    therefore knows which object it should work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at string variables:'
  prefs: []
  type: TYPE_NORMAL
- en: text = 'Strings in Python have many interesting methods.'If you are working
    with *PyCharm* and in the script editor, or in the Python console you can now
    type **text.** (with the dot operator) in the script editor or in the Python console,
    and the familiar context menu opens with the attributes and methods that the string
    class **str** makes available to your **text** object. You will immediately see
    that a rich selection of different methods is available here (◘ Fig. [21.2](#Fig2)).![](../images/474412_1_En_21_Chapter/474412_1_En_21_Fig2_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a code completion menu in an editor window. The editor displays
    the text, text dot, and the code completion menu displays identifiers such as
    upper, find, join, and count.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 21.2
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods of a **str** object Let’s try some of them out:'
  prefs: []
  type: TYPE_NORMAL
- en: '**lower()** and **upper()** transform the string into lower and upper case
    letters respectively:**>>>** text = ''An ordinary text, with a few words and punctuation
    marks.''**>>>** text.lower()''an ordinary text, with a few words and punctuation
    marks.''**>>>** text.upper()''AN ORDINARY TEXT, WITH A FEW WORDS AND PUNCTUATION
    MARKS.'''
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**isnumeric()** checks if the string could be turned into a number:**>>>**
    text.isnumeric()False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**count(*****substring*****)** counts the occurrences of the (partial) string
    **substring** passed as an argument to the method; it is case-sensitive, as you
    can see in the following example (only the “an” in “and” is counted):**>>>** text.count(''an'')1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**replace(*****old*****,** ***new*****,** ***occurrences*****)** replaces the
    specified number of occurrences of the old string with the new string; specifying
    the number of occurrences to replace is optional, so you can omit it, which will
    simply replace *all* occurrences:**>>>** text.replace(''words'', ''terms'', 1)''An
    ordinary text, with a few terms and punctuation marks.'''
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**__len__()** determines the length of the string:**>>>** text.__len__()58'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see from the two leading and trailing underscores, this is a special
    core Python method.21.1 [20 min]
  prefs: []
  type: TYPE_NORMAL
- en: Objects of type **str**, i.e., string variables, have several interesting methods
    other than the ones presented here as an example. Find out what other methods
    are available for **str** objects and try them out in the Python console. If you
    don’t understand a method or can’t use it successfully, don’t dwell on it and
    move on to the next method.
  prefs: []
  type: TYPE_NORMAL
- en: You can read about the details of the methods in the help. To do this, call
    the help with **help()** in the Python console and put **str.** in front of the
    methods when calling them, so that Python knows exactly which class you want to
    look at for the method (there could be several classes that have a method of that
    name), for example **help(str.isnumeric).**
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed during the exercise that methods such as **upper()**,
    **lower()**, and **replace()** do not modify the object for which they are called,
    but merely *return* a *modified copy of* the object. If you want to change the
    original object, you must assign the changed version, i.e., the return value of
    the method, to it. Let’s take a closer look at this using **upper()** as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** text = ''An ordinary text, with a few words and punctuation marks.''**>>>**
    text.upper()''AN ORDINARY TEXT, WITH A FEW WORDS AND PUNCTUATION MARKS.''**>>>**
    text''An ordinary text, with a few words and punctuation marks.''**>>>** text
    = text.upper()**>>>** text''AN ORDINARY TEXT, WITH A FEW WORDS AND PUNCTUATION
    MARKS.'''
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, calling the **text.upper()** method leaves the **text** variable
    completely unchanged. Only assigning the return value of the method to our original
    variable changes the object **text**.
  prefs: []
  type: TYPE_NORMAL
- en: 21.4.2 Creating Variables with the Constructor Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we saw that variables can be created simply by assigning
    a value to them for the first time. But there is another way to create new variables.
    As you know by now, variables are objects, that is, instances of a class. Like
    all classes, these objects have a constructor method, which is a special method
    that creates an object of that type. We can use these constructors to create variables.
    Let’s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x = int(3)**>>>** x3**>>>** type(x)**<class ''int''>**'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the constructor method returns an **int** object with the value passed
    to it as argument. This alone is perhaps not all that interesting; after all,
    we could have achieved the same effect more easily with the simple assignment
    **x = 3**. What is interesting is that we can also pass a floating-point number
    or a string to the constructor and it will create an **int** object from it. In
    the case of the floating-point number, the decimal part is simply ignored. If
    a string is passed to the constructor, the text must of course be convertible
    into a number, otherwise we get an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x = int(3.7)**>>>** x3**>>>** x = int(''3.7'')**>>>** x3**>>>** x =
    int(''abc'')**Traceback (most recent call last):****File "<input>", line 1, in
    <module>****ValueError: invalid literal for int() with base 10: ''abcd''.**'
  prefs: []
  type: TYPE_NORMAL
- en: 21.5 Converting Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is not uncommon to need to change the data type of variables. To do this,
    consider the following example, in which we add an integer variable and a floating-point
    number variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x = 2**>>>** type(x)**<class ''int''>****>>>** x = x + 3.7**>>>** x5.7**>>>**
    type(x)**<class float''>**'
  prefs: []
  type: TYPE_NORMAL
- en: When we created the variable, Python automatically chose **int** as the data
    type because we had assigned an integer to the variable. But when we then added
    3.7, a floating-point number, Python changed the type to **float** to accommodate
    the new value. So, Python *implicitly* converts without us having to intervene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s try something else:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x = 2**>>>** x = x + ''2.7''**Traceback (most recent call last):****File
    "<input>", line 1, in <module>****TypeError: unsupported operand type(s) for +:
    ''int'' and ''str''.**'
  prefs: []
  type: TYPE_NORMAL
- en: If we add a string to our variable **x**, Python no longer implicitly converts.
    Maybe it works the other way around, where we define **x** as a string and add
    a number to it?
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** x = ''2''**>>>** x = x + 3.7**Traceback (most recent call last):****File
    "<input>", line 1, in <module>****TypeError: can only concatenate str (not "float")
    to str**'
  prefs: []
  type: TYPE_NORMAL
- en: This doesn’t work either. So, Python does not convert between numbers and strings
    implicitly. Nevertheless, we sometimes need to convert strings to numbers to compute
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at this with an example. Do you remember the conversion from Kelvin
    to Celsius from ► Sect. [12.​2.​2](474412_1_En_12_Chapter.xhtml#Sec6)? There we
    discussed a simple program that takes a temperature in Kelvin as user input and
    converts it to degrees Celsius. We will now develop this program in Python. To
    do this, we make use of the **input(*****prompt*****)** function for input, which
    prompts the user for input, and returns that input in the form of a string. With
    this knowledge, it would be obvious to write code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'temp_kelvin = input(''Please enter a temperature in Kelvin: '')temp_celsius
    = temp_kelvin + 273.15print(temp_kelvin, ''Kelvin are'', temp_celsius, ''degrees
    Celsius.'')'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this program and enter a temperature in Kelvin, we get output like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Traceback (most recent call last):****File "C:/Users/MyUser/Python/var_examples.py",
    line 54, in <module>.****temp_celsius = temp_kelvin + 273.15****TypeError: can
    only concatenate str (not "float") to str**'
  prefs: []
  type: TYPE_NORMAL
- en: 'By now you understand the problem that occurs here: The **input()** function
    returns a string, but it can’t be computed with because Python doesn’t convert
    to a number implicitly. We need to convert *explicitly*. That’s exactly what we
    do in this modified version of the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'temp_kelvin = input(''Please enter a temperature in Kelvin: '')temp_celsius
    = float(temp_kelvin) + 273.15print(temp_kelvin, ''Kelvin are'', temp_celsius,
    ''degrees Celsius.'')'
  prefs: []
  type: TYPE_NORMAL
- en: 'This time we explicitly convert the string variable **temp_celsius** into a
    floating point number, using the **float()** function. You will immediately recognize
    the reference to the last section: **float()** is, of course, the constructor
    method of the class **float** here as well. So, when we convert the string variable
    **temp_kelvin** to a floating-point number, we are doing nothing more than simply
    creating a new **float** object by calling the constructor of this class. We immediately
    initialize the new **float** object with a value; this value may also be a string,
    the **float** constructor then creates a floating point number from it. The *explicit*
    conversion in Python thus runs via the class constructors. They can receive as
    arguments not only a value of the type that the class constructor creates (**float**
    in our case), but also various other types (**str** in our example). In general,
    the explicit conversion thus has the form: ***datatype*****(*****value*****)**.'
  prefs: []
  type: TYPE_NORMAL
- en: 21.2 [10 min]
  prefs: []
  type: TYPE_NORMAL
- en: Write a program that takes the age of the user in years and outputs the number
    of minutes the user has lived (at least).
  prefs: []
  type: TYPE_NORMAL
- en: 21.6 Complex Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 21.6.1 Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 21.6.1.1 Creating and Displaying Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unlike many other programming languages, Python does not know the concept of
    arrays as such. Instead, however, Python has a more general type of variable fields
    of which the array is ultimately a special case: the list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists are *ordered* summaries of *arbitrary* objects. Therefore, an array can
    also be understood as a list because it is nothing more than an ordered summary
    of objects of the *same type*. Lists are created in Python with square brackets,
    as you can see in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** numbers = [1, 2, 3, 4, 5, 6, 7]**>>>** first_names = [''Beverly'',
    ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']'
  prefs: []
  type: TYPE_NORMAL
- en: 'Entering the list name into the console shows us the contents of the list.
    Square brackets around the elements of the list remind us that this is indeed
    a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** numbers[1, 2, 3, 4, 5, 6, 7]**>>>** first_names[''Beverly'', ''Thomas'',
    ''Marc'', ''Jimmy'', ''Cathy'']'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not working in the console but in script mode, i.e. writing a whole
    program, then use the **print()** function for output, which can also process
    lists:'
  prefs: []
  type: TYPE_NORMAL
- en: print(numbers)print(first_names)
  prefs: []
  type: TYPE_NORMAL
- en: Writing the identifier of the list alone, for example **numbers** does not lead
    to an output in the program—unlike in the Python console—as we already saw in
    ► Sect. [21.1](#Sec1).
  prefs: []
  type: TYPE_NORMAL
- en: 21.6.1.2 Selecting Individual Elements of a List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Individual elements of the list can now be accessed by indexing, again using
    square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** numbers[3]4**>>>** firstnames[2]''Marc'''
  prefs: []
  type: TYPE_NORMAL
- en: 'Indexing in Python starts at 0, so the element with index 1 is already the
    *second* element in the list. You can use *negative* indexes to select from the
    back. If we wanted to pick the second name from the back of the list, we could
    write:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** first name[-2]''Jimmy'''
  prefs: []
  type: TYPE_NORMAL
- en: The last element of the list has the index −1, not −0 as you might expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The colon operator can also be used to specify a range as an index. For example,
    if we wanted to select the second to fourth first names, we could do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** first_names[2:5][''Marc'', ''Jimmy'', ''Cathy'']'
  prefs: []
  type: TYPE_NORMAL
- en: The elements with the indices 2, 3 and 4, i.e., the third, fourth and fifth
    element of the list, are selected. Please note that the element with index 5,
    i.e., the sixth element, is not part of the selection. The right border of the
    index specification is—counter-intuitively and unlike in other languages, such
    as R—not part of the selected elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the original list, the selection itself is again a list because we
    have selected several elements. If, on the other hand, we select only a single
    element, the selection is no longer a list, but has the type of the respective
    element of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** type(first_names)**<class ''list''>****>>>** sel = first_namse[2:5]**>>>**
    type(sel)**<class ''list''>****>>>** sel = first_names[2]**>>>** type(sel)**<class
    ''str''>**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When indexing with a range of indexes, one side can also remain open. If the
    left side remains open, the system selects from the beginning of the list; if
    the right side remains open, the system selects to the end of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']**>>>**
    first_names[:3][''Beverly'', ''Thomas'', ''Marc'']**>>>** first_names[3:][''Jimmy'',
    ''Cathy'']'
  prefs: []
  type: TYPE_NORMAL
- en: You could also leave both range boundaries open (**first_names[:]**), then all
    elements of the list would simply be selected (ultimately creating a copy of the
    list). If you want to select several, non-contiguous elements of a list in one
    step, for example the first and third element, this is not quite so easy in Python.
    This is where the use of list-comprehension expressions comes in handy, which
    we will deal with later when we look at the implementation of loops in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 21.6.1.3 Edit Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can use the indexing we just learned about not only to select items from
    a list for display or further processing, but also to modify the items in the
    list directly. In this section, we will look at how you can modify elements of
    a list, add elements to a list, delete elements from a list, sort a list, and
    join multiple lists into a new list.
  prefs: []
  type: TYPE_NORMAL
- en: Change List ElementsLet’s start by changing the value of a list item:**>>>**
    first_names = ['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']**>>>** first_names[1]
    = 'Jason'**>>>** first_names['Beverly', 'Jason', 'Marc', 'Jimmy', 'Cathy']
  prefs: []
  type: TYPE_NORMAL
- en: 'Even entire index ranges can be assigned like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']**>>>**
    first_names[3:5] = [''Joe'', ''Aimee'']**>>>** first_names[''Beverly'', ''Thomas'',
    ''Marc'', ''Joe'', ''Aimee'']'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, make sure that the value you assign is again a list (that is,
    it is enclosed in square brackets and is of the same the length of the sublist
    you want to replace).
  prefs: []
  type: TYPE_NORMAL
- en: 21.3 [5 min]
  prefs: []
  type: TYPE_NORMAL
- en: What happens if the assigned object is not a list or does not have the length
    of the substituted sublist? Try it out and see if you can explain the results!
  prefs: []
  type: TYPE_NORMAL
- en: Lists, like all variables in Python, are objects, so they have corresponding
    attributes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Append Elements to ListsThe **append(*****object*****)** method can be used
    to add an object to the list. This directly changes the list instance for which
    the **append()** method is called:**>>>** first_names = ['Beverly', 'Thomas',
    'Marc', 'Jimmy', 'Cathy']**>>>** first_names.append('Sandy')**>>>** first_names['Beverly',
    'Thomas', 'Marc', 'Jimmy', 'Cathy', 'Sandy']
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to add an element *anywhere in* the list, use the method **insert(*****insert_before_element_index*****,**
    ***object*****)** and pass it the position you want the new element to have and
    the element itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']**>>>**
    first_names.insert(2, ''Sandy'')**>>>** first_names[''Beverly'', ''Thomas'', ''Sandy'',
    ''Marc'', ''Jimmy'', ''Cathy'']Delete Elements from ListsYou can delete items
    from a list with similar ease:**>>>** first_names = [''Beverly'', ''Thomas'',
    ''Marc'', ''Jimmy'', ''Cathy'']**>>>** first_names.__delitem__(4)**>>>** first_names[''Beverly'',
    ''Thomas'', ''Marc'', ''Jimmy'']**>>>** del first_names[2][''Beverly'', ''Thomas'',
    ''Jimmy'']'
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you can either use the class method **__delitem__(*****elementindex*****)**,
    to which you only need to pass the index of the element to be deleted, or the
    operator **del**, which, because it is an operator, is used without parentheses!
    You call it together with the element to be deleted. You can even use the **del**
    operator to delete several elements at once, for example by calling **del first_names[2:4]**.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the example of deletion, some operations can be implemented
    with both a class method and an operator. This is also true for the selections
    we looked at in the previous section. Ultimately, the selection **firstname[2]**
    is nothing more than the call **first_names.__getitem__(3)** of the **__getitem__(*****elementindex*****)**
    method, and that’s exactly what Python processes internally when you index your
    list using the square brackets, which are themselves nothing more than an operator.
  prefs: []
  type: TYPE_NORMAL
- en: Sort ListsYou can easily sort your list by using the class methods **sort()**
    and **reverse()**, depending on whether you want to sort in ascending or descending
    order:**>>>** first_names = ['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']**>>>**
    first_names.sort()**>>>** first_names['Beverly', 'Cathy', 'Jimmy', 'Marc', 'Thomas']**>>>**
    first_names.reverse()**>>>** first_names['Thomas', 'Marc', 'Jimmy', 'Cathy', 'Beverly']Determine
    the Length of a ListYou can easily determine the length of a list using the **__len__()**
    method.**>>>** first_name.__len()__5
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the previously discussed methods to manipulate the class **list**, **__len__()**
    does not modify the list, but only returns the length of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Joining ListsIf you want to join two lists together, use the plus operator (**+**).**>>>**
    first_names + numbers['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy', 1, 2, 3,
    4, 5, 6, 7]
  prefs: []
  type: TYPE_NORMAL
- en: Here you can see that the result is a list whose elements are partly strings,
    but also partly numbers. Lists, unlike the more specialized arrays found in many
    programming languages, can contain different kinds of elements. In particular,
    the elements of lists can themselves be lists. We will take a closer look at this
    situation in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 21.6.1.4 Lists as Elements of Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** list_with_sublist = [1, 2, 3, [''a'', ''b'', ''c''], 4]'
  prefs: []
  type: TYPE_NORMAL
- en: 'It contains as fourth element (i.e., as element with index 3) again a list.
    We can also see this very quickly if we select the element and inspect it more
    closely:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** list_with_sublist = [1, 2, 3, [''a'', ''b'', ''c''], 4]**>>>** list_with_sublist
    [3][''a'', ''b'', ''c'']**>>>** type(list_with_sublist[3])**<class ''list''>**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To access an element of our “sub-list”, we first pick the fourth element with
    **list_with_sublist[3]**. This is now again a list. So, we should be able to select
    from this (sub-)list again, just as we did with the full list. For example, if
    we wanted to pick out the third element of the list, i.e., the **c**, we would
    index “twice” as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** list_with_lists[3][2]''c''In this way, lists can also be used to construct
    multidimensional variable fields. Suppose we wanted to map a rectangular value
    scheme that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | 2 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 5 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 8 | 9 |'
  prefs: []
  type: TYPE_TB
- en: This can be easily mapped with nested lists:**>>>** three_by_three = [[1,2,3],
    [4,5,6], [7,8,9]]**>>>** three_by_three[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then access the coordinates row 2, column 1 (i.e., the number 4 in our
    value scheme) by double indexing our list (note that the indexing starts at 0!):'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** three_by_three[1][0]4'
  prefs: []
  type: TYPE_NORMAL
- en: The first index is always the row index, the second the column index. Although
    multidimensional fields can also be represented very well with lists, at least
    if you are working with very large fields and the speed of the program is an important
    factor, you will want to use special data structures such as those contained in
    the *NumPy* module. *NumPy* is an important add-on library for anyone working
    in the data science area. The library also provides a special array data type
    that, while not as flexible as lists (because it only takes elements of the same
    type), is more compact in memory and faster to access. For our purposes here,
    however, lists, which are part of the standard Python language, will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 21.4 [20 min]
  prefs: []
  type: TYPE_NORMAL
- en: Try out working with lists a little! Create lists, select items from them, add
    new items, delete items. It is important that you get a feel for how to work with
    lists, because lists play a big role in practical work with Python.
  prefs: []
  type: TYPE_NORMAL
- en: 21.6.1.5 Strings as Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A special feature regarding lists are strings. In Python, they have list-like
    properties. Their individual elements, the characters, can be read-accessed in
    list notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** message = ''Hello World''**>>>** message[1]''e'''
  prefs: []
  type: TYPE_NORMAL
- en: Attempting to *edit* a string character in this way, such as with **message[1]
    = 'x'**, will result in the error message **‘str’ object does not support item
    assignment.**
  prefs: []
  type: TYPE_NORMAL
- en: 21.6.2 Tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tuples are a data type that is similar to lists in many ways. Just like lists,
    tuples are ordered collections of multiple objects that do not necessarily have
    to be of the same type. The main difference with lists is that tuples are *immutable*.
    Take a look at the following example, in which we create a tuple from three integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** number = (27, 9, 51)**>>>** number(27, 9, 51)**>>>** type(number)**<class
    ''tuple''>****>>>** number[1]9**>>>** type(number[1])**<class ''int''>****>>>**
    number[1]=36**Traceback (most recent call last):****File "<input>", line 1, in
    <module>****TypeError: ''tuple'' object does not support item assignment**'
  prefs: []
  type: TYPE_NORMAL
- en: Note that—unlike with lists—the elements with which the tuple is initialized
    are enclosed in *round* brackets. However, the elements are accessed in exactly
    the same way as in lists, namely by specifying the index of the element in question
    in *square* brackets; and here, too, indexing naturally starts at 0—as always
    in Python—so that **number[1]** queries the *second* element of the tuple. In
    the last step, we try to assign a value to this second element of the tuple. This
    fails because tuples are an immutable data type whose elements cannot be changed
    after initialization. Also, no new elements can be added. The tuple is and remains
    as it was created when it was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, you can also omit the parentheses when creating the tuple. So,
    we could also create the tuple **number** above this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** number = 27, 9, 51**>>>** number(27, 9, 51)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have asked yourself why you should use tuples at all, when lists can
    do everything tuples can do but are mutable on top of that. The main advantage
    of tuples is that Python can process them faster than lists. They are also useful
    when you want to make sure that your data is protected from being overwritten.
    If you accidentally try to do this in your program, you will get an error message,
    as you saw in the example above. Even if you don’t use tuples consciously very
    often, Python uses tuples in the background. For example, unlike many other languages,
    Python allows you to place multiple variable assignments in a single statement,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** a, b = 5, 3**>>>** a5**>>>** b3'
  prefs: []
  type: TYPE_NORMAL
- en: What happens internally here is that Python first creates a tuple **(5, 3)**
    and then assigns its elements to the two variables **a** and **b**. We will see
    later how in Python—and this is again not possible in many other programming languages—you
    can have a function/method return more than one value. “Under the hood” this work
    with tuples.
  prefs: []
  type: TYPE_NORMAL
- en: 21.6.3 Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another complex data type besides lists and tuples is the dictionary. The term
    “dictionary” describes the functionality of these data structures quite well.
    Unlike lists, where we use the index of the relevant element in the list to select
    a value, a *key* is used in dictionaries to achieve the same thing. The dictionaries
    are therefore *associative fields*. If you no longer remember the concept, it
    is best to turn back a few pages to ► Sect. [11.​6](474412_1_En_11_Chapter.xhtml#Sec9).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s create a dictionary that stores the age of a person (value)
    for each first name (key). The various key-value pairs are written in curly brackets,
    with the key and value each separated by a colon, and the pairs themselves separated
    by commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** d = {''Thomas'': 30, ''Beverly'': 19, ''Marc'': 28}**>>>** d{''Thomas'':
    30, ''Beverly'': 19, ''Marc'': 28}'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the keys are strings, the values are numbers. However, this
    does not have to be the case. Numbers can themselves be keys. Even tuples can
    be keys, but not lists, because keys must always be immutable (remember that tuples
    are immutable, but lists can be modified). All possible object types are suitable
    as values, including lists or dictionaries themselves. In this way, it is also
    possible to construct a nested dictionary. We will take a closer look at this
    in an exercise later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The individual elements are now accessed with the help of the key, as is usual
    with associative fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** d[''Thomas'']30'
  prefs: []
  type: TYPE_NORMAL
- en: Note that although the key-value pairs are written in curly brackets when the
    dictionary is created, square brackets are used to access individual elements
    of the field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike lists, dictionaries are *unordered* collections of elements. Accessing
    individual elements using a numeric index, which specifies the position of the
    element within the dictionary, is not possible because in an unordered data structure
    elements have no natural position at which they can be located and queried. Therefore,
    attempting to access an element using a numeric index will result in an error
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** d[1]**Traceback (most recent call last):****File "<input>", line 1,
    in <module>****KeyError: 1**'
  prefs: []
  type: TYPE_NORMAL
- en: This **KeyError** tells us that a key **1** does not occur in the dictionary.
    Python interprets the **1** as a key, tries to find the corresponding value, but
    finds that **1** is not among the keys used in the dictionary. We would receive
    a similar error message if we used a name as a key that does not occur in the
    dictionary, for example with **d['Jacob']**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elements can easily be added to a dictionary by making an assignment for the
    new element, associating the new key with a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** d[''Cathy''] = 36**>>>** d{''Thomas'': 31, ''Beverly'': 19, ''Marc'':
    28, ''Cathy'': 36}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we can also use an existing key in such an assignment, as in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** d[''Beverly''] = 22**>>>** d{''Thomas'': 31, ''Beverly'': 22, ''Marc'':
    28, ''Cathy'': 36}'
  prefs: []
  type: TYPE_NORMAL
- en: Since the key is ultimately the identifier we use to access an element of the
    dictionary, it must be unique. Therefore, we cannot simply add a new element that
    has a key which already exists in the dictionary. Instead we change the already
    existing element in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only adding, but also deleting elements is very easy with the **del** operator
    already known from lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** del d[''Thomas'']**>>>** d{''Beverly'': 22, ''Marc'': 28, ''Cathy'':
    36}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, as with lists, a call to the class method **__delitem__()**
    would be possible: **d.__delitem__(''Thomas'')**. Unlike the ordered lists, this
    method takes the corresponding key as argument instead of a numeric position index.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you are interested in checking whether a certain key occurs in the
    dictionary. This can easily be done with the **in** operator. If you apply the
    **in** operator to a key and a dictionary, the result is a logical value that
    indicates whether the key is used in the dictionary or not.
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** ''Cathy'' in dTrue**>>>** ''Amy'' in dFalse'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, keys and values can also be extracted from the dictionary. For this
    purpose, the dictionary class has two special methods, **keys()** and **values()**.
    The return values of these methods are a bit more complicated, we will deal with
    this kind of object, the iterable objects, in more detail later. To work with
    them easily, we convert them into a list using the **list()** method, which is
    the constructor method of the **list** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** list(d.keys())[''Beverly'', ''Marc'', ''Cathy'']**>>>** list(d.values())[22,
    28, 36]'
  prefs: []
  type: TYPE_NORMAL
- en: 'With these lists, in turn, we can of course do anything that lists allow us
    to do, for example, access a particular element. Since the list of keys is of
    course an ordered data structure, we can access its elements with a numerical
    index. For example, the second element with index 1 (remember: indexing in Python
    starts at 0 for the first element):'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** list(d.keys())[1]''Marc'''
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete elements of the dictionary can also be extracted into a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** list(d.items())[(''Beverly'', 22), (''Marc'', 28), (''Cathy'', 36)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of the list are now the individual elements of the dictionary.
    They are themselves tuples of key and value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** type(list(d.items())[0])**<class ''tuple''>**21.5 [10 min]'
  prefs: []
  type: TYPE_NORMAL
- en: Create a dictionary whose keys are numeric product numbers and whose values
    are dictionaries containing, for each product number, the description, manufacturer,
    and price of the product in question.
  prefs: []
  type: TYPE_NORMAL
- en: 21.6.4 Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last data type we want to look at is the *sets*. Sets and dictionaries have
    in common that both are *unordered* collections of objects. Similar to the keys
    of a dictionary, which must always be unique, each element in a set can only occur
    once. Sets support set operations as they are known from mathematical set theory,
    for example, the determination of the intersection or union of two sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a set, we use the curly braces—similar to the dictionary; this time,
    however, the curly braces do not contain key-value pairs, but simply the individual
    elements of the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** friends_thomas = {''Will'', ''Beverly'', ''Peter'', ''Michael''}**>>>**
    friends_julia = {''Peter'', ''Will'', ''Helen'', ''Michael'', ''Caroline''}'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily verify that the order of the elements does not matter by comparing
    two sets containing the same elements but in different order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** {''Beverly'', ''Peter''} == {''Peter'', ''Beverly''}True'
  prefs: []
  type: TYPE_NORMAL
- en: In doing so, we use the double equal sign for comparison, which, we will see
    later, is Python’s operator for comparisons for equality (a single equal sign
    would be considered by Python to be an attempt at assignment, which of course
    would not work here). The result of the comparison, **True**, confirms that the
    order of the elements in the sets does not matter; the two sets are identical
    despite different orders of their otherwise equal elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the sets defined above, we could now check, for example, which elements
    occur in both sets, i.e., which people are friends of both Julia and Thomas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** friends_thomas.intersection(friends_julia){''Will'', ''Peter''}'
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we use the class method **intersection(*****other_set*****)** here,
    which the class **set** brings with it by default. In this case, the result, namely
    the intersection that is again returned to us as **set** (easily recognizable
    by the curly brackets), would of course be the same if instead of calling **friends_thomas.intersection(friends_julia)**
    we had called **friends_julia.intersection(friends_thomas)** the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we could have worked with the intersection operator **&**, which
    is supported by the class **set**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** friends_thomas & friends_julia{''Will'', ''Peter''}'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the intersection operator is an ampersand is no coincidence, since
    we are looking for all elements in the intersection that are contained in one
    *and* the other set.
  prefs: []
  type: TYPE_NORMAL
- en: '*Union sets*, i.e., the set of all elements contained in one or both initial
    sets, can be determined with the class method **union(*****other_set*****)** or
    the pipe operator **|**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** friends_thomas.union(friends_julia){''Helen'', ''Caroline'', ''Michael'',
    ''Will'', ''Peter'', ''Beverly''}**>>>** friends_thomas | friends_julia{''Helen'',
    ''Caroline'', ''Michael'', ''Will'', ''Peter'', ''Beverly''}'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the union of our two sets contains the names **Will** and **Peter**
    only once, although they appear in both **friends_thomas** and **friends_julia**.
    But this is precisely the nature of sets (as well as sets in mathematics): All
    elements of a set are different from each other, no element can occur more than
    once.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can check whether one set is a *subset of* another:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** friends_thomas.issubset(friends_julia)False**>>>** {''Michael'', ''Beverly''}.issubset(friends_thomas)True'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, a convenient shortcut is available in the form of an operator, namely
    the less-than-equal operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** {''Michael'', ''Beverly''} <= friends_thomasTrue21.6 [20 min]'
  prefs: []
  type: TYPE_NORMAL
- en: Find out (for example, with the **help()** function) what other interesting
    operations are possible with sets and try them out. Use the example sets **friends_thomas**
    and **friends_julia** from this section or create your own sets.
  prefs: []
  type: TYPE_NORMAL
- en: 21.7 Self-Defined Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 21.7.1 Defining and Using Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the data types we looked at were classes, whether they were basic types
    like **int** and **str**, or more complex types like lists or dictionaries. Because
    Python as a programming language follows the object-oriented paradigm, we can
    of course define classes ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the example of the **Product** class from ► Sect. [11.​7.​2](474412_1_En_11_Chapter.xhtml#Sec12),
    which captures all the important basic information about a product? These properties
    were the name, a more detailed description, the part number, the manufacturer’s
    name, and the price. We can build such a class very easily in Python, using the
    **class** keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '**class** Product:name = ''''description = ''''item_number = ''''manufacturer
    = ''''price = 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the colon, the code block begins (attention, indentation!) with the attributes
    of the classes, to each of which we assign an initial value. That’s about it!
    Now we can use our class **Product** and create a variable of this type:'
  prefs: []
  type: TYPE_NORMAL
- en: gardenshovel = Product()
  prefs: []
  type: TYPE_NORMAL
- en: '**Product()** is the constructor method of our class, which we use here just
    as we did for Python’s basic data types in ► Sect. [21.4.2](#Sec11). While we
    haven’t defined a constructor of our own at all, our class gets a default constructor
    from Python that does nothing but create an object of the class. Later, when we
    look at methods/functions in a bit more detail, we’ll look at how we can write
    our own constructor and use it to allow the user of our class to, for example,
    set the values of certain attributes to their own specifications right when a
    new class instance is created. This is exactly what we did in ► Sect. [21.4.2](#Sec11),
    when we called the constructor of the class **int** with **int(56)** and caused
    it to create a new **int** object containing the integer value 56.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created the object of type **Product**, we can customize its
    properties as we wish:'
  prefs: []
  type: TYPE_NORMAL
- en: gardenshovel.name = 'Garden shovel, stainless steel'.gardenshovel.price = 10.99
  prefs: []
  type: TYPE_NORMAL
- en: If you work with *PyCharm* and type **gardenshovel.** (including the dot operator!),
    the dropdown menu that opens will list, among other things, the attributes we
    just defined that the object **gardenshovel**, as an instance of the **Product**
    class, has.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily verify that these assignments worked by displaying the values
    of the attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: print(gardenshovel.name)print(gardenshovel.price)
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are no longer in Python’s interactive mode here (you can easily
    tell by the missing input prompt **>>>** before the statements), although we could
    of course have fed the class definition into the Python console. Therefore, to
    display the contents of a variable, simply typing its identifier is no longer
    sufficient (in fact, it has no effect at all). Instead, we must explicitly cause
    the output by calling the **print()** function.
  prefs: []
  type: TYPE_NORMAL
- en: 21.7.2 Deriving Classes from Other Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In ► Sect. [11.​7.​3](474412_1_En_11_Chapter.xhtml#Sec13) we learned about
    the concept of inheritance, which of course Python also offers as an object-oriented
    language. There, we defined the class **Book** as a derived class of the class
    **Product**, which has two special attributes, **author** and **pages**, that
    the base/parent class **Product** does not have by default. In Python, to derive
    one class from another, the base class name is placed in parentheses after the
    derived class name in the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '**class** Book(Product):pages = 0author = '''''
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can create an instance of the **Book** class by calling its default
    constructor, which Python kindly provides:'
  prefs: []
  type: TYPE_NORMAL
- en: grisham1992 = Book()If you now display the attributes of the new object in *PyCharm*
    by typing **grisham1992**. you will immediately see that the instance of the class
    **Book** has not only its own attributes, namely **pages** and **author**, but
    also the properties inherited from **Product**, such as **description** and **price**.
    *PyCharm* also shows you, as you can see in ◘ Fig. [21.3](#Fig3), from which class
    the respective attribute originates.![](../images/474412_1_En_21_Chapter/474412_1_En_21_Fig3_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of a code completion menu in an editor window. The editor displays
    the text of properties of the book grisham 1992, and the code completion menu
    displays identifiers such as pages, price, author, and name.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 21.3
  prefs: []
  type: TYPE_NORMAL
- en: Own and inherited properties of the “Book” class
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now work with all properties as we wish:'
  prefs: []
  type: TYPE_NORMAL
- en: grisham1992.name = 'The Pelican Brief'grisham1992.price = 8.99grisham1992.author
    = 'John Grisham'grisham1992.pages = 478
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes in Python can be derived not only from one base class, but also from
    multiple base classes. For example, there could be another class **Copyright**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**class** Copyright:owner = ''''year = 1900'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we could derive our class **Book** from both base classes, **Product**
    and **Copyright** at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**class** Book(Product, Copyright):pages = 0author = '''''
  prefs: []
  type: TYPE_NORMAL
- en: 'By specifying both base classes in the definition of our class **Book**, we
    create a class that inherits the attributes and methods of both classes. Accordingly,
    we can now work with the attributes that the **Copyright** class brings:'
  prefs: []
  type: TYPE_NORMAL
- en: grisham1992 = Book()grisham1992.owner = 'Double'grisham1992.year = 199221.7
    [10 min]
  prefs: []
  type: TYPE_NORMAL
- en: Define a **Customer** class with useful customer attributes and derive a **BusinessCustomer**
    class from this class that contains additional attributes that are only relevant
    for business customers.
  prefs: []
  type: TYPE_NORMAL
- en: '21.7.3 Avoid Ambiguity: Name Mangling'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'But what if not only the class **Product**, but also the class **Copyright**
    had an attribute called **name**? The derived class **Book** would nevertheless
    have only *one* attribute **name**. But from which “parent” would this attribute
    now originate? Is it the name from **Product** or the name from **Copyright**?
    The answer in this case would be: that of **Product**, because Python proceeds
    from left to right, i.e. the class from which it is derived “first” is searched
    first for the attribute name. Python only searches in the other parent classes
    if the first parent class did not have an attribute of this identifier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To eliminate name confusion altogether, there is an option to prefix class
    attributes with a double underscore. Then the class definition of our **Copyright**
    class would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**class** Copyright:owner = ''''__name =''''year = 1900'
  prefs: []
  type: TYPE_NORMAL
- en: 'The effect of the double underscore is that Python automatically makes the
    property accessible under the identifier **_*****class*****__*****attribute***,
    which in our example is **_Copyright__name**:'
  prefs: []
  type: TYPE_NORMAL
- en: grisham1992._Copyright__name = 'Copyright'print(grisham1992._Copyright__name)
  prefs: []
  type: TYPE_NORMAL
- en: This process, also known as *name mangling*, allows us to avoid ambiguities
    and misunderstandings when accessing attributes whose names may occur more than
    once in the class hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 21.8 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned about variables in Python and how to work with them.
    We also learned how to define classes and create objects as instances of classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should take away the following points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Python knows simple data types, most notably **int** (integers), **float** (floating
    point numbers), **str** (strings), and **bool** (logical/truth values), as well
    as more complex data types, most notably **list** (an ordered collection of different
    objects), **dictionary** (an unordered associative field), **tuple** (an immutable
    collection of objects), and **set** (an unordered collection of unique objects).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All data types are classes, variables of these data types are object instances;
    they have attributes (or properties) and methods to manipulate and otherwise work
    with the objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable names are case-sensitive, as is the case everywhere in Python; the
    official recommendation is to use lowercase variables, and to separate multiple
    terms in variable names with an underscore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables do not have to be declared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables can be generated either by assigning an object to a variable name
    (where Python automatically determines the type) or by using the constructor method
    of the respective data type class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors can often be called with objects of other types as arguments; this
    allows explicit conversion between data types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python implicitly converts relatively little, but does between **int** and **float**,
    where necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings can be enclosed in single and double quotes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To display the contents of a variable, its name can be typed into the Python
    console; within a Python program, however, the output must always be explicitly
    brought up (primarily using the **print()** function).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The complex data types in Python differ in whether they are mutable or not
    (mutable: **list**, **dictionary**, **set**; immutable: **tuple**) and whether
    the elements in them are stored in an ordered or unordered fashion (ordered: **list**,
    **tuple**; unordered: **dictionary**, **set**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The elements of complex data types (and in the case of dictionaries, both keys
    and values) may be of different types and may themselves even be objects of that
    or another complex data type; for example, there may be a list that in turn contains
    lists as elements, or a dictionary whose keys are partly tuples and whose values
    are lists and other dictionaries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The elements of ordered data types (lists, tuples) can be addressed via numeric
    indices (that is, element numbers); the first element always has the index 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The colon operator can be used to address an index range, where **A:B** means
    all elements between the range boundaries **A** (inclusive) and **B-1** (inclusive).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range boundaries can also be left open, which is equivalent to “from the beginning”
    (left boundary not specified) or to the end (right boundary not specified).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Negative indexes mean: Indexing from the back instead of the front.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python does not know a special data type for arrays/fields, but the data type
    **list**, which holds arbitrary elements in ordered form; an array is thus a special
    case of a list (namely one whose elements are all of the same type).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings also behave like lists in read access, in that their individual characters
    can be addressed in the notation usual for lists; however, write access to the
    characters is not possible in this way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can define your own classes using the keyword **class**; classes can be
    derived from one or more “parent classes”, i.e., inherit their attributes and
    methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A double underscore of an attribute or method in a class definition means that
    the attribute/method is also accessible under the name **_*****class*****__*****attribute***
    or **_*****class*****__*****method()*** (*name mangling*); in this way, ambiguities
    in attribute/method identifiers caused by multiple inheritance can be avoided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table gives an overview of the most important data types. For
    the simple data types, you can see the creation by assignment and by calling the
    constructor method of the respective class. Of course, the complex data types
    **list**, **tuple**, **dictionary** and **set** can also be created by constructor,
    but this is not shown here for the sake of clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the most important data types
  prefs: []
  type: TYPE_NORMAL
- en: '| Data type | Saves | Creation of a variable | Access to elements |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **int** | Integers | Assignment:**x = 5**Constructor:**x = int(''5'')** |
    – |'
  prefs: []
  type: TYPE_TB
- en: '| **float** | Floating point values | Assignment:**x = 0.5**Constructor:**x
    = float(''5'')** | – |'
  prefs: []
  type: TYPE_TB
- en: '| **str** | Strings | Assignment:**x = ''Hello World''**Constructor:**x = str(0.5)**
    | – |'
  prefs: []
  type: TYPE_TB
- en: '| **boolean** | Logical/truth values | Assignment:**x = False**Constructor:**x
    = bool(''True****'')** | – |'
  prefs: []
  type: TYPE_TB
- en: '| **list** | Ordered, changeable compilation of other objects (possibly also
    of different types) | Elements comma-separated in square brackets:**x = [''Marc'',
    ''Helen'', ''Toby'', ''Thomas'']** | Index or index range in square brackets:**x[1]**(gives:
    **''Helen''**)**x[2:3]**(gives: **[''Hellen'', ''Thomas'']**) |'
  prefs: []
  type: TYPE_TB
- en: '| **tuple** | Ordered, unchangeable compilation of other objects (possibly
    of different types) | Elements comma separated in round brackets:**x = (''abc'',
    27.5)** | Index in round brackets:**x(1)**(gives: **27.5**) |'
  prefs: []
  type: TYPE_TB
- en: '| **dictionary** | Unordered set of key-value pairs, keys and values can be
    objects of different types; keys must be unique | Key-value pairs comma-separated
    in curly brackets, key and value each separated by colon:**x = {''Marc'' : 27,
    ''Helen'' : 41}** | Key in square brackets:**x = [''Marc'']**(provides: **27**)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **set** | Unordered collection of objects (possibly of different types) that
    must be unique (an object can only appear once in the list) | Elements comma-separated
    in curly brackets:**x = {''Marc'', ''Helen''}** | Since there is no natural order
    and no key for access, selection of a single element makes no sense (you would
    already have to know the element to access it) |'
  prefs: []
  type: TYPE_TB
- en: 21.9 Solutions to the Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise 21.1Some examples of other methods of the **str** object are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**find(*****sub*****)**: Searches for **sub** in the string of the **str**
    object and returns the index of the first character of the found substring, or
    −1 if the substring was not found. As always, this is case sensitive. Usage examples:**>>>**
    x = ''Hello world!''**>>>** x.find(''wo'')6**>>>** x.find(''WO'')-1**>>>** x.upper().find(''WO'')6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the last example, the string is first converted to upper case. **x.upper()**
    returns the string converted to upper case. This is, of course, again a **str**
    object. This is then searched using its **find()** method. This time it returns
    a hit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Further arguments can be used to restrict the range in which the string is
    to be searched; the specification **x.find(*****sub*****[,** ***start*****[,**
    ***end*****]]) -> int** in the help means that since **start** and **end** are
    optional arguments of **find()**, they can but do not have to be specified. That’s
    why they are each enclosed in square brackets. Note the subtleties of the bracket
    order: the square brackets around the **end** argument are contained within the
    square brackets enclosing the **start** argument. This means that **end** can
    only be specified if **start** has been specified, but **start** can be used without
    specifying **end**!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After the **->** you find the type of the return value of the function, in our
    case **int**, because the index is returned as a number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**capitalize()**: Capitalizes the string (first word only!) and converts all
    other characters to lowercase. Usage example:**>>>** x = ''hello world**>>>**
    x.capitalize()''Hello world'''
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**is.lower()**, **is.upper()**: Check whether the string is all lowercase or
    all uppercase. Usage example:**>>>** x.isupper()False**>>>** x = ''HELLO WORLD''**>>>**
    x.isupper()True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**center(*****width*****, [*****fillchar*****])**: Creates a string of length
    **width**, centred by the string of the **str** object. To the left and right
    of it, it is “padded” with the padding character (by default, if not specified:
    space). Usage example:**>>>** x = ''Hello World''**>>>** x.center(50, ''*'')''********************Hello
    World********************'' Exercise 21.2A program that reads the user’s age in
    years and outputs it as minutes might look like this:age = input(''Please enter
    your age in years:'')minutes = int(age) * 365 * 24 * 60print(''With'', age, you
    have already experienced at least'', minutes)Exercise 21.3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s first assign an object to the list elements with indices 3 and 4\. We
    start with an integer number:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']**>>>**
    first_names [3:4] = 23**Traceback (most recent call last):****File "<input>",
    line 1, in <module>****TypeError: can only assign an iterable**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We get an error message. Generally, Python cannot assign something which is
    itself not a list to a list/selection from a list (unless the selection contains
    only one element). Contrary to what one might expect, Python does not simply replace
    the elements 3 and 4, i.e. **''Jimmy''** and **''Cathy''** (indexing starts at
    0!), with the number 23\. The picture changes when we “wrap” the number 23 in
    a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']**>>>**
    first_names[3:4] = [23]**>>>** first_names[''Beverly'', ''Thomas'', ''Marc'',
    23]'
  prefs: []
  type: TYPE_NORMAL
- en: Now the two selected elements are actually replaced by the list containing only
    the number 23\. But since this is shorter than the replaced partial list, our
    list **first_names** is *shortened* accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s try something else. This time we replace the part list with a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']**>>>**
    first_names[3:4] = ''Amy''**>>>** first_names[''Beverly'', ''Thomas'', ''Marc'',
    ''A'', ''m'', ''y'']'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the assignment **first_names[3:4] = 23** above, this time we don’t get
    an error message. But something seemingly strange happens: The partial list **first_names[3:4]**
    is replaced by the letters of the name Amy, with each letter becoming a new list
    element. The reason is that strings can also be interpreted as lists. Therefore,
    the assignment **first_names[3:4] = ''Amy''** is ultimately a replacement by a
    list, namely by the list **[''A'', ''m'', ''y'']**.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 21.4
  prefs: []
  type: TYPE_NORMAL
- en: '*No solution*.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 21.5
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we are now dealing with a nested dictionary. For the sake of clarity,
    you can see the dictionary definition below with line breaks (you remember from
    ► Sect. [20.​1.​2](474412_1_En_20_Chapter.xhtml#Sec3) that a statement can be
    wrapped inside curly braces):'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** d= { 12345:**...** {**...** ''description'': ''Plastic Garden Chair
    "Garden Friend"'',**...** ''manufacturer'': ''Garden Paradise Inc.'',**...** ''price'':
    10.99**...** },**...** 56789:**...** {**...** ''description'': ''Garden shovel,
    stainless steel'',**...** ''manufacturer'': ''Big G Gardening Tools Inc.'',**...**
    ''price'': 49.90**...** }**...** }'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access is then via two keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '**>>>** d[12345][''price'']10.99'
  prefs: []
  type: TYPE_NORMAL
- en: The expression **d[12345]** returns a dictionary, and a value is selected from
    this dictionary using a key that exists in this dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 21.6Some examples of other set operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**difference(*****other_set*****)**: Returns the elements that exist in **other_set**
    but not in the set whose **difference()** method was called. Usage example:**>>>**
    friends_thomas = {''Will'', ''Beverly'', ''Peter'', ''Michael''}**>>>** friends_julia
    = {''Peter'', ''Will'', ''Helen'', ''Michael'', ''Caroline''}**>>>** friends_julia.difference(friends_thomas){''Caroline'',
    ''Helen''}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**remove(*****element*****)**: Deletes an element from a set. Usage example:**>>>**
    friends_julia.remove(''Helen'')**>>>** friends_julia{''Peter'', ''Will'', ''Michael'',
    ''Caroline''}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**isdisjoint(*****other_set*****)**: Checks if the set whose **isdisjoint()**
    method is called and the other set are disjoint, that is, have no elements in
    common. Usage example:**>>>** friends_thomas = {''Will'', ''Beverly'', ''Peter'',
    ''Michael''}**>>>** friends_julia = {''Peter'', ''Will'', ''Helen'', ''Michael''}**>>>**
    friends_thomas.isdisjoint(friends_julia)False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 21.7
  prefs: []
  type: TYPE_NORMAL
- en: 'The two classes **Customer** and **BusinessCustomer** could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**class** Client:firstname = ''''lastname = ''''street = ''''city = ''''zip
    = ''''email = ''''**class** BusinessCustomer(Customer):company = ''''payment_terms
    = 14taxid = '''''
  prefs: []
  type: TYPE_NORMAL
