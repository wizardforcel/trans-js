- en: © 作者，独家授权`Springer Fachmedien Wiesbaden GmbH`，`Springer Nature`的一部分 2024`J.
    L. Zuckarelli`学习使用`Python`和`JavaScript` [https://doi.org/10.1007/978-3-658-42912-6_21](https://doi.org/10.1007/978-3-658-42912-6_21)
  id: totrans-0
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21. 变量与对象：如何存储数据以便使用？
  id: totrans-1
  prefs:
  - PREF_H1
  stylish: true
  type: TYPE_NORMAL
- en: Joachim L. Zuckarelli^([1](#Aff2)  )(1)`München`, `Germany`Overview
  id: totrans-2
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在本章中，我们将把重点转向在`Python`中处理变量。此外，我们还将探讨如何将各种变量聚合到类列表的结构（数组）中，并在哈希（字典）中映射键值对。鉴于`Python`的面向对象特性，所有变量都是具有属性和方法的对象，我们的讨论将超越仅仅创建、赋值和在不同数据类型之间转换变量。我们将深入探讨`Python`的面向对象实现，并演示您如何利用面向对象编程在`Python`中为您的项目带来益处。
  id: totrans-3
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在本章中，您将学习：
  id: totrans-4
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 如何在`Python`中创建变量并为其赋值
  id: totrans-5
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 变量的基本类型有哪些，如何使用它们
  id: totrans-6
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 变量的对象特性表达了什么，以及这对您在变量的实际工作中意味着什么
  id: totrans-7
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 如何将变量从一种数据类型转换为另一种数据类型，以及`Python`何时自动为您进行转换
  id: totrans-8
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 存在更复杂的数据类型（例如，列表和字典），以及如何使用它们
  id: totrans-9
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 如何在`Python`中定义类，如何自己定义和使用对象类
  id: totrans-10
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 21.1 创建和赋值变量
  id: totrans-11
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 与其他一些语言不同，在`Python`中创建变量是相当简单的。这是因为变量在`Python`中不需要声明；它们在首次使用时会自动创建。因此，赋值
  id: totrans-12
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `x = 5`创建了一个（整数）变量并将其值设置为`5`（`>>>`是提示字符，提示您输入，因此您不需要输入这个！）'
  id: totrans-13
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 我们在这里简单地将变量命名为`x`。在►章节[11](474412_1_En_11_Chapter.xhtml)，我们说变量名应该是有意义的，并允许代码的阅读者猜测变量将包含什么样的内容。尽管在这些例子中我们将其简化，`Python`仍然为您提供了使用有意义的变量名的每一个机会。正如您从►节[20.​1.​3](474412_1_En_20_Chapter.xhtml#Sec4)中已知，`Python`中的名称可以由大小写字母、数字和下划线字符组成。数字不允许出现在变量名的开头，但可以在名称的其他地方使用。此外，名称开头（有时结尾）带下划线在`Python`中有特殊含义，我们将在后面讨论。因此，不建议以下划线开头或结尾命名变量。除此之外，您可以完全自由地命名您的变量。
  id: totrans-14
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Python`决定变量应该具有什么类型。在变量的生命周期内，类型可能会改变，例如，通过将不同类型的数据分配给变量。'
  id: totrans-15
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> x = ''A string (str) variable''`不仅值发生了变化，变量的数据类型也发生了变化，现在它是一个字符串变量。在下一节中，当我们查看变量的对象特性时，您将学习到在`Python`中创建变量的第二种方法，除了赋值以外。'
  id: totrans-16
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 如果您在`Python`控制台中工作，可以随时通过输入变量的名称来显示变量的值。
  id: totrans-17
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> x` `''A string (str) variable''`如果您在`Python`脚本中编写代码，则必须使用`print()`函数，您在上一章中已学习过，来打印变量的内容：`print(x)`'
  id: totrans-18
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 如果您在`Python`程序中仅写变量名，则没有输出。
  id: totrans-19
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 顺便提一下，您不能在控制台中访问您在程序中创建的变量。控制台的命名空间和您程序的命名空间是分开的。如果您在控制台中使用一个您在程序中创建的变量，您将收到一个错误信息（当然，除非您已经通过控制台创建了一个同名变量——但那样您也会使用这个变量，而不是您在程序中使用的那个变量）。
  id: totrans-20
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 有时您会意外访问一个不存在的变量，例如因为您输入了错误的标识符。然后，您将收到如下错误信息：
  id: totrans-21
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Traceback (most recent call last):` `File "D:\Applications\Anaconda\lib\site-packages\IPython\core\interactiveshell.py",
    line 2961, in run_code` `exec(code_obj, self.user_global_ns, self.user_ns)` `File
    "<ipython-input-16-9063a9f0e032>", line 1, in <module>` `y` `NameError: name ''y''
    is not defined`'
  id: totrans-22
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 这里关键的是最后一行。它告诉我们一个名为`y`的变量，在这里我们尝试访问它，但它根本不存在。
  id: totrans-23
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21.2 删除变量
  id: totrans-24
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 一旦创建，变量可以使用`del`命令再次删除。这是有意义的，特别是如果变量占用了大量内存（例如，如果您已经完全读取了一个大文件），并且在您不再需要数据后希望释放内存。
  id: totrans-25
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 如果您在`Python`控制台中删除一个变量，然后尝试访问它，您将收到一个错误信息：
  id: totrans-26
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> del x` `>>> x` `Traceback (most recent call last):` `File "<input>", line
    1, in <module>` `NameError: name ''x'' is not defined`'
  id: totrans-27
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The error message talks about the `name` `x` not being defined. Like many other
    programming languages, Python makes a clear distinction between the value of the
    variable and its name. The name is just a reference to the value, which is located
    in a certain area of memory. In principle, the name and value exist independently
    of each other. Now, it could be that several names refer to exactly the same value,
    that is, to the same location in memory. If the value stored in the memory in
    question changes, the values of all these variables also change accordingly. In
    such a situation with multiple names all pointing to the same memory location,
    if you delete one name, the value and the other names (and therefore variables)
    are preserved. You can then simply no longer address the value under the deleted
    name, but only under the remaining names.
  id: totrans-28
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Python counts the names that point to a value (the result is called the `reference
    counter`). If there is no more name pointing to a certain value, Python deletes
    the value itself. This process is called `garbage collection`. However, since
    there will usually be only one name that has a `binding to` the value of your
    variable, when you call the `del` command, the value itself is usually also deleted
    and the memory in question is freed.
  id: totrans-29
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`21.3 Basic Types of Variables`'
  id: totrans-30
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: In this section we deal with the most important types of variables. We will
    first concentrate on variables that contain only one value. In the following section,
    we will look at more complex data types that can hold multiple values at the same
    time.
  id: totrans-31
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`21.3.1 Numbers (int, float)`'
  id: totrans-32
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: Numbers in Python come in the form of integers (`int`) or floating-point numbers
    (`float`). Unlike many other programming languages, `int` variables in Python
    do not have a fixed range of values beyond which another data type that takes
    up more memory must be chosen. Python simply reserves as much memory for the variable
    as is needed to hold the value it contains.
  id: totrans-33
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'You can see this very nicely by looking at the size of the variables using
    the `sys.getsizeof(object)` function:'
  id: totrans-34
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> x = 5 >>> sys.sizeof(x) 14 >>> x = 1000000000000 18`'
  id: totrans-35
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As you can see, the memory requirement has increased from the original `14`
    bytes to `18` bytes after we assigned a significantly larger value, one trillion,
    to the variable instead of `5`.
  id: totrans-36
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: You may wonder why even a small value like `5` still requires `14` bytes in
    memory. In many other programming languages such a variable would have the size
    of only `2` bytes (= `16` bits). This can represent numbers between `0` and `2^(16)
    = 65,536`. So why is Python such a “memory hog”? The answer has to do with the
    way Python stores variables and will be discussed in the following section.
  id: totrans-37
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The decimal separator for floating point numbers is the period, as is customary
    in English. The biggest problem with this in Python is that if you habitually
    use the comma instead of the period (as it is common in many European and South
    American countries), you don’t get an error message:'
  id: totrans-38
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `pi = 3.1415926535` `>>>` `pi(3, 1415926535)`'
  id: totrans-39
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Python misinterpreted our input and created a variable of a completely different
    type, namely a `tuple` . We will deal with these tuples in more detail a little
    later in this chapter.
  id: totrans-40
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`21.3.2 Strings (str)`'
  id: totrans-41
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 'Strings, variables of type `str` , can be enclosed in Python in either single
    or double quotes:'
  id: totrans-42
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `x = "A text in double quotes."` `>>>` `x` `''A text in double quotes.''`
    `>>>` `y = ''A text in single quotes.''` `>>>` `y` `''A text in single quotes.''`'
  id: totrans-43
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The advantage of being able to use both types of quotation marks is that in
    Python you have no difficulty in displaying quotation marks within a text, because
    the two different variants of quotation marks mean that there is no danger of
    confusion between the quotation marks that are part of the text and those that
    delimit the string at the front and back:'
  id: totrans-44
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `quote = ''Hamlet said, "To be or not to be. That is the question here!"''`
    `>>>` `quote` `''Hamlet said, "To be or not to be. That is the question here!"''`'
  id: totrans-45
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'As you will have noticed, Python automatically encloses the output of the variable’s
    contents in (single) quotes to make it clear that this is a string. The following
    example shows that this is a practical feature:'
  id: totrans-46
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `x = ''5''` `>>>` `x` `''5''` `>>>` `x = 5` `>>>` `x` `5`'
  id: totrans-47
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In the first assignment, the content of the variable is a string, in the second
    case it is a number, which could now be used in a calculation.
  id: totrans-48
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'In Python, it is very easy to create strings that go over multiple lines. To
    do this, simply enclose the text in triple quotes:'
  id: totrans-49
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`z = """The text starts on the first lineand continues on the second line."""`
    `print(z)` This program results in the following output: The text begins on the
    first line and continues on the second line.'
  id: totrans-50
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In fact, the line break is preserved in the output. You can use this feature
    not only when you are working in script mode, i.e., writing a program to execute
    it afterwards. Even in interactive mode, Python recognizes after pressing the
    `<ENTER>` key that you have started a multiline string here, and therefore waits
    with the execution of the statement (which is, after all, normally triggered with
    `<ENTER>`) and allows you to continue writing on the next line instead.
  id: totrans-51
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: You have already become acquainted with this type of string as `docstrings`
    in the previous chapter. Docstrings are placed in your program code as documentation,
    but not with the intention of being further processed or output to the screen
    for the end user of the program.
  id: totrans-52
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 有时您希望在程序代码中包装字符串，而这种包装在输出字符串时不可见；关键是要使程序代码更清晰（记得从► Sect. [20.​1.​1](474412_1_En_20_Chapter.xhtml#Sec2)！推荐的每行79个字符的限制！）。在这种情况下，您可以使用反斜杠（`\\`）：
  id: totrans-53
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`message = ''Hello '' \''world''` `print(message)`'
  id: totrans-54
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 这段代码生成的输出为：
  id: totrans-55
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Hello world`'
  id: totrans-56
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 这意味着并不是有两行不同的字符串，而只是一个字符串，出于实际原因在代码中分布在两行上。
  id: totrans-57
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`21.3.3 Truth Values (bool)`'
  id: totrans-58
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 真值或逻辑值`true`和`false`在`Python`中使用数据类型`bool`表示，`bool`是对19世纪英语数学家和逻辑学家乔治·布尔的致敬，他在形式逻辑的发展中做出了重要贡献。
  id: totrans-59
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 与其他变量类型不同，类型为`bool`的变量只能取两个值：`True`和`False`。请注意大小写！常量`True`和`False`必须以大写字母书写。如果我们写成`false`，`Python`会认为我们想使用一个名为`false`的变量，而这个变量当然不存在：
  id: totrans-60
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> x = false` `Traceback (most recent call last):` `File "<input>", line
    1, in <module>` `NameError: name ''false'' is not defined` `>>> x = False` `>>>
    x` `False`'
  id: totrans-61
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 此外，不要使用引号，因为它们会使变量成为`str`变量：
  id: totrans-62
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> x = ''False''` `>>> x` `''False''` `>>> type(x)` `<class ''str''>` `>>>
    x = False` `>>> x` `False` `>>> type(x)` `<class ''bool''>`'
  id: totrans-63
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Python`内部将值`True`和`False`存储为`0`和`1`，因此您可以像对待普通数字一样对它们进行计算：'
  id: totrans-64
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> x = 5 * True` `>>> x` `5`'
  id: totrans-65
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`21.3.4 None`'
  id: totrans-66
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 一种特殊的数据类型是`NoneType`。您不能创建自己的这种类型的变量。相反，`Python`已经为您创建了一个类型为`NoneType`的对象，即`None`（多么有创意！）。这允许您将值`None`赋给一个变量，这意味着该变量当前没有真正有意义的值：
  id: totrans-67
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> x = None` `>>> x` `None` `>>> type(x)` `<class ''NoneType''>`'
  id: totrans-68
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: But isn’t that a bit awkward? Couldn’t we just assign the variable the value
    `0` if the variable is a number, or `''`，即一个空字符串，如果它是一个字符串？当然，我们确实可以这样做，但前提是`0`或`''`在内容上没有实际意义。然而，当你测量温度时，例如，或者在一个从−5到+5的范围内调查一个人对某个话题的态度时，值`0`确实可以具有其自身的真实意义。在这种情况下，受访者给出了值`0`，从而表示对该话题的中立态度，还是根本没有回答问题（`None`），这之间是有区别的。为了使这种区别显而易见，使用一个特殊的指示符来表示“没有真实值存在”是有意义的，而这正是`None`值的作用。
  id: totrans-69
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 顺便说一下，你不能用`None`进行计算：
  id: totrans-70
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> None + 1 Traceback (most recent call last): File "<input>", line 1, in
    <module> TypeError: unsupported operand type(s) for +: ''NoneType'' and ''int''.`'
  id: totrans-71
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 如果`None`被作为逻辑表达式进行评估，它被视为`False`。所以，`None`确实没有其他任何用途，除了表明变量不包含真实值。
  id: totrans-72
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21.3.5 其他数据类型
  id: totrans-73
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 除了到目前为止讨论的数据类型外，Python本身还知道几种其他数据类型，例如`complex`，这是一种用于表示数学中已知的复数的数据类型，复数由实部和虚部组成。
  id: totrans-74
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 各种不是标准语言一部分的包（程序库）也提供了自己的数据类型。一个例子是`NumPy`包，这是一个用于高效处理向量和矩阵的库，是在统计和机器学习方法中进行工作的重要基础，Python在这些领域找到了相当大的应用。
  id: totrans-75
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`NumPy`不仅提供了一些新的复杂数据类型，还有几种基本数据类型也可以使用。对于已经熟知的数据类型`int`和`float`，例如，`NumPy`有自己的替代品，其特征在于，它们在内存需求上并不随变量内容的变化而变化，正如Python中的标准数据类型那样，而是始终占用固定数量的内存字节。这允许在处理这样的变量时进行非常快速的计算，特别是在处理大量此类变量时，效率计算是一个重要的技能，尤其是在处理大量数据（如机器学习）时。'
  id: totrans-76
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 然而，由于我们在大多数使用案例中可以使用到目前为止讨论的数据类型，我们就先到这里，接下来在下一节中更仔细地观察Python中变量的特性。
  id: totrans-77
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21.4 变量作为对象
  id: totrans-78
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 21.4.1 变量的属性和方法
  id: totrans-79
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: Python受到面向对象编程范式的强烈影响。与一些其他也采用这种编程方法的编程语言（如`C++`）不同，在Python中，即使是最简单的变量也是对象。
  id: totrans-80
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在`Python`中，变量最终始终是一个`class`的具体实例，例如浮点数的类`float`。类`float`有一整套可以通过该类的具体实例，即变量对象访问的方法和属性。如果你对类和实例/对象的术语不再熟悉，只需翻回几页到►`Sect.
    [11.​7](474412_1_En_11_Chapter.xhtml#Sec10)`并在继续之前刷新你的知识！
  id: totrans-81
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 如果你在使用`PyCharm`时，在代码编辑器中输入你已经在程序中使用的变量名，后面跟着一个点，一个小的代码补全菜单会弹出，在这里你可以看到属于该变量类的方法和属性。你也可以在控制台中做同样的事情，输入一个你已经通过`Python`控制台赋值的变量，同样后面跟着一个点。
  id: totrans-82
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`The dot`是`Python`中的运算符，它允许你访问对象的方法和属性。因此，当你在变量名后输入一个点时，`PyCharm`期望你使用该变量的方法或属性，并显示相应的列表。你可以在◘`Fig.
    [21.1](#Fig1)`中看到这个示例。![](../images/474412_1_En_21_Chapter/474412_1_En_21_Fig1_HTML.jpg)'
  id: totrans-83
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 编辑器窗口中的代码补全菜单的截图。编辑器显示文本`x dot`，代码补全菜单显示标识符，如`image`、`real`、`numerator`和`denominator`。
  id: totrans-84
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Fig. 21.1`'
  id: totrans-85
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 整数变量的代码补全菜单，从代码编辑器中调用
  id: totrans-86
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 菜单中标记为小“m”的条目是类`float`为对象提供的方法，标记为小“p”的条目是属性（“p”代表`property`）。你还可以在右侧的代码补全菜单中看到对象的方法或属性来自哪里。在我们的例子中，所有方法和属性都直接来自类`int`，但有些也会来自更一般的类`object`，类`int`正是从该类派生的。从某种意义上说，类`object`是类`int`的父类，并从中继承了方法和属性。
  id: totrans-87
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 现在在控制台中创建一个`float`变量，并调用该变量对象的方法`is_integer()`：
  id: totrans-88
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> x = 5.3 >>> x.is_integer() False`'
  id: totrans-89
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 该方法检查浮点数是否也是整数，当然在我们的例子中并非如此。类方法`is_integer()`不需要任何函数参数，因为它自动引用我们调用它的对象，即`x`。虽然不需要传递参数给函数，但它仍然必须始终用（空）圆括号调用，以识别它是一个函数。
  id: totrans-90
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 然而，类`float`不仅具有方法，还有一些属性。其中一个属性是`__class__`。它表示对象的类：
  id: totrans-91
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> x.__class__ <class ''float''>`'
  id: totrans-92
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 另外，您也可以使用函数``type(*****object*****)``来确定对象类型，该对象作为参数传递给函数：
  id: totrans-93
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '``>>>`` ``type(x)``**<class ''float''>**'
  id: totrans-94
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 借助函数``isinstance(*****object*****,** ***class*****)``，它像``type(*****object*****)``一样是Python标准库的一部分，您可以确定一个变量是否属于某种类型；用我们的面向对象术语更准确地说，您可以确定一个变量是否是某个``class``的``instance``。要做到这一点，变量和要检查的类作为参数传递给函数：
  id: totrans-95
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '``>>>`` ``isinstance(x, str)``False``>>>`` ``isinstance(x, float)``True'
  id: totrans-96
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 让我们更仔细地看看对象的方法，即类为对象提供的函数。稍早之前，我们已经了解了``is_integer()``，这是类``float``的一个方法，它检查当前对象，即我们正在调用其方法的对象，是否是一个整数。如您所知，我们不必将要检查的变量传递给这个特殊函数，因为该方法已经是对象的一部分，因此知道应该处理哪个对象。
  id: totrans-97
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 现在让我们看看字符串变量：
  id: totrans-98
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '``text = ''Strings in Python have many interesting methods.''``如果您在``PyCharm``中工作，在脚本编辑器或Python控制台中，您可以在脚本编辑器或Python控制台中键入``text.``（使用点操作符），熟悉的上下文菜单将显示字符串类``str``为您的``text``对象提供的属性和方法。您将立即看到这里有丰富的不同方法可供选择（◘
    图 [21.2](#Fig2)）。![](../images/474412_1_En_21_Chapter/474412_1_En_21_Fig2_HTML.jpg)'
  id: totrans-99
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在编辑器窗口中，代码补全菜单的截图。编辑器显示文本``text``，代码补全菜单显示标识符，如``upper``、``find``、``join``和``count``。
  id: totrans-100
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 图 21.2
  id: totrans-101
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '``str``对象的方法让我们尝试其中的一些：'
  id: totrans-102
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '``lower()``和``upper()``分别将字符串转换为小写和大写字母：``>>>`` ``text = ''An ordinary text,
    with a few words and punctuation marks.''`` ``>>>`` ``text.lower()``''an ordinary
    text, with a few words and punctuation marks.''`` ``>>>`` ``text.upper()``''AN
    ORDINARY TEXT, WITH A FEW WORDS AND PUNCTUATION MARKS.'''
  id: totrans-103
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '``isnumeric()``检查字符串是否可以转换为数字：``>>>`` ``text.isnumeric()``False'
  id: totrans-104
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '``count(*****substring*****)``计算作为参数传递给该方法的（部分）字符串``substring``的出现次数；它是区分大小写的，如以下示例所示（仅计算“and”中的“an”）：``>>>``
    ``text.count(''an'')``1'
  id: totrans-105
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`replace(*****old*****,** ***new*****,** ***occurrences*****)` replaces the
    specified number of occurrences of the old string with the new string; specifying
    the number of occurrences to replace is optional, so you can omit it, which will
    simply replace `all` occurrences:`>>>` text.replace(''words'', ''terms'', 1)''An
    ordinary text, with a few terms and punctuation marks.'''
  id: totrans-106
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`__len__()` determines the length of the string:`>>>` text.__len__()`58`'
  id: totrans-107
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: As you can see from the two leading and trailing underscores, this is a special
    core Python method. `21.1 [20 min]`
  id: totrans-108
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Objects of type `str`，i.e.，string variables, have several interesting methods
    other than the ones presented here as an example. Find out what other methods
    are available for `str` objects and try them out in the Python console. If you
    don’t understand a method or can’t use it successfully, don’t dwell on it and
    move on to the next method.
  id: totrans-109
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: You can read about the details of the methods in the help. To do this, call
    the help with `help()` in the Python console and put `str.` in front of the methods
    when calling them, so that Python knows exactly which class you want to look at
    for the method (there could be several classes that have a method of that name),
    for example `help(str.isnumeric).`
  id: totrans-110
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'You may have noticed during the exercise that methods such as `upper()`，`lower()`，and
    `replace()` do not modify the object for which they are called, but merely `return`
    a `modified copy of` the object. If you want to change the original object, you
    must assign the changed version, i.e., the return value of the method, to it.
    Let’s take a closer look at this using `upper()` as an example:'
  id: totrans-111
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` text = ''An ordinary text, with a few words and punctuation marks.''`>>>`
    text.upper()`''AN ORDINARY TEXT, WITH A FEW WORDS AND PUNCTUATION MARKS.''`>>>`
    text`''An ordinary text, with a few words and punctuation marks.''`>>>` text =
    text.upper()`>>>` text`''AN ORDINARY TEXT, WITH A FEW WORDS AND PUNCTUATION MARKS.'''
  id: totrans-112
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As you can see, calling the `text.upper()`方法 leaves the `text` variable completely
    unchanged. Only assigning the return value of the method to our original variable
    changes the object `text`。
  id: totrans-113
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`21.4.2 Creating Variables with the Constructor Method`'
  id: totrans-114
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 'In the previous section, we saw that variables can be created simply by assigning
    a value to them for the first time. But there is another way to create new variables.
    As you know by now, variables are objects, that is, instances of a class. Like
    all classes, these objects have a constructor method, which is a special method
    that creates an object of that type. We can use these constructors to create variables.
    Let’s look at the following example:'
  id: totrans-115
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` x = int(3)`>>>` x`3` `>>>` type(x)`<class ''int''>`'
  id: totrans-116
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'So, the constructor method returns an `int` object with the value passed to
    it as argument. This alone is perhaps not all that interesting; after all, we
    could have achieved the same effect more easily with the simple assignment `x
    = 3`. What is interesting is that we can also pass a floating-point number or
    a string to the constructor and it will create an `int` object from it. In the
    case of the floating-point number, the decimal part is simply ignored. If a string
    is passed to the constructor, the text must of course be convertible into a number,
    otherwise we get an error message:'
  id: totrans-117
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` x = int(3.7) `>>>` x 3 `>>>` x = int(''3.7'') `>>>` x 3 `>>>` x = int(''abc'')
    Traceback (most recent call last): File "<input>", line 1, in <module> ValueError:
    invalid literal for int() with base 10: ''abc''.'
  id: totrans-118
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21.5 Converting Variables
  id: totrans-119
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 'It is not uncommon to need to change the data type of variables. To do this,
    consider the following example, in which we add an integer variable and a floating-point
    number variable:'
  id: totrans-120
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` x = 2 `>>>` type(x) `<class ''int''>` `>>>` x = x + 3.7 `>>>` x 5.7 `>>>`
    type(x) `<class float''>`'
  id: totrans-121
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: When we created the variable, Python automatically chose `int` as the data type
    because we had assigned an integer to the variable. But when we then added 3.7,
    a floating-point number, Python changed the type to `float` to accommodate the
    new value. So, Python *implicitly* converts without us having to intervene.
  id: totrans-122
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Now let’s try something else:'
  id: totrans-123
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` x = 2 `>>>` x = x + ''2.7'' Traceback (most recent call last): File "<input>",
    line 1, in <module> TypeError: unsupported operand type(s) for +: ''int'' and
    ''str''.'
  id: totrans-124
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: If we add a string to our variable `x`, Python no longer implicitly converts.
    Maybe it works the other way around, where we define `x` as a string and add a
    number to it?
  id: totrans-125
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` x = ''2'' `>>>` x = x + 3.7 Traceback (most recent call last): File "<input>",
    line 1, in <module> TypeError: can only concatenate str (not "float") to str.'
  id: totrans-126
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: This doesn’t work either. So, Python does not convert between numbers and strings
    implicitly. Nevertheless, we sometimes need to convert strings to numbers to compute
    with them.
  id: totrans-127
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Let’s look at this with an example. Do you remember the conversion from Kelvin
    to Celsius from ► Sect. [12.​2.​2](474412_1_En_12_Chapter.xhtml#Sec6)? There we
    discussed a simple program that takes a temperature in Kelvin as user input and
    converts it to degrees Celsius. We will now develop this program in Python. To
    do this, we make use of the `input(prompt)` function for input, which prompts
    the user for input, and returns that input in the form of a string. With this
    knowledge, it would be obvious to write code like the following:'
  id: totrans-128
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`temp_kelvin = input(''Please enter a temperature in Kelvin: '') temp_celsius
    = temp_kelvin + 273.15 print(temp_kelvin, ''Kelvin are'', temp_celsius, ''degrees
    Celsius.'')`'
  id: totrans-129
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'If we run this program and enter a temperature in Kelvin, we get output like
    the following:'
  id: totrans-130
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '**Traceback (most recent call last):** **File "C:/Users/MyUser/Python/var_examples.py",
    line 54, in <module>.** `temp_celsius = temp_kelvin + 273.15` **TypeError: can
    only concatenate str (not "float") to str**'
  id: totrans-131
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'By now you understand the problem that occurs here: The `input()` function
    returns a string, but it can’t be computed with because Python doesn’t convert
    to a number implicitly. We need to convert `explicitly`. That’s exactly what we
    do in this modified version of the example:'
  id: totrans-132
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`temp_kelvin = input(''Please enter a temperature in Kelvin: '')` `temp_celsius
    = float(temp_kelvin) + 273.15` `print(temp_kelvin, ''Kelvin are'', temp_celsius,
    ''degrees Celsius.'')`'
  id: totrans-133
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'This time we explicitly convert the string variable `temp_celsius` into a floating
    point number, using the `float()` function. You will immediately recognize the
    reference to the last section: `float()` is, of course, the constructor method
    of the class `float` here as well. So, when we convert the string variable `temp_kelvin`
    to a floating-point number, we are doing nothing more than simply creating a new
    `float` object by calling the constructor of this class. We immediately initialize
    the new `float` object with a value; this value may also be a string, the `float`
    constructor then creates a floating point number from it. The `explicit` conversion
    in Python thus runs via the class constructors. They can receive as arguments
    not only a value of the type that the class constructor creates (`float` in our
    case), but also various other types (`str` in our example). In general, the explicit
    conversion thus has the form: `datatype(value)`.'
  id: totrans-134
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21.2 [10 min]
  id: totrans-135
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Write a program that takes the age of the user in years and outputs the number
    of minutes the user has lived (at least).
  id: totrans-136
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21.6 Complex Data Types
  id: totrans-137
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 21.6.1 Lists
  id: totrans-138
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 21.6.1.1 Creating and Displaying Lists
  id: totrans-139
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 'Unlike many other programming languages, Python does not know the concept of
    arrays as such. Instead, however, Python has a more general type of variable fields
    of which the array is ultimately a special case: the list.'
  id: totrans-140
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Lists are `ordered` summaries of `arbitrary` objects. Therefore, an array can
    also be understood as a list because it is nothing more than an ordered summary
    of objects of the `same type`. Lists are created in Python with square brackets,
    as you can see in the following example:'
  id: totrans-141
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '**>>>** `numbers = [1, 2, 3, 4, 5, 6, 7]`**>>>** `first_names = [''Beverly'',
    ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`'
  id: totrans-142
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Entering the list name into the console shows us the contents of the list.
    Square brackets around the elements of the list remind us that this is indeed
    a list:'
  id: totrans-143
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '**>>>** `numbers[1, 2, 3, 4, 5, 6, 7]`**>>>** `first_names[''Beverly'', ''Thomas'',
    ''Marc'', ''Jimmy'', ''Cathy'']`'
  id: totrans-144
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'If you are not working in the console but in script mode, i.e. writing a whole
    program, then use the `print()` function for output, which can also process lists:'
  id: totrans-145
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`print(numbers)` `print(first_names)`'
  id: totrans-146
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 单独写列表的标识符，例如`numbers`并不会在程序中产生输出——与在 Python 控制台中不同——正如我们在►节中看到的那样[21.1](#Sec1)。
  id: totrans-147
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21.6.1.2 Selecting Individual Elements of a List
  id: totrans-148
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 现在可以通过索引再次使用方括号访问列表的单个元素：
  id: totrans-149
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `numbers[3]` `4` `>>>` `first_names[2]` `''Marc''`'
  id: totrans-150
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Python 中的索引从`0`开始，因此索引为`1`的元素已经是列表中的*第二*个元素。你可以使用*负*索引从后面选择。如果我们想从列表的后面选择第二个名字，可以写：
  id: totrans-151
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `first_names[-2]` `''Jimmy''`'
  id: totrans-152
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 列表的最后一个元素的索引是`−1`，而不是`−0`，正如你可能期望的那样。
  id: totrans-153
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 冒号运算符也可以用来指定一个范围作为索引。例如，如果我们想选择第二到第四个名字，可以这样做：
  id: totrans-154
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `first_names[2:5]` `[''Marc'', ''Jimmy'', ''Cathy'']`'
  id: totrans-155
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 具有索引`2`、`3`和`4`的元素，即列表的第三个、第四个和第五个元素被选中。请注意，索引为`5`的元素，即第六个元素，不在选择范围内。索引规格的右边界——反直觉且与其他语言（如
    R）不同——不属于所选元素。
  id: totrans-156
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 就像原始列表一样，选择本身又是一个列表，因为我们选择了多个元素。如果另一方面我们只选择单个元素，选择不再是列表，而是具有该列表相应元素的类型：
  id: totrans-157
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `type(first_names)` `<class ''list''>` `>>>` `sel = first_names[2:5]`
    `>>>` `type(sel)` `<class ''list''>` `>>>` `sel = first_names[2]` `>>>` `type(sel)`
    `<class ''str''>`'
  id: totrans-158
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 当使用索引范围时，一侧也可以保持开放。如果左侧保持开放，系统将从列表的开头选择；如果右侧保持开放，系统将选择到列表的末尾：
  id: totrans-159
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names[:3]` `[''Beverly'', ''Thomas'', ''Marc'']` `>>>` `first_names[3:]`
    `[''Jimmy'', ''Cathy'']`'
  id: totrans-160
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 你也可以将两个范围边界保持开放（`first_names[:]`），那么列表的所有元素将被简单选择（最终创建列表的副本）。如果你想一步选择多个不连续的元素，例如第一个和第三个元素，在
    Python 中并不是那么简单。这就是使用列表推导表达式派上用场的地方，我们将在稍后研究 Python 中循环的实现时讨论。
  id: totrans-161
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21.6.1.3 Edit Lists
  id: totrans-162
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 我们刚刚学习的索引不仅可以用来从列表中选择项目以显示或进一步处理，还可以直接修改列表中的项目。在本节中，我们将研究如何修改列表的元素、向列表中添加元素、删除列表中的元素、排序列表，以及将多个列表合并成一个新列表。
  id: totrans-163
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Change List Elements Let’s start by changing the value of a list item: `>>>`
    `first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']` `>>>`
    `first_names[1] = ''Jason''` `>>>` `first_names = [''Beverly'', ''Jason'', ''Marc'',
    ''Jimmy'', ''Cathy'']`'
  id: totrans-164
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Even entire index ranges can be assigned like this:'
  id: totrans-165
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names[3:5] = [''Joe'', ''Aimee'']` `>>>` `first_names = [''Beverly'',
    ''Thomas'', ''Marc'', ''Joe'', ''Aimee'']`'
  id: totrans-166
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In this case, make sure that the value you assign is again a list (that is,
    it is enclosed in square brackets and is of the same the length of the sublist
    you want to replace).
  id: totrans-167
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21.3 [5 min]
  id: totrans-168
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: What happens if the assigned object is not a list or does not have the length
    of the substituted sublist? Try it out and see if you can explain the results!
  id: totrans-169
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Lists, like all variables in Python, are objects, so they have corresponding
    attributes and methods.
  id: totrans-170
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Append Elements to Lists The `append(object)` method can be used to add an
    object to the list. This directly changes the list instance for which the `append()`
    method is called: `>>>` `first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'',
    ''Cathy'']` `>>>` `first_names.append(''Sandy'')` `>>>` `first_names = [''Beverly'',
    ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'', ''Sandy'']`'
  id: totrans-171
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'If you want to add an element `anywhere in` the list, use the method `insert(insert_before_element_index,
    object)` and pass it the position you want the new element to have and the element
    itself:'
  id: totrans-172
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names.insert(2, ''Sandy'')` `>>>` `first_names = [''Beverly'', ''Thomas'',
    ''Sandy'', ''Marc'', ''Jimmy'', ''Cathy'']` Delete Elements from Lists You can
    delete items from a list with similar ease: `>>>` `first_names = [''Beverly'',
    ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']` `>>>` `first_names.__delitem__(4)`
    `>>>` `first_names = [''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'']` `>>>` `del
    first_names[2]` `first_names = [''Beverly'', ''Thomas'', ''Jimmy'']`'
  id: totrans-173
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: To do this, you can either use the class method `__delitem__(elementindex)`
    to which you only need to pass the index of the element to be deleted, or the
    operator `del`, which, because it is an operator, is used without parentheses!
    You call it together with the element to be deleted. You can even use the `del`
    operator to delete several elements at once, for example by calling `del first_names[2:4]`.
  id: totrans-174
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: As you can see from the example of deletion, some operations can be implemented
    with both a class method and an operator. This is also true for the selections
    we looked at in the previous section. Ultimately, the selection `first_names[2]`
    is nothing more than the call `first_names.__getitem__(3)` of the `__getitem__(elementindex)`
    method, and that’s exactly what Python processes internally when you index your
    list using the square brackets, which are themselves nothing more than an operator.
  id: totrans-175
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Sort Lists You can easily sort your list by using the class methods `sort()`
    and `reverse()`, depending on whether you want to sort in ascending or descending
    order:**>>>** `first_names = ['Beverly', 'Thomas', 'Marc', 'Jimmy', 'Cathy']`**>>>**
    `first_names.sort()`**>>>** `first_names`['Beverly', 'Cathy', 'Jimmy', 'Marc',
    'Thomas']**>>>** `first_names.reverse()`**>>>** `first_names`['Thomas', 'Marc',
    'Jimmy', 'Cathy', 'Beverly'] Determine the Length of a List You can easily determine
    the length of a list using the `__len__()` method.**>>>** `first_name.__len__()`5
  id: totrans-176
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Unlike the previously discussed methods to manipulate the class `list`, `__len__()`
    does not modify the list, but only returns the length of the list.
  id: totrans-177
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Joining Lists If you want to join two lists together, use the plus operator
    (**+**).**>>>** `first_names + numbers`['Beverly', 'Thomas', 'Marc', 'Jimmy',
    'Cathy', 1, 2, 3, 4, 5, 6, 7]
  id: totrans-178
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Here you can see that the result is a list whose elements are partly strings,
    but also partly numbers. Lists, unlike the more specialized arrays found in many
    programming languages, can contain different kinds of elements. In particular,
    the elements of lists can themselves be lists. We will take a closer look at this
    situation in the following section.
  id: totrans-179
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21.6.1.4 Lists as Elements of Lists
  id: totrans-180
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 'Consider the following list:'
  id: totrans-181
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '**>>>** `list_with_sublist = [1, 2, 3, [''a'', ''b'', ''c''], 4]`'
  id: totrans-182
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'It contains as fourth element (i.e., as element with index 3) again a list.
    We can also see this very quickly if we select the element and inspect it more
    closely:'
  id: totrans-183
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '**>>>** `list_with_sublist = [1, 2, 3, [''a'', ''b'', ''c''], 4]`**>>>** `list_with_sublist[3]`[''a'',
    ''b'', ''c'']**>>>** `type(list_with_sublist[3])`**<class ''list''>**'
  id: totrans-184
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'To access an element of our “sub-list”, we first pick the fourth element with
    `list_with_sublist[3]`. This is now again a list. So, we should be able to select
    from this (sub-)list again, just as we did with the full list. For example, if
    we wanted to pick out the third element of the list, i.e., the **c**, we would
    index “twice” as follows:'
  id: totrans-185
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '**>>>** `list_with_lists[3][2]`''c''In this way, lists can also be used to
    construct multidimensional variable fields. Suppose we wanted to map a rectangular
    value scheme that looks like this:'
  id: totrans-186
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '| 1 | 2 | 3 |'
  id: totrans-187
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| 4 | 5 | 6 |'
  id: totrans-188
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| 7 | 8 | 9 |'
  id: totrans-189
  prefs: []
  stylish: true
  type: TYPE_TB
- en: This can be easily mapped with nested lists:**>>>** `three_by_three = [[1, 2,
    3], [4, 5, 6], [7, 8, 9]]`**>>>** `three_by_three`[[1, 2, 3], [4, 5, 6], [7, 8,
    9]]
  id: totrans-190
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'We can then access the coordinates row 2, column 1 (i.e., the number 4 in our
    value scheme) by double indexing our list (note that the indexing starts at 0!):'
  id: totrans-191
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '**>>>** `three_by_three[1][0]`4'
  id: totrans-192
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The first index is always the row index, the second the column index. Although
    multidimensional fields can also be represented very well with lists, at least
    if you are working with very large fields and the speed of the program is an important
    factor, you will want to use special data structures such as those contained in
    the `NumPy` module. `NumPy` is an important add-on library for anyone working
    in the data science area. The library also provides a special array data type
    that, while not as flexible as lists (because it only takes elements of the same
    type), is more compact in memory and faster to access. For our purposes here,
    however, lists, which are part of the standard Python language, will suffice.
  id: totrans-193
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21.4 [20 min]
  id: totrans-194
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Try out working with lists a little! Create lists, select items from them, add
    new items, delete items. It is important that you get a feel for how to work with
    lists, because lists play a big role in practical work with Python.
  id: totrans-195
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21.6.1.5 Strings as Lists
  id: totrans-196
  prefs:
  - PREF_H4
  stylish: true
  type: TYPE_NORMAL
- en: 'A special feature regarding lists are strings. In Python, they have list-like
    properties. Their individual elements, the characters, can be read-accessed in
    list notation:'
  id: totrans-197
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '**>>>** `message = ''Hello World''` **>>>** `message[1]` ''e'''
  id: totrans-198
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Attempting to `edit` a string character in this way, such as with **`message[1]
    = 'x'`**, will result in the error message **‘str’ object does not support item
    assignment.**
  id: totrans-199
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21.6.2 Tuples
  id: totrans-200
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 'Tuples are a data type that is similar to lists in many ways. Just like lists,
    tuples are ordered collections of multiple objects that do not necessarily have
    to be of the same type. The main difference with lists is that tuples are `immutable`.
    Take a look at the following example, in which we create a tuple from three integers:'
  id: totrans-201
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '**>>>** `number = (27, 9, 51)` **>>>** `number(27, 9, 51)` **>>>** `type(number)`
    **<class ''tuple''>** **>>>** `number[1]` 9 **>>>** `type(number[1])` **<class
    ''int''>** **>>>** `number[1]=36` **Traceback (most recent call last):** **File
    "<input>", line 1, in <module>** **TypeError: ''tuple'' object does not support
    item assignment**'
  id: totrans-202
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Note that—unlike with lists—the elements with which the tuple is initialized
    are enclosed in `round` brackets. However, the elements are accessed in exactly
    the same way as in lists, namely by specifying the index of the element in question
    in `square` brackets; and here, too, indexing naturally starts at 0—as always
    in Python—so that **`number[1]`** queries the `second` element of the tuple. In
    the last step, we try to assign a value to this second element of the tuple. This
    fails because tuples are an immutable data type whose elements cannot be changed
    after initialization. Also, no new elements can be added. The tuple is and remains
    as it was created when it was created.
  id: totrans-203
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'By the way, you can also omit the parentheses when creating the tuple. So,
    we could also create the tuple **`number`** above this way:'
  id: totrans-204
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '**>>>** `number = 27, 9, 51` **>>>** `number(27, 9, 51)`'
  id: totrans-205
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '-   你可能会问，既然列表可以做所有元组能做的事情，并且列表是可变的，那么为什么还要使用元组呢？元组的主要优势在于，Python可以比列表更快地处理它们。当你想确保数据不会被覆盖时，元组也很有用。如果你在程序中意外尝试这样做，将会收到错误信息，就像你在上面的示例中看到的那样。即使你不常意识到地使用元组，Python在后台也会使用元组。例如，与许多其他语言不同，Python允许你在一条语句中放置多个变量赋值，如下所示：'
  id: totrans-206
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `a, b = 5, 3` `>>>` `a` 5 `>>>` `b` 3'
  id: totrans-207
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 这里的内部过程是，Python首先创建一个元组`(5, 3)`，然后将其元素分配给两个变量`a`和`b`。我们稍后将看到，在Python中——而这在许多其他编程语言中是不可行的——你可以让一个函数/方法返回多个值。“在幕后”这个过程与元组一起进行。
  id: totrans-208
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21.6.3`Dictionaries`
  id: totrans-209
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 除了列表和元组，另一个复杂的数据类型是字典。术语“字典”很好地描述了这些数据结构的功能。与列表不同，在列表中我们使用相关元素在列表中的索引来选择值，而在字典中使用*键*来实现同样的功能。因此，字典是*关联字段*。如果你不再记得这个概念，最好向后翻几页到►
    Sect. [11.​6](474412_1_En_11_Chapter.xhtml#Sec9)。
  id: totrans-210
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 作为一个示例，让我们创建一个字典，存储每个名字（键）对应的年龄（值）。各种键值对用大括号书写，键和值之间用冒号分隔，键值对之间用逗号分隔：
  id: totrans-211
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `d = {''Thomas'': 30, ''Beverly'': 19, ''Marc'': 28}` `>>>` `d` `{''Thomas'':
    30, ''Beverly'': 19, ''Marc'': 28}`'
  id: totrans-212
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 在我们的示例中，键是字符串，值是数字。然而，这并不一定是这样。数字本身也可以是键。甚至元组也可以是键，但列表不行，因为键必须始终是不可变的（记住，元组是不可变的，而列表可以被修改）。所有可能的对象类型都可以作为值，包括列表或字典本身。通过这种方式，也可以构造一个嵌套字典。我们将在以后的练习中更详细地研究这一点。
  id: totrans-213
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 现在可以通过键来访问单个元素，这与关联字段的使用方式是一致的：
  id: totrans-214
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `d[''Thomas'']`30'
  id: totrans-215
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 注意，虽然在创建字典时键值对是用大括号书写的，但在访问字段的单个元素时则使用方括号。
  id: totrans-216
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Unlike lists, dictionaries are `unordered` collections of elements. Accessing
    individual elements using a numeric index, which specifies the position of the
    element within the dictionary, is not possible because in an unordered data structure
    elements have no natural position at which they can be located and queried. Therefore,
    attempting to access an element using a numeric index will result in an error
    message:'
  id: totrans-217
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> d[1] Traceback (most recent call last): File "<input>", line 1, in <module>
    KeyError: 1`'
  id: totrans-218
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: This `KeyError` tells us that a key `1` does not occur in the dictionary. Python
    interprets the `1` as a key, tries to find the corresponding value, but finds
    that `1` is not among the keys used in the dictionary. We would receive a similar
    error message if we used a name as a key that does not occur in the dictionary,
    for example with `d['Jacob']`.
  id: totrans-219
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Elements can easily be added to a dictionary by making an assignment for the
    new element, associating the new key with a value:'
  id: totrans-220
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> d[''Cathy''] = 36 >>> d {''Thomas'': 31, ''Beverly'': 19, ''Marc'': 28,
    ''Cathy'': 36}`'
  id: totrans-221
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Of course, we can also use an existing key in such an assignment, as in the
    following example:'
  id: totrans-222
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> d[''Beverly''] = 22 >>> d {''Thomas'': 31, ''Beverly'': 22, ''Marc'':
    28, ''Cathy'': 36}`'
  id: totrans-223
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Since the key is ultimately the identifier we use to access an element of the
    dictionary, it must be unique. Therefore, we cannot simply add a new element that
    has a key which already exists in the dictionary. Instead we change the already
    existing element in this case.
  id: totrans-224
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Not only adding, but also deleting elements is very easy with the `del` operator
    already known from lists:'
  id: totrans-225
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> del d[''Thomas''] >>> d {''Beverly'': 22, ''Marc'': 28, ''Cathy'': 36}`'
  id: totrans-226
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Alternatively, as with lists, a call to the class method `__delitem__()` would
    be possible: `d.__delitem__(''Thomas'')`. Unlike the ordered lists, this method
    takes the corresponding key as argument instead of a numeric position index.'
  id: totrans-227
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Sometimes you are interested in checking whether a certain key occurs in the
    dictionary. This can easily be done with the `in` operator. If you apply the `in`
    operator to a key and a dictionary, the result is a logical value that indicates
    whether the key is used in the dictionary or not.
  id: totrans-228
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> ''Cathy'' in d True >>> ''Amy'' in d False`'
  id: totrans-229
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Of course, keys and values can also be extracted from the dictionary. For this
    purpose, the dictionary class has two special methods, `keys()` and `values()`.
    The return values of these methods are a bit more complicated, we will deal with
    this kind of object, the iterable objects, in more detail later. To work with
    them easily, we convert them into a list using the `list()` method, which is the
    constructor method of the `list` class:'
  id: totrans-230
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> list(d.keys()) [''Beverly'', ''Marc'', ''Cathy''] >>> list(d.values())
    [22, 28, 36]`'
  id: totrans-231
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'With these lists, in turn, we can of course do anything that lists allow us
    to do, for example, access a particular element. Since the list of keys is of
    course an ordered data structure, we can access its elements with a numerical
    index. For example, the second element with index `1` (remember: indexing in Python
    starts at `0` for the first element):'
  id: totrans-232
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> list(d.keys())[1] ''Marc''`'
  id: totrans-233
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The complete elements of the dictionary can also be extracted into a list:'
  id: totrans-234
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> list(d.items()) [ (''Beverly'', 22), (''Marc'', 28), (''Cathy'', 36) ]`'
  id: totrans-235
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The elements of the list are now the individual elements of the dictionary.
    They are themselves tuples of key and value:'
  id: totrans-236
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> type(list(d.items())[0]) <class ''tuple''> 21.5 [10 min]`'
  id: totrans-237
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Create a dictionary whose keys are numeric product numbers and whose values
    are dictionaries containing, for each product number, the description, manufacturer,
    and price of the product in question.
  id: totrans-238
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`21.6.4 Sets`'
  id: totrans-239
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: The last data type we want to look at is the `sets`.* Sets and dictionaries
    have in common that both are `unordered` collections of objects. Similar to the
    keys of a dictionary, which must always be unique, each element in a set can only
    occur once. Sets support set operations as they are known from mathematical set
    theory, for example, the determination of the intersection or union of two sets.
  id: totrans-240
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'To create a set, we use the curly braces—similar to the dictionary; this time,
    however, the curly braces do not contain key-value pairs, but simply the individual
    elements of the set:'
  id: totrans-241
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> friends_thomas = {''Will'', ''Beverly'', ''Peter'', ''Michael''} >>> friends_julia
    = {''Peter'', ''Will'', ''Helen'', ''Michael'', ''Caroline''}`'
  id: totrans-242
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'You can easily verify that the order of the elements does not matter by comparing
    two sets containing the same elements but in different order:'
  id: totrans-243
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> {''Beverly'', ''Peter''} == {''Peter'', ''Beverly''} True`'
  id: totrans-244
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: In doing so, we use the double equal sign for comparison, which, we will see
    later, is Python’s operator for comparisons for equality (a single equal sign
    would be considered by Python to be an attempt at assignment, which of course
    would not work here). The result of the comparison, `True`, confirms that the
    order of the elements in the sets does not matter; the two sets are identical
    despite different orders of their otherwise equal elements.
  id: totrans-245
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'With the sets defined above, we could now check, for example, which elements
    occur in both sets, i.e., which people are friends of both Julia and Thomas:'
  id: totrans-246
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>> friends_thomas.intersection(friends_julia) {''Will'', ''Peter''}`'
  id: totrans-247
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: To do this, we use the class method `intersection(other_set)` here, which the
    class `set` brings with it by default. In this case, the result, namely the intersection
    that is again returned to us as `set` (easily recognizable by the curly brackets),
    would of course be the same if instead of calling `friends_thomas.intersection(friends_julia)`
    we had called `friends_julia.intersection(friends_thomas)` the other way around.
  id: totrans-248
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Similarly, we could have worked with the intersection operator `&`, which is
    supported by the class `set`:'
  id: totrans-249
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `friends_thomas & friends_julia` `{''Will'', ''Peter''}`'
  id: totrans-250
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The fact that the intersection operator is an ampersand is no coincidence, since
    we are looking for all elements in the intersection that are contained in one
    `and` the other set.
  id: totrans-251
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Union sets`, i.e., the set of all elements contained in one or both initial
    sets, can be determined with the class method `union(other_set)` or the pipe operator
    `|`:'
  id: totrans-252
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `friends_thomas.union(friends_julia)` `{''Helen'', ''Caroline'', ''Michael'',
    ''Will'', ''Peter'', ''Beverly''}` `>>>` `friends_thomas | friends_julia` `{''Helen'',
    ''Caroline'', ''Michael'', ''Will'', ''Peter'', ''Beverly''}`'
  id: totrans-253
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'As you can see, the union of our two sets contains the names `Will` and `Peter`
    only once, although they appear in both `friends_thomas` and `friends_julia`.
    But this is precisely the nature of sets (as well as sets in mathematics): All
    elements of a set are different from each other, no element can occur more than
    once.'
  id: totrans-254
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Similarly, we can check whether one set is a `subset of` another:'
  id: totrans-255
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `friends_thomas.issubset(friends_julia)` `False` `>>>` `{''Michael'',
    ''Beverly''}.issubset(friends_thomas)` `True`'
  id: totrans-256
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Again, a convenient shortcut is available in the form of an operator, namely
    the less-than-equal operator:'
  id: totrans-257
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `{''Michael'', ''Beverly''} <= friends_thomas` `True` 21.6 [20 min]'
  id: totrans-258
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Find out (for example, with the `help()` function) what other interesting operations
    are possible with sets and try them out. Use the example sets `friends_thomas`
    and `friends_julia` from this section or create your own sets.
  id: totrans-259
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21.7 Self-Defined Classes
  id: totrans-260
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 21.7.1 Defining and Using Classes
  id: totrans-261
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: All the data types we looked at were classes, whether they were basic types
    like `int` and `str` or more complex types like lists or dictionaries. Because
    Python as a programming language follows the object-oriented paradigm, we can
    of course define classes ourselves.
  id: totrans-262
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Remember the example of the `Product` class from ► Sect. [11.​7.​2](474412_1_En_11_Chapter.xhtml#Sec12),
    which captures all the important basic information about a product? These properties
    were the name, a more detailed description, the part number, the manufacturer’s
    name, and the price. We can build such a class very easily in Python, using the
    `class` keyword:'
  id: totrans-263
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`class` `Product`: `name = ''''` `description = ''''` `item_number = ''''`
    `manufacturer = ''''` `price = 0.0`'
  id: totrans-264
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'After the colon, the code block begins (attention, indentation!) with the attributes
    of the classes, to each of which we assign an initial value. That’s about it!
    Now we can use our class `Product` and create a variable of this type:'
  id: totrans-265
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`gardenshovel = Product()`'
  id: totrans-266
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`Product()` is the constructor method of our class, which we use here just
    as we did for Python’s basic data types in ► Sect. [21.4.2](#Sec11). While we
    haven’t defined a constructor of our own at all, our class gets a default constructor
    from Python that does nothing but create an object of the class. Later, when we
    look at methods/functions in a bit more detail, we’ll look at how we can write
    our own constructor and use it to allow the user of our class to, for example,
    set the values of certain attributes to their own specifications right when a
    new class instance is created. This is exactly what we did in ► Sect. [21.4.2](#Sec11),
    when we called the constructor of the class `int` with `int(56)` and caused it
    to create a new `int` object containing the integer value 56.'
  id: totrans-267
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Now that we have created the object of type `Product`, we can customize its
    properties as we wish:'
  id: totrans-268
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`gardenshovel.name = ''Garden shovel, stainless steel''`. `gardenshovel.price
    = 10.99`'
  id: totrans-269
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: If you work with `*PyCharm*` and type `gardenshovel.` (including the dot operator!),
    the dropdown menu that opens will list, among other things, the attributes we
    just defined that the object `gardenshovel`, as an instance of the `Product` class,
    has.
  id: totrans-270
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'You can easily verify that these assignments worked by displaying the values
    of the attributes:'
  id: totrans-271
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`print(gardenshovel.name)` `print(gardenshovel.price)`'
  id: totrans-272
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Note that we are no longer in Python’s interactive mode here (you can easily
    tell by the missing input prompt `>>>` before the statements), although we could
    of course have fed the class definition into the Python console. Therefore, to
    display the contents of a variable, simply typing its identifier is no longer
    sufficient (in fact, it has no effect at all). Instead, we must explicitly cause
    the output by calling the `print()` function.
  id: totrans-273
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 21.7.2 Deriving Classes from Other Classes
  id: totrans-274
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 'In ► Sect. [11.​7.​3](474412_1_En_11_Chapter.xhtml#Sec13) we learned about
    the concept of inheritance, which of course Python also offers as an object-oriented
    language. There, we defined the class `Book` as a derived class of the class `Product`,
    which has two special attributes, `author` and `pages`, that the base/parent class
    `Product` does not have by default. In Python, to derive one class from another,
    the base class name is placed in parentheses after the derived class name in the
    class definition:'
  id: totrans-275
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`class` `Book(Product):` `pages = 0` `author = ''''`'
  id: totrans-276
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Now we can create an instance of the `Book` class by calling its default constructor,
    which Python kindly provides:'
  id: totrans-277
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`grisham1992` = `Book`()If you now display the attributes of the new object
    in `*PyCharm*` by typing `grisham1992`. you will immediately see that the instance
    of the class `Book` has not only its own attributes, namely `pages` and `author`,
    but also the properties inherited from `Product`, such as `description` and `price`.
    `*PyCharm*` also shows you, as you can see in ◘ Fig. [21.3](#Fig3), from which
    class the respective attribute originates.![](../images/474412_1_En_21_Chapter/474412_1_En_21_Fig3_HTML.jpg)'
  id: totrans-278
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: A screenshot of a code completion menu in an editor window. The editor displays
    the text of properties of the book `grisham 1992`, and the code completion menu
    displays identifiers such as `pages`, `price`, `author`, and `name`.
  id: totrans-279
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Fig. 21.3
  id: totrans-280
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Own and inherited properties of the `“Book”` class
  id: totrans-281
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'We can now work with all properties as we wish:'
  id: totrans-282
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`grisham1992.name` = `''The Pelican Brief''` `grisham1992.price` = `8.99` `grisham1992.author`
    = `''John Grisham''` `grisham1992.pages` = `478`'
  id: totrans-283
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Classes in Python can be derived not only from one base class, but also from
    multiple base classes. For example, there could be another class `Copyright`:'
  id: totrans-284
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`class` `Copyright`:`owner` = ''''`year` = 1900'
  id: totrans-285
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Then we could derive our class `Book` from both base classes, `Product` and
    `Copyright` at the same time:'
  id: totrans-286
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`class` `Book`(`Product`, `Copyright`):`pages` = 0`author` = '''''
  id: totrans-287
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'By specifying both base classes in the definition of our class `Book`, we create
    a class that inherits the attributes and methods of both classes. Accordingly,
    we can now work with the attributes that the `Copyright` class brings:'
  id: totrans-288
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`grisham1992` = `Book`() `grisham1992.owner` = `''Double''` `grisham1992.year`
    = `1992`21.7 [10 min]'
  id: totrans-289
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Define a `Customer` class with useful customer attributes and derive a `BusinessCustomer`
    class from this class that contains additional attributes that are only relevant
    for business customers.
  id: totrans-290
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '21.7.3 Avoid Ambiguity: Name Mangling'
  id: totrans-291
  prefs:
  - PREF_H3
  stylish: true
  type: TYPE_NORMAL
- en: 'But what if not only the class `Product`, but also the class `Copyright` had
    an attribute called `name`? The derived class `Book` would nevertheless have only
    `one` attribute `name`. But from which “parent” would this attribute now originate?
    Is it the name from `Product` or the name from `Copyright`? The answer in this
    case would be: that of `Product`, because Python proceeds from left to right,
    i.e. the class from which it is derived “first” is searched first for the attribute
    name. Python only searches in the other parent classes if the first parent class
    did not have an attribute of this identifier.'
  id: totrans-292
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'To eliminate name confusion altogether, there is an option to prefix class
    attributes with a double underscore. Then the class definition of our `Copyright`
    class would look like this:'
  id: totrans-293
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`class` `Copyright`:`owner` = ''''`__name` = ''''`year` = 1900'
  id: totrans-294
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The effect of the double underscore is that Python automatically makes the
    property accessible under the identifier `__class__attribute__`, which in our
    example is `__Copyright__name`:'
  id: totrans-295
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`grisham1992._Copyright__name = ''Copyright''` `print(grisham1992._Copyright__name)`'
  id: totrans-296
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 这个过程，也称为`name mangling`，可以避免在访问类层次结构中可能重复出现的属性名称时的歧义和误解。
  id: totrans-297
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`21.8 Summary`'
  id: totrans-298
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 在本章中，我们学习了Python中的变量及如何使用它们。我们还学习了如何定义类并创建对象作为类的实例。
  id: totrans-299
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 你应该从本章中记住以下几点：
  id: totrans-300
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Python知道简单数据类型，最显著的是`int`（整数）、`float`（浮点数）、`str`（字符串）和`bool`（逻辑/真值），以及更复杂的数据类型，最显著的是`list`（不同对象的有序集合）、`dictionary`（无序关联字段）、`tuple`（不可变对象的集合）和`set`（无序唯一对象的集合）。
  id: totrans-301
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 所有数据类型都是类，这些数据类型的变量是对象实例；它们具有属性（或特性）和方法，用于操作和处理对象。
  id: totrans-302
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 变量名区分大小写，这在Python中是普遍的；官方推荐使用小写变量，并用下划线分隔变量名中的多个术语。
  id: totrans-303
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 变量不需要声明。
  id: totrans-304
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 变量可以通过将对象赋值给变量名生成（此时Python自动确定类型），也可以通过使用相应数据类型类的构造方法生成。
  id: totrans-305
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 构造函数通常可以用其他类型的对象作为参数调用；这允许数据类型之间的显式转换。
  id: totrans-306
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Python隐式转换的相对较少，但在必要时会在`int`和`float`之间进行转换。
  id: totrans-307
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 字符串可以用单引号和双引号括起来。
  id: totrans-308
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 要显示变量的内容，可以在Python控制台中输入其名称；然而，在Python程序中，输出必须始终明确调用（主要使用`print()`函数）。
  id: totrans-309
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Python中的复杂数据类型在是否可变（可变：`list`、`dictionary`、`set`；不可变：`tuple`）以及其元素是以有序还是无序方式存储（有序：`list`、`tuple`；无序：`dictionary`、`set`）上有所不同。
  id: totrans-310
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 复杂数据类型的元素（在字典的情况下，包括键和值）可以是不同类型的，甚至可以是该复杂数据类型或其他复杂数据类型的对象；例如，可能有一个列表，其中包含列表作为元素，或者一个字典，其键部分是元组，值是列表和其他字典。
  id: totrans-311
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 有序数据类型（列表、元组）的元素可以通过数字索引（即元素编号）访问；第一个元素的索引总是0。
  id: totrans-312
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 冒号运算符可以用来表示索引范围，其中`A:B`表示范围边界`A`（包含）和`B-1`（包含）之间的所有元素。
  id: totrans-313
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Range boundaries can also be left open, which is equivalent to “from the beginning”
    (left boundary not specified) or to the end (right boundary not specified).
  id: totrans-314
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 'Negative indexes mean: Indexing from the back instead of the front.'
  id: totrans-315
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Python does not know a special data type for arrays/fields, but the data type
    `list`, which holds arbitrary elements in ordered form; an array is thus a special
    case of a `list` (namely one whose elements are all of the same type).
  id: totrans-316
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: Strings also behave like `lists` in read access, in that their individual characters
    can be addressed in the notation usual for `lists`; however, write access to the
    characters is not possible in this way.
  id: totrans-317
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: You can define your own classes using the keyword `class`; classes can be derived
    from one or more “parent classes”, i.e., inherit their attributes and methods.
  id: totrans-318
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: A double underscore of an attribute or method in a class definition means that
    the attribute/method is also accessible under the name `_*class*__*attribute*`
    or `_*class*__*method()*` (*name mangling*); in this way, ambiguities in attribute/method
    identifiers caused by multiple inheritance can be avoided.
  id: totrans-319
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: The following table gives an overview of the most important data types. For
    the simple data types, you can see the creation by assignment and by calling the
    constructor method of the respective class. Of course, the complex data types
    `list`, `tuple`, `dictionary` and `set` can also be created by constructor, but
    this is not shown here for the sake of clarity.
  id: totrans-320
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Overview of the most important data types
  id: totrans-321
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '| Data type | Saves | Creation of a variable | Access to elements |'
  id: totrans-322
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-323
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `int` | Integers | Assignment:`x = 5`Constructor:`x = int(''5'')` | – |'
  id: totrans-324
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `float` | Floating point values | Assignment:`x = 0.5`Constructor:`x = float(''5'')`
    | – |'
  id: totrans-325
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `str` | Strings | Assignment:`x = ''Hello World''`Constructor:`x = str(0.5)`
    | – |'
  id: totrans-326
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `boolean` | Logical/truth values | Assignment:`x = False`Constructor:`x =
    bool(''True'')` | – |'
  id: totrans-327
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `list` | Ordered, changeable compilation of other objects (possibly also
    of different types) | Elements comma-separated in square brackets:`x = [''Marc'',
    ''Helen'', ''Toby'', ''Thomas'']` | Index or index range in square brackets:`x[1]`(gives:
    `''Helen''`)*`x[2:3]`*(gives: `[''Hellen'', ''Thomas'']`) |'
  id: totrans-328
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `tuple` | Ordered, unchangeable compilation of other objects (possibly of
    different types) | Elements comma separated in round brackets:`x = (''abc'', 27.5)`
    | Index in round brackets:`x(1)`(gives: `27.5`) |'
  id: totrans-329
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `dictionary` | Unordered set of key-value pairs, keys and values can be objects
    of different types; keys must be unique | Key-value pairs comma-separated in curly
    brackets, key and value each separated by colon:`x = {''Marc'' : 27, ''Helen''
    : 41}` | Key in square brackets:`x = [''Marc'']`(provides: `27`) |'
  id: totrans-330
  prefs: []
  stylish: true
  type: TYPE_TB
- en: '| `set` | 不可排序的对象集合（可能是不同类型），必须是唯一的（对象在列表中只能出现一次） | 以逗号分隔的元素在大括号中：`x = {''Marc'',
    ''Helen''}` | 由于没有自然顺序且没有访问的键，选择单个元素是没有意义的（您必须已经知道该元素才能访问它） |'
  id: totrans-331
  prefs: []
  stylish: true
  type: TYPE_TB
- en: 21.9 练习的解决方案
  id: totrans-332
  prefs:
  - PREF_H2
  stylish: true
  type: TYPE_NORMAL
- en: 练习 21.1 `str`对象的其他方法的一些示例是：
  id: totrans-333
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`find(''sub'')`：在`str`对象的字符串中搜索`sub`，并返回找到的子字符串的第一个字符的索引，如果未找到子字符串，则返回−1。这个过程是区分大小写的。使用示例：`>>>
    x = ''Hello world!''` `>>> x.find(''wo'') 6` `>>> x.find(''WO'') -1` `>>> x.upper().find(''WO'')
    6`'
  id: totrans-334
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 在最后的示例中，字符串首先被转换为大写。`x.upper()`返回转换为大写的字符串。这当然又是一个`str`对象。然后使用其`find()`方法进行搜索。这次返回了一个命中。
  id: totrans-335
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: 可以使用进一步的参数来限制要搜索的字符串范围；帮助中的规范 `x.find('sub'[, start[, end]]) -> int` 意味着由于`start`和`end`是`find()`的可选参数，因此可以指定也可以不指定。这就是为什么它们各自被方括号括起来。注意括号顺序的细微差别：围绕`end`参数的方括号被包含在围绕`start`参数的方括号中。这意味着`end`只能在指定了`start`的情况下被指定，但`start`可以在不指定`end`的情况下使用！
  id: totrans-336
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: 在`->`之后，您会找到函数返回值的类型，在我们的例子中是`int`，因为索引作为数字返回。
  id: totrans-337
  prefs:
  - PREF_IND
  stylish: true
  type: TYPE_NORMAL
- en: '`capitalize()`：将字符串的首字母大写（仅首个单词！），并将所有其他字符转换为小写。使用示例：`>>> x = ''hello world''`
    `>>> x.capitalize() ''Hello world''`'
  id: totrans-338
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`is.lower()`，`is.upper()`：检查字符串是否全为小写或全为大写。使用示例：`>>> x.isupper() False` `>>>
    x = ''HELLO WORLD''` `>>> x.isupper() True`'
  id: totrans-339
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`center(width, [fillchar])`：创建一个长度为`width`的字符串，由`str`对象的字符串居中。左右两侧用填充字符“填充”（默认情况下，如果未指定，则为空格）。使用示例：`>>>
    x = ''Hello World''` `>>> x.center(50, ''*'') ''********************Hello World********************''
    练习 21.2 一个程序，读取用户的年龄（以年为单位）并将其输出为分钟，可能如下所示：`age = input(''Please enter your age
    in years:'')` `minutes = int(age) * 365 * 24 * 60` `print(''With'', age, ''you
    have already experienced at least'', minutes)` 练习 21.3'
  id: totrans-340
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: 让我们首先为具有索引 3 和 4 的列表元素分配一个对象。我们从一个整数开始：
  id: totrans-341
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `first_names` = `[''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names [3:4]` = 23 `Traceback (most recent call last):` `File "<input>",
    line 1, in <module>` `TypeError: can only assign an iterable`'
  id: totrans-342
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'We get an error message. Generally, Python cannot assign something which is
    itself not a list to a list/selection from a list (unless the selection contains
    only one element). Contrary to what one might expect, Python does not simply replace
    the elements 3 and 4, i.e. `‘Jimmy’` and `‘Cathy’` (indexing starts at 0!), with
    the number 23\. The picture changes when we “wrap” the number 23 in a list:'
  id: totrans-343
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `first_names` = `[''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names[3:4]` = `[23]` `>>>` `first_names` = `[''Beverly'', ''Thomas'',
    ''Marc'', 23]`'
  id: totrans-344
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Now the two selected elements are actually replaced by the list containing only
    the number 23\. But since this is shorter than the replaced partial list, our
    list `first_names` is `shortened` accordingly.
  id: totrans-345
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Now let’s try something else. This time we replace the part list with a string:'
  id: totrans-346
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `first_names` = `[''Beverly'', ''Thomas'', ''Marc'', ''Jimmy'', ''Cathy'']`
    `>>>` `first_names[3:4]` = `''Amy''` `>>>` `first_names` = `[''Beverly'', ''Thomas'',
    ''Marc'', ''A'', ''m'', ''y'']`'
  id: totrans-347
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Unlike the assignment `first_names[3:4] = 23` above, this time we don’t get
    an error message. But something seemingly strange happens: The partial list `first_names[3:4]`
    is replaced by the letters of the name `Amy`, with each letter becoming a new
    list element. The reason is that strings can also be interpreted as lists. Therefore,
    the assignment `first_names[3:4] = ''Amy''` is ultimately a replacement by a list,
    namely by the list `[''A'', ''m'', ''y'']`.'
  id: totrans-348
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Exercise 21.4
  id: totrans-349
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`No solution`.'
  id: totrans-350
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: Exercise 21.5
  id: totrans-351
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Here we are now dealing with a nested dictionary. For the sake of clarity,
    you can see the dictionary definition below with line breaks (you remember from
    ► Sect. [20.​1.​2](474412_1_En_20_Chapter.xhtml#Sec3) that a statement can be
    wrapped inside curly braces):'
  id: totrans-352
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `d` = `{ 12345: {... ''description'': ''Plastic Garden Chair "Garden
    Friend"'', ... ''manufacturer'': ''Garden Paradise Inc.'', ... ''price'': 10.99
    ... }, 56789: {... ''description'': ''Garden shovel, stainless steel'', ... ''manufacturer'':
    ''Big G Gardening Tools Inc.'', ... ''price'': 49.90 ... }}`'
  id: totrans-353
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Access is then via two keys:'
  id: totrans-354
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`>>>` `d[12345][''price'']` 10.99'
  id: totrans-355
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: The expression `d[12345]` returns a dictionary, and a value is selected from
    this dictionary using a key that exists in this dictionary.
  id: totrans-356
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'Exercise 21.6 Some examples of other set operations:'
  id: totrans-357
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`difference(other_set)`: Returns the elements that exist in `other_set` but
    not in the set whose `difference()` method was called. Usage example: `>>>` `friends_thomas`
    = `{''Will'', ''Beverly'', ''Peter'', ''Michael''}` `>>>` `friends_julia` = `{''Peter'',
    ''Will'', ''Helen'', ''Michael'', ''Caroline''}` `>>>` `friends_julia.difference(friends_thomas)`
    `{''Caroline'', ''Helen''}`'
  id: totrans-358
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`remove(***element***)`: Deletes an element from a set. Usage example: `>>>`
    `friends_julia.remove(''Helen'')` `>>>` `friends_julia` `{''Peter'', ''Will'',
    ''Michael'', ''Caroline''}`'
  id: totrans-359
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`isdisjoint(***other_set***)`: Checks if the set whose `isdisjoint()` method
    is called and the other set are disjoint, that is, have no elements in common.
    Usage example: `>>>` `friends_thomas = {''Will'', ''Beverly'', ''Peter'', ''Michael''}`
    `>>>` `friends_julia = {''Peter'', ''Will'', ''Helen'', ''Michael''}` `>>>` `friends_thomas.isdisjoint(friends_julia)`
    `False`'
  id: totrans-360
  prefs:
  - PREF_UL
  stylish: true
  type: TYPE_NORMAL
- en: '`Exercise 21.7`'
  id: totrans-361
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: 'The two classes `Customer` and `BusinessCustomer` could look like this:'
  id: totrans-362
  prefs: []
  stylish: true
  type: TYPE_NORMAL
- en: '`class` `Client`: `firstname = ''''` `lastname = ''''` `street = ''''` `city
    = ''''` `zip = ''''` `email = ''''` `class` `BusinessCustomer`(`Customer`): `company
    = ''''` `payment_terms = 14` `taxid = ''''`'
  id: totrans-363
  prefs: []
  stylish: true
  type: TYPE_NORMAL
