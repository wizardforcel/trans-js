- en: 'Chapter 3: C++: Bridging Procedural and Object-Oriented Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3.1 The Evolution from C to C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The development of C++ marked a significant evolution in programming languages,
    bridging the gap between procedural and object-oriented programming (OOP). In
    this section, we’ll explore the journey from C to C++ and the core concepts that
    define C++ as a versatile and powerful language.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Origins of C++:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ was created by Bjarne Stroustrup in the early 1980s as an extension of the
    C programming language. Stroustrup’s goal was to combine C’s efficiency and low-level
    capabilities with high-level features, enabling more structured and modular code.
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iostream>'
  prefs: []
  type: TYPE_NORMAL
- en: int main()  {
  prefs: []
  type: TYPE_NORMAL
- en: std::cout <<  "Hello, C++!"  <<  std::endl;
  prefs: []
  type: TYPE_NORMAL
- en: return  0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Object-Oriented Programming (OOP):'
  prefs: []
  type: TYPE_NORMAL
- en: One of the fundamental shifts in C++ compared to C is the introduction of OOP.
    In C++, you can define classes and objects, encapsulating data and behavior into
    reusable and organized units.
  prefs: []
  type: TYPE_NORMAL
- en: class Rectangle {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: int width;
  prefs: []
  type: TYPE_NORMAL
- en: int height;
  prefs: []
  type: TYPE_NORMAL
- en: int area()  {
  prefs: []
  type: TYPE_NORMAL
- en: return width * height;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: int main()  {
  prefs: []
  type: TYPE_NORMAL
- en: Rectangle rect;
  prefs: []
  type: TYPE_NORMAL
- en: rect.width =  5;
  prefs: []
  type: TYPE_NORMAL
- en: rect.height =  10;
  prefs: []
  type: TYPE_NORMAL
- en: int area = rect.area();
  prefs: []
  type: TYPE_NORMAL
- en: return  0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Classes and Objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes in C++ serve as blueprints for creating objects. They encapsulate data
    (attributes) and functions (methods) that operate on that data. Objects are instances
    of classes.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ supports inheritance, allowing you to create new classes based on existing
    ones. Inheritance enables code reuse and the creation of class hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: 'class Square :  public Rectangle {'
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: Square(int side)  {
  prefs: []
  type: TYPE_NORMAL
- en: width = side;
  prefs: []
  type: TYPE_NORMAL
- en: height = side;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Polymorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism in C++ allows objects of different classes to be treated as objects
    of a common base class. This facilitates dynamic method invocation and runtime
    flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: class Shape {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: virtual  void draw()  {
  prefs: []
  type: TYPE_NORMAL
- en: // Default implementation
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Circle :  public Shape {'
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void draw()  override  {
  prefs: []
  type: TYPE_NORMAL
- en: // Draw a circle
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Encapsulation:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ supports encapsulation, hiding the internal details of a class and exposing
    only what’s necessary. Access specifiers like  public,  private, and  protected
    control the visibility of class members.
  prefs: []
  type: TYPE_NORMAL
- en: class BankAccount {
  prefs: []
  type: TYPE_NORMAL
- en: 'private:'
  prefs: []
  type: TYPE_NORMAL
- en: double balance;
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void deposit(double amount)  {
  prefs: []
  type: TYPE_NORMAL
- en: if  (amount >  0)  {
  prefs: []
  type: TYPE_NORMAL
- en: balance += amount;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: double getBalance()  {
  prefs: []
  type: TYPE_NORMAL
- en: return balance;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Templates:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ introduced templates, enabling generic programming. Templates allow you
    to write code that works with different data types while maintaining type safety.
  prefs: []
  type: TYPE_NORMAL
- en: template  <typename T>
  prefs: []
  type: TYPE_NORMAL
- en: T add(T a, T b)  {
  prefs: []
  type: TYPE_NORMAL
- en: return a + b;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '8\. Standard Template Library (STL):'
  prefs: []
  type: TYPE_NORMAL
- en: The STL is a collection of pre-defined classes and functions in C++ for common
    data structures (like vectors, lists, and maps) and algorithms. It simplifies
    complex tasks and promotes code reusability.
  prefs: []
  type: TYPE_NORMAL
- en: '#include <vector>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <algorithm>'
  prefs: []
  type: TYPE_NORMAL
- en: int main()  {
  prefs: []
  type: TYPE_NORMAL
- en: std::vector<int> numbers =  {5,  2,  8,  1,  9};
  prefs: []
  type: TYPE_NORMAL
- en: std::sort(numbers.begin(), numbers.end());
  prefs: []
  type: TYPE_NORMAL
- en: return  0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: The evolution from C to C++ brought about a rich set of features and programming
    paradigms, making C++ a versatile language suitable for various applications.
    Its ability to seamlessly combine procedural and object-oriented programming has
    contributed to its enduring popularity in software development. Understanding
    C++’s core concepts is essential for leveraging its full potential in modern programming.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Core Concepts of Object-Oriented Programming in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object-Oriented Programming (OOP) is a fundamental paradigm in C++, enabling
    developers to create more organized, modular, and maintainable code. In this section,
    we’ll delve into the core concepts of OOP as applied in C++.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Classes and Objects:'
  prefs: []
  type: TYPE_NORMAL
- en: At the heart of OOP in C++ are classes and objects. A class is a blueprint for
    creating objects. It defines attributes (data members) and methods (functions)
    that describe the behavior and properties of objects.
  prefs: []
  type: TYPE_NORMAL
- en: class Circle {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: double radius;
  prefs: []
  type: TYPE_NORMAL
- en: double calculateArea()  {
  prefs: []
  type: TYPE_NORMAL
- en: return  3.14159  * radius * radius;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: In this example,  Circle is a class with a  radius attribute and a method  calculateArea()
    that computes the area of a circle.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Encapsulation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Encapsulation is the practice of bundling data (attributes) and the methods
    (functions) that operate on that data within a class. In C++, you can control
    the visibility of class members using access specifiers:  public,  private, and  protected.'
  prefs: []
  type: TYPE_NORMAL
- en: class BankAccount {
  prefs: []
  type: TYPE_NORMAL
- en: 'private:'
  prefs: []
  type: TYPE_NORMAL
- en: double balance;
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void deposit(double amount)  {
  prefs: []
  type: TYPE_NORMAL
- en: if  (amount >  0)  {
  prefs: []
  type: TYPE_NORMAL
- en: balance += amount;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: double getBalance()  {
  prefs: []
  type: TYPE_NORMAL
- en: return balance;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the  balance attribute is encapsulated as  private, meaning it can only
    be accessed and modified through the public methods  deposit() and  getBalance().
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance allows you to create new classes (derived or subclass) based on
    existing ones (base or superclass). Derived classes inherit the attributes and
    methods of the base class, promoting code reuse and hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: class Shape {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: virtual  double calculateArea()  {
  prefs: []
  type: TYPE_NORMAL
- en: return  0.0;  // Default implementation
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Circle :  public Shape {'
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: double radius;
  prefs: []
  type: TYPE_NORMAL
- en: double calculateArea()  override  {
  prefs: []
  type: TYPE_NORMAL
- en: return  3.14159  * radius * radius;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: In this example,  Circle is a derived class of  Shape and overrides the  calculateArea()
    method to provide its own implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Polymorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism allows objects of different classes to be treated as objects of
    a common base class. This facilitates dynamic method invocation and runtime flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Shape* shape =  new Circle();
  prefs: []
  type: TYPE_NORMAL
- en: double area = shape->calculateArea();
  prefs: []
  type: TYPE_NORMAL
- en: Here, a  Circle object is treated as a  Shape object, and the  calculateArea()
    method is called accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction is the process of simplifying complex systems by modeling them as
    objects with specific behaviors and attributes. Classes provide a level of abstraction
    by encapsulating relevant details.
  prefs: []
  type: TYPE_NORMAL
- en: class Car {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: virtual  void start()  =  0;
  prefs: []
  type: TYPE_NORMAL
- en: virtual  void stop()  =  0;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: 'class ElectricCar :  public Car {'
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void start()  override  {
  prefs: []
  type: TYPE_NORMAL
- en: // Start the electric car
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void stop()  override  {
  prefs: []
  type: TYPE_NORMAL
- en: // Stop the electric car
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: In this example,  Car is an abstract class with two pure virtual functions,
    enforcing that derived classes like  ElectricCar must provide implementations
    for  start() and  stop().
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Composition:'
  prefs: []
  type: TYPE_NORMAL
- en: Composition is the practice of building complex objects by combining simpler
    objects as attributes. It promotes code modularity and reusability.
  prefs: []
  type: TYPE_NORMAL
- en: class Engine {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void start()  {
  prefs: []
  type: TYPE_NORMAL
- en: // Start the engine
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void stop()  {
  prefs: []
  type: TYPE_NORMAL
- en: // Stop the engine
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: class Car {
  prefs: []
  type: TYPE_NORMAL
- en: 'private:'
  prefs: []
  type: TYPE_NORMAL
- en: Engine engine;
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void start()  {
  prefs: []
  type: TYPE_NORMAL
- en: engine.start();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void stop()  {
  prefs: []
  type: TYPE_NORMAL
- en: engine.stop();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a  Car contains an  Engine as an attribute, allowing it to
    delegate tasks to the  Engine object.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these core OOP concepts in C++ is essential for designing and
    developing software with a structured and modular approach. These concepts provide
    the foundation for building complex and maintainable systems, and they are widely
    used in a variety of applications, from game development to enterprise software.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '3.3 Memory Management: From Malloc to Constructors'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory management is a crucial aspect of C++ programming, and it differs significantly
    from C due to the introduction of classes and objects. In this section, we’ll
    explore how C++ manages memory, including the use of constructors and destructors.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: In C++, constructors are special member functions defined within a class that
    are called when an object of the class is created. Constructors initialize the
    object’s attributes and allocate resources if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: class Student {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: Student()  {
  prefs: []
  type: TYPE_NORMAL
- en: // Constructor
  prefs: []
  type: TYPE_NORMAL
- en: age =  0;
  prefs: []
  type: TYPE_NORMAL
- en: name =  "Unknown";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'private:'
  prefs: []
  type: TYPE_NORMAL
- en: int age;
  prefs: []
  type: TYPE_NORMAL
- en: std::string  name;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the  Student class has a constructor that sets default values
    for the  age and  name attributes when a  Student object is created.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: The destructor is another special member function that is called when an object
    goes out of scope or is explicitly deleted. Destructors are used to release resources
    allocated by the object, such as dynamic memory or file handles.
  prefs: []
  type: TYPE_NORMAL
- en: class FileHandler {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: FileHandler(const  std::string& filename)  {
  prefs: []
  type: TYPE_NORMAL
- en: '// Constructor: Open the file'
  prefs: []
  type: TYPE_NORMAL
- en: file.open(filename);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ~FileHandler()  {
  prefs: []
  type: TYPE_NORMAL
- en: '// Destructor: Close the file'
  prefs: []
  type: TYPE_NORMAL
- en: file.close();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'private:'
  prefs: []
  type: TYPE_NORMAL
- en: std::ifstream  file;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the  FileHandler class has a constructor that opens a file
    and a destructor that closes the file when the object is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Dynamic Memory Allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ provides operators like  new and  delete for dynamic memory allocation and
    deallocation. When you use  new to create an object, its constructor is called,
    and memory is allocated on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Student* studentPtr =  new Student();  // Dynamic object creation
  prefs: []
  type: TYPE_NORMAL
- en: 'To deallocate the memory and call the destructor, you use  delete:'
  prefs: []
  type: TYPE_NORMAL
- en: delete studentPtr;  // Destructor is called, and memory is freed
  prefs: []
  type: TYPE_NORMAL
- en: '4\. RAII (Resource Acquisition Is Initialization):'
  prefs: []
  type: TYPE_NORMAL
- en: RAII is a C++ programming idiom that ties the lifetime of a resource (like memory
    or file handles) to the lifetime of an object. Constructors acquire resources,
    and destructors release them, ensuring that resources are properly managed.
  prefs: []
  type: TYPE_NORMAL
- en: class DatabaseConnection {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: DatabaseConnection()  {
  prefs: []
  type: TYPE_NORMAL
- en: '// Constructor: Open a database connection'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ~DatabaseConnection()  {
  prefs: []
  type: TYPE_NORMAL
- en: '// Destructor: Close the database connection'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: With RAII, resource management becomes automatic and deterministic, minimizing
    the risk of resource leaks.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Copy Constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ provides copy constructors, which are used to create a copy of an existing
    object. By default, C++ generates a copy constructor that performs a member-wise
    copy. However, you can define a custom copy constructor to ensure proper copying
    of resources.
  prefs: []
  type: TYPE_NORMAL
- en: class MyString {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: MyString(const MyString& other)  {
  prefs: []
  type: TYPE_NORMAL
- en: // Custom copy constructor
  prefs: []
  type: TYPE_NORMAL
- en: data =  new  char[strlen(other.data)  +  1];
  prefs: []
  type: TYPE_NORMAL
- en: strcpy(data, other.data);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'private:'
  prefs: []
  type: TYPE_NORMAL
- en: char* data;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the  MyString class defines a custom copy constructor to create
    a deep copy of the character data.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding memory management in C++ is essential for creating robust and
    resource-efficient programs. Constructors and destructors play a pivotal role
    in managing resources, and the RAII idiom encourages best practices in resource
    management. By using these features effectively, C++ developers can ensure proper
    allocation and deallocation of memory and other resources throughout the lifetime
    of objects.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 The Standard Template Library (STL)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Standard Template Library (STL) is a core component of C++ that provides
    a collection of pre-defined classes and functions for common data structures and
    algorithms. It simplifies complex tasks and promotes code reusability by offering
    a set of well-tested and efficient components. In this section, we’ll explore
    some of the key components of the STL.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Containers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'STL provides several container classes for storing and managing data efficiently.
    Some commonly used containers include:'
  prefs: []
  type: TYPE_NORMAL
- en: '•            Vector: A dynamic array that automatically resizes itself when
    elements are added or removed.'
  prefs: []
  type: TYPE_NORMAL
- en: '•            List: A doubly-linked list that allows efficient insertion and
    deletion of elements anywhere in the list.'
  prefs: []
  type: TYPE_NORMAL
- en: '•            Map: An associative container that stores key-value pairs, providing
    fast lookups by key.'
  prefs: []
  type: TYPE_NORMAL
- en: '•            Set: A container that stores unique elements, useful for maintaining
    a collection of distinct values.'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <vector>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <map>'
  prefs: []
  type: TYPE_NORMAL
- en: std::vector<int> numbers =  {1,  2,  3,  4,  5};
  prefs: []
  type: TYPE_NORMAL
- en: std::map<std::string,  int> ageMap;
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterators are used to traverse and manipulate elements in containers. They provide
    a uniform way to access elements regardless of the underlying container type.
  prefs: []
  type: TYPE_NORMAL
- en: for  (auto it = numbers.begin(); it != numbers.end();  ++it)  {
  prefs: []
  type: TYPE_NORMAL
- en: // Access or modify elements using 'it'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'STL includes a wide range of algorithms that operate on containers. These algorithms
    perform tasks like sorting, searching, and modifying elements. Some commonly used
    algorithms include:'
  prefs: []
  type: TYPE_NORMAL
- en: '•            std::sort: Sorts elements in a container.'
  prefs: []
  type: TYPE_NORMAL
- en: '•            std::find: Searches for an element in a container.'
  prefs: []
  type: TYPE_NORMAL
- en: '•            std::for_each: Applies a function to each element in a container.'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <algorithm>'
  prefs: []
  type: TYPE_NORMAL
- en: std::sort(numbers.begin(), numbers.end());
  prefs: []
  type: TYPE_NORMAL
- en: auto result =  std::find(numbers.begin(), numbers.end(),  3);
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Function Objects (Functors):'
  prefs: []
  type: TYPE_NORMAL
- en: Functors are objects that behave like functions. They are often used with algorithms
    to customize their behavior. You can define your own functors by overloading the  operator().
  prefs: []
  type: TYPE_NORMAL
- en: struct Square {
  prefs: []
  type: TYPE_NORMAL
- en: int  operator()(int x)  const  {
  prefs: []
  type: TYPE_NORMAL
- en: return x * x;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: std::transform(numbers.begin(), numbers.end(), numbers.begin(), Square());
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Strings:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ provides the  std::string class as part of the STL, offering a more user-friendly
    and versatile alternative to C-style character arrays.  std::string handles memory
    management and provides various string manipulation functions.
  prefs: []
  type: TYPE_NORMAL
- en: '#include <string>'
  prefs: []
  type: TYPE_NORMAL
- en: std::string  greeting =  "Hello, World!";
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Smart Pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: STL includes smart pointers like  std::shared_ptr,  std::unique_ptr, and  std::weak_ptr
    to manage dynamic memory efficiently. These pointers automatically handle memory
    deallocation when the object is no longer needed, reducing the risk of memory
    leaks.
  prefs: []
  type: TYPE_NORMAL
- en: '#include <memory>'
  prefs: []
  type: TYPE_NORMAL
- en: std::shared_ptr<int> sharedPtr =  std::make_shared<int>(42);
  prefs: []
  type: TYPE_NORMAL
- en: std::unique_ptr<double> uniquePtr =  std::make_unique<double>(3.14);
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Utility Functions:'
  prefs: []
  type: TYPE_NORMAL
- en: STL provides utility functions like  std::pair and  std::tuple for handling
    pairs and tuples of values. These are commonly used in functions and algorithms
    that return multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: '#include <utility>'
  prefs: []
  type: TYPE_NORMAL
- en: std::pair<int,  std::string> person =  std::make_pair(25,  "Alice");
  prefs: []
  type: TYPE_NORMAL
- en: std::tuple<int,  double,  std::string> data =  std::make_tuple(42,  3.14,  "Hello");
  prefs: []
  type: TYPE_NORMAL
- en: The Standard Template Library is a powerful tool for C++ developers, offering
    a wide range of reusable components and algorithms that simplify common programming
    tasks. By leveraging the STL effectively, programmers can write more efficient
    and maintainable code, reducing the need for reinventing the wheel when it comes
    to data structures and algorithms. Understanding the STL’s components and how
    to use them is essential for any C++ developer.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Real-world Applications of C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ is a versatile programming language known for its performance and efficiency.
    In this section, we’ll explore some real-world applications of C++ and how it
    is used in various domains.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Systems Programming:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ is widely used for systems programming tasks. It plays a crucial role in
    developing operating systems, device drivers, and firmware for embedded systems.
    Its low-level capabilities make it suitable for managing hardware resources and
    interacting with peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: // Example of systems programming in C++
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iostream>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <fstream>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <unistd.h>'
  prefs: []
  type: TYPE_NORMAL
- en: int main()  {
  prefs: []
  type: TYPE_NORMAL
- en: std::cout <<  "Hello, C++ Systems Programming!"  <<  std::endl;
  prefs: []
  type: TYPE_NORMAL
- en: std::ofstream  outputFile("data.txt");
  prefs: []
  type: TYPE_NORMAL
- en: outputFile <<  "Data written to a file."  <<  std::endl;
  prefs: []
  type: TYPE_NORMAL
- en: close(1);  // Close standard output
  prefs: []
  type: TYPE_NORMAL
- en: return  0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Game Development:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ is a popular choice for game development due to its performance and ability
    to handle resource-intensive tasks. Game engines like Unreal Engine and Unity
    use C++ extensively for their core systems.
  prefs: []
  type: TYPE_NORMAL
- en: // Game development in C++
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iostream>'
  prefs: []
  type: TYPE_NORMAL
- en: class Game {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void run()  {
  prefs: []
  type: TYPE_NORMAL
- en: // Game loop
  prefs: []
  type: TYPE_NORMAL
- en: while  (isRunning)  {
  prefs: []
  type: TYPE_NORMAL
- en: // Game logic and rendering
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'private:'
  prefs: []
  type: TYPE_NORMAL
- en: bool isRunning =  true;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. High-Performance Computing (HPC):'
  prefs: []
  type: TYPE_NORMAL
- en: C++ is favored in the field of high-performance computing, where maximum computational
    power is required. C++’s low-level memory control and optimization capabilities
    make it suitable for scientific simulations, weather modeling, and financial analysis.
  prefs: []
  type: TYPE_NORMAL
- en: // High-performance computing in C++
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iostream>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <vector>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <omp.h>'
  prefs: []
  type: TYPE_NORMAL
- en: int main()  {
  prefs: []
  type: TYPE_NORMAL
- en: std::vector<double> data(1000000,  0.0);
  prefs: []
  type: TYPE_NORMAL
- en: '#pragma omp parallel for'
  prefs: []
  type: TYPE_NORMAL
- en: for  (int i =  0; i < data.size();  ++i)  {
  prefs: []
  type: TYPE_NORMAL
- en: data[i]  = i *  2.0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: std::cout <<  "HPC task completed."  <<  std::endl;
  prefs: []
  type: TYPE_NORMAL
- en: return  0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Aerospace and Defense:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ is used in the aerospace and defense industries for tasks like flight control
    systems, radar signal processing, and simulation software. Its reliability and
    real-time capabilities make it suitable for safety-critical applications.
  prefs: []
  type: TYPE_NORMAL
- en: // Aerospace application in C++
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iostream>'
  prefs: []
  type: TYPE_NORMAL
- en: class FlightControlSystem {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void controlFlight()  {
  prefs: []
  type: TYPE_NORMAL
- en: // Flight control logic
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Finance and Trading:'
  prefs: []
  type: TYPE_NORMAL
- en: In the finance sector, C++ is used for algorithmic trading, risk management,
    and high-frequency trading systems. Its low-latency capabilities and efficient
    memory management are critical for processing large volumes of financial data.
  prefs: []
  type: TYPE_NORMAL
- en: // Algorithmic trading in C++
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iostream>'
  prefs: []
  type: TYPE_NORMAL
- en: class TradingAlgorithm {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void execute()  {
  prefs: []
  type: TYPE_NORMAL
- en: // Trading strategy implementation
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Game Engines and Graphics Libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ is the language of choice for developing game engines and graphics libraries.
    Libraries like OpenGL and DirectX leverage C++’s performance to create immersive
    gaming experiences.
  prefs: []
  type: TYPE_NORMAL
- en: // Graphics programming with C++
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iostream>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <OpenGL/gl.h>'
  prefs: []
  type: TYPE_NORMAL
- en: int main()  {
  prefs: []
  type: TYPE_NORMAL
- en: // OpenGL rendering code
  prefs: []
  type: TYPE_NORMAL
- en: return  0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Automotive Industry:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ is used for developing embedded software in vehicles, including engine control
    units (ECUs), infotainment systems, and autonomous driving algorithms. Its real-time
    capabilities and performance are critical for automotive applications.
  prefs: []
  type: TYPE_NORMAL
- en: // Automotive software development in C++
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iostream>'
  prefs: []
  type: TYPE_NORMAL
- en: class AutonomousDrivingSystem {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void drive()  {
  prefs: []
  type: TYPE_NORMAL
- en: // Autonomous driving logic
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: C++’s wide range of applications is a testament to its flexibility and power.
    It continues to be a preferred choice for projects that demand high performance,
    efficient memory management, and low-level control. Understanding how C++ is used
    across different domains is valuable for developers looking to specialize in specific
    industries or projects.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
